<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>9. 三器一闭 | 晚上十一点睡觉のBlog</title><meta name="author" content="晚上十一点睡觉"><meta name="copyright" content="晚上十一点睡觉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="三器一闭：迭代器、生成器、装饰器以及闭包 迭代器引入如果开发中有以下需求，如何解决？ class StuSystem(object):    &amp;quot;&amp;quot;&amp;quot;    学生管理系统    &amp;quot;&amp;quot;&amp;quot;    def __init__(self):"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gungnir.top/posts/5766/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?60a7a67c81784f02b889a11753e4e8cc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 晚上十一点睡觉","link":"链接: ","source":"来源: 晚上十一点睡觉のBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '9. 三器一闭',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-26 13:42:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237497.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">晚上十一点睡觉のBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">9. 三器一闭</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-03T08:40:57.000Z" title="发表于 2022-11-03 16:40:57">2022-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-26T05:42:25.455Z" title="更新于 2022-12-26 13:42:25">2022-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/">Python全栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Python核心编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="9. 三器一闭"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/5766/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>三器一闭：迭代器、生成器、装饰器以及闭包</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>如果开发中有以下需求，如何解决？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stus = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line"></span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu[<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu[<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu[<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line"></span><br><span class="line">        self.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建管理系统对象</span></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加3个学生信息到系统中</span></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 问题1：怎样才能实现用for循环遍历系统中所有的学生信息呢？下面的方式能实现吗？</span></span><br><span class="line"><span class="comment">## for item in stu_sys.stus:  # 通过实例对象访问实例属性 列表</span></span><br><span class="line"><span class="comment">##     print(item)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 当前的想法是对这个类的实例对象进行迭代循环 而不是实例属性</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> stu_sys:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 问题2：如果需要一个列表，这个列表 样子例如 [&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;id&#x27;: 10086&#125;, &#123;&#x27;name&#x27;: &#x27;李四&#x27;: &#x27;id&#x27;: 10087&#125;]</span></span><br><span class="line"><span class="comment">## stu_list = [ ...列表推导式...]</span></span><br><span class="line"><span class="comment">## 这个列表推导式该怎样写才能实现呢？</span></span><br></pre></td></tr></table></figure>

<p>在实际开发工作中，经常需要快速的将对象转化问其他的不同的数据类型，此时如果能快速的遍历出自定义的对象，这样大大减少代码的冗余，而且可读性会更优美</p>
<p>问题是，怎样实现呢？</p>
<p>今天我们要学习的知识只有1个，那就是<code>迭代器</code></p>
<h3 id="什么是迭代"><a href="#什么是迭代" class="headerlink" title="什么是迭代"></a>什么是迭代</h3><p>迭代是访问<strong>序列类型</strong>元素的一种方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以通过for循环将nums列表中的每个数据依次获取</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> name:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>

<p>我们已经知道可以对<code>list</code>、<code>tuple</code>、<code>str</code>等类型的数据使用<code>for...in...</code>的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫<strong>迭代</strong></p>
<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代<strong>对象</strong></h3><blockquote>
<p>注意：是可迭代的“对象”</p>
</blockquote>
<p>是否所有的数据类型都可以放到<code>for...in...</code>的语句中，然后让<code>for...in...</code>每次从中取出一条数据供我们使用呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weight = <span class="number">160</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> weight:</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>

<p>通过运行可以发现，并不是所有的类型都可以通过<code>for...in...</code>的方式进行遍历</p>
<p>我们可以通俗的认为：只要是可以通过f<code>or...in…</code>的形式进行遍历的，那么这个数据类型就是<strong>可以迭代的</strong></p>
<h4 id="可迭代的数据类型"><a href="#可迭代的数据类型" class="headerlink" title="可迭代的数据类型"></a>可迭代的数据类型</h4><ul>
<li>列表</li>
<li>元组</li>
<li>字典</li>
<li>字符串</li>
<li>集合</li>
</ul>
<h4 id="不可迭代的数据类型"><a href="#不可迭代的数据类型" class="headerlink" title="不可迭代的数据类型"></a>不可迭代的数据类型</h4><ul>
<li>整型</li>
<li>浮点型</li>
</ul>
<h4 id="判断数据类型到底是否可迭代"><a href="#判断数据类型到底是否可迭代" class="headerlink" title="判断数据类型到底是否可迭代"></a>判断数据类型到底是否可迭代</h4><blockquote>
<p>[5. 函数进阶 Python中isinstance-和type-的区别 | 晚上十一点睡觉 (gungnir.top)](<a href="https://gungnir.top/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/5">https://gungnir.top/Python全栈/Python核心编程/5</a>. 函数进阶.html#Python中isinstance-和type-的区别)</p>
<p>前面谈到过<code>isinstance</code>的用法，<code>isinstance()</code> 判断当前这个对象是否是我指定对象的子类，此处只要判断其是否是<code>Iterable</code>类的子类即可判断该类型是否可以迭代。</p>
<p>只要是通过<code>isinstance</code>来判断出是<code>Iterable</code>类的实例，即<code>isinstance</code>的结果是<code>True</code>那么就表示，这个数据类型是可以迭代的数据类型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: <span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: <span class="built_in">isinstance</span>([], Iterable)</span><br><span class="line">Out[<span class="number">51</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: <span class="built_in">isinstance</span>(&#123;&#125;, Iterable)</span><br><span class="line">Out[<span class="number">52</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: <span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable)</span><br><span class="line">Out[<span class="number">53</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: <span class="built_in">isinstance</span>(mylist, Iterable)</span><br><span class="line">Out[<span class="number">54</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: <span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable)</span><br><span class="line">Out[<span class="number">55</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="可迭代对象的特征"><a href="#可迭代对象的特征" class="headerlink" title="可迭代对象的特征"></a>可迭代对象的特征</h4><blockquote>
<p>在一个对象中，如果只是实现了一个<code>__iter__</code>方法 我们称当前的这个对象为一个可以迭代的对象</p>
</blockquote>
<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一个可以<strong>记住遍历的位置</strong>的**<u>对象</u>**。迭代器对象从第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<blockquote>
<p>迭代器本质上就是一种取值的计算方式，通过一个算法筛选出符合条件的数据</p>
</blockquote>
<h4 id="可迭代对象的本质"><a href="#可迭代对象的本质" class="headerlink" title="可迭代对象的本质"></a>可迭代对象的本质</h4><blockquote>
<p><strong>迭代器对象</strong>的概念和<strong>可迭代对象</strong>的概念一定要区分开</p>
<p>迭代器一定是一个可迭代对象</p>
<p>但是可迭代对象不一定是一个迭代器</p>
</blockquote>
<p>分析 <strong>可迭代对象</strong> 进行迭代的过程，发现每迭代一次（即在<code>for...in...</code>中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。</p>
<p>那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(<code>Iterator</code>)</p>
<p>可迭代对象的<strong>本质</strong>就是可以向我们提供一个这样的中间“人”，即迭代器帮助我们对其进行迭代遍历使用。</p>
<p><code>list</code>、<code>tuple</code>等都是可迭代对象，我们可以通过<code>iter()</code>函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用<code>next()</code>函数来获取下一条数据。</p>
<blockquote>
<ul>
<li><code>iter()</code>获取可迭代对象的迭代器</li>
<li><code>next()</code>获取迭代器种的数据</li>
</ul>
</blockquote>
<h4 id="获取可迭代对象的迭代器"><a href="#获取可迭代对象的迭代器" class="headerlink" title="获取可迭代对象的迭代器"></a>获取可迭代对象的迭代器</h4><blockquote>
<p>注意<code>Iterator</code>和<code>Iterable</code>是不同的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums))</span><br><span class="line"></span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums_iter))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br></pre></td></tr></table></figure>

<h4 id="获取迭代器的数据"><a href="#获取迭代器的数据" class="headerlink" title="获取迭代器的数据"></a>获取迭代器的数据</h4><p>上面提到，通过<code>iter()</code>能够得到一个可迭代对象的 迭代器，可以通过<code>next()</code>函数多次提取迭代器中的数据，下面我们就测试下</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="comment">#内置模块，在collection文件里面有一个abc模块，从该模块导入Iterator类</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"><span class="comment">## 1. 获取迭代器对象</span></span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. 使用next() 方法获取迭代器中的元素  next执行一次获取一个元素 依次获取</span></span><br><span class="line">num1 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num1)</span><br><span class="line"></span><br><span class="line">num2 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num2)</span><br><span class="line"></span><br><span class="line">num3 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num3)</span><br><span class="line"></span><br><span class="line">num4 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num4)</span><br></pre></td></tr></table></figure>

<h4 id="StopIteration-异常"><a href="#StopIteration-异常" class="headerlink" title="StopIteration 异常"></a>StopIteration 异常</h4><p>如果将上面的代码，多写一次的<code>next()</code>会怎样呢？看如下测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num1)</span><br><span class="line"></span><br><span class="line">num2 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num2)</span><br><span class="line"></span><br><span class="line">num3 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num3)</span><br><span class="line"></span><br><span class="line">num4 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num4)</span><br><span class="line"></span><br><span class="line">num5 = <span class="built_in">next</span>(nums_iter)  <span class="comment"># 这里会产生异常</span></span><br><span class="line"><span class="built_in">print</span>(num5)</span><br><span class="line"><span class="comment">## 3. 如果获取的元素超出了当前列表的元素范围 则报错 因为没有元素可以返回了</span></span><br></pre></td></tr></table></figure>

<p>可以看到23行，即第5次调用<code>next()</code>时，产生了异常。why？？？？？？</p>
<p>因为列表<code>nums</code>中只有4个数据，也就是说可以调用4次<code>next</code>是完全合理的，但是如果，调用的次数多了肯定是不合理，都没有5个数据，怎么可以能取5次呢！显然是不对的</p>
<p>此时估计想明白了，为什么会产生异常，其实就是一种告知迭代结束的标志而已</p>
<p>添加<code>try...except...</code>即可解决刚刚遇到的问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num5 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line">    <span class="built_in">print</span>(num5)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;迭代结束: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>大家是否还记得 在刚开学习今天的知识时，我们引入了一个学生管理系统的问题，该怎样实现呢</p>
<p>我们下面来谈谈</p>
<blockquote>
<ul>
<li><code>__iter__</code>方法 声明一个可迭代对象</li>
<li><code>__next__</code>方法 声明一个迭代器对象</li>
</ul>
</blockquote>
<h4 id="iter-方法"><a href="#iter-方法" class="headerlink" title="__iter__方法"></a><code>__iter__</code>方法</h4><p>上面提到<code>iter()</code>方法必须是对”可迭代“对象 才能 提取到 ”迭代器“对象，但是怎样保证自定义的对象是”可迭代“对象呢？</p>
<p>答：只要在类中定义<code>__iter__</code>方法，那么这个类创建出来的对象一定是可迭代对象</p>
<p>通俗的说：一个具备了<code>__iter__</code>方法的对象就是一个可以迭代的对象</p>
<p>测试代码一：无<code>__iter__</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist.add(<span class="number">11</span>)</span><br><span class="line">mylist.add(<span class="number">22</span>)</span><br><span class="line">mylist.add(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mylist是否是可以迭代对象 False</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/ubuntu/Desktop/stu_code/测试代码.py&quot;, line 19, in &lt;module&gt;</span><br><span class="line">    for temp in mylist:</span><br><span class="line">TypeError: &#x27;MyList&#x27; object is not iterable</span><br></pre></td></tr></table></figure>



<p>测试代码二：有<code>__iter__</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist.add(<span class="number">11</span>)</span><br><span class="line">mylist.add(<span class="number">22</span>)</span><br><span class="line">mylist.add(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mylist是否是可以迭代对象 True</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/ubuntu/Desktop/stu_code/测试代码.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    for temp in mylist:</span><br><span class="line">TypeError: iter() returned non-iterator of type &#x27;NoneType&#x27;</span><br></pre></td></tr></table></figure>

<p>能够看出，一个类，只要有<code>__iter__</code>方法，那么这个类创建出来的对象就是可以迭代对象</p>
<p>其实，当我们调用<code>iter()</code>函数提取一个可迭代对象的 迭代器时，实际上会自动调用这个对象的<code>__iter__</code>方法，并且这个方法返回迭代器</p>
<h4 id="next-方法"><a href="#next-方法" class="headerlink" title="__next__方法"></a><code>__next__</code>方法</h4><p>通过上面的分析，我们已经知道，迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用<code>next()</code>函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。</p>
<p>实际上，在使用<code>next()</code>函数的时候，调用的就是迭代器对象的<code>__next__</code>方法（Python3中是对象的<code>__next__</code>方法，Python2中是对象的<code>next()</code>方法）。</p>
<p>所以，<u>我们要想构造一个迭代器，就要实现它的<code>__next__</code>方法</u>。</p>
<p>但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现<code>__iter__</code>方法，而<code>__iter__</code>方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的<code>__iter__</code>方法返回自身即可。</p>
<p>一个实现了<code>__iter__</code>方法和<code>__next__</code>方法的对象，就是迭代器</p>
<p>如何判断一个对象是否是迭代器</p>
<p>可以使用 isinstance() 判断一个对象是否是 Iterator 对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: <span class="built_in">isinstance</span>([], Iterator)</span><br><span class="line">Out[<span class="number">57</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: <span class="built_in">isinstance</span>(<span class="built_in">iter</span>([]), Iterator)</span><br><span class="line">Out[<span class="number">58</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: <span class="built_in">isinstance</span>(<span class="built_in">iter</span>(<span class="string">&quot;abc&quot;</span>), Iterator)</span><br><span class="line">Out[<span class="number">59</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>自定义迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的一个可迭代对象&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> MyIterator()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的供上面可迭代对象使用的一个迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist_iter = <span class="built_in">iter</span>(mylist)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist是否是迭代器&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterator))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist_iter是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist_iter, Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist_iter是否是迭代器&quot;</span>, <span class="built_in">isinstance</span>(mylist_iter, Iterator))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mylist是否是可以迭代对象 True</span><br><span class="line">mylist是否是迭代器 False</span><br><span class="line">mylist_iter是否是可以迭代对象 True</span><br><span class="line">mylist_iter是否是迭代器 True</span><br></pre></td></tr></table></figure>

<h4 id="自定义迭代器案例"><a href="#自定义迭代器案例" class="headerlink" title="自定义迭代器案例"></a>自定义<code>迭代器</code>案例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;&quot;&quot;自定义的一个可迭代对象&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 想要把普通对象转为一个可以迭代的对象</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> MyIterator(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 自定义迭代器的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line">    <span class="comment"># 在计数之前 我需要知道这个被迭代的对象的长度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, my_list</span>):</span><br><span class="line">        self.my_list = my_list</span><br><span class="line">        <span class="comment"># 创建一个计数器</span></span><br><span class="line">        <span class="comment"># current用来记录当前访问到的位置</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):  <span class="comment"># 返回一个迭代器</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 声明这个类是一个迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current &lt; <span class="built_in">len</span>(self.my_list.items):</span><br><span class="line">            item = self.my_list.items[self.current]</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 一个新的关键字 当for循环接收到这个异常错误之后 会自动停止</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">            <span class="comment">#主动抛出异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list = MyList()</span><br><span class="line"></span><br><span class="line">my_list.add(<span class="number">1</span>)</span><br><span class="line">my_list.add(<span class="number">2</span>)</span><br><span class="line">my_list.add(<span class="number">3</span>)</span><br><span class="line">my_list.add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment">## for 循环的本质是一个死循环 在不停的调用__next__方法 直到抛出StopIteration停止</span></span><br><span class="line"><span class="comment">#for循环底层原理是while循环</span></span><br><span class="line"> <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">while true:</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        next(obj)</span></span><br><span class="line"><span class="string">    except:</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">   &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>可迭代对象通过<code>__iter__</code>方法向我们返回一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据。</p>
<h3 id="for-in-循环的本质"><a href="#for-in-循环的本质" class="headerlink" title="for...in...循环的本质"></a><code>for...in...</code>循环的本质</h3><ol>
<li>先调用<code>iter()</code>函数，它会自动调用可迭代对象中的<code>__iter__</code>方法，此方法返回这个可迭代对象的 迭代器对象</li>
<li>对获取到的迭代器不断调用<code>next()</code>函数，它会自动调用迭代器中的<code>__next__</code>方法来获取下一个值</li>
<li>当遇到<code>StopIteration</code>异常后循环结束</li>
</ol>
<h3 id="并不是只有for循环能接收可迭代对象"><a href="#并不是只有for循环能接收可迭代对象" class="headerlink" title="并不是只有for循环能接收可迭代对象"></a>并不是只有<code>for</code>循环能接收可迭代对象</h3><p>除了for循环能接收可迭代对象，list、tuple等也能接收。</p>
<p>列表 字典 集合 元组等容器类型都能接收一个迭代器或者可迭代对象 且转为指定的容器类型</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的一个可迭代对象&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        myiterator = MyIterator(self)</span><br><span class="line">        <span class="keyword">return</span> myiterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的供上面可迭代对象使用的一个迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mylist</span>):</span><br><span class="line">        self.mylist = mylist</span><br><span class="line">        <span class="comment"># current用来记录当前访问到的位置</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current &lt; <span class="built_in">len</span>(self.mylist.items):</span><br><span class="line">            item = self.mylist.items[self.current]</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mylist = MyList()</span><br><span class="line">    mylist.add(<span class="number">1</span>)</span><br><span class="line">    mylist.add(<span class="number">2</span>)</span><br><span class="line">    mylist.add(<span class="number">3</span>)</span><br><span class="line">    mylist.add(<span class="number">4</span>)</span><br><span class="line">    mylist.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    nums = <span class="built_in">list</span>(mylist)</span><br><span class="line">    <span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ul>
<li>凡是可作用于<code>for </code>循环的对象都是<code> Iterable</code> 类型</li>
<li>凡是可作用于 <code>next()</code> 函数的对象都是<code> Iterator</code> 类型</li>
<li>序列数据类型如<code> list</code> 、<code>dict</code>、<code>str</code>等是 <code>Iterable </code>但不是<code>Iterator</code>，不过可以通过 <code>iter() </code>函数获得一个 <code>Iterator </code>对象</li>
<li>可迭代对象不一定是一个迭代器，迭代器一定是一个可以迭代的对象</li>
</ul>
<blockquote>
<ul>
<li>在一个对象中，如果只是实现了一个<code>__iter__</code>方法 我们称当前的这个对象为一个可以迭代的对象</li>
<li>在一个对象中，创建了<code>__iter__</code>以及<code>__next__</code>方法 则当前的对象才是一个迭代器</li>
</ul>
</blockquote>
<ul>
<li>为什么不将迭代器的迭代方式直接写在可迭代对象类的代码之中呢？</li>
</ul>
<blockquote>
<p>目的是为了解耦：因为以后有时候一个迭代器可能存在几百行代码的情况，如果放在一起维护起来会非常麻烦。</p>
<p>而且分开写迭代器可以在不同场景复用</p>
</blockquote>
<ul>
<li>为什么不使用继承实现迭代，而是对象关联？</li>
</ul>
<blockquote>
<ul>
<li>在项目开发中 不只有单继承，还有多继承，多继承情况复杂，不建议太多的继承，能少继承一个就少继承一个</li>
<li>继承的执行速度比对象关联慢</li>
</ul>
</blockquote>
<ul>
<li>应用场景：爬虫、数据分析</li>
</ul>
<blockquote>
<p>如：使用类进行歌曲抓取<br>可以在类中去创建一个容器 对当前这个容器进行歌曲的添加  这些歌曲本质是一个文件对象<br>通过文件读写的方式进行下载——迭代<br>需要实现一个迭代器       </p>
</blockquote>
<h3 id="随堂作业"><a href="#随堂作业" class="headerlink" title="随堂作业"></a>随堂作业</h3><p>既然已经学习过了迭代器，那么今天刚开始的知识点也就自然有了答案</p>
<ul>
<li>实现用<code>for</code>循环遍历学生系统中的所有学生信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stus = []</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu[<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu[<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu[<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line">        self.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.stus):</span><br><span class="line">            ret = self.stus[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建管理系统对象</span></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加3个学生信息到系统中</span></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 问题1：怎样才能实现用for循环遍历系统中所有的学生信息呢？下面的方式能实现吗？</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> stu_sys:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) ubuntu@VM-16-5-ubuntu:~/Desktop/stu_code$ /home/ubuntu/miniconda3/bin/python /home/ubuntu/Desktop/stu_code/测试代码.py</span><br><span class="line">请输入新学生的姓名:顾安</span><br><span class="line">请输入新学生的手机号:13711111111</span><br><span class="line">请输入新学生的住址:长沙</span><br><span class="line">请输入新学生的姓名:安娜</span><br><span class="line">请输入新学生的手机号:13711111112</span><br><span class="line">请输入新学生的住址:长沙</span><br><span class="line">请输入新学生的姓名:双双</span><br><span class="line">请输入新学生的手机号:13711111113</span><br><span class="line">请输入新学生的住址:长沙</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;tel&#x27;: &#x27;13711111111&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;安娜&#x27;, &#x27;tel&#x27;: &#x27;13711111112&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;双双&#x27;, &#x27;tel&#x27;: &#x27;13711111113&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对输入的数据进行格式转换</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stus = []</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu[<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu[<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu[<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line">        self.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.stus):</span><br><span class="line">            ret = self.stus[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line">stu_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> stu_sys]</span><br><span class="line"><span class="built_in">print</span>(stu_list)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">请输入新学生的姓名:顾安</span><br><span class="line">请输入新学生的手机号:13711111111</span><br><span class="line">请输入新学生的住址:长沙</span><br><span class="line">请输入新学生的姓名:安娜</span><br><span class="line">请输入新学生的手机号:13711111112</span><br><span class="line">请输入新学生的住址:南京</span><br><span class="line">请输入新学生的姓名:双双</span><br><span class="line">请输入新学生的手机号:13711111113</span><br><span class="line">请输入新学生的住址:上海</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;tel&#x27;: &#x27;13711111111&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;安娜&#x27;, &#x27;tel&#x27;: &#x27;13711111112&#x27;, &#x27;address&#x27;: &#x27;南京&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;双双&#x27;, &#x27;tel&#x27;: &#x27;13711111113&#x27;, &#x27;address&#x27;: &#x27;上海&#x27;&#125;]</span><br></pre></td></tr></table></figure>



<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>在Python中，使用生成器可以很方便的支持迭代器协议。（这句话的意思就是生成器是一种特殊的迭代器）</p>
<p>生成器通过<strong>生成器函数</strong>产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用<code>yield</code>一次返回一个结果，在每个结果之间<strong>挂起</strong>和<strong>继续</strong>它们的状态，来自动实现迭代协议。</p>
<blockquote>
<ul>
<li>涉及到关键字<code>yield</code></li>
<li>在每个结果之间<strong>挂起</strong>和<strong>继续</strong>它们的状态，可以理解为“暂停”</li>
</ul>
</blockquote>
<p>也就是说，<code>yield</code>是一个<strong>语法糖</strong>，内部实现支持了迭代器协议，同时yield内部是一个状态机，维护着挂起和继续的状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 如果一个函数中存在yield关键字 则当前这个函数是一个特殊的生成器函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">## 所谓的生成器 是一种特殊的函数 不能像普通函数一样进行()调用        </span></span><br><span class="line">my_range = my_range(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(my_range)	<span class="comment">#这个地方同样是打印生成器的信息，</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br><span class="line"><span class="comment">## print([i for i in my_range])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 因为之前讲过一句话 生成器是一种特殊的迭代器  next()</span></span><br><span class="line"><span class="comment">#使用生成器的方法</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_range:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment">#讲解一下for循环干了啥：</span></span><br><span class="line"><span class="comment">#for循环会自动对my_range使用iter()获取其迭代器对象</span></span><br><span class="line"><span class="comment">#for item in my_range中的my_range就变成了一个迭代器，</span></span><br><span class="line"><span class="comment">#此时for 循环中使用next()获取该迭代器的数据</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，定义了一个生成器函数，函数返回一个<strong>生成器对象</strong>，然后就可以通过<code>for</code>语句进行迭代访问了。</p>
<blockquote>
<p>其实，生成器函数返回生成器的迭代器。 “生成器的迭代器”这个术语通常被称作”生成器”。要注意的是生成器就是一类特殊的迭代器。作为一个迭代器，生成器必须要定义一些方法，其中一个就是<code>__next__()</code>。如同迭代器一样，我们可以使用<code>__next__()</code>函数来获取下一个值。</p>
<p>但是生成器的定义中并没有定义<code>next</code>和<code>iter</code>函数，这是因为生成器内部实现了迭代器协议（上面提到过），我们不需要自己写<code>next</code>和<code>iter</code></p>
</blockquote>
<blockquote>
<p>使用生成器<code>my_range</code>的两种方法：</p>
<ul>
<li><code>print(next(my_range))</code></li>
<li>通过<code>for</code>语句进行迭代访问</li>
</ul>
</blockquote>
<h3 id="生成器工作流程"><a href="#生成器工作流程" class="headerlink" title="生成器工作流程"></a>生成器工作流程</h3><p>下面就仔细看看生成器是怎么工作的。从上面的例子也可以看到，生成器函数跟普通的函数是有很大差别的。结合上面的例子我们加入一些打印信息，进一步看看生成器的执行流程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始迭代...&#x27;</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;迭代中...&#x27;</span>)</span><br><span class="line">        <span class="comment"># 生成器执行时遇到yield关键字会暂停</span></span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;迭代结束...&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 1. 创建一个变量用于接收生成器所返回的迭代器对象</span></span><br><span class="line">my_iter = my_range(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br></pre></td></tr></table></figure>

<p><strong>执行过程！！！</strong>：(一句话总结就是：生成器在遇到<code>yield</code>关键字的时候会暂停)</p>
<ol>
<li><p>当调用生成器函数的时候，函数只是返回了一个生成器对象，并没有执行。</p>
</li>
<li><p>当<code>next()</code>方法第一次被调用的时候，生成器函数才开始执行，执行到yield语句处停止: <code>next()</code>方法的返回值就是yield语句处的参数（yielded value）</p>
</li>
<li><p>当继续调用<code>next()</code>方法的时候，函数将接着上一次停止的yield语句处继续执行，并到下一个yield处停止；如果后面没有yield就抛出<code>StopIteration</code>异常</p>
</li>
</ol>
<p><strong>return和yield的区别：</strong></p>
<ul>
<li>return</li>
</ul>
<blockquote>
<ul>
<li>代表的是整个函数结束</li>
<li>在结束前可以返回值</li>
<li>return在函数中只有一个</li>
</ul>
</blockquote>
<ul>
<li>yield</li>
</ul>
<blockquote>
<ul>
<li>返回一个生成器对象</li>
<li>可以使用next取到这个生成器对象的值</li>
<li>但是yield不代表当前函数结束</li>
<li>yield可以在函数中写多个</li>
</ul>
</blockquote>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><h4 id="引入：复习列表推导式"><a href="#引入：复习列表推导式" class="headerlink" title="引入：复习列表推导式"></a>引入：复习列表推导式</h4><p>在开始介绍生成器表达式之前，先看看我们比较熟悉的列表解析( <code>List comprehensions</code>)（列表推导式），列表解析一般都是下面的形式。</p>
<blockquote>
<p>[3. 序列类型 l#列表推导式| 晚上十一点睡觉 (gungnir.top)](<a href="https://gungnir.top/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/3">https://gungnir.top/Python全栈/Python核心编程/3</a>. 序列类型.html#列表推导式)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr]</span><br></pre></td></tr></table></figure>

<p>迭代<code>iterable</code>里所有内容，每一次迭代后，把<code>iterable</code>里满足<code>cond_expr</code>条件的内容放到<code>iter_var</code>中，再在表达式<code>expr</code>中应该<code>iter_var</code>的内容，最后用表达式的计算值生成一个列表。</p>
<p>例如，生成一个<code>list</code>包含50以内的所有奇数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>) <span class="keyword">if</span> i % <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h4 id="生成器表达式格式："><a href="#生成器表达式格式：" class="headerlink" title="生成器表达式格式："></a>生成器表达式格式：</h4><p>生成器表达式是在python2.4中引入的，当<u>序列过长， 而每次只需要获取一个元素时</u>，应当考虑使用生成器表达式而不是列表解析。生成器表达式的语法和列表解析一样，只不过生成器表达式是被<code>()</code>括起来的，而不是<code>[]</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr)</span><br></pre></td></tr></table></figure>

<p>生成器表达式并不是创建一个列表， 而是返回一个<strong>生成器</strong>，这个生成器在每次计算出一个条目后，把这个条目”产生”（<code>yield</code>）出来。 生成器表达式使用了”惰性计算”（<code>lazy evaluation</code>），只有在检索时才被赋值（<code>evaluated</code>），所以在列表比较长的情况下使用内存上更有效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>) <span class="keyword">if</span> i % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__iter__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__next__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(gen))</span><br><span class="line"><span class="comment">#in判断前面字符串是否在后面的对象里</span></span><br><span class="line"><span class="comment">## 使用sum求和之后会导致再次迭代所获取的值为空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(gen))</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> gen])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成器会在协程中使用</span></span><br><span class="line"><span class="comment">## 生成器也会在scrapy框架中使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 通过代码发现 创建5亿的序列过程极其漫长</span></span><br><span class="line"><span class="comment">## my_list = [i for i in range(500000000)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 通过生成器表达式创建长序列</span></span><br><span class="line">iter_list = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500000000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iter_list:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<h4 id="注意点总结："><a href="#注意点总结：" class="headerlink" title="注意点总结："></a>注意点总结：</h4><blockquote>
<ul>
<li>序列过长， 而每次只需要获取一个元素时考虑生成器表达式</li>
<li>生成器表达式返回的是一个<strong>生成器</strong>，不是一个元组或者列表！既然返回的是生成器就意味着其是一个特殊的迭代器，我们可以通过下面的方法使用这个生成器表达式：</li>
</ul>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#for循环遍历取出每个值</span></span><br><span class="line">iter_list = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50000</span>))</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iter_list:</span><br><span class="line">    	<span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#next一个个取值</span></span><br><span class="line">iter_list = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50000</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iter_list))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iter_list))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过元组接收可迭代对象</span></span><br><span class="line">iter_list = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50000</span>))</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> iter_list])</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>生成器表达式内存占用:</li>
</ul>
<blockquote>
<p><strong>为什么生成器执行以上代码速度要比列表推导式快的多？</strong></p>
<p>列表这种容器需要占用系统内存，并且在生成内存的时候将元素创建出来。这就是在使用列表推导式生成大数目的推导式的时候比较慢的原因。</p>
<p>而生成器表达式不同，使用next()获取这个生成器中的值 在内存中只有一个</p>
<p>第一次调用next获取返回值 0<br>第二次调用next获取返回值 1  当前的这个值将覆盖上一个值<br>以此类推….<br>    无论有多少个值，在内存中只保证有一个值<br>    并且是调用一次 产生一个值</p>
<p>(这种现象的原因是<code>yield</code>)</p>
</blockquote>
</blockquote>
<h3 id="生成器中的send-与close-方法"><a href="#生成器中的send-与close-方法" class="headerlink" title="生成器中的send()与close()方法"></a>生成器中的<code>send()</code>与<code>close()</code>方法</h3><p>生成器中还有两个很重要的方法：<code>send()</code>和<code>close()</code>。</p>
<h4 id="send-value"><a href="#send-value" class="headerlink" title="send(value):"></a><code>send(value)</code>:</h4><blockquote>
<p>从前面了解到，<code>next()</code>方法可以恢复生成器状态并继续执行，其实<code>send()</code>是除<code>next()</code>外另一个恢复生成器的方法。</p>
<p>Python 2.5中，<code>yield</code>语句变成了<code>yield</code>表达式，也就是说<code>yield</code>可以有一个值，而这个值就是<code>send()</code>方法的参数，所以<code>send(None)</code>和<code>next()</code>是等效的。同样，<code>next()</code>和<code>send()</code>的返回值都是<code>yield</code>语句处的参数<code>(yield value)</code></p>
</blockquote>
<ul>
<li>关于<code>send()</code>方法需要注意的是：</li>
</ul>
<blockquote>
<p>调用send传入非None值前，生成器必须处于挂起状态，否则将抛出异常。也就是说，第一次调用时，要使用<code>next()</code>语句或<code>send(None)</code>，因为没有<code>yield</code>语句来接收这个值。</p>
<p>所以建议第一次调用都建议使用<code>next()</code></p>
</blockquote>
<ul>
<li>用何种方式接收<code>send()</code>传递的参数</li>
</ul>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_value = <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p>如上，通过变量接受<code>yield</code>表达式的值，并可以在后面自由的使用该变量</p>
</blockquote>
<ul>
<li>主要应用场景</li>
</ul>
<blockquote>
<ul>
<li>想在程序运行的过程中对当前的函数的运行过程进行操作的时候</li>
<li>就算想让生成器这个函数不仅仅做生成器的工作的时候，希望让他产生其他功能的时候，可以去用</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        str_value = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">if</span> str_value == <span class="string">&#x27;你好&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;当前判断方法被执行...&#x27;</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(str_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_iter = my_range(<span class="number">5</span>)</span><br><span class="line"><span class="comment">## send 方法与next()方法 使用方式类似</span></span><br><span class="line"><span class="comment">## send 可以向生成器传递一个参数 并在生成器中进行接收</span></span><br><span class="line"><span class="comment">## send 一般情况下不在第一次获取值时使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 第一次取值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 第二次取值时并向当前的生成器传递一个参数</span></span><br><span class="line"><span class="built_in">print</span>(my_iter.send(<span class="string">&#x27;你好&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(my_iter.send(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以在程序运行的过程中对当前的函数的运行过程进行操作</span></span><br><span class="line"><span class="comment">## 想要发送一个信息让当前这个生成器做其他事情 send</span></span><br><span class="line"><span class="comment">## 协程不需要锁 单线程</span></span><br></pre></td></tr></table></figure>

<h4 id="close"><a href="#close" class="headerlink" title="close():"></a><code>close()</code>:</h4><p>这个方法用于关闭生成器，对关闭的生成器后再次调用<code>next</code>或<code>send</code>将抛出<code>StopIteration</code>异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        val = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;val is: &#x27;</span>, val)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_range = my_range(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_range.__next__())</span><br><span class="line"><span class="built_in">print</span>(my_range.__next__())</span><br><span class="line"><span class="built_in">print</span>(my_range.send(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line">my_range.close()</span><br><span class="line"><span class="built_in">print</span>(my_range.send(<span class="string">&#x27;world&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>生成器是一种特殊的迭代器</li>
<li>内部支持了迭代器协议：不需要明确定义<code>__iter__()</code>和<code>__next__()</code>方法。</li>
<li>生成器通过生成器函数产生，生成器函数可以通过常规的<code>def</code>语句来定义，但是不用<code>return</code>返回，而是用<code>yield</code>一次返回一个结果。</li>
<li>在生成器函数中，可以定义多个yield</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h3><blockquote>
<p>想想看怎样用程序实现下面的功能呢？</p>
<p>在一个聊天软件中显示是谁发送了这条信息，即：一条信息标记了是谁发送的</p>
<p>今天我们要研究的知识点是<code>闭包</code>，实现上述功能的方式可能有多种，但是闭包会更简单。</p>
</blockquote>
<h4 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a>普通方式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">user_name, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (user_name, content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_name1 = <span class="string">&quot;安娜&quot;</span></span><br><span class="line">user_name2 = <span class="string">&quot;双双&quot;</span></span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;我一个人刚刚好~~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(安娜):今天吃了么？</span><br><span class="line">(双双):吃了~</span><br><span class="line">(安娜):吃了啥？</span><br><span class="line">(双双):半只牛~</span><br><span class="line">(安娜):为啥不给我吃？</span><br><span class="line">(双双):我一个人刚刚好~~</span><br><span class="line">(安娜):友谊的小船说翻就翻！</span><br><span class="line">(双双):我会游泳~~~</span><br></pre></td></tr></table></figure>

<p>小总结：</p>
<ul>
<li>上述代码已经实现了要求，但是每次发送信息时需要将用户名称传递到<code>say</code>函数中，相对比较麻烦</li>
</ul>
<h4 id="面向对象的方式解决上述问题"><a href="#面向对象的方式解决上述问题" class="headerlink" title="面向对象的方式解决上述问题"></a>面向对象的方式解决上述问题</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.user_name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (self.user_name, content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&quot;安娜&quot;</span>)</span><br><span class="line">p2 = Person(<span class="string">&quot;双双&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1.say(<span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;我一个人刚刚好~~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(安娜):今天吃了么？</span><br><span class="line">(双双):吃了~</span><br><span class="line">(安娜):吃了啥？</span><br><span class="line">(双双):半只牛~</span><br><span class="line">(安娜):为啥不给我吃？</span><br><span class="line">(双双):我一个人刚刚好~~</span><br><span class="line">(安娜):友谊的小船说翻就翻！</span><br><span class="line">(双双):我会游泳~~~</span><br></pre></td></tr></table></figure>

<p>小总结：</p>
<ul>
<li>通过面向对象的方式能够实现上述要求，但是发现使用了类以及对象，总体感觉还是较为复杂，再者说继承的object类中有很多默认的方法，既然这个程序不需要，显然会造成一定的浪费</li>
</ul>
<h4 id="使用闭包解决上述问题"><a href="#使用闭包解决上述问题" class="headerlink" title="使用闭包解决上述问题"></a>使用闭包解决上述问题</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">content</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (name, content))</span><br><span class="line">    <span class="keyword">return</span> say</span><br><span class="line"></span><br><span class="line">p1 = person(<span class="string">&quot;安娜&quot;</span>)</span><br><span class="line">p2 = person(<span class="string">&quot;双双&quot;</span>)</span><br><span class="line"></span><br><span class="line">p1(<span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;我一个人刚刚好~~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><blockquote>
<p>定义函数可以理解为：</p>
<p>定义了一个全局变量，其变量名字是函数的名字，即<code>test</code>。这个test变量指向了一个代码块，这个代码块是函数。其实就是说test保存了一个代码块的地址，即引用</p>
</blockquote>
<h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>闭包<code>(closure</code>) 定义非常抽象，很难看懂。下面尝试从概念上去理解一下闭包：</p>
<blockquote>
<p>在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 —— 维基百科<code>https://zh.wikipedia.org/wiki/闭包_(计算机科学)</code></p>
</blockquote>
<p>用比较容易懂的人话说：<u>就是当某个函数被当成对象返回时，夹带了外部变量，就形成了一个闭包</u>。可以这样理解，<u>闭包就是能够读取其他函数内部变量的函数</u></p>
<p>看如下案例，便于理解什么是闭包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_printer</span>(<span class="params">msg</span>):  <span class="comment"># 可以认为是 外部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printer</span>():  <span class="comment"># 可以认为是 内部函数</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">    <span class="keyword">return</span> printer  <span class="comment"># 返回的内部函数的引用</span></span><br><span class="line"></span><br><span class="line">printer = make_printer(<span class="string">&#x27;Good!&#x27;</span>)</span><br><span class="line">printer()</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Good</span><br></pre></td></tr></table></figure>

<p><strong>总结一下闭包的特征：</strong></p>
<blockquote>
<ol>
<li>存在函数嵌套</li>
<li>内部函数使用了外部函数的参数</li>
</ol>
<p>符合这两条件的即闭包</p>
</blockquote>
<h3 id="闭包案例"><a href="#闭包案例" class="headerlink" title="闭包案例"></a>闭包案例</h3><p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_in</span>(<span class="params">number_in</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in test_in 函数, number_in is %d&quot;</span> % number_in)</span><br><span class="line">        <span class="keyword">return</span> number + number_in</span><br><span class="line">    <span class="keyword">return</span> test_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 给test函数赋值，这个20就是给参数number</span></span><br><span class="line">ret = test(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 注意这里的100其实给参数number_in</span></span><br><span class="line"><span class="built_in">print</span>(ret(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 注意这里的200其实给参数number_in</span></span><br><span class="line"><span class="built_in">print</span>(ret(<span class="number">200</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">in test_in 函数, number_in is 100</span><br><span class="line">120</span><br><span class="line">in test_in 函数, number_in is 200</span><br><span class="line">220</span><br></pre></td></tr></table></figure>

<h3 id="使用闭包需要注意的问题"><a href="#使用闭包需要注意的问题" class="headerlink" title="使用闭包需要注意的问题"></a>使用闭包需要注意的问题</h3><blockquote>
<p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。因此可以手动解除对匿名函数的引用，以便释放内存。</p>
<p>需要注意到一个关键点：<strong>闭包函数保持持久性的原因</strong>~~</p>
<p>如果一个函数中有内层函数，如果内层函数没有释放，则外层函数永远不会被垃圾回收。实际上只要将内部代码走完就会释放内存。</p>
<blockquote>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/yiyueqinghui/article/details/96453390">什么是闭包，闭包造成的内存泄露如何解决_一月清辉的博客-CSDN博客_闭包内存泄漏</a></p>
</blockquote>
<p>但是有时候在内部函数中引用了外部函数。因为内部函数没有运行，且内部函数中的代码又引用了外部函数中的参数，导致外部函数在执行完毕后不能进行回收GC。回收机制检测当前函数&#x2F;代码状态打上标签，表示外部函数不能被回收。。而内部函数呢，如果做的事情返回的东西又包含外部函数的参数，则此时外部函数依旧不能释放</p>
<p>就是一个如此的循环。。</p>
</blockquote>
<h3 id="使用闭包修改外部函数中的变量"><a href="#使用闭包修改外部函数中的变量" class="headerlink" title="使用闭包修改外部函数中的变量"></a>使用闭包修改外部函数中的变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>(<span class="params">start=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_one</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> start  <span class="comment"># nonlocal 关键字用于在嵌套函数内部使用变量，其中变量不应属于内部函数。</span></span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">return</span> add_one</span><br><span class="line"></span><br><span class="line">c1 = counter(<span class="number">5</span>)  <span class="comment"># 创建一个闭包</span></span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"></span><br><span class="line">c2 = counter(<span class="number">50</span>)  <span class="comment"># 创建另外一个闭包</span></span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"><span class="built_in">print</span>(c2())</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td></tr></table></figure>

<hr>
<p>插播一条知识：</p>
<h3 id="global和nonlocal关键字用法区别"><a href="#global和nonlocal关键字用法区别" class="headerlink" title="global和nonlocal关键字用法区别"></a>global和nonlocal关键字用法区别</h3><blockquote>
<p>第一，两者的功能不同。global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。</p>
<p>第二，两者使用的范围不同。global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误（见第一）。</p>
</blockquote>
<h4 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h4><blockquote>
<ol>
<li>nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量。</li>
</ol>
</blockquote>
<hr>
<h3 id="多个闭包"><a href="#多个闭包" class="headerlink" title="多个闭包"></a>多个闭包</h3><p>如上面的代码中，调用了2次<code>counter</code>，也就意味着创建了2个闭包，并且每个闭包之间没有任何关系。</p>
<h3 id="闭包总结"><a href="#闭包总结" class="headerlink" title="闭包总结"></a>闭包总结</h3><ol>
<li>闭包定义是在函数内再嵌套函数</li>
<li>闭包是可以访问另一个函数局部作用域中变量的函数</li>
<li>闭包可以读取另外一个函数内部的变量</li>
<li>闭包可以让参数和变量不会被垃圾回收机制回收，始终保持在内存中（而普通的函数调用结束后 会被Python解释器自动释放局部变量）</li>
<li>闭包：实际上就是可以将函数当成一个实例对象一样去使用的一种编程<strong>手法</strong>，只不过某些时候用的更好，不会也没关系，面向对象都能完成，只不过闭包更加轻量</li>
<li>闭包的特性就是内部函数使用外部函数的参数，外部函数返回内部函数的引用。就相当于外面给参数，里面处理参数，我们就是通过里面处理参数的函数做事情（所以我们才需要返回内部函数的引用）</li>
</ol>
<h3 id="闭包和面向对象比较"><a href="#闭包和面向对象比较" class="headerlink" title="闭包和面向对象比较"></a>闭包和面向对象比较</h3><p>大家是否有种感觉，好像闭包与对象有些类似。确实是这样的，对象其实可通俗的理解为<strong>数据(属性) + 功能(方法)<strong>，而闭包也可以理解为</strong>数据 + 功能</strong>，</p>
<blockquote>
<ul>
<li>只不过此时<strong>数据</strong>是<u>外部函数中的那些局部变量或者形参</u>，</li>
<li>而<strong>功能</strong>则是<u>内部函数</u>。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>两者主要区别：</li>
</ul>
<blockquote>
<ul>
<li>面向对象返回的是一个实例方法</li>
<li>闭包返回的是一个函数的引用</li>
</ul>
</blockquote>
</blockquote>
<p>通俗来讲就是，对象适合完成较为复杂的功能，而闭包则更轻量</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器是python语言中的语法糖，可以通过装饰器对函数的功能进行拓展。</p>
<blockquote>
<ul>
<li><strong>s什么是语法糖？</strong></li>
</ul>
<p>如果一个函数定义的上方有<code>@函数名</code>。默认将被装饰的函数的引用传递给上方的装饰器</p>
<ul>
<li>一个小技巧</li>
</ul>
<p>以后怎么看一个语法糖呢？怎么阅读代码？可以先阅读其框架，即函数名称、参数、返回值。然再一步步深入读</p>
<p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211291650343.png" alt="image-20221129165045502"></p>
</blockquote>
<h3 id="为什么需要装饰器"><a href="#为什么需要装饰器" class="headerlink" title="为什么需要装饰器"></a>为什么需要装饰器</h3><p>我们假设你的程序实现了<code>say_hello()</code>和<code>say_goodbye()</code>两个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)  <span class="comment"># 此处应打印goodbye</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure>

<p>假设上述代码中的say_goodbye函数出现了bug，为了之后能更好的维护，现在需要在调用方法前记录函数调用名称，以定位出错位置。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[DEBUG]: Enter say_hello()</span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">[DEBUG]: Enter say_goodbye()</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure>

<p>实现方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter say_hello()&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter say_goodbye()&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure>

<p>对上述代码进行优化：</p>
<blockquote>
<p>这个时候用到了一个包：<code>inspect</code></p>
<p>一段你测试代码，来康康<code>inspect</code>有什么功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    <span class="keyword">import</span> inspect</span><br><span class="line">    caller_name = inspect.stack()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(caller_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test over&quot;</span></span><br><span class="line"><span class="built_in">print</span>(debug())</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[</span><br><span class="line">    FrameInfo(</span><br><span class="line">        frame=&lt;frame at <span class="number">0x0000020E59DB6DD0</span>, file <span class="string">&#x27;F:\\Learning\\ComputerScience\\Cyber Security\\Python全栈\\核心编程\\09三闭一器\\SourceCode_装饰器\\test.py&#x27;</span>, line <span class="number">4</span>, code debug&gt;, </span><br><span class="line">        filename=<span class="string">&#x27;F:\\Learning\\ComputerScience\\Cyber Security\\Python全栈\\核心编程\\09三闭一器\\SourceCode_装饰器\\test.py&#x27;</span>, </span><br><span class="line">        lineno=<span class="number">3</span>, </span><br><span class="line">        function=<span class="string">&#x27;debug&#x27;</span>, </span><br><span class="line">        code_context=[<span class="string">&#x27;    caller_name = inspect.stack()\n&#x27;</span>], index=<span class="number">0</span></span><br><span class="line">            ),</span><br><span class="line">    FrameInfo(</span><br><span class="line">        frame=&lt;frame at <span class="number">0x0000020E59CF8C40</span>, file <span class="string">&#x27;F:\\Learning\\ComputerScience\\Cyber Security\\Python全栈\\核心编程\\09三闭一器\\SourceCode_装饰器\\test.py&#x27;</span>, line <span class="number">6</span>, code &lt;module&gt;&gt;,</span><br><span class="line">        filename=<span class="string">&#x27;F:\\Learning\\ComputerScience\\Cyber Security\\Python全栈\\核心编程\\09三闭一器\\SourceCode_装饰器\\test.py&#x27;</span>,</span><br><span class="line">        lineno=<span class="number">6</span>, </span><br><span class="line">        function=<span class="string">&#x27;&lt;module&gt;&#x27;</span>, </span><br><span class="line">        code_context=[<span class="string">&#x27;print(debug())\n&#x27;</span>], </span><br><span class="line">        index=<span class="number">0</span></span><br><span class="line">            )</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>刨析一下输出的内容：<code>inspect.stack()[1][3]</code>就是拿到当前函数的名字</p>
<p>不过该包一般用不到</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    <span class="keyword">import</span> inspect</span><br><span class="line">    caller_name = inspect.stack()[<span class="number">1</span>][<span class="number">3</span>]  <span class="comment"># 可以返回函数名与当前函数的返回值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(caller_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    debug()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    debug()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;goodbye!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure>

<p>上述代码需要在每个业务函数里都要调用一下<code>debug()</code>函数，是不是很难受？万一老板说say相关的函数不用debug，do相关的才需要呢？</p>
<p>那么装饰器这时候应该登场了。</p>
<h3 id="装饰器是什么"><a href="#装饰器是什么" class="headerlink" title="装饰器是什么"></a>装饰器是什么</h3><blockquote>
<p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下<strong>增加额外功能</strong>，<u>装饰器的返回值也是一个函数对象（实际上就是函数引用）</u>。它经常用于有切面需求的场景，比如：<strong>插入日志、性能测试、事务处理（数据库）、缓存（redis）、权限校验等场景（网站开发）</strong>。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续<strong>重用</strong>。</p>
<p>实际上面向对象的核心也是重用，所以装饰器的功能实际上也可以通过面向对象的继承来实现。但面向对象不是万能的，，</p>
</blockquote>
<p>概括的讲，装饰器的作用就是<strong>为已经存在的函数或对象添加额外的功能</strong>。</p>
<h3 id="如何实现一个装饰器"><a href="#如何实现一个装饰器" class="headerlink" title="如何实现一个装饰器"></a>如何实现一个装饰器</h3><p>在早些时候 (<code>Python Version &lt; 2.4</code>，2004年以前)，为一个函数添加额外功能的写法是这样的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))<span class="comment">#func.__name__是输出该函数的名字，注意func是一个函数的引用。需要注意到的是，这个地方并没有实现魔术方法，那么__name__是从哪来的呢？答案是继承自object父类</span></span><br><span class="line">        <span class="keyword">return</span> func()<span class="comment"># 参数func是一个函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 现在我需要将say_hello函数的引用传给debug函数</span></span><br><span class="line">say_hello = debug(say_hello)</span><br><span class="line">say_hello()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果：</span></span><br><span class="line">[DEBUG]: enter say_hello()</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的<code>debug</code>函数其实已经是一个装饰器了，它对原函数做了包装并返回了另外一个函数，额外添加了一些功能。</p>
<p>实际上上面的写法就是一个闭包，在闭包那一节讲到的就是如此。不同之处在于，这个地方传递给外部函数的不是一个参数，而是一个函数的引用（从某种意义上来说也是一种参数了）。</p>
<p>除此之外，都是一样的操作：外部函数<code>debug</code>传递参数给内部函数<code>wrapper</code>，内部函数使用传进来的参数做了一件<code>print</code>的事情。最后外部函数返回的是内部函数的引用，即通过该引用来调用内部函数~~</p>
</blockquote>
<p>因为这样写实在不太优雅，在后面版本的Python中支持了<code>@</code>语法糖，下面代码等同于早期的写法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug		</span><span class="comment"># 装饰器依赖闭包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行过程：</p>
<p>先运行<code>say_hello()</code>，然后检测到语法糖<code>@debug</code>，会先运行这个，将<code>@debug</code>下面的函数引用当作参数传递给<code>debug</code>函数，最后<code>debug</code>函数经过处理返回传入的<code>say_hello()</code>函数，就相当于在执行<code>say_hello()</code>的基础上额外执行了<code>print(&quot;[DEBUG]: enter &#123;&#125;()&quot;.format(func.__name__))</code></p>
</blockquote>
<p>这是最简单的装饰器，但是有一个问题，如果被装饰的函数需要传入参数，那么这个装饰器就坏了。因为返回的函数并不能接受参数，你可以指定装饰器函数<code>wrapper</code>接受和原函数一样的参数，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 规律: 外层函数一般接收函数引用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">something</span>):  <span class="comment"># 指定一毛一样的参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="comment"># 规律: 内部函数返回被装饰的函数的调用</span></span><br><span class="line">        <span class="keyword">return</span> func(something)</span><br><span class="line"> 	<span class="comment"># 规律：外层函数返回内层函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装过函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;顾安&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="万能装饰器"><a href="#万能装饰器" class="headerlink" title="万能装饰器"></a>万能装饰器</h4><p>这样你就解决了一个问题，但又多了N个问题。因为函数有千千万，你只管你自己的函数，别人的函数参数是什么样子，鬼知道？还好Python提供了可变参数<code>*args</code>和关键字参数<code>**kwargs</code>，有了这两个参数，装饰器就可以用于任意目标函数了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;顾安&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><blockquote>
<p>如果装饰器也需要传递参数呢？</p>
</blockquote>
<p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出<code>log</code>信息，而且还需指定<code>log</code>的级别，那么装饰器就会是这样的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 接收装饰器本身的参数  level: 日志报警等级 info debug warning error</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logging</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="comment"># 接收被装饰的函数的引用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">func</span>):</span><br><span class="line">         <span class="comment"># 接收被装饰的函数的参数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner_wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(level=level,func=func.__name__))</span><br><span class="line">             <span class="comment"># 返回的是被装饰的函数的调用</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&#x27;INFO&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果没有使用@语法，等同于</span></span><br><span class="line"><span class="comment">## say = logging(level=&#x27;INFO&#x27;)(say)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&#x27;DEBUG&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do &#123;&#125;...&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    do(<span class="string">&quot;my work&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>是不是有一些晕？你可以这么理解，当带参数的装饰器被打在某个函数上时，比如<code>@logging(level=&#39;DEBUG&#39;)</code>，它其实是一个函数，会马上被执行，只要它返回的结果是一个装饰器时，那就没问题。细细再体会一下。</p>
<h3 id="基于类的装饰器"><a href="#基于类的装饰器" class="headerlink" title="基于类的装饰器"></a>基于类的装饰器</h3><p>装饰器函数其实是这样一个接口约束，它必须接受一个<code>callable</code>对象作为参数，然后返回一个<u><code>callable</code>对象</u>。在Python中一般<code>callable</code>对象都是函数，但也有例外。只要某个对象重载了<code>__call__()</code>方法，那么这个对象就是callable的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call me!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t()  <span class="comment"># call me</span></span><br></pre></td></tr></table></figure>

<p>像<code>__call__</code>这样前后都带下划线的方法在Python中被称为内置方法，有时候也被称为魔法方法。重载这些魔法方法一般会改变对象的内部行为。上面这个例子就让一个类对象拥有了被调用的行为。</p>
<p>回到装饰器上的概念上来，<u>装饰器要求接受一个<code>callable</code>对象，并返回一个<code>callable</code>对象</u>。那么用类来实现也是也可以的。我们可以让类的构造函数<code>__init__()</code>接受一个函数，然后重载<code>__call__()</code>并返回一个函数，也可以达到装饰器函数的效果。</p>
<blockquote>
<p><a href="http://gungnir.top/38482.html">8. 进阶面向对象 | 晚上十一点睡觉の Blog (gungnir.top)</a>中搜索<code>__init__</code>，讲到了用法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logging</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(func=self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果没有使用@语法，等同于</span></span><br><span class="line"><span class="comment">## say = Logging()(say)</span></span><br><span class="line"><span class="comment">#这个地方say指向的是Logging类生成的对象</span></span><br><span class="line"><span class="meta">@Logging</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;木木&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="带参数的类装饰器"><a href="#带参数的类装饰器" class="headerlink" title="带参数的类装饰器"></a>带参数的类装饰器</h3><p>如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接收的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载<code>__call__</code>方法是就需要接收一个函数并返回一个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logging</span>:</span><br><span class="line">    <span class="comment"># 创建这个类本身的参数 使用实例属性进行接收</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level=<span class="string">&#x27;INFO&#x27;</span></span>):</span><br><span class="line">        self.level = level</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 创建__call__方法 用于接收被装饰的函数的引用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):  <span class="comment"># 接收函数</span></span><br><span class="line">        <span class="comment"># 创建一个内部函数用来接收被装饰的函数的参数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                level=self.level,</span><br><span class="line">                func=func.__name__))</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment"># 返回函数</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[DEBUG]: enter <span class="subst">&#123;func.__name__&#125;</span>()&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args)  <span class="comment"># 参数func是一个函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果没有使用@语法，等同于</span></span><br><span class="line"><span class="comment">## say = logging(level=&#x27;INFO&#x27;)(say)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Logging(<span class="params">level=<span class="string">&#x27;INFO&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;木木&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>装饰器的优势在于：并没有对原函数进行修改，而是在原函数的基础上，增加额外的功能，并且莫有对原函数有改动。所做的操作不过是使用<code>@debug</code>语法糖罢了</p>
</li>
<li><p>装饰器要求接受一个<code>callable</code>对象，并返回一个<code>callable</code>对象</p>
</li>
<li><p>一个函数可以套上多个装饰器，一个装饰器也可以修饰多个函数</p>
</li>
<li><p>规律1: 外层函数一般接收函数引用</p>
</li>
<li><p>规律2：外层函数返回内层函数的引用</p>
</li>
<li><p>规律3: 内部函数返回被装饰的函数的调用</p>
</li>
</ul>
<p>以后装饰器都可以按照这个步骤来写</p>
<hr>
<h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/210501891">牛鹭学院：Python语法糖，你知道吗？ - 知乎 (zhihu.com)</a></li>
</ul>
</blockquote>
<blockquote>
<p><strong>声明：</strong></p>
<ol>
<li><p>若文章存在错误，望诸君不吝指正^</p>
</li>
<li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p>
</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://gungnir.top/">晚上十一点睡觉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gungnir.top/posts/5766/">http://gungnir.top/posts/5766/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gungnir.top" target="_blank">晚上十一点睡觉のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237497.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/41054/"><img class="prev-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237494.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ThinkPHP框架漏洞总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/38482/"><img class="next-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237577.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">8. 进阶面向对象</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/24764/" title="1. 基础知识"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237554.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">1. 基础知识</div></div></a></div><div><a href="/posts/5964/" title="11. 异常与文件操作"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237522.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-30</div><div class="title">11. 异常与文件操作</div></div></a></div><div><a href="/posts/38591/" title="10. 元类编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237574.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">10. 元类编程</div></div></a></div><div><a href="/posts/10554/" title="13. 多线程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237573.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">13. 多线程</div></div></a></div><div><a href="/posts/4710/" title="12. 网络编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308745.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">12. 网络编程</div></div></a></div><div><a href="/posts/60681/" title="14. 多进程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237532.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="title">14. 多进程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">晚上十一点睡觉</div><div class="author-info__description">晚上十一点睡觉的个人博客，个人笔记及日志，最近在学习网络安全和Python</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/11pmsleep"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/11pmsleep" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:860637048@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=860637048" rel="external nofollow noreferrer" target="_blank" title="qq"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记迁移整理中~~~以前习惯有道云记笔记，整理知识也算沉淀自己的一部分吧·· 加油··stay passionate and never say die!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.2.</span> <span class="toc-text">什么是迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">可迭代对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">可迭代的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">不可迭代的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.3.3.</span> <span class="toc-text">判断数据类型到底是否可迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.4.</span> <span class="toc-text">可迭代对象的特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="toc-number">1.4.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">可迭代对象的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">获取可迭代对象的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.3.</span> <span class="toc-text">获取迭代器的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StopIteration-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.4.</span> <span class="toc-text">StopIteration 异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">自定义迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iter-%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">__iter__方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#next-%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">__next__方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">自定义迭代器案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in-%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.6.</span> <span class="toc-text">for...in...循环的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%8F%AA%E6%9C%89for%E5%BE%AA%E7%8E%AF%E8%83%BD%E6%8E%A5%E6%94%B6%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.</span> <span class="toc-text">并不是只有for循环能接收可迭代对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">简单总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E5%A0%82%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.9.</span> <span class="toc-text">随堂作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-1"><span class="toc-number">2.1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">生成器工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">生成器表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%EF%BC%9A%E5%A4%8D%E4%B9%A0%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">引入：复习列表推导式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">生成器表达式格式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.3.3.</span> <span class="toc-text">注意点总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%AD%E7%9A%84send-%E4%B8%8Eclose-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">生成器中的send()与close()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#send-value"><span class="toc-number">2.4.1.</span> <span class="toc-text">send(value):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#close"><span class="toc-number">2.4.2.</span> <span class="toc-text">close():</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">3.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-2"><span class="toc-number">3.1.</span> <span class="toc-text">引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">普通方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E4%B8%8A%E8%BF%B0%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">面向对象的方式解决上述问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E8%A7%A3%E5%86%B3%E4%B8%8A%E8%BF%B0%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.3.</span> <span class="toc-text">使用闭包解决上述问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">函数引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.</span> <span class="toc-text">闭包的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%A1%88%E4%BE%8B"><span class="toc-number">3.4.</span> <span class="toc-text">闭包案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">使用闭包需要注意的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">3.6.</span> <span class="toc-text">使用闭包修改外部函数中的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#global%E5%92%8Cnonlocal%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.</span> <span class="toc-text">global和nonlocal关键字用法区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nonlocal%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.7.1.</span> <span class="toc-text">nonlocal关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E9%97%AD%E5%8C%85"><span class="toc-number">3.8.</span> <span class="toc-text">多个闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.</span> <span class="toc-text">闭包总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83"><span class="toc-number">3.10.</span> <span class="toc-text">闭包和面向对象比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">为什么需要装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.2.</span> <span class="toc-text">装饰器是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">如何实现一个装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">万能装饰器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">带参数的装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">基于类的装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">带参数的类装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#refer"><span class="toc-number">5.</span> <span class="toc-text">refer</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4710/" title="12. 网络编程"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308745.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="12. 网络编程"/></a><div class="content"><a class="title" href="/posts/4710/" title="12. 网络编程">12. 网络编程</a><time datetime="2022-12-27T09:19:51.804Z" title="更新于 2022-12-27 17:19:51">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/45992/" title="jQuery基础学习"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237573.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jQuery基础学习"/></a><div class="content"><a class="title" href="/posts/45992/" title="jQuery基础学习">jQuery基础学习</a><time datetime="2022-12-27T04:54:28.971Z" title="更新于 2022-12-27 12:54:28">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5964/" title="11. 异常与文件操作"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237522.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="11. 异常与文件操作"/></a><div class="content"><a class="title" href="/posts/5964/" title="11. 异常与文件操作">11. 异常与文件操作</a><time datetime="2022-12-26T17:08:11.261Z" title="更新于 2022-12-27 01:08:11">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/38591/" title="10. 元类编程"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237574.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="10. 元类编程"/></a><div class="content"><a class="title" href="/posts/38591/" title="10. 元类编程">10. 元类编程</a><time datetime="2022-12-26T10:50:34.343Z" title="更新于 2022-12-26 18:50:34">2022-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5766/" title="9. 三器一闭"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237497.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="9. 三器一闭"/></a><div class="content"><a class="title" href="/posts/5766/" title="9. 三器一闭">9. 三器一闭</a><time datetime="2022-12-26T05:42:25.455Z" title="更新于 2022-12-26 13:42:25">2022-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 晚上十一点睡觉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 11pmsleep's blog ~~~ 该网站用来记录学习笔记及生活，欢迎交流技术~~~Blog仅供个人记录笔记学习所用，若有侵权，联系我删除~若有错误，也望诸君不吝指正</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>