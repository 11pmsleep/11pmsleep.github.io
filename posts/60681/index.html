<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>14. 多进程 | 晚上十一点睡觉のBlog</title><meta name="author" content="晚上十一点睡觉"><meta name="copyright" content="晚上十一点睡觉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多进程 进程什么是进程程序：例如xxx.py这是程序，是一个静态的文件代码 进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。进程的本质就是为一个程序提供操作系统的资源。 进程多任务：不仅可以通过线程完成多任务，进程也是可以的 线程：运行程序的最基本的单位 进程"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gungnir.top/posts/60681/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?60a7a67c81784f02b889a11753e4e8cc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 晚上十一点睡觉","link":"链接: ","source":"来源: 晚上十一点睡觉のBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '14. 多进程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-10 16:03:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">129</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">43</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308753.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">晚上十一点睡觉のBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">14. 多进程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-03T09:46:34.000Z" title="发表于 2022-12-03 17:46:34">2022-12-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-10T08:03:46.921Z" title="更新于 2023-01-10 16:03:46">2023-01-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/">Python全栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Python核心编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="14. 多进程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/60681/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>多进程</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>程序：例如xxx.py这是程序，是一个静态的文件代码</p>
<p>进程：一个程序运行起来后，<strong>代码+用到的资源 称之为进程</strong>，它是操作系统分配资源的基本单元。进程的本质就是为一个程序提供操作系统的资源。</p>
<p>进程多任务：不仅可以通过线程完成多任务，进程也是可以的</p>
<p>线程：运行程序的最基本的单位</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态。</p>
<ul>
<li>就绪态：运行的条件都已经具备，正在等在cpu执行</li>
<li>执行态：cpu正在执行其功能</li>
<li>等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态</li>
</ul>
<h2 id="进程的创建-multiprocessing"><a href="#进程的创建-multiprocessing" class="headerlink" title="进程的创建 - multiprocessing"></a>进程的创建 - <code>multiprocessing</code></h2><p><code>multiprocessing</code>模块就是跨平台版本的<strong>多进程模块</strong>，提供了一个<code>Process</code>类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。</p>
<h3 id="Process语法结构如下："><a href="#Process语法结构如下：" class="headerlink" title="Process语法结构如下："></a><code>Process</code>语法结构如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看源码：（和线程非常类似）</p>
<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202301031739909.png" alt="image-20230103173950322" style="zoom:50%;" />

<ul>
<li><code>target</code>：如果传递了函数的引用，可以任务这个子进程就执行这里的代码</li>
<li><code>args</code>：给<code>target</code>指定的函数传递的参数，以元组的方式传递</li>
<li><code>kwargs</code>：给<code>target</code>指定的函数传递命名参数</li>
<li><code>name</code>：给进程设定一个名字，可以不设定</li>
<li><code>group</code>：指定进程组，大多数情况下用不到</li>
</ul>
</blockquote>
<h3 id="Process创建的实例对象的常用方法"><a href="#Process创建的实例对象的常用方法" class="headerlink" title="Process创建的实例对象的常用方法"></a><code>Process</code>创建的实例对象的<strong>常用方法</strong></h3><blockquote>
<ul>
<li><code>start()</code>：启动子进程实例（创建子进程）</li>
<li><code>is_alive()</code>：判断进程子进程是否存活</li>
<li><code>join([timeout])</code>：是否等待子进程执行结束，或等待多少秒</li>
<li><code>terminate()</code>：不管任务是否完成，立即终止子进程</li>
</ul>
</blockquote>
<h3 id="Process创建的实例对象的常用属性"><a href="#Process创建的实例对象的常用属性" class="headerlink" title="Process创建的实例对象的常用属性"></a><code>Process</code>创建的实例对象的<strong>常用属性</strong></h3><blockquote>
<ul>
<li><code>name</code>：当前进程的别名，默认为Process-N，N为从1开始递增的整数</li>
<li><code>pid</code>：当前进程的<code>pid</code>（进程号）</li>
</ul>
</blockquote>
<h3 id="获取当前线程的信息"><a href="#获取当前线程的信息" class="headerlink" title="获取当前线程的信息"></a>获取当前线程的信息</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(multiprocessing.current_process().name)<span class="comment">#打印进程名字</span></span><br><span class="line"><span class="built_in">print</span>(multiprocessing.current_process().pid)<span class="comment">#打印pid</span></span><br><span class="line"><span class="built_in">print</span>(multiprocessing.current_process().is_alive())<span class="comment">#打印进程是否活着</span></span><br></pre></td></tr></table></figure>

<h3 id="启动创建的线程"><a href="#启动创建的线程" class="headerlink" title="启动创建的线程"></a>启动创建的线程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;子进程要执行的代码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前任务被子进程运行...&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=run_proc)<span class="comment">#和线程的使用基本上类似</span></span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前任务被主进程运行...&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动</p>
<h3 id="获取进程的-pid"><a href="#获取进程的-pid" class="headerlink" title="获取进程的 pid"></a>获取进程的 pid</h3><p><strong>示例代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;子进程要执行的代码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程运行中，pid=%d...&#x27;</span> % os.getpid())  <span class="comment"># os.getpid获取当前进程的进程号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程运行中，pid=%d...&#x27;</span> % os.getppid())  <span class="comment"># os.getppid获取当前进程的父进程号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程将要结束...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程pid: %d&#x27;</span> % os.getpid())  <span class="comment"># os.getpid获取当前进程的进程号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程pid: %d&#x27;</span> % os.getppid())  <span class="comment"># os.getppid获取当前进程的父进程号</span></span><br><span class="line">    p = Process(target=run_proc)</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getpid()</span><br><span class="line">os.getppid()</span><br></pre></td></tr></table></figure>

<ul>
<li>上面两个函数获取当前进程和父进程的<code>pid</code></li>
<li><code>main</code>函数，当前<code>python</code>文件的父进程是<code>pycharm</code>，<code>pycharm</code>通过当前<code>.py</code>文件代码生成的进程</li>
</ul>
</blockquote>
<h3 id="给子进程指定的函数传递参数"><a href="#给子进程指定的函数传递参数" class="headerlink" title="给子进程指定的函数传递参数"></a>给子进程指定的函数传递参数</h3><p><strong>示例代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process		<span class="comment">#从multiprocessing模块导入process.py文件</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name, age, **kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;子进程运行中，name=%s, age=%d, pid=%d...&#x27;</span> % (name, age, os.getpid()))</span><br><span class="line">        <span class="built_in">print</span>(kwargs)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">&#x27;test&#x27;</span>, <span class="number">18</span>), kwargs=&#123;<span class="string">&quot;m&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line">    p.start()</span><br><span class="line">    sleep(<span class="number">5</span>)  <span class="comment"># 5秒之后，立即结束子进程</span></span><br><span class="line">    p.terminate()       <span class="comment">#主线程结束后，僵尸进程才会结束</span></span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    但是通过执行系统命令ps查看停止后的进程</span></span><br><span class="line"><span class="string">    你会发现, 直接调用terminate方法停止的进程变成了一个僵尸进程(defunct), </span></span><br><span class="line"><span class="string">    只能等待主程序退出, 这个僵尸进程才会消失.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 等待子进程真正结束</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())</span><br></pre></td></tr></table></figure>



<h3 id="进程间不同享全局变量"><a href="#进程间不同享全局变量" class="headerlink" title="进程间不同享全局变量"></a>进程间不同享全局变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;子进程要执行的代码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in 子进程_1 pid=%d ,初始列表=%s&quot;</span> % (os.getpid(), nums))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        nums.append(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in 子进程_1 pid=%d ,nums=%s&quot;</span> % (os.getpid(), nums))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;子进程要执行的代码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in 子进程_2 pid=%d ,nums=%s&quot;</span> % (os.getpid(), nums))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = Process(target=work1)</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line"></span><br><span class="line">    p2 = Process(target=work2)</span><br><span class="line">    p2.start()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>结论：</strong></p>
<ul>
<li>进程间并不会共享变量</li>
<li>理解这一点的前提是需要先理解<strong>进程是如何创建的？</strong></li>
</ul>
<blockquote>
<p>子进程的创建就是由主进程，将当前父进程的资源(代码)拷贝到子进程中，具备了所有的环境资源后，子进程得以运行，并不是通过共享变量的方式获得资源~~。所以进程之间并不会共享变量</p>
</blockquote>
<ul>
<li>那么进程间如何进行数据交换？后面的进程间通信会讲到如何用队列进行通信</li>
<li>所以进程比线程更耗资源</li>
</ul>
</blockquote>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>关于进程函数入口的问题</li>
</ol>
<blockquote>
<ul>
<li>如果大家创建的是一个多进程任务 <strong>必须写入函数入口</strong> 。不写报错</li>
</ul>
<blockquote>
<p>多进程任务在不同的操作系统上创建的进程方式是不一样的</p>
<p>下面是各个系统启动进程的方式。</p>
<ul>
<li><code>windows：spawn</code> (必须要写入函数入口的)</li>
<li><code>linux: fork</code>  (在Linux内核的机器中，高版本不需要指定函数入口)</li>
<li><code>macOS: fork</code></li>
</ul>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.coder.work/article/973287">windows - spawn 和 fork 有什么区别？ - IT工具网 (coder.work)</a></p>
</blockquote>
<ul>
<li>如果不指定函数入口，就需要指定当前进程对象启动的方式（如果有函数入口，就不必指定进程对象的启动方式）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> multiprocessing  <span class="comment"># 多进程任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是任务1: %s&#x27;</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是任务2: %s&#x27;</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&#x27;spawn&#x27;</span>)  <span class="comment"># windows不支持 #设置启动方式</span></span><br><span class="line">    <span class="comment"># 创建了两个进程对象</span></span><br><span class="line">    p1 = multiprocessing.Process(target=test_1)</span><br><span class="line">    p2 = multiprocessing.Process(target=test_2)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>多进程之间的执行循序也是无序的，由操作系统调度</li>
<li>在计算机中可以创建进程并且进程之间相互独立</li>
<li>子进程将父进程的代码copy并创建了一个单独的空间进行代码运行</li>
<li>进程是可以进行并行的但是这个是理论上的</li>
</ol>
<h2 id="进程、线程对比"><a href="#进程、线程对比" class="headerlink" title="进程、线程对比"></a>进程、线程对比</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ</li>
<li>线程，能够完成多任务，比如 一个QQ中的多个聊天窗口</li>
</ul>
<h3 id="定义的不同"><a href="#定义的不同" class="headerlink" title="定义的不同"></a>定义的不同</h3><ul>
<li>进程是系统进行资源分配和调度的一个独立单位.</li>
<li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p>一个程序至少有一个进程,一个进程至少有一个线程.</p>
</li>
<li><p>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</p>
</li>
<li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</p>
</li>
<li><p>线程不能够独立执行，必须依存在进程中</p>
</li>
<li><p>可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人</p>
</li>
<li><p><strong>进程只是占用内存，线程才消耗CPU</strong>。默认一个进程必须有一个线程</p>
</li>
<li><p>进程会特别占用内存，平时能用线程就用线程</p>
</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h3 id="一个问题：应用场景"><a href="#一个问题：应用场景" class="headerlink" title="一个问题：应用场景"></a>一个问题：应用场景</h3><blockquote>
<p>那么进程也可以完成多任务，那么为什么既有线程又有进程？这是因为适用场景不同</p>
<p>线程：网络IO程序、文件读写、上传下载等 处理过程中存在可以等待空余时间的操作</p>
<p>进程：计算</p>
<p>线程虽然广义上实现了多线程，但是本质上还是单线程，也就是通过并发实现（因为<code>GIL</code>的存在）。进程可以接近真正的<strong>并行</strong>，可以真正的提高计算速度。当然了即使是超级计算机也不能真正的实现<strong>并行</strong>，一核心一个任务还是比较奢侈的。真正意义上的并行暂时还是很难的</p>
<p>如果不想有<code>GIL</code>，可以去学习一下<code>Jpython</code>，，，<code>Cpython</code>是由<code>GIL</code>的</p>
</blockquote>
<h2 id="进程间通信-Queue"><a href="#进程间通信-Queue" class="headerlink" title="进程间通信 - Queue"></a>进程间通信 - <code>Queue</code></h2><p><code>Process</code>之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。比如栈和队列</p>
<h3 id="Queue的使用"><a href="#Queue的使用" class="headerlink" title="Queue的使用"></a>Queue的使用</h3><p>可以使用<code>multiprocessing</code>模块的<code>Queue</code>实现多进程之间的数据传递。</p>
<p><code>Queue</code>本身是一个消息列队程序，首先用一个小实例来演示一下<code>Queue</code>的工作原理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">3</span>)  <span class="comment"># 初始化一个Queue对象，最多可接收三条put消息</span></span><br><span class="line">q.put(<span class="string">&quot;消息1&quot;</span>)</span><br><span class="line">q.put(<span class="string">&quot;消息2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full())  <span class="comment"># 判断当前队列是否已满: False</span></span><br><span class="line">q.put(<span class="string">&quot;消息3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是put的三种使用方法</span></span><br><span class="line"><span class="comment"># 如果当前设定了队列的最大长度当超出长度时使用put方法会造成程序堵塞</span></span><br><span class="line">q.put(<span class="string">&quot;消息4&quot;</span>)</span><br><span class="line"><span class="comment"># put等待两秒会抛出异常</span></span><br><span class="line">q.put(<span class="string">&quot;消息4&quot;</span>, <span class="literal">True</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 如果队列已满put_nowait会立即抛出异常，</span></span><br><span class="line">q.put_nowait(<span class="string">&quot;消息4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐的方式，先判断消息列队是否已满，再写入</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> q.full():</span><br><span class="line">    q.put_nowait(<span class="string">&quot;消息4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取消息时，先判断消息列队是否为空，再读取</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">        <span class="built_in">print</span>(q.get_nowait())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<p>初始化<code>Queue()</code>对象时（例如：<code>q=Queue()</code>），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；</p>
<ul>
<li><p><code>Queue.qsize()</code>：返回当前队列包含的消息数量；</p>
</li>
<li><p><code>Queue.empty()</code>：如果队列为空，返回True，反之False ；</p>
</li>
<li><p><code>Queue.full()</code>：如果队列满了，返回True,反之False；</p>
</li>
<li><p><code>Queue.get([block[, timeout]])</code>：获取队列中的一条消息，然后将其从列队中移除，<code>block</code>默认值为<code>True</code>；</p>
<blockquote>
<ul>
<li>如果<code>block</code>使用默认值，且没有设置<code>timeout</code>（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了<code>timeout</code>，则会等待<code>timeout</code>秒，若还没读取到任何消息，则抛出”<code>Queue.Empty</code>“异常；</li>
<li>如果<code>block</code>值为<code>False</code>，消息列队如果为空，则会立刻抛出”<code>Queue.Empty</code>“异常；</li>
</ul>
</blockquote>
</li>
<li><p><code>Queue.get_nowait()</code>：相当<code>Queue.get(False)</code>；</p>
</li>
<li><p><code>Queue.put(item,[block[, timeout]])</code>：将<code>item</code>消息写入队列，<code>block</code>默认值为<code>True</code>；</p>
<blockquote>
<ul>
<li><p>如果<code>block</code>使用默认值，且没有设置<code>timeout</code>（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了<code>timeout</code>，则会等待<code>timeout</code>秒，若还没空间，则抛出”<code>Queue.Full</code>“异常；</p>
</li>
<li><p>如果<code>block</code>值为<code>False</code>，消息列队如果没有空间可写入，则会立刻抛出”<code>Queue.Full</code>“异常；</p>
</li>
</ul>
</blockquote>
</li>
<li><p><code>Queue.put_nowait(item)</code>：相当<code>Queue.put(item, False)</code></p>
</li>
</ul>
<h3 id="Queue-实例"><a href="#Queue-实例" class="headerlink" title="Queue 实例"></a><code>Queue</code> 实例</h3><p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get(<span class="literal">True</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Get %s from queue.&#x27;</span> % value)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;所有数据都写入并且读完&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="进程的创建-进程池-Pool"><a href="#进程的创建-进程池-Pool" class="headerlink" title="进程的创建 - 进程池 Pool"></a>进程的创建 - 进程池 Pool</h2><h3 id="使用-Pool-创建进程池"><a href="#使用-Pool-创建进程池" class="headerlink" title="使用 Pool 创建进程池"></a>使用 Pool 创建进程池</h3><p>当需要创建的子进程数量不多时，可以直接利用<code>multiprocessing</code>中的<code>Process</code>动态生成多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到<code>multiprocessing</code>模块提供的<code>Pool</code>方法。</p>
<p>初始化<code>Pool</code>时，可以指定一个最大进程数，当有新的请求提交到<code>Pool</code>中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">msg</span>):</span><br><span class="line">    p_start = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s开始执行,进程号为%d&quot;</span> % (msg, os.getpid()))</span><br><span class="line">    <span class="comment"># random.random()随机生成0~1之间的浮点数</span></span><br><span class="line">    time.sleep(random.random() * <span class="number">2</span>)</span><br><span class="line">    p_stop = time.time()</span><br><span class="line">    <span class="built_in">print</span>(msg, <span class="string">&quot;执行完毕，耗时%0.2f&quot;</span> % (p_stop - p_start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main_start = time.time()</span><br><span class="line">    po = Pool(<span class="number">3</span>)  <span class="comment"># 定义一个进程池，最大进程数3。。# 如果任务数大于进程数 则多出来的任务会等待被执行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 异步执行：</span></span><br><span class="line">        <span class="comment"># 进程任务Pool().apply_async</span></span><br><span class="line">        <span class="comment"># Pool().apply_async(要调用的目标的引用,(传递给目标的参数元祖,))</span></span><br><span class="line">        <span class="comment"># 每次循环将会用空闲出来的子进程去调用目标</span></span><br><span class="line">        po.apply_async(worker, (i,))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 同步执行：</span></span><br><span class="line">        <span class="comment"># 执行该方法会导致主进程堵塞，一般不用同步执行。同步执行就相当于一个单进程</span></span><br><span class="line">        <span class="comment"># po.apply(worker, (i,))  </span></span><br><span class="line">        <span class="comment"># 简单来说就是异步快，同步慢</span></span><br><span class="line">        <span class="comment"># 如果第二个函数执行需要依赖第一个函数中的返回值，这个时候就需要单线程运行，使用同步</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----start----&quot;</span>)</span><br><span class="line">    po.close()  <span class="comment"># 关闭进程池，关闭后po不再接收新的请求。 当进程池一旦创建并调用close之后 不能动态的去创建进程数量</span></span><br><span class="line">    po.join()  <span class="comment"># 等待po中所有子进程执行完成后再解阻塞，必须放在close语句之后</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----end-----&quot;</span>)</span><br><span class="line">    main_stop = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;耗时: <span class="subst">&#123;main_stop - main_start&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>multiprocessing.Pool</code>常用函数解析：</p>
<ul>
<li><code>apply_async(func[, args[, kwds]])</code> ：使用非阻塞方式调用 <code>func</code>（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），<code>args</code>为传递给<code>func</code>的参数列表，<code>kwds</code>为传递给<code>func</code>的关键字参数列表</li>
<li><code>close()</code>：关闭<code>Pool</code>，使其不再接受新的任务。 当进程池一旦创建并调用close之后 不能动态的去创建进程数量。这个close是关闭进程池这个容器，而不是关闭进程</li>
<li><code>terminate()</code>：不管任务是否完成，立即终止</li>
<li><code>join()</code>：主进程阻塞，等待所有子进程的退出， 必须在<code>close</code>或<code>terminate</code>之后使用</li>
</ul>
<h3 id="进程池中的-Queue"><a href="#进程池中的-Queue" class="headerlink" title="进程池中的 Queue"></a>进程池中的 <code>Queue</code></h3><p>如果要使用Pool创建进程，就需要使用<code>multiprocessing.Manager()</code>中的<code>Queue()</code>，而不是<code>multiprocessing.Queue()</code>，否则会得到一条如下的错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RuntimeError: Queue objects should only be shared between processes through inheritance.</span><br></pre></td></tr></table></figure>

<p>下面的实例演示了进程池中的进程如何通信：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改import中的Queue为Manager</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager, Pool</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reader</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;reader启动(%s),父进程为(%s)&quot;</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;reader从Queue获取到消息：%s&quot;</span> % q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;writer启动(%s),父进程为(%s)&quot;</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;tuling&quot;</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s) start&quot;</span> % os.getpid())</span><br><span class="line">    q = Manager().Queue()  <span class="comment"># 使用Manager中的Queue</span></span><br><span class="line">    po = Pool()</span><br><span class="line">    po.apply_async(writer, (q,))</span><br><span class="line">    <span class="comment"># 等待队列写入</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    po.apply_async(reader, (q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s) End&quot;</span> % os.getpid())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取进程池返回值"><a href="#获取进程池返回值" class="headerlink" title="获取进程池返回值"></a>获取进程池返回值</h3><ol>
<li>同步&#x2F;异步获取返回值(一个个提交获得返回值)</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">i</span>):  <span class="comment"># 返回值存在于进程池，父子进程没有返回值</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> i * i  <span class="comment"># 任务函数使用return将计算结果返回</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    po = Pool(<span class="number">5</span>)</span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 将任务中的返回值赋值给result</span></span><br><span class="line">        <span class="comment"># 返回值类型为进程池结果对象</span></span><br><span class="line">        result = po.apply_async(func, args=(i,))  <span class="comment"># 异步获取</span></span><br><span class="line">        <span class="comment"># result = po.apply(func, args=(i,))  同步获取</span></span><br><span class="line">        <span class="comment"># 将结果添加到列表中</span></span><br><span class="line">        result_list.append(result)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> result_list:</span><br><span class="line">        <span class="comment"># 使用进程池结果对象中的get方法获取结果</span></span><br><span class="line">        <span class="built_in">print</span>(item.get())</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用﻿<code>map()</code>﻿方法获取返回值（多个同时提交）</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">i</span>):</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> i * i</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    po = Pool(<span class="number">5</span>)</span><br><span class="line">    result = po.<span class="built_in">map</span>(func, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>﻿<code>map()</code>﻿是一次性返回所有子进程的返回值，自带﻿<code>close﻿、﻿join</code>﻿</li>
<li>﻿<code>apply_async</code>﻿是分批返回</li>
</ul>
<h3 id="异步进程池"><a href="#异步进程池" class="headerlink" title="异步进程池"></a>异步进程池</h3><blockquote>
<p><code>Python3.2</code>以后带来了<code>concurrent.futures</code>模块。这个模块具有线程池和进程池、管理并行编程任务、处理非确定性的执行流程、进程&#x2F;线程同步等功能</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor,ThreadPoolExecutor,as_completed</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#concurrent.futures.Executor 这是一个虚拟基类,提供了异步执行的方法</span></span><br><span class="line"><span class="comment">#submit(function,argument)   调度函数(可调用对象)的执行,将argument作为参数传入</span></span><br><span class="line"><span class="comment">#map(function,argument)      将argument作为参数执行函数,以异步的方式</span></span><br><span class="line"><span class="comment">#shutdown(Wait=True)         发出让执行者释放所有资源的信号</span></span><br><span class="line"><span class="comment">#concurrent.futures.Future   其中包括函数的异步执行,Future对象是submit任务(即带有参数的functions) 到executor的实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Executor是抽象类,可以通过子类访问,即线程或进程的ExecutorPools</span></span><br><span class="line"><span class="comment">#因为,线程或进程的实例时依赖于资源的任务,所以最好以&quot;池&quot;的形式将他们组织在一起,作为可以重用的launcher或executor</span></span><br><span class="line"></span><br><span class="line">number_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number</span>(<span class="params">data</span>):<span class="comment">#这个函数  只能消耗CPU资源  没啥意义</span></span><br><span class="line"></span><br><span class="line">    item = count(data)</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">number</span>):<span class="comment">#单纯计算  随便写</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5000000</span>):</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i * number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()<span class="comment">#程序启动时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启线程池  CPU密集型 慢     IO密集型  快</span></span><br><span class="line">    <span class="comment"># with ThreadPoolExecutor(max_workers = 5) as t:# max_workers参数为 你要开多少个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#     for item in number_list:#提交任务 </span></span><br><span class="line">    <span class="comment">#         t.submit(add_number,item)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#     reqs = [t.submit(add_number,item) for item in number_list]#提交任务 简洁写法</span></span><br><span class="line">    <span class="comment">#     for req in as_completed(reqs):# 转成 可迭代对象</span></span><br><span class="line">    <span class="comment">#         print(req.result())#打印信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启进程池  CPU密集型 快     IO密集型  快</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(max_workers = <span class="number">5</span>) <span class="keyword">as</span> t:<span class="comment"># max_workers参数为 你要开多少个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> number_list:<span class="comment">#提交任务 </span></span><br><span class="line">            t.submit(add_number,item)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reqs = [t.submit(add_number,item) for item in number_list]#提交任务 简洁写法</span></span><br><span class="line">        <span class="comment"># for req in as_completed(reqs):# 转成 可迭代对象</span></span><br><span class="line">        <span class="comment">#     print(req.result())#打印信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;程序总耗时：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start_time))<span class="comment">#当前时间 减去 启动时间 = 程序过程耗时</span></span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><blockquote>
<p>爬取豆瓣读书</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,multiprocessing<span class="comment">#多进程</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,ProcessPoolExecutor<span class="comment">#异步并发包</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">   <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://book.douban.com/tag/%E5%B0%8F%E8%AF%B4&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_html</span>(<span class="params">url</span>):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;html当前进程为&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(multiprocessing.current_process().pid))<span class="comment">#打印当前进程的pid</span></span><br><span class="line"></span><br><span class="line">   html = requests.get(url,headers=headers)</span><br><span class="line">   threadpools = ThreadPoolExecutor(max_workers = <span class="number">3</span>)<span class="comment">#创建线程池3个线程</span></span><br><span class="line"></span><br><span class="line">   soup = BeautifulSoup(html.text,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">   urls = soup.select(<span class="string">&#x27;.subject-item .info a&#x27;</span>)<span class="comment">#获取 a 标签</span></span><br><span class="line">   <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">      link = url[<span class="string">&#x27;href&#x27;</span>]<span class="comment">#获取书本链接</span></span><br><span class="line">      threadpools.submit(get_link,link)<span class="comment">#获取每本书都提交 1 个线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_link</span>(<span class="params">url</span>):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;获取书的父进程为&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(multiprocessing.current_process().pid))<span class="comment">#打印当前进程的pid</span></span><br><span class="line"></span><br><span class="line">   html = requests.get(url,headers=headers)</span><br><span class="line">   soup = BeautifulSoup(html.text,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">   title = soup.select_one(<span class="string">&#x27;#wrapper h1 span&#x27;</span>).text<span class="comment">#获取标题</span></span><br><span class="line">   <span class="built_in">print</span>(title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   urls = [<span class="string">&#x27;https://book.douban.com/tag/%E5%B0%8F%E8%AF%B4&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;https://book.douban.com/tag/%E9%9A%8F%E7%AC%94&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;https://book.douban.com/tag/%E6%96%87%E5%AD%A6&#x27;</span>,]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">with</span> ProcessPoolExecutor(max_workers = <span class="number">3</span>) <span class="keyword">as</span> p:<span class="comment">#创建 3 个进程</span></span><br><span class="line">      <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">         p.submit(get_html,url) <span class="comment">#每个进程都提交给get_html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在分类不多的情况下 可以考虑 1 个分类 创建 1 个进程</span></span><br><span class="line"><span class="comment">#假如处理大量任务  比如有 10000 个任务</span></span><br><span class="line"><span class="comment">#则结合你服务器的当前状态 决定进程池和线程池大小</span></span><br><span class="line"><span class="comment">#由于进程池和线程池  存在可复用性  可反复利用池的东西</span></span><br><span class="line"><span class="comment">#正常情况下 三分之一即可 比如 100 个任务  池的大小为 30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：</span></span><br><span class="line"><span class="comment">#网络爬虫 如果线程大于 3 就很容易造成封IP  </span></span><br><span class="line"><span class="comment">#要么线程开小点  爬慢点</span></span><br><span class="line"><span class="comment">#要么构建IP代理池  定期更换IP  </span></span><br></pre></td></tr></table></figure>

<h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1sK4y1x7fy/?spm_id_from=pageDriver&vd_source=e73a152dada4626bad49c30d848902f7">【爬虫策略】13分钟掌握Python多进程 | 进程池 | 并发编程 | 手把手新人向 | 大学生编程 | 程序员 | 爬虫基础入门_哔哩哔哩_bilibili</a></li>
<li></li>
</ul>
</blockquote>
<blockquote>
<p><strong>声明：</strong></p>
<ol>
<li><p>若文章存在错误，望诸君不吝指正^</p>
</li>
<li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p>
</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://gungnir.top/">晚上十一点睡觉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gungnir.top/posts/60681/">http://gungnir.top/posts/60681/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gungnir.top" target="_blank">晚上十一点睡觉のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308753.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/62245/"><img class="prev-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237579.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SQL注入利用过程详解</div></div></a></div><div class="next-post pull-right"><a href="/posts/29404/"><img class="next-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237527.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTML基础知识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/24764/" title="1. 基础知识"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237554.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">1. 基础知识</div></div></a></div><div><a href="/posts/5964/" title="11. 异常与文件操作"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237513.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-30</div><div class="title">11. 异常与文件操作</div></div></a></div><div><a href="/posts/38591/" title="10. 元类编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237574.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">10. 元类编程</div></div></a></div><div><a href="/posts/10554/" title="13. 多线程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308746.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">13. 多线程</div></div></a></div><div><a href="/posts/4710/" title="12. 网络编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308745.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">12. 网络编程</div></div></a></div><div><a href="/posts/21255/" title="15. 协程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237504.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-06</div><div class="title">15. 协程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">晚上十一点睡觉</div><div class="author-info__description">晚上十一点睡觉的个人博客，个人笔记及日志，最近在学习网络安全和Python</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">129</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">43</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/11pmsleep"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/11pmsleep" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:860637048@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=860637048" rel="external nofollow noreferrer" target="_blank" title="qq"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记迁移整理中~~~以前习惯有道云记笔记，整理知识也算沉淀自己的一部分吧·· 加油··stay passionate and never say die!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">进程的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-multiprocessing"><span class="toc-number">2.</span> <span class="toc-text">进程的创建 - multiprocessing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Process%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">Process语法结构如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">Process创建的实例对象的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Process%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">Process创建的实例对象的常用属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">2.4.</span> <span class="toc-text">获取当前线程的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">启动创建的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E7%9A%84-pid"><span class="toc-number">2.6.</span> <span class="toc-text">获取进程的 pid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%8C%87%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">给子进程指定的函数传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%B8%8D%E5%90%8C%E4%BA%AB%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.8.</span> <span class="toc-text">进程间不同享全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.9.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">3.</span> <span class="toc-text">进程、线程对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">3.2.</span> <span class="toc-text">定义的不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.</span> <span class="toc-text">一个问题：应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-Queue"><span class="toc-number">4.</span> <span class="toc-text">进程间通信 - Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">Queue的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue-%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.2.</span> <span class="toc-text">Queue 实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-%E8%BF%9B%E7%A8%8B%E6%B1%A0-Pool"><span class="toc-number">5.</span> <span class="toc-text">进程的创建 - 进程池 Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Pool-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.1.</span> <span class="toc-text">使用 Pool 创建进程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84-Queue"><span class="toc-number">5.2.</span> <span class="toc-text">进程池中的 Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E6%B1%A0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">获取进程池返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.4.</span> <span class="toc-text">异步进程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#refer"><span class="toc-number">7.</span> <span class="toc-text">refer</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/21255/" title="15. 协程"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237504.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="15. 协程"/></a><div class="content"><a class="title" href="/posts/21255/" title="15. 协程">15. 协程</a><time datetime="2023-01-10T16:18:08.864Z" title="更新于 2023-01-11 00:18:08">2023-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/60681/" title="14. 多进程"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308753.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="14. 多进程"/></a><div class="content"><a class="title" href="/posts/60681/" title="14. 多进程">14. 多进程</a><time datetime="2023-01-10T08:03:46.921Z" title="更新于 2023-01-10 16:03:46">2023-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/10554/" title="13. 多线程"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308746.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="13. 多线程"/></a><div class="content"><a class="title" href="/posts/10554/" title="13. 多线程">13. 多线程</a><time datetime="2023-01-10T06:24:08.337Z" title="更新于 2023-01-10 14:24:08">2023-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/18048/" title="2. 判断语句和循环语句"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237562.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2. 判断语句和循环语句"/></a><div class="content"><a class="title" href="/posts/18048/" title="2. 判断语句和循环语句">2. 判断语句和循环语句</a><time datetime="2023-01-07T04:55:28.323Z" title="更新于 2023-01-07 12:55:28">2023-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/45702/" title="utools：超好用的工具箱"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237506.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="utools：超好用的工具箱"/></a><div class="content"><a class="title" href="/posts/45702/" title="utools：超好用的工具箱">utools：超好用的工具箱</a><time datetime="2023-01-05T10:54:29.659Z" title="更新于 2023-01-05 18:54:29">2023-01-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 晚上十一点睡觉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 11pmsleep's blog ~~~ 该网站用来记录学习笔记及生活，欢迎交流技术~~~Blog仅供个人记录笔记学习所用，若有侵权，联系我删除~若有错误，也望诸君不吝指正</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>