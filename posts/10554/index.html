<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>13. 多线程 | 晚上十一点睡觉のBlog</title><meta name="author" content="晚上十一点睡觉"><meta name="copyright" content="晚上十一点睡觉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程 本章将介绍Python中的多线程编程。多线程一直是Python学习中的重点和难点，需要反复练习和研究。 线程和进程在学习多线程的使用之前，需要先了解线程、进程的概念。 进程进程（Process，有时被称为重量级进程）是程序的一次执行。每个进程都有自己的地址空间、内存、数据栈以及记录运行轨迹的辅"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gungnir.top/posts/10554/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?60a7a67c81784f02b889a11753e4e8cc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 晚上十一点睡觉","link":"链接: ","source":"来源: 晚上十一点睡觉のBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '13. 多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-05 23:17:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237573.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">晚上十一点睡觉のBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">13. 多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-02T09:05:37.000Z" title="发表于 2022-12-02 17:05:37">2022-12-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-05T15:17:15.673Z" title="更新于 2022-12-05 23:17:15">2022-12-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/">Python全栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Python核心编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="13. 多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/10554/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>线程</p>
<p>本章将介绍Python中的多线程编程。多线程一直是Python学习中的重点和难点，需要反复练习和研究。</p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p>在学习多线程的使用之前，需要先了解线程、进程的概念。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程（<code>Process</code>，有时被称为重量级进程）是程序的一次执行。每个进程都有自己的<strong>地址空间、内存、数据栈以及记录运行轨迹的辅助数据</strong>，操作系统管理运行的所有进程，并为这些进程公平分配时间。进程可以通过<code>fork</code>和<code>spawn</code>操作完成其他任务。</p>
<p>因为各个进程有自己的内存空间、数据栈等，所以只能使用进程间通信（<code>Inter Process Communication, IPC</code>），而不能直接共享信息。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程（<code>Thread</code>，有时被称为轻量级进程）跟进程有些相似，不同的是所有线程运行在同一个进程中，共享运行环境。</p>
<p>线程有<strong>开始、顺序执行和结束</strong>3部分，有一个自己的指令指针，记录运行到什么地方。线程的运行可能被抢占（中断）或暂时被挂起（睡眠），从而让其他线程运行，这叫作<strong>让步</strong>。</p>
<p>一个进程中的各个线程之间共享同一块数据空间，所以线程之间可以比进程之间更方便地共享数据和相互通信。</p>
<p>线程一般是<strong>并发执行</strong>的。正是由于这种并行和数据共享的机制，使得多个任务的合作变得可能。实际上，在单CPU系统中，真正的并发并不可能，每个线程会被安排成每次只运行一小会儿，然后就把CPU让出来，让其他线程运行。在进程的整个运行过程中，每个线程都只做自己的事，需要时再跟其他线程共享运行结果。多个线程共同访问同一块数据不是完全没有危险的，由于访问数据的顺序不一样，因此有可能导致数据结果不一致的问题，这叫作<strong>竞态条件</strong>。大多数线程库都带有一系列同步原语，用于控制线程的执行和数据的访问。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><blockquote>
<ul>
<li>通俗来讲<strong>进程</strong>就是给软件分配各种资源的一个单位，分配如内存、寄存器等等各种资源。进程被我们所接收进行管理这个软件</li>
<li>一个进程至少有一个线程执行代码</li>
<li>进程没有执行代码的功能，执行代码是线程来完成的</li>
<li>多个进程中的线程是相互独立的</li>
<li>多个线程一定是在一个进程中的</li>
<li>在一个进程中的多个线程只能有一个线程被运行</li>
</ul>
</blockquote>
<h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><p>本小节主要学习 Python 中的 <code>threading</code> 模块。实际上线程用的不多，后面的协程用的会比较多</p>
<h3 id="全局解释器锁"><a href="#全局解释器锁" class="headerlink" title="全局解释器锁"></a>全局解释器锁</h3><p>Python代码的执行由Python虚拟机（解释器主循环）控制。Python在设计之初就考虑到在主循环中只能有一个线程执行，虽然Python解释器中可以“运行”多个线程，但是在任意时刻只有一个线程在解释器中运行。</p>
<p>Python虚拟机的访问由全局解释器锁（<code>Global Interpreter Lock, GIL</code>）控制，这个锁能保证同一时刻只有一个线程运行。</p>
<p>在多线程环境中，Python虚拟机按以下方式执行：</p>
<blockquote>
<ol>
<li>设置<code>GIL</code>。</li>
<li>切换到一个线程运行。</li>
<li>运行指定数量的<strong>字节码指令</strong>或线程主动让出控制（可以调用time.sleep(0)）。</li>
<li>把线程设置为睡眠状态。</li>
<li>解锁<code>GIL</code>。</li>
<li>再次重复以上所有步骤。</li>
</ol>
</blockquote>
<p>在调用外部代码（如C&#x2F;C++扩展函数）时，<code>GIL</code>将被锁定，直到这个函数结束为止（由于在此期间没有运行Python的字节码，因此不会做线程切换），编写扩展的程序员可以主动解锁<code>GIL</code>。</p>
<h3 id="多任务的概念"><a href="#多任务的概念" class="headerlink" title="多任务的概念"></a>多任务的概念</h3><p>什么叫 “多任务” 呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p>
<p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p>
<p>答案就是: <strong>操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</strong></p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>
<p><strong>注意 并发和并行的概念区分</strong>：</p>
<blockquote>
<ul>
<li>并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</li>
<li>并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的。</li>
</ul>
</blockquote>
<h3 id="threading-模块的使用"><a href="#threading-模块的使用" class="headerlink" title="threading 模块的使用"></a><code>threading</code> 模块的使用</h3><blockquote>
<p>python中需要使用一个模块来完成多线程任务。<code>threading</code> 标准库</p>
</blockquote>
<h4 id="单线程代码示例："><a href="#单线程代码示例：" class="headerlink" title="单线程代码示例："></a>单线程代码示例：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        print_hello()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该程序至少<code>5s</code>执行完，会在五次执行<code>print_hello()</code>的时候，阻塞<code>1s</code></p>
</blockquote>
<h4 id="多线程代码示例："><a href="#多线程代码示例：" class="headerlink" title="多线程代码示例："></a>多线程代码示例：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 使用多线程进行任务加速</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 1. 创建一个线程对象</span></span><br><span class="line">        t = threading.Thread(target=print_hello)</span><br><span class="line">        <span class="comment"># 2. 使用线程对象启动一个线程</span></span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<h4 id="threading源码"><a href="#threading源码" class="headerlink" title="threading源码"></a><code>threading</code>源码</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202212041446168.png" alt="image-20221204144636726"></p>
<p>可以看到初始化传入的一些参数</p>
<blockquote>
<p>注意点：</p>
<ul>
<li>使用<code>threading.Thread</code>类创建一个线程对象，传入初始化参数<code>target=xxx</code>，<code>xxx</code>是一个函数引用，实际上就是绑定任务—&gt;也就是函数</li>
<li>使用线程对象的<code>start()</code>方法，启动线程</li>
<li>多线程的任务调度我们是控制不了的，由操作系统决定</li>
<li>给线程传递传递参数：<code>args=(g_nums,)</code>，从上面的初始化函数可以看到，<code>args</code>变量需要传入一个<code>元组()</code>，作为线程的参数</li>
</ul>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = threading.Thread(target=work_1, args=(g_nums,))</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="主线程等待所有子线程结束后退出"><a href="#主线程等待所有子线程结束后退出" class="headerlink" title="主线程等待所有子线程结束后退出"></a>主线程等待所有子线程结束后退出</h3><blockquote>
<p>在一个进程中可以创建多个线程。线程有主次之分，主线程，子线程</p>
<p><code>from time import sleep, ctime</code>中的<code>ctime</code>可以计算程序的运行时间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, ctime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在唱歌: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在跳舞: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;程序开始: <span class="subst">&#123;ctime()&#125;</span>&#x27;</span>)</span><br><span class="line">    t1 = threading.Thread(target=sing)</span><br><span class="line">    t2 = threading.Thread(target=dance)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 注释下一行代码查看程序是否立即退出</span></span><br><span class="line">    <span class="comment"># sleep(5)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;程序结束: <span class="subst">&#123;ctime()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<p>前文得知：一段代码必须有一个线程去执行。那么：</p>
<ul>
<li><p>该程序总共有三个线程，每个线程负责一段代码的运行。<code>sing()</code>和<code>dance()</code>两个函数由<code>t1</code>和<code>t2</code>两个子线程执行。那么<code>main()</code>函数呢？由主线程管理执行。</p>
</li>
<li><p>python代码的本质是什么？<code>py文件</code>。主线程主要负责执行<code>.py文件</code>的。</p>
</li>
<li><p>在程序运行的开始，主线程就被创建，并且只有等所有子线程结束后，主线程才会退出。如果主线程代码执行完毕，但是子线程还在任务中，主线程会等待子线程任务执行完毕后再退出程序</p>
</li>
<li><p>如果在<code>py文件</code>中发现<code>threading</code>，则会自动创建一个子线程</p>
</li>
</ul>
</blockquote>
<h3 id="查看线程数量"><a href="#查看线程数量" class="headerlink" title="查看线程数量"></a>查看线程数量</h3><blockquote>
<p>一般情况用不到</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, ctime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在唱歌: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在跳舞: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;程序开始: <span class="subst">&#123;ctime&#125;</span>&#x27;</span>)</span><br><span class="line">    t1 = threading.Thread(target=sing)</span><br><span class="line">    t2 = threading.Thread(target=dance)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># print(threading.enumerate())</span></span><br><span class="line">        length = <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;当前线程数量: <span class="subst">&#123;length&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果线程数量等于1意味着当前只有一个主线程</span></span><br><span class="line">            <span class="comment"># 如果只剩下主线程则终止循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>len(threading.enumerate())</code>查看线程数量</p>
</blockquote>
<h3 id="线程执行代码的封装——用类实现线程"><a href="#线程执行代码的封装——用类实现线程" class="headerlink" title="线程执行代码的封装——用类实现线程"></a>线程执行代码的封装——用类实现线程</h3><p>通过上一小节，能够看出，通过使用<code>threading</code>模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用<code>threading</code>模块时，往往会定义一个新的子类class，只要继承<code>threading.Thread</code>就可以了，然后重写<code>run</code>方法。</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line">    <span class="comment"># 当前类中有没有写构造函数？</span></span><br><span class="line">    <span class="comment"># 如果你当前构造的类需要有实例属性</span></span><br><span class="line">    <span class="comment"># 那么在重写__init__方法时，需要在子类中的__init__中调用线程类的__init__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 在线程类中必须先要运行线程父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment">#再去自定义自己的代码</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># self.name是threading模块中的一个方法 保存的是当前线程的名称</span></span><br><span class="line">            msg = <span class="string">&#x27;我是 &#x27;</span> + self.name + <span class="string">&#x27; @ &#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li><p>python的<code>threading.Thread</code>类有一个<code>run</code>方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过<code>Thread</code>类的<code>start</code>方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用<code>run</code>方法执行线程。</p>
</li>
<li><p>如果你当前构造的类需要有实例属性。那么需要重写<code>__init__</code>方法</p>
</li>
<li><p>用<code>t1 = threading.Thread(target=sing)</code>方法构建线程的时候：</p>
</li>
</ul>
<p><code>target</code>将获取到到函数引用传递给<code>run</code>方法。<code>run</code>方法是负责运行任务的一个方法，在<code>threading.Thread</code>类中通过<code>start</code>找到<code>run</code>并且调用<code>run</code>。</p>
</blockquote>
<h3 id="线程的执行顺序"><a href="#线程的执行顺序" class="headerlink" title="线程的执行顺序"></a>线程的执行顺序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            msg = <span class="string">&#x27;我是 &#x27;</span> + self.name + <span class="string">&#x27; @ &#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong></p>
<p>从代码和执行结果我们可以看出，<strong>多线程程序的执行顺序是不确定</strong>的。当执行到<code>sleep</code>语句时，线程将被阻塞（<code>Blocked</code>），到<code>sleep</code>结束后，线程进入就绪（<code>Runnable</code>）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ol>
<li>每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。<code>MyThread.name</code>获取</li>
<li>当线程的<code>run()</code>方法结束时该线程完成。</li>
<li>无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</li>
</ol>
</blockquote>
<h2 id="多线程-共享全局变量（重要）"><a href="#多线程-共享全局变量（重要）" class="headerlink" title="多线程 - 共享全局变量（重要）"></a>多线程 - 共享全局变量（重要）</h2><blockquote>
<p>多个线程同时对一个全局变量进行调用，会出现<strong>资源竞争</strong>的现象，因为线程在全局上看，他们是同时执行的</p>
</blockquote>
<h3 id="整型类型共享"><a href="#整型类型共享" class="headerlink" title="整型类型共享"></a>整型类型共享</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 循环相加三次</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;子线程1中计算得出的值为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程2中获取到的值为: <span class="subst">&#123;g_num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 线程启动之前获取全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程未启动之前主线程获取的值为: <span class="subst">&#123;g_num&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建线程对象 当前这个线程创建完之后线程是否已经存在？ 不存在的 对象不是线程 就是一串代码地址</span></span><br><span class="line">    <span class="comment"># 创建线程对象</span></span><br><span class="line">    t1 = threading.Thread(target=work_1)</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过延迟保证t1线程中的事情做完</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    t2 = threading.Thread(target=work_2)</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;主线程最终获取到的值为: <span class="subst">&#123;g_num&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="序列类型共享"><a href="#序列类型共享" class="headerlink" title="序列类型共享"></a>序列类型共享</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">g_nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 在全局列表中添加一个元素</span></span><br><span class="line">    nums.append(<span class="number">44</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程1添加完成之后的列表元素为: <span class="subst">&#123;nums&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程2获取的列表元素为: <span class="subst">&#123;nums&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=work_1, args=(g_nums,))</span><br><span class="line">    t1.start()</span><br><span class="line">    <span class="comment"># 确保子线程1完成操作后再执行一下代码</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    t2 = threading.Thread(target=work_2, args=(g_nums,))</span><br><span class="line">    t2.start()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;主线程获取到的全局列表元素为: <span class="subst">&#123;g_nums&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><blockquote>
<ul>
<li>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据</li>
<li>缺点就是，线程是对全局变量随意更改可能造成多线程之间对全局变量的混乱（即线程非安全）</li>
</ul>
</blockquote>
<h2 id="多线程-共享全局变量问题"><a href="#多线程-共享全局变量问题" class="headerlink" title="多线程 - 共享全局变量问题"></a>多线程 - 共享全局变量问题</h2><h3 id="多线程开发可能遇到的问题"><a href="#多线程开发可能遇到的问题" class="headerlink" title="多线程开发可能遇到的问题"></a>多线程开发可能遇到的问题</h3><p>假设两个线程<code>t1</code>和<code>t2</code>都要对全局变量<code>g_num</code>(默认是0)进行加1运算，<code>t1</code>和<code>t2</code>都各对<code>g_num</code>加10次，<code>g_num</code>的最终的结果应该为20。</p>
<p>但是由于是多线程同时操作，有可能出现下面情况：</p>
<ol>
<li>在<code>g_num=0</code>时，<code>t1</code>取得<code>g_num=0</code>。此时系统把<code>t1</code>调度为”<code>sleeping</code>”状态，把<code>t2</code>转换为”<code>running</code>”状态，<code>t2</code>也获得<code>g_num=0</code></li>
<li>然后<code>t2</code>对得到的值进行加1并赋给<code>g_num</code>，使得<code>g_num=1</code></li>
<li>然后系统又把<code>t2</code>调度为”<code>sleeping</code>”，把<code>t1</code>转为”<code>running</code>”。线程<code>t1</code>又把它之前得到的0加1后赋值给<code>g_num</code>。</li>
<li>这样导致虽然<code>t1</code>和<code>t2</code>都对<code>g_num</code>加1，但结果仍然是<code>g_num=1</code></li>
</ol>
<p>示例代码一：小单位数据测试，结果暂时是对的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程1计算的结果为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程2计算的结果为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程创建之前g_num的值为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line">    t1 = threading.Thread(target=work_1, args=(<span class="number">100</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    t2 = threading.Thread(target=work_2, args=(<span class="number">100</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待子线程任务执行完毕后再执行主线程代码</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2个线程对同一个全局变量操作之后的最终结果是:%s&quot;</span> % g_num)</span><br></pre></td></tr></table></figure>

<p>示例代码二：数据放大后弊端出现，结果和预期计算不符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程1计算的结果为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程2计算的结果为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程创建之前g_num的值为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line">    t1 = threading.Thread(target=work_1, args=(<span class="number">1000000</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    t2 = threading.Thread(target=work_2, args=(<span class="number">1000000</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待子线程任务执行完毕后再执行主线程代码</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2个线程对同一个全局变量操作之后的最终结果是:%s&quot;</span> % g_num)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>结论：</strong>如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确</p>
</blockquote>
<h2 id="同步的概念"><a href="#同步的概念" class="headerlink" title="同步的概念"></a>同步的概念</h2><p>同步就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。</p>
<p>“同” 字从字面上容易理解为一起动作</p>
<p>其实不是，”同” 字应是指协同、协助、互相配合。</p>
<p>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。</p>
<h3 id="解决线程同时修改全局变量的方式"><a href="#解决线程同时修改全局变量的方式" class="headerlink" title="解决线程同时修改全局变量的方式"></a>解决线程同时修改全局变量的方式</h3><p>对于上一小节提出的那个计算错误的问题，可以通过<strong>线程同步</strong>来进行解决</p>
<p>思路，如下:</p>
<ol>
<li>系统调用<code>t1</code>，然后获取到<code>g_num</code>的值为0，此时上一把锁，即不允许其他线程操作<code>g_num</code></li>
<li><code>t1</code>对<code>g_num</code>的值进行<code>+1</code></li>
<li><code>t1</code>解锁，此时<code>g_num</code>的值为1，其他的线程就可以使用<code>g_num</code>了，而且是<code>g_num</code>的值不是0而是1</li>
<li>同理其他线程在对<code>g_num</code>进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性</li>
</ol>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</p>
<p><u>线程同步能够保证多个线程安全访问竞争资源</u>，最简单的同步机制是引入<strong>互斥锁</strong>。</p>
<p>互斥锁为资源引入一个状态：<code>锁定 / 非锁定</code></p>
<blockquote>
<p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为 “锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成 “非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p>
</blockquote>
<h3 id="threading-Lock-类"><a href="#threading-Lock-类" class="headerlink" title="threading.Lock()类"></a><code>threading.Lock()</code>类</h3><p><code>threading</code>模块中定义了<code>Lock</code>类，可以方便的处理锁定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建线程互斥锁  一般设置为一个全局的变量</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure>

<p><strong>注意点：</strong></p>
<ul>
<li>如果这个锁之前是没有上锁的，那么<code>acquire</code>不会堵塞</li>
<li>如果在调用<code>acquire</code>对这个锁上锁之前 它已经被 其他线程上了锁，那么此时<code>acquire</code>会堵塞，直到这个锁被解锁为止</li>
</ul>
<h3 id="互斥锁的使用"><a href="#互斥锁的使用" class="headerlink" title="互斥锁的使用"></a>互斥锁的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个互斥锁</span></span><br><span class="line"><span class="comment"># 默认是未上锁的状态</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number_1</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()  <span class="comment"># 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程1计算得出的结果为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number_2</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()  <span class="comment"># 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程2计算得出的结果为: <span class="subst">&#123;g_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建2个线程，让他们各自对g_num加1000000次</span></span><br><span class="line">    p1 = threading.Thread(target=add_number_1, args=(<span class="number">1000000</span>,))</span><br><span class="line">    p1.start()</span><br><span class="line"></span><br><span class="line">    p2 = threading.Thread(target=add_number_2, args=(<span class="number">1000000</span>,))</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待计算完成</span></span><br><span class="line">    <span class="comment"># 主线程等待: 当主线程运行到没有代码到时候会进行等待 直到子线程任务完成则结束程序    </span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#或者使用这样的等待代码：让主线程等待t1和t2的执行</span></span><br><span class="line">    <span class="comment">#t1.join()#主线程等待子线程1执行完毕后才会向下执行</span></span><br><span class="line">    <span class="comment">#t2.join()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2个线程对同一个全局变量操作之后的最终结果是:%s&quot;</span> % g_num)</span><br></pre></td></tr></table></figure>

<p>可以看到最后的结果，加入互斥锁后，其结果与预期相符。</p>
<blockquote>
<p>上面阻塞主线程的代码也可以是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1.join()<span class="comment">#主线程等待子线程1执行完毕后才会向下执行</span></span><br><span class="line">   t2.join()</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="上锁解锁过程"><a href="#上锁解锁过程" class="headerlink" title="上锁解锁过程"></a>上锁解锁过程</h3><p>当一个线程调用锁的<code>acquire()</code>方法获得锁时，锁就进入“<code>locked</code>”状态。</p>
<p>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“<code>blocked</code>”状态，称为“阻塞”，直到拥有锁的线程调用锁的<code>release()</code>方法释放锁之后，锁进入“<code>unlocked</code>”状态。</p>
<p>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（<code>running</code>）状态。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>锁的好处：</p>
<ul>
<li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li>
</ul>
<p>锁的坏处：</p>
<ul>
<li>阻止了多线程<strong>并发</strong>执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li>
<li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p>
<p>尽管死锁很少发生，但一旦发生就会造成应用的停止响应。</p>
<p>所以尽量不要使用两把锁</p>
<h3 id="死锁代码案例"><a href="#死锁代码案例" class="headerlink" title="死锁代码案例"></a>死锁代码案例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 对mutexA上锁</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mutexA上锁后，延时1秒，等待另外那个线程 把mutexB上锁</span></span><br><span class="line">        <span class="built_in">print</span>(self.name+<span class="string">&#x27;----do1---up----&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(self.name+<span class="string">&#x27;----do1---down----&#x27;</span>)</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对mutexA解锁</span></span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 对mutexB上锁</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mutexB上锁后，延时1秒，等待另外那个线程 把mutexA上锁</span></span><br><span class="line">        <span class="built_in">print</span>(self.name+<span class="string">&#x27;----do2---up----&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(self.name+<span class="string">&#x27;----do2---down----&#x27;</span>)</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对mutexB解锁</span></span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread1()</span><br><span class="line">    t2 = MyThread2()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用<strong>线程池</strong>可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。</p>
<p>线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。</p>
<p>此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。</p>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>线程池的基类是﻿<code>concurrent.futures</code>﻿。</p>
<p>模块中的﻿<code>Executor</code>提供了两个子类，即﻿<code>ThreadPoolExecutor</code>﻿和﻿<code>ProcessPoolExecutor</code>﻿。</p>
<p>其中﻿<code>ThreadPoolExecutor</code>﻿用于创建线程池，而﻿<code>ProcessPoolExecutor</code>﻿用于创建进程池。</p>
<p>如果使用<strong>线程池&#x2F;进程池</strong>来管理并发编程，那么只要将相应的﻿<code>task</code>﻿函数提交给线程池&#x2F;进程池，剩下的事情就由<strong>线程池&#x2F;进程池</strong>来搞定。</p>
<p>详情参考，具体内容在爬虫中会讲到：</p>
<blockquote>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.yuque.com/tuling_python/python_basic/tiplonn9wwnyr38y">13.1.9 线程池 - 补充内容 (yuque.com)</a></p>
</blockquote>
<h2 id="案例：TCP-并发服务器"><a href="#案例：TCP-并发服务器" class="headerlink" title="案例：TCP 并发服务器"></a>案例：<strong>TCP 并发服务器</strong></h2><blockquote>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.yuque.com/tuling_python/python_basic/glly5am10mxccrwg">13.1.8 TCP 并发服务器 (yuque.com)</a></p>
</blockquote>
<h2 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h2><ul>
<li>创建线程对象 当前这个线程创建完之后线程是否已经存在？</li>
</ul>
<blockquote>
<p>不存在的 。对象不是线程 ，对象只是一串代码地址，线程暂时还不存在。</p>
<p>执行<code>start()</code>之后，线程才存在于内存中</p>
</blockquote>
<hr>
<h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><blockquote>
<p>- </p>
</blockquote>
<blockquote>
<p><strong>声明：</strong></p>
<ol>
<li><p>若文章存在错误，望诸君不吝指正^</p>
</li>
<li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p>
</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://gungnir.top/">晚上十一点睡觉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gungnir.top/posts/10554/">http://gungnir.top/posts/10554/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gungnir.top" target="_blank">晚上十一点睡觉のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237573.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4710/"><img class="prev-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308745.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">12. 网络编程</div></div></a></div><div class="next-post pull-right"><a href="/posts/52098/"><img class="next-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237532.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SQL注入防御</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/24764/" title="1. 基础知识"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237554.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">1. 基础知识</div></div></a></div><div><a href="/posts/5964/" title="11. 异常与文件操作"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237522.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-30</div><div class="title">11. 异常与文件操作</div></div></a></div><div><a href="/posts/38591/" title="10. 元类编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237574.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">10. 元类编程</div></div></a></div><div><a href="/posts/4710/" title="12. 网络编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308745.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">12. 网络编程</div></div></a></div><div><a href="/posts/60681/" title="14. 多进程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237532.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="title">14. 多进程</div></div></a></div><div><a href="/posts/21255/" title="15. 协程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237516.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-06</div><div class="title">15. 协程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">晚上十一点睡觉</div><div class="author-info__description">晚上十一点睡觉的个人博客，个人笔记及日志，最近在学习网络安全和Python</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/11pmsleep"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/11pmsleep" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:860637048@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=860637048" rel="external nofollow noreferrer" target="_blank" title="qq"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记迁移整理中~~~以前习惯有道云记笔记，整理知识也算沉淀自己的一部分吧·· 加油··stay passionate and never say die!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">注意：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">使用线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">全局解释器锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">多任务的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threading-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">threading 模块的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">单线程代码示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">多线程代码示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#threading%E6%BA%90%E7%A0%81"><span class="toc-number">2.3.3.</span> <span class="toc-text">threading源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E6%89%80%E6%9C%89%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F%E5%90%8E%E9%80%80%E5%87%BA"><span class="toc-number">2.4.</span> <span class="toc-text">主线程等待所有子线程结束后退出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="toc-number">2.5.</span> <span class="toc-text">查看线程数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B0%81%E8%A3%85%E2%80%94%E2%80%94%E7%94%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">线程执行代码的封装——用类实现线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.7.</span> <span class="toc-text">线程的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">多线程 - 共享全局变量（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%85%B1%E4%BA%AB"><span class="toc-number">3.1.</span> <span class="toc-text">整型类型共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E5%85%B1%E4%BA%AB"><span class="toc-number">3.2.</span> <span class="toc-text">序列类型共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">多线程 - 共享全局变量问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">多线程开发可能遇到的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.</span> <span class="toc-text">同步的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">解决线程同时修改全局变量的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#threading-Lock-%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">threading.Lock()类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">互斥锁的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E9%94%81%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">上锁解锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">6.4.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">7.1.</span> <span class="toc-text">死锁代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">线程池的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9ATCP-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">案例：TCP 并发服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">10.</span> <span class="toc-text">一些注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#refer"><span class="toc-number">11.</span> <span class="toc-text">refer</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/48031/" title="JavaScript基础知识"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308757.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript基础知识"/></a><div class="content"><a class="title" href="/posts/48031/" title="JavaScript基础知识">JavaScript基础知识</a><time datetime="2022-12-27T17:11:27.294Z" title="更新于 2022-12-28 01:11:27">2022-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/45992/" title="jQuery基础学习"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237533.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jQuery基础学习"/></a><div class="content"><a class="title" href="/posts/45992/" title="jQuery基础学习">jQuery基础学习</a><time datetime="2022-12-27T10:54:26.065Z" title="更新于 2022-12-27 18:54:26">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4710/" title="12. 网络编程"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308745.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="12. 网络编程"/></a><div class="content"><a class="title" href="/posts/4710/" title="12. 网络编程">12. 网络编程</a><time datetime="2022-12-27T09:19:51.804Z" title="更新于 2022-12-27 17:19:51">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5964/" title="11. 异常与文件操作"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237522.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="11. 异常与文件操作"/></a><div class="content"><a class="title" href="/posts/5964/" title="11. 异常与文件操作">11. 异常与文件操作</a><time datetime="2022-12-26T17:08:11.261Z" title="更新于 2022-12-27 01:08:11">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/38591/" title="10. 元类编程"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237574.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="10. 元类编程"/></a><div class="content"><a class="title" href="/posts/38591/" title="10. 元类编程">10. 元类编程</a><time datetime="2022-12-26T10:50:34.343Z" title="更新于 2022-12-26 18:50:34">2022-12-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 晚上十一点睡觉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 11pmsleep's blog ~~~ 该网站用来记录学习笔记及生活，欢迎交流技术~~~Blog仅供个人记录笔记学习所用，若有侵权，联系我删除~若有错误，也望诸君不吝指正</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>