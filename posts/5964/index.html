<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>11. 异常与文件操作 | 晚上十一点睡觉のBlog</title><meta name="author" content="晚上十一点睡觉"><meta name="copyright" content="晚上十一点睡觉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="异常与文件处理 学习目标:  正确处理各种异常，以及创建和自定义创建异常 在Python中如何处理文件  异常什么是异常本节开始介绍之前，先看看如下程序： &amp;gt;&amp;gt;&amp;gt; print(a)Traceback (most recent call last):  File &amp;quot;&amp;lt;"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gungnir.top/posts/5964/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?60a7a67c81784f02b889a11753e4e8cc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 晚上十一点睡觉","link":"链接: ","source":"来源: 晚上十一点睡觉のBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '11. 异常与文件操作',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-01 15:21:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">109</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237490.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">晚上十一点睡觉のBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">11. 异常与文件操作</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-29T17:36:23.000Z" title="发表于 2022-11-30 01:36:23">2022-11-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-01T07:21:16.578Z" title="更新于 2022-12-01 15:21:16">2022-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/">Python全栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Python核心编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="11. 异常与文件操作"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/5964/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>异常与文件处理</p>
<p>学习目标:</p>
<ul>
<li>正确处理各种异常，以及创建和自定义创建异常</li>
<li>在Python中如何处理文件</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h3><p>本节开始介绍之前，先看看如下程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p>是不是很熟悉，这是我们前面经常看到的程序运行出现的错误。</p>
<p>作为Python初学者，在学习Python编程的过程中，经常会看到一些报错信息，使你编写的程序不能如期工作，如我们前面看到过的<code>NameError</code>、<code>SyntaxError</code>、<code>TypeError</code>、<code>ValueError</code>等，这些都是异常。</p>
<p>异常是一个事件，该事件会在程序执行过程中发生，影响程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生异常。异常是Python的对象，表示一个错误。当Python脚本发生异常时，我们需要捕获并处理异常，否则程序会终止执行。</p>
<p>每一个异常都是一些类的实例，这些实例可以被引用，并且可以用很多种方法进行捕捉，使得错误可以被处理，而不是让整个程序失败。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>出现异常怎么办呢？</p>
<p>就如我们使用的工具出了点小毛病，我们可以想办法修理好它。程序也一样，前辈们经过不断积累与思考，创造了不少好方法处理程序中的异常，最简单的是使用<code>try</code>语句处理。</p>
<p><code>try</code>语句的基本形式为 <code>try / except</code>。<code>try / except</code> 语句用来检测<code>try</code>语句块中的错误，从而让<code>except</code>语句捕获异常信息并处理。如果你不想在发生异常时结束程序，只需在try语句块中捕获异常即可。</p>
<p>捕获异常的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#如果在try部分引发了异常</span></span><br></pre></td></tr></table></figure>

<p><code>try</code>的工作原理是，开始一个<code>try</code>语句后，Python就在当前程序的上下文中做标记，当出现异常时就可以回到做标记的地方。首先执行try子句，接下来发生什么依赖于执行时是否出现异常。</p>
<p>如果<code>try</code>后的语句执行时发生异常，程序就跳回<code>try</code>并执行<code>except</code>子句。异常处理完毕后，控制流就可以通过整个<code>try</code>语句了（除非在处理异常时又引发新异常）。</p>
<p>例如以下示例所示（<code>exp_exception.py</code>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exp_exception</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = x / y</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;a = <span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="comment"># 如果当前try语句块中的代码报错 则会运行当前的代码块</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;程序出现异常，异常信息：被除数为0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp_exception(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果在try语句中出现报错则会去运行except中的代码</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">程序出现异常，异常信息：被除数为0</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，程序最后执行的是except子句，如果语句正常，应该输出”a &#x3D; “的形式。</p>
<p>这里你可能会有疑问：直接在做除法前对y值进行判断不就解决问题了，何必使用try&#x2F;except语句呢？</p>
<p>在本例中这么做确实更好一些。如果给程序加入更多除法，就得给每个除法语句加一个判断语句，这样整段代码看上去就是一堆类似if的功能重复判断语句，真正有效的代码没多少。而使用 try &#x2F; except 只需要一个错误处理器即可。</p>
<p><strong>提示：</strong>如果没有处理异常，异常就会被“传播”到调用的函数中。如果在调用的函数中依然没有处理，异常就会继续 “传播”，直到程序的最顶层。也就是可以处理其他人程序中未处理的异常。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><blockquote>
<ul>
<li>主动抛出：<code>try / except</code></li>
<li>被动抛出：<code>raise</code></li>
</ul>
</blockquote>
<p>Python使用<code>raise</code>语句抛出一个指定异常。我们可以使用类（<code>Exception</code>的子类）或实例参数调用<code>raise</code>语句引发异常。使用类时程序会自动创建实例。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> Exception</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">Exception</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">&#x27;This is NameError&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: This <span class="keyword">is</span> NameError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p>由操作结果看到，第一个示例<code>raise Exception</code>引发了一个没有相关错误信息的普通异常，第二个示例输出了一些错误提示。</p>
<p>如果只想知道是否抛出了异常，并不想处理，使用一个简单的<code>raise</code>语句就可以再次把异常抛出，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> NameError(<span class="string">&#x27;This is NameError&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;An exception happened&#x27;</span>)</span><br><span class="line">    <span class="comment"># raise 不加reise 输出对应字符结束程序</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> NameError(<span class="string">&#x27;This is NameError&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;An exception happened&#x27;</span>)</span><br><span class="line">    <span class="keyword">raise</span>  <span class="comment"># 添加raise则打印对应字符并再次显示异常</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 在第三方库中已经自己定义了一些异常类</span></span><br><span class="line"><span class="comment"># 继承python Exception 类</span></span><br><span class="line"><span class="comment"># 真正的作用: 知道有这个错误 但是当前这个错误不会影响到你的业务代码</span></span><br><span class="line"><span class="comment"># 防止程序因为报错导致异常退出</span></span><br></pre></td></tr></table></figure>

<p>由输出结果看到，使用<code>raise</code>可以输出更深层次的异常。在使用过程中，可以借助该方法得到更详尽的异常信息。</p>
<p>我们前面碰到的<code>NameError、SyntaxError、TypeError、ValueError</code>等异常类称为<strong>内建异常类</strong>。在Python中，内建的异常类有很多，可以使用<code>dir</code>函数列出异常类的内容，并用在<code>raise</code>语句中，用法如<code>raise NameError</code>这般。</p>
<h3 id="捕捉多个异常"><a href="#捕捉多个异常" class="headerlink" title="捕捉多个异常"></a>捕捉多个异常</h3><p>我们在前面讲述了处理一个异常的情况，若涉及多个异常，该怎么处理呢？</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>Python支持在一个 try &#x2F; except 语句中处理多个异常，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字<span class="number">1</span>&gt;：</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#如果在try部分引发了name1异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字<span class="number">2</span>&gt;，&lt;数据&gt;:</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#如果引发了name2异常，获得附加数据</span></span><br></pre></td></tr></table></figure>

<h4 id="try语句按照如下方式工作："><a href="#try语句按照如下方式工作：" class="headerlink" title="try语句按照如下方式工作："></a><code>try</code>语句按照如下方式工作：</h4><blockquote>
<p>首先，执行<code>try</code>子句（在关键字<code>try</code>和关键字<code>except</code>之间的语句）。如果没有发生异常，忽略<code>except</code>子句，<code>try</code>子句执行后结束。如果在执行<code>try</code>子句的过程中发生异常，<code>try</code>子句余下的部分就会被忽略。如果异常的类型和<code>except</code>之后的名称相符，对应的<code>except</code>子句就会被执行。最后执行<code>try</code>语句之后的代码。如果一个异常没有与任何<code>except</code>匹配，这个异常就会传递到上层的<code>try</code>中。一个<code>try</code>语句可能包含多个<code>except</code>子句，分别处理不同的异常，但最多只有一个分支会被执行。</p>
</blockquote>
<p>处理程序只针对对应<code>try</code>子句中的异常进行处理，而不会处理其他异常语句中的异常，例如（mult_exception.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multi_exception</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = x / y</span><br><span class="line">        <span class="comment"># b = name</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is ZeroDivisionError&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is NameError&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">multi_exception(<span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">this is ZeroDivisionError</span><br></pre></td></tr></table></figure>

<p>若把<code>a = x / y</code>注释掉或放到<code>b = name</code>下面，则得到的执行结果为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">this is NameError</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，一个<code>try</code>可包含多个<code>except</code>子句，但子句中只有一个分支会被处理。</p>
<h4 id="使用异常相比于if去判断的优势："><a href="#使用异常相比于if去判断的优势：" class="headerlink" title="使用异常相比于if去判断的优势："></a>使用异常相比于if去判断的优势：</h4><p>当然，你可能会考虑使用<code>if</code>语句，但这样需要考虑是否做了除法运算，做除法运算时是否使用了变量，是否可能有等于0的变量用作被除数等。需要考虑很多种情况，也需要写很多if语句判断，若不经过严密思考和大量测试，很难把所有情况都考虑到。此外，if语句过多会使程序阅读起来比较困难。抛出异常的方式更加简单、直观，可以清晰帮助用户定位问题，并且可以自定义异常信息，进一步定位问题所在。</p>
<h3 id="使用一个块捕捉多个异常"><a href="#使用一个块捕捉多个异常" class="headerlink" title="使用一个块捕捉多个异常"></a>使用一个块捕捉多个异常</h3><p>上一节讲述了一个try语句对应多个except子句，若需要一个try对应一个except子句，同时捕捉一个以上异常，可以实现吗？我们先看如下示例（model_exception.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model_exception</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b = name</span><br><span class="line">        a = x / y</span><br><span class="line">    <span class="keyword">except</span> (ZeroDivisionError, NameError, TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;one of ZeroDivisionError or NameError or TypeError happened&#x27;</span>,e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_exception(<span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">one of ZeroDivisionError or NameError or TypeError happened</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，如果需要使用一个块捕捉多个类型的异常，可以将它们作为元组列出。使用该方式时，遇到的异常类型是元组中的任意一个，都会走异常流程。</p>
<p>这么做有什么好处呢？假如我们希望多个except子句输出同样的信息，就没有必要在几个except子句中重复输入语句，放到一个异常块中即可。</p>
<h3 id="捕捉对象"><a href="#捕捉对象" class="headerlink" title="捕捉对象"></a>捕捉对象</h3><p>如果希望在<code>except</code>子句中访问异常对象本身，也就是看到一个异常对象真正的异常信息，而不是输出自己定义的异常信息，可以使用<code>as e</code>的形式，我们称之为<strong>捕捉对象</strong>。</p>
<blockquote>
<p><code>as</code>:<code>python</code>关键字，用来设置别名</p>
</blockquote>
<p>示例如下（model_exception_1.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model_exception</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b = name</span><br><span class="line">        a = x / y</span><br><span class="line">    <span class="keyword">except</span>(ZeroDivisionError, NameError, TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_exception(<span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">name &#x27;name&#x27; is not defined</span><br></pre></td></tr></table></figure>

<p>若 <code>a = x / y</code> 在前，则结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">division by zero</span><br></pre></td></tr></table></figure>

<p>由输出的结果可知，执行过程中抛出的异常被截获并正常输出了相关异常信息，并且使用这种方式可以捕捉多个异常。</p>
<p><strong>提示：</strong>在Python 2中，捕捉对象的子句写法是“<code>Exception,e</code>”，中间使用“<code>,</code>”号分隔，而不是<code>as</code>。此处的<code>e</code>也可以使用其他字母，用<code>e</code>意义比较明确，取自<code>except</code>的首字母。</p>
<h3 id="全捕捉"><a href="#全捕捉" class="headerlink" title="全捕捉"></a>全捕捉</h3><h4 id="存在漏捕捉异常的情形"><a href="#存在漏捕捉异常的情形" class="headerlink" title="存在漏捕捉异常的情形"></a>存在漏捕捉异常的情形</h4><p>前面我们讲述了很多异常，大家可能以为可以捕捉所有异常，其实并非如此。请看如下示例</p>
<p>（model_exception_2.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model_exception</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = x / y</span><br><span class="line">        b = name</span><br><span class="line">    <span class="keyword">except</span>(ZeroDivisionError, NameError, TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_exception(<span class="number">2</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在该示例中，调用函数时有一个实参传入的是空字符串。执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">unsupported operand type(s) for /: &#x27;int&#x27; and &#x27;str&#x27;</span><br></pre></td></tr></table></figure>

<p>由结果看到，这里抛出的信息并不像我们之前看到的那样，带有明显的Error关键词或异常词。此处只是告知不支持的操作类型。</p>
<p>在实际编码过程中，即使程序能处理好几种类型的异常，但有一些异常还是会从我们手掌中溜走。上面示例中的异常就逃过了<code>try/except</code>语句的检查，对于这种情况我们根本无法预测会发生什么，也无法提前做任何准备。在这种情况下，与其使用不是捕捉异常的<code>try/except</code>语句隐藏异常，不如让程序立即崩溃。</p>
<h4 id="单纯的try…except…捕捉所有异常"><a href="#单纯的try…except…捕捉所有异常" class="headerlink" title="单纯的try…except…捕捉所有异常"></a>单纯的try…except…捕捉所有异常</h4><blockquote>
<p>做法就是不指定任何的异常类</p>
</blockquote>
<p>如果要处理这种异常，该怎么办呢？先看如下示例（model_exception_3.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model_exception</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b = name</span><br><span class="line">        a = x / y</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error happened&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_exception(<span class="number">2</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Error happened</span><br></pre></td></tr></table></figure>

<p>由程序和执行结果看到，可以在<code>except</code>子句中忽略所有异常类，从而让程序输出自己定义的异常信息。</p>
<p>当然，这里只给出了一种可参考的解决方式。从实用性方面讲，不建议这么做，因为这样捕捉异常非常危险，会隐藏所有没有预先想到的错误。建议使用抛出异常的方式处理，或者对异常对象<code>e</code>进行一些检查。</p>
<h4 id="使用Exception异常基类（能捕捉到大部分内置异常类的错误）"><a href="#使用Exception异常基类（能捕捉到大部分内置异常类的错误）" class="headerlink" title="使用Exception异常基类（能捕捉到大部分内置异常类的错误）"></a>使用<code>Exception</code>异常基类（能捕捉到大部分内置异常类的错误）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">	pass</span><br><span class="line">except Exception:</span><br><span class="line">	print &quot;使用基类捕捉大部分异常&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，Python内部并不会定义世界上所有的错误，所以<code>Exception</code>只能捕捉大部分的异常，如果Python内置的异常不包含现实中的错误，则会被忽略错过~~！！</p>
</blockquote>
<h3 id="异常中的-else"><a href="#异常中的-else" class="headerlink" title="异常中的 else"></a>异常中的 else</h3><p>如果程序执行完异常还需要做其他事情，怎么办呢？</p>
<p>异常为我们提供了<code>try…except…else</code>语句实现该功能，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#如果在try部分引发了异常1</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#如果引发了异常2，获得附加数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;语句&gt;　　<span class="comment">#如果没有发生异常</span></span><br></pre></td></tr></table></figure>

<p>如果在<code>try</code>子句执行时没有发生异常，就会执行<code>else</code>语句后的语句（如果有<code>else</code>）。使用else子句比把所有语句都放在<code>try</code>子句里面更好，这样可以避免一些意想不到而<code>except</code>又没有捕获的异常。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model_exception</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = x / y</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error happened&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;It went as expected&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_exception(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">It went as expected</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，没有发生异常时，会执行else子句的流程。</p>
<p>综上所述，当程序没有发生异常时，通过添加一个else子句做一些事情（比如输出一些信息）很有用，可以帮助我们更好地判断程序的执行情况。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>尽管内建异常类包括大部分异常，而且可满足很多要求，但有时还是要创建自己的异常类。比如需要精确知道问题的根源，就需要使用自定义异常精确定位问题。可以通过创建一个新<code>exception</code>类拥有自己的异常。异常应该继承自<code>Exception</code>类，可以直接继承，也可以间接继承。</p>
<p>因为错误就是类，捕获一个错误就是捕获该类的一个实例，因此错误并不是凭空产生的，而是由一些不合理的部分导致的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。如果要抛出错误，那么可以根据需要定义一个错误的类，选择好继承关系，然后用raise语句抛出一个错误的实例。</p>
<p>例如（my_error.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):<span class="comment">#过 print 输出实例化类的结果。print(类实例) ,此时自动调用str魔术方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;this is self define error&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_error_test</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> MyError()</span><br><span class="line">    <span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exception info: &#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_error_test()</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">exception info:  this is self define error</span><br></pre></td></tr></table></figure>

<p>由程序和执行结果看到，程序正确执行了自定义的异常，并且需要继承Exception类。</p>
<p>这只是一个简单的示例，还有不少细节需要琢磨，此处不做深入探讨，有兴趣的同学可以查阅相关资料进行实践。</p>
<p><strong>提示：</strong>异常最好以<code>Error</code>结尾，一方面贴近标准异常的命名，另一方面便于见名知意。</p>
<h3 id="finally-子句"><a href="#finally-子句" class="headerlink" title="finally 子句"></a>finally 子句</h3><p>Python中的 <code>finally</code> 子句需要和 <code>try</code> 子句一起使用，组成 <code>try / finally</code> 的语句形式，<code>try / finally</code> 语句无论发生异常与否都将执行最后的代码。注意一定是最后执行</p>
<p>例如(use_finally.py)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_finally</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = x / y</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;No matter what happened, I will show in front of you&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use_finally(<span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/poppies/Desktop/python<span class="emphasis">_projects/基础部分/use_</span>finally.py&quot;, line 8, in <span class="language-xml"><span class="tag">&lt;<span class="name">module</span>&gt;</span></span></span><br><span class="line"><span class="code">    use_finally(2, 0)</span></span><br><span class="line"><span class="code">  File &quot;/Users/poppies/Desktop/python_projects/基础部分/use_finally.py&quot;, line 3, in use_finally</span></span><br><span class="line"><span class="code">    a = x / y</span></span><br><span class="line"><span class="code">ZeroDivisionError: division by zero</span></span><br><span class="line"><span class="code">No matter what happened, I will show in front of you</span></span><br></pre></td></tr></table></figure>

<p>由执行结果看到，finally子句被执行了，无论try子句中是否发生异常，finally都会被执行。</p>
<p>这里我们有一个疑问，虽然执行了<code>finally</code>子句，但是最后还是抛出异常了，是否可以使用<code>except</code>截获异常呢？</p>
<p>可以使用<code>except</code>截获异常<code>。try、except、else</code>和<code>finally</code>可以组合使用，但要记得<code>else</code>在<code>except</code>之后，<code>finally</code>在<code>except</code>和<code>else</code>之后。</p>
<p>对于上面的示例，可以更改如下（use_finally_1.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_finally</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = x / y</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Some bad thing happened: division by zero&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;No matter what happened, I will show in front of you&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use_finally(<span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Some bad thing happened: division by zero</span><br><span class="line">No matter what happened, I will show in front of you</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，先执行了<code>except</code>子句的输出语句，后面跟着执行了<code>finally</code>子句的输出语句。如果再添加<code>else</code>子句，当程序正常运行时会先执行<code>else</code>子句，然后执行<code>finally</code>子句。在有<code>finally</code>的异常处理程序中，<code>finally</code>中的子句一定是最后执行的。</p>
<blockquote>
<p><code>finally</code>子句在关闭文件或数据库连接时非常有用（文件操作和数据库操作后面会具体讲解）。</p>
</blockquote>
<p><strong>提示：</strong>在<code>Python 2.5</code>之前的版本中，<code>finally</code>需要独立使用，不能与<code>try</code>语句配合。在Python 2.5之后才支持这些语句的组合使用。</p>
<h3 id="异常和函数"><a href="#异常和函数" class="headerlink" title="异常和函数"></a>异常和函数</h3><h4 id="程序异常处理顺序过程："><a href="#程序异常处理顺序过程：" class="headerlink" title="程序异常处理顺序过程："></a>程序异常处理顺序过程：</h4><p>异常和函数能够很自然地一起工作。如果异常在函数内引发而不被处理，就会传播至函数调用的地方。如果异常在函数调用的地方也没有被处理，就会继续传播，一直到达主程序。如果在主程序也没有做异常处理，异常就会被Python解释器捕获，输出一个错误信息，然后退出程序。</p>
<p>例如（division_fun.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">division_fun</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x / <span class="built_in">int</span>(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp_fun</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> division_fun(x, y) * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">x, y</span>):</span><br><span class="line">    exp_fun(x, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main(<span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/poppies/Desktop/python<span class="emphasis">_projects/基础部分/division_</span>func.py&quot;, line 13, in <span class="language-xml"><span class="tag">&lt;<span class="name">module</span>&gt;</span></span></span><br><span class="line"><span class="code">    main(2, 0)</span></span><br><span class="line"><span class="code">  File &quot;/Users/poppies/Desktop/python_projects/基础部分/division_func.py&quot;, line 10, in main</span></span><br><span class="line"><span class="code">    exp_fun(x, y)</span></span><br><span class="line"><span class="code">  File &quot;/Users/poppies/Desktop/python_projects/基础部分/division_func.py&quot;, line 6, in exp_fun</span></span><br><span class="line"><span class="code">    return division_fun(x, y) * 10</span></span><br><span class="line"><span class="code">  File &quot;/Users/poppies/Desktop/python_projects/基础部分/division_func.py&quot;, line 2, in division_fun</span></span><br><span class="line"><span class="code">    return x / int(y)</span></span><br><span class="line"><span class="code">ZeroDivisionError: division by zero</span></span><br></pre></td></tr></table></figure>

<p>由执行结果看到，<code>division_fun</code>函数中产生的异常通过<code>division_fun</code>和<code>exp_fun</code>函数传播，<code>exp_fun</code>中的异常通过<code>exp_fun</code>和<code>main</code>函数传播，传递到函数调用处由解释器处理，最终抛出堆栈的异常信息。</p>
<p><strong>提示：</strong>异常信息是以堆栈的形式被抛出的，因而是<strong>从下往上查看</strong>的。所谓堆栈，就是最先被发现的异常信息最后被输出（就像子弹入弹夹和出弹夹一样），也称作先进后出（<code>First In Last Out，FILO</code>）。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><h4 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a><code>open</code>函数</h4><p>在Python中，打开文件使用的是<code>open</code>函数。<code>open</code>函数的基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(file_name [, access_mode][, buffering])</span><br></pre></td></tr></table></figure>

<p><strong>参数解析：</strong></p>
<blockquote>
<ul>
<li><p><code>file_name</code> 变量：是一个包含要访问的文件名称的字符串值。</p>
</li>
<li><p><code>access_mode</code> 变量：指打开文件的模式，对应有<strong>只读、写入、追加</strong>等。<code>access_mode</code>变量值不是必需的（不带<code>access_mode</code>变量时，要求<code>file_name</code>存在，否则报异常），默认的文件访问模式为<strong>只读（r）</strong>。</p>
</li>
<li><p><code>buffering</code>：（这个参数一般用不到）</p>
<blockquote>
<ul>
<li>如果<code>buffering</code>的值被设为0，就不会有寄存；</li>
<li>如果<code>buffering</code>的值取1，访问文件时就会寄存行；</li>
<li>如果将<code>buffering</code>的值设为大于1的整数，表示这就是寄存区的缓冲大小；</li>
<li>如果取负值，寄存区的缓冲大小就是系统默认的值。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><code>open</code>函数返回一个<code>File</code>（文件）对象。<code>File</code>对象代表计算机中的一个文件，是Python中另一种类型的值，就像我们熟悉的列表和字典。</p>
<p>例如（file_open_1.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;d:/test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path)</span><br><span class="line"><span class="built_in">print</span>(f_name.name)</span><br><span class="line"><span class="comment"># open函数有一个返回值：是一个文件对象 file_obj</span></span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">d:/test.txt</span><br></pre></td></tr></table></figure>

<p>执行结果告诉我们打开的是d盘下的<code>test.txt</code>文件（执行该程序前，已经创建了一个名为test.txt的文件）。</p>
<h4 id="文件路径的概念"><a href="#文件路径的概念" class="headerlink" title="文件路径的概念"></a>文件路径的概念</h4><p>文件路径：在该程序中，我们先定义了一个<code>path</code>变量，变量值是一个文件的路径。文件的路径是指文件在计算机上的位置，如该程序中的<code>d:/test.txt</code>是指文件在d盘、文件名为<code>test.txt</code>。文件路径又分为绝对路径和相对路径。</p>
<blockquote>
<ul>
<li><p>绝对路径：总是从根文件夹开始。比如在Windows环境下，一般从c盘、d盘等开始，c盘、d盘被称为根文件夹，在该盘中的文件都得从根文件夹开始往下一级一级查找。在Linux环境下，一般从usr、home等根文件开始。比如在上面的示例程序中，path变量值就是一个绝对路径，在文件搜索框中输入绝对路径可以直接找到该文件。</p>
</li>
<li><p>相对路径：相对于程序当前工作目录的路径。比如当前工作文件存放的绝对路径是d:\python\workspace，如果使用相对路径，就可以不写这个路径，用一个“.”号代替这个路径值。</p>
</li>
</ul>
</blockquote>
<p>例如（file_open_2.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f_name.name)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">./test.txt</span><br></pre></td></tr></table></figure>

<p>除了单个点（.），还可以使用两个点（..）表示父文件夹（或上一级文件夹）。此处不具体讨论，有兴趣可以自己尝试。</p>
<h4 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h4><p>我们在前面讲到，使用<code>open</code>函数时可以选择是否传入<code>mode</code>参数。在前面的示例中，<code>mode</code>传入了一个值为<code>w</code>的参数，这个参数是什么意思呢？<code>mode</code>可以传入哪些值呢？</p>
<h5 id="mode常用的模式："><a href="#mode常用的模式：" class="headerlink" title="mode常用的模式："></a><strong>mode常用的模式：</strong></h5><ul>
<li><code>r</code>：表示文件只能读取</li>
<li><code>w</code>：表示文件只能写入</li>
<li><code>a</code>：表示打开文件，在原有内容的基础上追加内容，在末尾写入</li>
<li><code>w+</code>:表示可以对文件进行读写双重操作</li>
</ul>
<blockquote>
<p>说明：</p>
<ul>
<li><p>如果打开文件时使用读模式，就不能写入文件，即不能用下面这种形式操作文件：</p>
<p>没有<code>rw</code>这种东西，如果同时要读写的话只能用<code>w+</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(path, <span class="string">&#x27;rw&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>open</code>返回的对象不能同时读写。如果需要同时读写，需要进行配置，自行百度如何操作。否则大多是时候都是用两个文件，一个读一个写</li>
</ul>
</blockquote>
<h5 id="mode二进制常用模式："><a href="#mode二进制常用模式：" class="headerlink" title="mode二进制常用模式："></a><strong>mode二进制常用模式：</strong></h5><ul>
<li><code>rb</code>：以二进制格式打开一个文件，用于只读</li>
<li><code>wb</code>：以二进制格式打开一个文件，用于只写</li>
<li><code>ab</code>：以二进制格式打开一个文件，用于追加</li>
<li><code>wb</code>+:以二进制格式打开一个文件，用于读写</li>
</ul>
<blockquote>
<p>说明：</p>
<ul>
<li><p>使用<code>open</code>函数时，明确指定读模式和什么模式都不指定的效果是一样的，我们在前面的示例中已经验证。</p>
</li>
<li><p>使用写模式可以向文件写入内容。<code>+</code>参数可以用到其他任何模式中，指明读和写都是允许的。比如w+可以在打开一个文件时用于文件的读写。</p>
</li>
<li><p>当参数带上字母b时，表示可以用来读取一个二进制文件。Python在一般情况下处理的都是文本文件，有时也不能避免处理其他格式的文件。</p>
</li>
</ul>
</blockquote>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><code>open</code>函数的第3个参数是可选择的，该参数用于控制文件的缓存。如果该参数赋值为<code>0</code>或<code>False</code>，<code>I/O（输入／输出）</code>就是无缓存的。如果是<code>1</code>或<code>True</code>，<code>I/O</code>就是有缓存的。大于1的整数代表缓存的大小（单位是字节），-1或小于0的整数代表使用默认的缓存大小。</p>
<p>大家可能对缓存和I&#x2F;O有些不明白。缓存一般指的是内存，计算机从内存中读取数据的速度远远大于从磁盘读取数据的速度，一般内存大小远小于磁盘大小，内存的速度比较快，但资源比较紧张，所以这里有是否对数据进行缓存的设置。</p>
<p>I&#x2F;O在计算机中指Input&#x2F;Output，也就是输入和输出。由于程序和运行时数据在内存中驻留，由CPU这个超快的计算核心执行，涉及数据交换的地方通常是磁盘、网络等，因此需要I&#x2F;O接口。</p>
<p>比如打开浏览器，访问百度首页，浏览器需要通过网络I&#x2F;O获取百度网页。浏览器首先会发送数据给百度服务器，告诉它想要首页的HTML，这个动作是往外发数据，叫Output；随后百度服务器把网页发过来，这个动作是从外面接收数据，叫Input。通常，程序完成I&#x2F;O操作会有Input和Output两个数据流。当然也有只用一个数据流的情况，比如从磁盘读取文件到内存，只有Input操作，没有Output操作；反过来，把数据写到磁盘文件里，只有Output操作，没有Input操作。</p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>上一节介绍了打开文件的<code>open</code>函数，也做了一些简单操作，接下来介绍一些基本文件方法。在开始介绍之前，首先需要了解一下流的概念。</p>
<p>I&#x2F;O编程中，流（Stream）是一个很重要的概念。可以把流想象成一根水管，数据就是水管里的水，但是只能单向流动。<code>Input Stream</code>就是数据从外面（磁盘、网络）流进内存，<code>Output Stream</code>就是数据从内存流到外面去。浏览网页时，浏览器和服务器之间至少需要建立两根水管，才能既发送数据又接收数据。</p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p><code>open</code>函数返回的是一个<code>File</code>对象，有了<code>File</code>对象，就可以开始读取内容。</p>
<p><strong>如果希望将整个文件的内容读取为一个字符串值，可以使用File对象的<code>read()</code>方法。</strong></p>
<p><code>read()</code>方法从一个打开的文件中读取字符串。需要注意，Python字符串可以是二进制数据，而不仅仅是文字。</p>
<p>语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.read([count])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<ul>
<li><code>fileObject</code>为<code>open</code>函数返回的<code>File对象</code></li>
<li><code>count</code>参数是从已打开的文件中读取的字节计数</li>
<li>该方法从文件的开头开始读入，如果没有传入<code>count</code>，就会尝试<strong>尽可能</strong>多地读取内容，很可能一直读取到文件末尾。</li>
</ul>
</blockquote>
<p>比如我们在test.txt文件中写入“Hello world!Welcome!”，执行如下代码（file_read.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;read result: <span class="subst">&#123;f_name.read(<span class="number">12</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">read result: Hello World!</span><br></pre></td></tr></table></figure>

<p>将 <code>print(&#39;read result:&#39;, f_name.read(12))</code> 更改为 <code>print(&#39;read result:&#39;,f_name.read())</code> ，得到的执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">read result: Hello world!Welcome!</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，没有指定读取字节数时，read方法会读取打开文件中的所有字节。</p>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><h5 id="覆盖重新写"><a href="#覆盖重新写" class="headerlink" title="覆盖重新写"></a>覆盖重新写</h5><p>除了读取数据外，我们还可以向文件中写入数据。在Python中，将内容写入文件的方式与<code>print</code>函数将字符串输出到屏幕上类似。</p>
<p>在Python中，用<code>write()</code>方法向一个文件写入数据。<code>write()</code>方法可将任何字符串写入一个打开的文件。需要注意，Python字符串可以是二进制数据，而不仅仅是文字。</p>
<p><code>write()</code>方法不会在字符串结尾添加换行符（’<code>\n</code>‘），语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileObject.write(string)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p><code>fileObject</code>为<code>open</code>函数返回的<code>File对象</code>，<code>string</code>参数是需要写入文件中的内容。</p>
</blockquote>
<p>该方法返回写入文件的字符串的长度。</p>
<p>例如（file_write.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;write length: <span class="subst">&#123;f_name.write(<span class="string">&#x27;Hello World!&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">write length: 12</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，我们向test.txt文件中写入了12个字符。下面验证一下写入的是否是我们指定的字符，在上面的程序中追加两行代码并执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read result: &#x27;</span>, f_name.read())</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">read result: Hello World!</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，写入文件的是我们指定的内容。不过这里有一个疑问，我们在这里执行了两次写入操作，得到的结果怎么只写入了一次？</p>
<h5 id="追加append"><a href="#追加append" class="headerlink" title="追加append"></a>追加append</h5><p>写文件（write）方法的处理方式是：将覆写原有文件，从头开始，每次写入都会覆盖前面所有内容，就像用一个新值覆盖一个变量的值。若需要在当前文件的字符串后追加字符，该怎么办呢？</p>
<p>可以将第二个参数w更换为a，即以追加模式打开文件，例如（file_add.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;write length: <span class="subst">&#123;f_name.write(<span class="string">&#x27;Hello World!&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;read result: <span class="subst">&#123;f_name.read()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容追加写入</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;add length: <span class="subst">&#123;f_name.write(<span class="string">&#x27;welcome!&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;read result: <span class="subst">&#123;f_name.read()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">write length: 12</span><br><span class="line">read result: Hello World!</span><br><span class="line">add length: 8</span><br><span class="line">read result: Hello World!welcome!</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，输出结果在文件末尾成功添加了对应字符串。</p>
<blockquote>
<p><strong>提示：</strong>如果传递给<code>open</code>函数的文件名不存在，写模式（<code>w</code>）和追加模式（<code>a</code>）就会创建一个新的空文件，然后执行写入或追加。</p>
</blockquote>
<h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>如果想追加的字符串在下一行，该怎么办呢？</p>
<p>在Python中，用<code>\n</code>表示换行。对于上面的示例，若需要追加的内容在下一行，可以如下操作（file_change_line.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;write length: <span class="subst">&#123;f_name.write(<span class="string">&#x27;Hello World!&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;read result: <span class="subst">&#123;f_name.read()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;add length: &#x27;</span>, f_name.write(<span class="string">&#x27;\nwelcome!&#x27;</span>))</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;read result: <span class="subst">&#123;f_name.read()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">write length: 12</span><br><span class="line">read result: Hello World!</span><br><span class="line">add length:  9</span><br><span class="line">read result: Hello World!</span><br><span class="line">welcome!</span><br></pre></td></tr></table></figure>

<p>由执行结果看到，后面追加的内容在下一行了。</p>
<h4 id="特定编码文件的读写"><a href="#特定编码文件的读写" class="headerlink" title="特定编码文件的读写"></a>特定编码文件的读写</h4><blockquote>
<p><strong>提示：</strong>若需要读或写特定编码方式的文本，则需要给<code>open</code>函数传入<code>encoding</code>参数；若需要读取<code>GBK</code>编码的文件，则前面的示例可以改写为<code>f_name=open(path, &#39;r&#39;,encoding=&#39;gbk&#39;)</code>，这样读取到的文件就是<code>GBK</code>编码方式的文件了。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows 默认bgk</span></span><br><span class="line"><span class="comment"># linux unix 默认编码集utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f_name = open(path, &#x27;w&#x27;, encoding=&#x27;gbk&#x27;)</span></span><br><span class="line"><span class="comment"># f_name.write(&#x27;我家的猫会跳高...&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_file = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(read_file.read())</span><br></pre></td></tr></table></figure>

<h4 id="读写行"><a href="#读写行" class="headerlink" title="读写行"></a>读写行</h4><h5 id="readline"><a href="#readline" class="headerlink" title="readline()"></a><code>readline()</code></h5><p>我们目前对文件的读操作是按字节读或整个读取，而写操作是全部覆写或追加，这样的操作在实际应用中很不实用。</p>
<p>Python为我们提供了<code>readline()、readlines()和writelines()</code>等方法用于行操作，例如（file_read_write.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f_name.write(<span class="string">&#x27;Hello World!\n&#x27;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">f_name.write(<span class="string">&#x27;welcome!&#x27;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;readline result: <span class="subst">&#123;f_name.readline(<span class="number">3</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f_name.readline()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;readline result: <span class="subst">&#123;f_name.readline()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">readline result: Hel</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">class</span> &#x27;<span class="attr">str</span>&#x27;&gt;</span></span></span><br><span class="line">readline result: welcome!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<ul>
<li>由执行结果得知，<code>readline</code>方法会从文件中读取单独一行，换行符为<code>\n</code>。<code>readline</code>方法如果返回一个空字符串，说明已经读取到最后一行了。<code>readline</code> 读取一行，每一行数据最后有一个隐藏的<code>\n</code>。通过识别<code>\n</code>判断何时读取结束</li>
<li><code>readline()</code>返回结果是一个字符串，表示读取一行，将读取的结果保存进一个字符串。<code>readline</code>方法也可以像<code>read</code>方法一样传入数值读取对应的字符数，当传入的数值小于等于字符串的长度值时，该字符串会被读取相应的长度；当传入小于或等于0的数值表示整行都输出，所有字符都会被读取。</li>
<li><strong>并且需要注意到输出的第三行，它是接着上一次输出结果的后面继续输出的！！！</strong>在这个地方有一个指针，文件读到指针指向的位置，下一次继续读取就在上一次指针停下的地方继续读取！在Python没有真正意义上的指针。这个类似指针功能的东西是一个对象，以后有时间再继续研究</li>
</ul>
</blockquote>
<h5 id="readlines"><a href="#readlines" class="headerlink" title="readlines()"></a><code>readlines()</code></h5><p>观察下面代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f_name.write(<span class="string">&#x27;Hello World!\n&#x27;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">f_name.write(<span class="string">&#x27;welcome!&#x27;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;readlines result: <span class="subst">&#123;f_name.readlines()&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f_name.readlines()))</span><br></pre></td></tr></table></figure>

<p>得到的输出结果为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">readlines result: [&#x27;Hello World!\n&#x27;, &#x27;welcome!&#x27;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<ul>
<li><code>readlines()</code>输出结果为一个字符串的列表。列表中的每个字符串就是文本中的每一行，并且换行符也会被输出。</li>
<li><code>readlines()</code> 将文件中的所有的数据全部读取，如果读取一行数据则将这一行数据作为一个列表的元素。</li>
</ul>
</blockquote>
<h5 id="writelines"><a href="#writelines" class="headerlink" title="writelines"></a><code>writelines</code></h5><p>例如（file_read_lines.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">str_list = [<span class="string">&#x27;Hello World!\n&#x27;</span>, <span class="string">&#x27;welcome!\n&#x27;</span>, <span class="string">&#x27;welcome!\n&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;write length: <span class="subst">&#123;f_name.writelines(str_list)&#125;</span>&#x27;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;read result: <span class="subst">&#123;f_name.read()&#125;</span>&#x27;</span>)</span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;readline result: <span class="subst">&#123;f_name.readline()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">write length: None</span><br><span class="line">read result: Hello World!</span><br><span class="line">welcome!</span><br><span class="line">welcome!</span><br><span class="line"></span><br><span class="line">readline result: Hello World!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<p>由执行结果看到，<code>writelines</code>方法和<code>readlines</code>方法相反，传给它一个字符串列表（任何序列或可迭代对象），它会把所有字符串写入文件。如果没有<code>writeline</code>方法，那么可以使用<code>write</code>方法代替这个方法的功能。</p>
</blockquote>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>我们前面介绍了很多读取和写入文件的内容，都没有提到在读或写文件的过程中出现异常时该怎么处理。在读或写文件的过程中，出现异常的概率还是挺高的，特别对于大文件的读取和写入，出现异常更是家常便饭。在读或写文件的过程中，出现异常该怎么处理呢？</p>
<p>这就需要用到前面介绍的异常的知识了，用<code>try</code>语句捕获可能出现的异常。在捕获异常前有一个动作要执行，就是使用<code>close</code>方法关闭文件。</p>
<h4 id="显式关闭"><a href="#显式关闭" class="headerlink" title="显式关闭"></a>显式关闭</h4><p>一般情况下，一个文件对象在退出程序后会自动关闭，但是为了安全起见，还是要显式地写一个close方法关闭文件。</p>
<p>一般显式关闭文件读或写的操作如下（file_close.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line">f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;write length: <span class="subst">&#123;f_name.write(<span class="string">&#x27;Hello World!&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">f.name.close()</span><br></pre></td></tr></table></figure>

<p>这段代码和没有加<code>close</code>方法的执行结果一样。这样处理后的函数比没有加<code>close</code>方法时更安全，可以避免在某些操作系统或设置中进行无用的修改，也可以避免用完系统中所打开文件的配额。</p>
<p>对内容更改过的文件一定要记得关闭，因为写入的数据可能被缓存，如果程序或系统因为某些原因而崩溃，被缓存部分的数据就不会写入文件了。为了安全起见，在使用完文件后一定要记得关闭。</p>
<p>当使用<code>try</code>语句出现异常时，即使使用了<code>close</code>方法，也可能不被执行，这时该怎么办呢？</p>
<p>还记得<code>finally</code>子句吗？可以将<code>close</code>方法放在<code>finally</code>子句中执行，从而保证无论程序是否正常执行都会调用close方法。</p>
<p>上面的示例可以更改成更安全的形式（file_safe_close.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f_name = <span class="literal">None</span></span><br><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f_name = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;write length: <span class="subst">&#123;f_name.write(<span class="string">&#x27;Hello World!&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;程序异常: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f_name:</span><br><span class="line">        <span class="built_in">print</span>(f_name.name)</span><br><span class="line">        f_name.close()</span><br></pre></td></tr></table></figure>

<h4 id="自动关闭"><a href="#自动关闭" class="headerlink" title="自动关闭"></a>自动关闭</h4><p>如果每次都要这么写，就会很烦琐，是否有更简便的方式处理呢？</p>
<p>在 Python 中，对应的解决方式是使用 <code>with as</code> 语句操作上下文管理器（<code>context manager</code>），它能够帮助我们自动分配并且释放资源。</p>
<p>什么是上下文管理器？同时包含 <code>__enter__()</code> 和 <code>__exit__()</code> 方法的对象就是上下文管理器。常见构建上下文管理器的方式有 2 种，分别是基于类实现和基于生成器实现。</p>
<p>例如，使用 <code>with as</code> 操作已经打开的文件对象（这些文件对象本身就是上下文管理器），无论期间是否抛出异常，都能保证 <code>with as</code> 语句执行完毕后自动关闭已经打开的文件。</p>
<p>Python中引入了<code>with</code>语句自动帮我们调用<code>close</code>方法。可以使用<code>with</code>语句将上面的程序更改为</p>
<p>（file_safer_close.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&#x27;./test.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:	</span><br><span class="line">    <span class="comment"># f 是用来接受open返回的文件对象的变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;write length: <span class="subst">&#123;f.write(<span class="string">&#x27;Hello World!&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;文件内容: <span class="subst">&#123;f.read()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码和上面使用<code>try/finally</code>的效果一样，并且会自动调用<code>close</code>方法，不用显式地写该方法。可以发现，代码比前面简洁多了，后面可以多用这种方式编写。</p>
<blockquote>
<p>只要你的类实现了上下文管理器的内置方法 就可以使用with。如线程池、<code>aiohttp</code> 异步爬虫库等情景</p>
</blockquote>
<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>在应用程序的过程中，可能需要程序帮助我们重命名某个文件的名字，而不是通过手动的方式进行，这样是否可以呢？</p>
<p>Python的<code>os模块</code>为我们提供了<code>rename</code>方法，即文件重命名。使用这个方法需要导入<code>os模块</code>。<code>rename</code>方法的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(current_file_name, new_file_name)</span><br></pre></td></tr></table></figure>

<p><code>os</code>为导入的<code>os模块</code>，<code>current_file_name</code>为当前文件名，<code>new_file_name</code>为新文件名。若文件不在当前目录下，则文件名需要带上绝对路径。</p>
<p>该方法没有返回值。</p>
<p>使用示例如下（file_rename.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">&#x27;./test.txt&#x27;</span>, <span class="string">&#x27;./test_文件重命名.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果可以到对应目录下查看，若之前已经创建了名为 test.txt 的文件，则将文件名更改为 test_文件重命名.txt；若之前没有创建 test.txt 文件，则先创建 test.txt 文件，然后将文件名更改为 test_文件重命名.txt。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在应用程序的过程中，我们是否可以通过程序删除某个文件呢？</p>
<p>Python的<code>os模块</code>为我们提供了<code>remove</code>方法，即删除文件。使用这个方法需要导入<code>os模块</code>。<code>remove</code>方法的语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(file_name)</span><br></pre></td></tr></table></figure>

<p><code>os</code>为导入的<code>os模块</code>，<code>file_name</code>为需要删除的文件名。若文件不在当前目录下，则文件名需要使用绝对路径。</p>
<p>该方法没有返回值。</p>
<p>使用示例如下（file_remove.py）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;remove result: <span class="subst">&#123;os.remove(<span class="string">&#x27;./test_文件重命名.txt&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;文件错误或文件不存在: &#x27;</span>, e)</span><br></pre></td></tr></table></figure>

<p>执行该方法会把前面的示例中重命名的test2.txt文件删除。当然，该方法只能删除已经存在的文件，文件不存在就会抛异常。</p>
<hr>
<h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><blockquote>
<p>- </p>
</blockquote>
<blockquote>
<p><strong>声明：</strong></p>
<ol>
<li><p>若文章存在错误，望诸君不吝指正^</p>
</li>
<li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p>
</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://gungnir.top/">晚上十一点睡觉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gungnir.top/posts/5964/">http://gungnir.top/posts/5964/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gungnir.top" target="_blank">晚上十一点睡觉のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237490.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/38591/"><img class="prev-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237512.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">10. 元类编程</div></div></a></div><div class="next-post pull-right"><a href="/posts/40881/"><img class="next-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308742.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hexo教程-搜索引擎收录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/38591/" title="10. 元类编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237512.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">10. 元类编程</div></div></a></div><div><a href="/posts/24764/" title="1. 基础知识"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237560.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">1. 基础知识</div></div></a></div><div><a href="/posts/4710/" title="12. 网络编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237563.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">12. 网络编程</div></div></a></div><div><a href="/posts/18048/" title="2. 判断语句和循环语句"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237529.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-29</div><div class="title">2. 判断语句和循环语句</div></div></a></div><div><a href="/posts/10627/" title="3. 序列类型"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237539.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-30</div><div class="title">3. 序列类型</div></div></a></div><div><a href="/posts/50125/" title="4. 函数"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308765.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-30</div><div class="title">4. 函数</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">晚上十一点睡觉</div><div class="author-info__description">晚上十一点睡觉的个人博客，个人笔记及日志，最近在学习网络安全和Python</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">109</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/11pmsleep"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/11pmsleep" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:860637048@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=860637048" rel="external nofollow noreferrer" target="_blank" title="qq"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记迁移整理中~~~以前习惯有道云记笔记，整理知识也算沉淀自己的一部分吧·· 加油··stay passionate and never say die!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.</span> <span class="toc-text">什么是异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E6%8D%89%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.</span> <span class="toc-text">捕捉多个异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5%E6%8C%89%E7%85%A7%E5%A6%82%E4%B8%8B%E6%96%B9%E5%BC%8F%E5%B7%A5%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">try语句按照如下方式工作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E7%9B%B8%E6%AF%94%E4%BA%8Eif%E5%8E%BB%E5%88%A4%E6%96%AD%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">使用异常相比于if去判断的优势：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%9D%97%E6%8D%95%E6%8D%89%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.5.</span> <span class="toc-text">使用一个块捕捉多个异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E6%8D%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">捕捉对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8D%95%E6%8D%89"><span class="toc-number">1.7.</span> <span class="toc-text">全捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E6%BC%8F%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8%E7%9A%84%E6%83%85%E5%BD%A2"><span class="toc-number">1.7.1.</span> <span class="toc-text">存在漏捕捉异常的情形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%AF%E7%9A%84try%E2%80%A6except%E2%80%A6%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.7.2.</span> <span class="toc-text">单纯的try…except…捕捉所有异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Exception%E5%BC%82%E5%B8%B8%E5%9F%BA%E7%B1%BB%EF%BC%88%E8%83%BD%E6%8D%95%E6%8D%89%E5%88%B0%E5%A4%A7%E9%83%A8%E5%88%86%E5%86%85%E7%BD%AE%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">使用Exception异常基类（能捕捉到大部分内置异常类的错误）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%AD%E7%9A%84-else"><span class="toc-number">1.8.</span> <span class="toc-text">异常中的 else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.10.</span> <span class="toc-text">finally 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">异常和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%A1%BA%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.11.1.</span> <span class="toc-text">程序异常处理顺序过程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">打开文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">open函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">文件路径的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.3.</span> <span class="toc-text">文件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mode%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">mode常用的模式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mode%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">mode二进制常用模式：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.4.</span> <span class="toc-text">缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">读写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E9%87%8D%E6%96%B0%E5%86%99"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">覆盖重新写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0append"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">追加append</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">换行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E7%BC%96%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">2.2.3.</span> <span class="toc-text">特定编码文件的读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E8%A1%8C"><span class="toc-number">2.2.4.</span> <span class="toc-text">读写行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#readline"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">readline()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#readlines"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">readlines()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#writelines"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">writelines</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">关闭文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%85%B3%E9%97%AD"><span class="toc-number">2.3.1.</span> <span class="toc-text">显式关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD"><span class="toc-number">2.3.2.</span> <span class="toc-text">自动关闭</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">2.4.</span> <span class="toc-text">文件重命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.</span> <span class="toc-text">删除文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#refer"><span class="toc-number">3.</span> <span class="toc-text">refer</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/27148/" title="hexo教程-搭建个人博客踩坑"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237534.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo教程-搭建个人博客踩坑"/></a><div class="content"><a class="title" href="/posts/27148/" title="hexo教程-搭建个人博客踩坑">hexo教程-搭建个人博客踩坑</a><time datetime="2022-12-01T20:06:04.292Z" title="更新于 2022-12-02 04:06:04">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/40881/" title="hexo教程-搜索引擎收录"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211308742.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo教程-搜索引擎收录"/></a><div class="content"><a class="title" href="/posts/40881/" title="hexo教程-搜索引擎收录">hexo教程-搜索引擎收录</a><time datetime="2022-12-01T19:46:44.476Z" title="更新于 2022-12-02 03:46:44">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4710/" title="12. 网络编程"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237563.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="12. 网络编程"/></a><div class="content"><a class="title" href="/posts/4710/" title="12. 网络编程">12. 网络编程</a><time datetime="2022-12-01T18:46:52.094Z" title="更新于 2022-12-02 02:46:52">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5964/" title="11. 异常与文件操作"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237490.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="11. 异常与文件操作"/></a><div class="content"><a class="title" href="/posts/5964/" title="11. 异常与文件操作">11. 异常与文件操作</a><time datetime="2022-12-01T07:21:16.578Z" title="更新于 2022-12-01 15:21:16">2022-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/22609/" title="网站SEO优化"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237551.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网站SEO优化"/></a><div class="content"><a class="title" href="/posts/22609/" title="网站SEO优化">网站SEO优化</a><time datetime="2022-11-30T11:09:16.189Z" title="更新于 2022-11-30 19:09:16">2022-11-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 晚上十一点睡觉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 11pmsleep's blog ~~~ 该网站用来记录学习笔记及生活，欢迎交流技术~~~Blog仅供个人记录笔记学习所用，若有侵权，联系我删除~若有错误，也望诸君不吝指正</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>