<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>10. 元类编程 | 晚上十一点睡觉のBlog</title><meta name="author" content="晚上十一点睡觉"><meta name="copyright" content="晚上十一点睡觉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="元类编程 学习目标：学习元类编程方便后面看框架代码，实际工作上基本上不会用到元类编程 元类类也是对象在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立： &amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):…       pa"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://gungnir.top/posts/38591/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?60a7a67c81784f02b889a11753e4e8cc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 晚上十一点睡觉","link":"链接: ","source":"来源: 晚上十一点睡觉のBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '10. 元类编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-02 19:18:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237538.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">晚上十一点睡觉のBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">10. 元类编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-29T12:09:20.000Z" title="发表于 2022-11-29 20:09:20">2022-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-02T11:18:43.549Z" title="更新于 2022-12-02 19:18:43">2022-12-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/">Python全栈</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Python核心编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="10. 元类编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/38591/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>元类编程</p>
<p>学习目标：学习元类编程方便后面看框架代码，实际工作上基本上不会用到元类编程</p>
<h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><h3 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h3><p>在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ObjectCreator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">…       <span class="keyword">pass</span></span><br><span class="line">…</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>

<p>但是，Python中的类还远不止如此。<strong>类同样也是一种对象</strong>。是的，没错，就是对象。只要你使用关键字<code>class</code>，Python解释器在执行的时候就会创建一个对象。</p>
<p>代码段示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">ObjectCreator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">…       <span class="keyword">pass</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>以上代码将会在内存中创建一个对象，名字就是<code>ObjectCreator</code>。这个对象（<code>类对象ObjectCreator</code>）拥有创建对象（实例对象）的能力。</p>
<p>但是，它的本质仍然是一个对象，所以你可以对它做如下的操作：</p>
<blockquote>
<ol>
<li>你可以将它<strong>赋值</strong>给一个变量</li>
<li>你可以<strong>拷贝</strong>它</li>
<li>你可以为它<strong>增加属性</strong></li>
<li>你可以将它作为函数<strong>参数进行传递</strong></li>
</ol>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectCreate</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 打印类对象</span></span><br><span class="line"><span class="built_in">print</span>(ObjectCreate)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将类对象作为一个参数进行传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="built_in">print</span>(obj)</span><br><span class="line">echo(ObjectCreate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断当前类对象是否有指定的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(ObjectCreate, <span class="string">&#x27;new_attribute&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建属性</span></span><br><span class="line">ObjectCreate.new_attribute = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(ObjectCreate, <span class="string">&#x27;new_attribute&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(ObjectCreate.new_attribute)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将类对象赋值给一个对象</span></span><br><span class="line">class_obj = ObjectCreate</span><br><span class="line"><span class="comment"># 打印类的实例对象</span></span><br><span class="line"><span class="built_in">print</span>(class_obj())</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;__main__.ObjectCreate&#x27;&gt;</span><br><span class="line">&lt;class &#x27;__main__.ObjectCreate&#x27;&gt;</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">foo</span><br><span class="line">&lt;__main__.ObjectCreate object at 0x105dd9fa0&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<ul>
<li>判断当前类对象是否有指定的属性：<code>hasattr()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>(<span class="built_in">object</span>, name)</span><br><span class="line"><span class="comment">#object -- 对象。</span></span><br><span class="line"><span class="comment">#name -- 字符串，属性名。</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="动态的创建类"><a href="#动态的创建类" class="headerlink" title="动态的创建类"></a>动态的创建类</h3><p>类也是对象，你可以在运行时创建它们，就像其他任何对象一样。</p>
<p>可以在函数中创建类，使用<code>class</code>关键字即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">choose_class</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;foo&#x27;</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> Foo</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Bar</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> Bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数获取类对象</span></span><br><span class="line">MyClass = choose_class(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(MyClass)</span><br><span class="line"><span class="comment"># 获取实例对象</span></span><br><span class="line">my_class = MyClass()</span><br><span class="line"><span class="built_in">print</span>(my_class)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以通过开发者传入的字符串进行选择性创建类</span></span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/Users/poppies/miniconda3/bin/python3 /Users/poppies/Documents/projects_codes/python_code/python_basic/class_test.py</span><br><span class="line">&lt;class &#x27;__main__.choose_class.&lt;locals&gt;.Foo&#x27;&gt;</span><br><span class="line">&lt;__main__.choose_class.&lt;locals&gt;.Foo object at 0x107175fa0&gt;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>但这还不够动态，因为你仍然需要自己编写整个类的代码。</p>
<p>由于类也是对象，所以它们肯定是通过什么东西来生成的才对，当使用class关键字时，Python解释器自动创建这个对象。但和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。</p>
<p>还记得内建函数<code>type</code>吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">1</span>))  <span class="comment"># 数值的类型</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;1&quot;</span>))  <span class="comment"># 字符串的类型</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(ObjectCreator()))  <span class="comment"># 实例对象的类型</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.ObjectCreator&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(ObjectCreator))  <span class="comment"># 类的类型</span></span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>仔细观察上面的运行结果，发现使用<code>type</code>对<code>ObjectCreator</code>查看类型是，答案为：<code>type</code>。</p>
<h3 id="使用type创建类"><a href="#使用type创建类" class="headerlink" title="使用type创建类"></a>使用<code>type</code>创建类</h3><p><code>type</code>除了可以查看对象的类型，还有一种完全不同的功能：<strong>创建类</strong></p>
<p><code>type</code>可以接受一个类的描述作为参数，然后返回一个类。</p>
<p>注意：</p>
<blockquote>
<p>type会根据传入的参数不同，执行不同的事情，例如type(“hello”)表示获取”hello”的类型，而传入的参数不同还能够表示创建一个类</p>
<p><strong>要注意：</strong></p>
<p>尽量不要让一个函数拥有2种完全不同的功能，这样会很傻，Python之所以将type设计为2个功能是为了保持向后兼容性</p>
</blockquote>
<h4 id="type语法："><a href="#type语法：" class="headerlink" title="type语法："></a><code>type</code>语法：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(类名, 由父类名称组成的元组(针对无继承的情况，可以为空),包含属性的字典(名称和值)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意点：</p>
<ol>
<li>第一个参数是字符串</li>
<li>在有父类情况下，其第二个参数后面括号内，一定不要忘记那个”<u><code>,</code></u>“，如果忘记了这个<u><code>,</code></u>就不是一个元组了</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Son = <span class="built_in">type</span>(<span class="string">&#x27;Son&#x27;</span>, (Father,), &#123;<span class="string">&#x27;echo_bar&#x27;</span>: echo_bar&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>第三个参数是字典！在字典中可以添加属性和函数引用！</li>
</ol>
</blockquote>
<p>比如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照普通定义类的方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">help</span>(A))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用type这种特殊方式</span></span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">help</span>(B))</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/Users/poppies/miniconda3/bin/python3 /Users/poppies/Documents/projects_codes/python_code/python_basic/class_test.py</span><br><span class="line">Help on class A in module __main__:</span><br><span class="line"></span><br><span class="line">class A(builtins.object)</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary for instance variables (if defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (if defined)</span><br><span class="line"></span><br><span class="line">None</span><br><span class="line">Help on class B in module __main__:</span><br><span class="line"></span><br><span class="line">class B(builtins.object)</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |  </span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary for instance variables (if defined)</span><br><span class="line"> |  </span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (if defined)</span><br><span class="line"></span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用type创建带有属性的类"><a href="#使用type创建带有属性的类" class="headerlink" title="使用type创建带有属性的类"></a>使用<code>type</code>创建带有属性的类</h4><h5 id="添加类属性的方法："><a href="#添加类属性的方法：" class="headerlink" title="添加类属性的方法："></a>添加类属性的方法：</h5><p><code>type</code>接收一个字典来为类定义属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Foo = <span class="built_in">type</span>(<span class="string">&#x27;Foo&#x27;</span>, (), &#123;<span class="string">&#x27;bar&#x27;</span>: <span class="literal">True</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>可以翻译为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    bar = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>并且可以将Foo当成一个普通的类一样使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Foo)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Foo&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Foo.bar)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f)</span><br><span class="line">&lt;__main__.Foo <span class="built_in">object</span> at <span class="number">0x8a9b84c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.bar)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>当然，你可以继承这个类，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">FooChild</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">…       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>使用<code>type</code>创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = <span class="built_in">type</span>(<span class="string">&#x27;FooChild&#x27;</span>, (Foo,), &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(FooChild)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.FooChild&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(FooChild.bar)  <span class="comment"># bar属性是由Foo继承而来</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li><code>type</code>的第2个参数，元组中是父类的名字，而不是字符串</li>
<li><strong><u>添加的属性是类属性，并不是实例属性</u></strong></li>
</ul>
<h5 id="添加实例属性的方法："><a href="#添加实例属性的方法：" class="headerlink" title="添加实例属性的方法："></a>添加实例属性的方法：</h5><blockquote>
<p>在类中，无论是实例方法、类方法、静态方法都可以归类是一种属性</p>
<p>实例方法定义一个函数让函数的第一个参数为<code>self</code>，那么就可以在该函数中定义实例属性了</p>
<p>参考下面添加<code>__init__</code>构造方法，看完就懂了，很简单</p>
</blockquote>
<h4 id="使用type创建带有方法的类"><a href="#使用type创建带有方法的类" class="headerlink" title="使用type创建带有方法的类"></a>使用<code>type</code>创建带有方法的类</h4><p>最终你会希望为你的类增加方法。只需要定义一个<u>有着恰当签名的函数并将其作为属性赋值</u>就可以了。</p>
<h5 id="添加实例方法："><a href="#添加实例方法：" class="headerlink" title="添加实例方法："></a>添加实例方法：</h5><blockquote>
<p>实际上就是先定义函数，然后将函数引用当作类属性传递进类。普通的实例方法不要忘记传递参数<code>self</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个Father类并说明当前类只是继承了object</span></span><br><span class="line">Father = <span class="built_in">type</span>(<span class="string">&#x27;Father&#x27;</span>, (), &#123;<span class="string">&#x27;bar&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断类中是否存在指定的属性/方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Father: &#x27;</span>, <span class="built_in">hasattr</span>(Father, <span class="string">&#x27;echo_bar&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo_bar</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前方法被执行: &#x27;</span>, self.bar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子类并让子类继承Father类，一定不要忘记那个逗号，在第二个参数括号内</span></span><br><span class="line">Son = <span class="built_in">type</span>(<span class="string">&#x27;Son&#x27;</span>, (Father,), &#123;<span class="string">&#x27;echo_bar&#x27;</span>: echo_bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断子类中是否存在指定的属性/方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Son: &#x27;</span>, <span class="built_in">hasattr</span>(Son, <span class="string">&#x27;echo_bar&#x27;</span>))</span><br><span class="line"></span><br><span class="line">son = Son()</span><br><span class="line">son.echo_bar()</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/Users/poppies/miniconda3/bin/python3 /Users/poppies/Documents/projects_codes/python_code/python_basic/class_test.py</span><br><span class="line">Father:  False</span><br><span class="line">Son:  True</span><br><span class="line">当前方法被执行:  True</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h5 id="添加构造方法"><a href="#添加构造方法" class="headerlink" title="添加构造方法"></a>添加构造方法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name=name</span><br><span class="line"></span><br><span class="line">son = <span class="built_in">type</span>(<span class="string">&quot;son&quot;</span>,(),&#123;<span class="string">&quot;__init__&quot;</span>:__init__&#125;)</span><br><span class="line">jack=son(<span class="string">&quot;jack&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(jack.name)</span><br></pre></td></tr></table></figure>

<h5 id="添加静态方法："><a href="#添加静态方法：" class="headerlink" title="添加静态方法："></a>添加静态方法：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Father = <span class="built_in">type</span>(<span class="string">&#x27;Father&#x27;</span>, (), &#123;<span class="string">&#x27;bar&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断类中是否存在指定的属性/方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Father: &#x27;</span>, <span class="built_in">hasattr</span>(Father, <span class="string">&#x27;echo_bar&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo_bar</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前方法被执行: &#x27;</span>, self.bar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">static_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是一个静态方法...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子类并让子类继承Father</span></span><br><span class="line">Son = <span class="built_in">type</span>(<span class="string">&#x27;Son&#x27;</span>, (Father,), &#123;<span class="string">&#x27;echo_bar&#x27;</span>: echo_bar, <span class="string">&#x27;static_func&#x27;</span>: static_func&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断子类中是否存在指定的属性/方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Son: &#x27;</span>, <span class="built_in">hasattr</span>(Son, <span class="string">&#x27;echo_bar&#x27;</span>))</span><br><span class="line"></span><br><span class="line">son = Son()</span><br><span class="line">son.echo_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行静态方法</span></span><br><span class="line">son.static_func()</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/Users/poppies/miniconda3/bin/python3 /Users/poppies/Documents/projects_codes/python_code/python_basic/class_test.py</span><br><span class="line">Father:  False</span><br><span class="line">Son:  True</span><br><span class="line">当前方法被执行:  True</span><br><span class="line">这是一个静态方法...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h5 id="添加类方法："><a href="#添加类方法：" class="headerlink" title="添加类方法："></a>添加类方法：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Father = <span class="built_in">type</span>(<span class="string">&#x27;Father&#x27;</span>, (), &#123;<span class="string">&#x27;bar&#x27;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断类中是否存在指定的属性/方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Father: &#x27;</span>, <span class="built_in">hasattr</span>(Father, <span class="string">&#x27;echo_bar&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo_bar</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前方法被执行: &#x27;</span>, self.bar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">static_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是一个静态方法...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义类方法</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">class_func</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是一个类方法, 并使用类方法访问属性: &#x27;</span>, cls.bar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子类并让子类继承Father</span></span><br><span class="line">Son = <span class="built_in">type</span>(<span class="string">&#x27;Son&#x27;</span>, (Father,), &#123;<span class="string">&#x27;echo_bar&#x27;</span>: echo_bar, <span class="string">&#x27;static_func&#x27;</span>: static_func, <span class="string">&#x27;class_func&#x27;</span>: class_func&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断子类中是否存在指定的属性/方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Son: &#x27;</span>, <span class="built_in">hasattr</span>(Son, <span class="string">&#x27;echo_bar&#x27;</span>))</span><br><span class="line"></span><br><span class="line">son = Son()</span><br><span class="line">son.echo_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行静态方法</span></span><br><span class="line">son.static_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行类方法</span></span><br><span class="line">son.class_func()</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/Users/poppies/miniconda3/bin/python3 /Users/poppies/Documents/projects_codes/python_code/python_basic/class_test.py</span><br><span class="line">Father:  False</span><br><span class="line">Son:  True</span><br><span class="line">当前方法被执行:  True</span><br><span class="line">这是一个静态方法...</span><br><span class="line">这是一个类方法, 并使用类方法访问属性:  True</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。</p>
<p>以下代码是较为简单的使用<code>type</code>创建类的代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_b</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;使用实例方法打印属性: &#x27;</span>, self.num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_static</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个静态方法...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_class</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;使用类方法打印属性: &#x27;</span>, cls.num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面通过type来创建一个类</span></span><br><span class="line"><span class="comment"># 名字是B</span></span><br><span class="line"><span class="comment"># 继承A</span></span><br><span class="line"><span class="comment"># 有3个属性，因为它们指向函数（第5、10，15行定义的函数），所以也称之为定义了3个方法</span></span><br><span class="line">B = <span class="built_in">type</span>(<span class="string">&quot;B&quot;</span>, (A,), &#123;<span class="string">&quot;print_b&quot;</span>: print_b, <span class="string">&quot;print_static&quot;</span>: print_static, <span class="string">&quot;print_class&quot;</span>: print_class&#125;)</span><br><span class="line">b = B()  <span class="comment"># 创建实例对象</span></span><br><span class="line">b.print_b()  <span class="comment"># 调用实例方法</span></span><br><span class="line">b.print_static()  <span class="comment"># 调用静态方法</span></span><br><span class="line">b.print_class()  <span class="comment"># 调用类方法</span></span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">使用实例方法打印属性:  100</span><br><span class="line">这是一个静态方法...</span><br><span class="line">使用类方法打印属性:  100</span><br></pre></td></tr></table></figure>

<h3 id="元类本身的探究"><a href="#元类本身的探究" class="headerlink" title="元类本身的探究"></a>元类本身的探究</h3><p>元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。</p>
<p>元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass = MetaClass()  <span class="comment"># 使用元类创建出一个对象，这个对象称为“类”</span></span><br><span class="line">my_object = MyClass()  <span class="comment"># 使用“类”来创建出实例对象</span></span><br></pre></td></tr></table></figure>

<p>你已经看到了<code>type</code>可以让你这样操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass = <span class="built_in">type</span>(<span class="string">&#x27;MyClass&#x27;</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>函数<code>type</code>实际上是一个<strong>元类</strong>。</p>
<blockquote>
<ul>
<li><code>type</code>就是<code>Python</code>在背后用来创建所有类的元类。</li>
<li><code>str</code>是用来创建字符串对象的类，而<code>int</code>是用来创建整数对象的类。</li>
<li><code>type</code>就是创建类对象的类。</li>
</ul>
</blockquote>
<p>你可以通过检查<code>__class__</code>属性来看到这一点。<code>Python</code>中所有的东西，注意，我是指所有的东西 - 都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来，这个类就是<code>type</code>。</p>
<h4 id="测试代码一："><a href="#测试代码一：" class="headerlink" title="测试代码一："></a>测试代码一：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数字的类</span></span><br><span class="line">age = <span class="number">35</span></span><br><span class="line"><span class="built_in">print</span>(age.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试字符串的类</span></span><br><span class="line">name = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数的类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试实例对象的的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">b = Bar()</span><br><span class="line"><span class="built_in">print</span>(b.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试类对象的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Bar.__class__)</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/Users/poppies/miniconda3/bin/python3 /Users/poppies/Documents/projects_codes/python_code/python_basic/class_test.py</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br><span class="line">&lt;class &#x27;__main__.Bar&#x27;&gt;</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>现在，对于任何一个<code>__class__</code>的<code>__class__</code>属性又是什么呢？</p>
<h4 id="测试代码二："><a href="#测试代码二：" class="headerlink" title="测试代码二："></a>测试代码二：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数字的类</span></span><br><span class="line">age = <span class="number">35</span></span><br><span class="line"><span class="built_in">print</span>(age.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试字符串的类</span></span><br><span class="line">name = <span class="string">&#x27;bob&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数的类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试实例对象的的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">b = Bar()</span><br><span class="line"><span class="built_in">print</span>(b.__class__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试类对象的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Bar.__class__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------分割线-------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试类型的类</span></span><br><span class="line"><span class="built_in">print</span>(age.__class__.__class__)</span><br><span class="line"><span class="built_in">print</span>(name.__class__.__class__)</span><br><span class="line"><span class="built_in">print</span>(Foo.__class__.__class__)</span><br><span class="line"><span class="built_in">print</span>(b.__class__.__class__)</span><br><span class="line"><span class="built_in">print</span>(Bar.__class__.__class__)  <span class="comment"># type类的元类也是type</span></span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/Users/poppies/miniconda3/bin/python3 /Users/poppies/Documents/projects_codes/python_code/python_basic/class_test.py</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br><span class="line">&lt;class &#x27;__main__.Bar&#x27;&gt;</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">------分割线-------</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><blockquote>
<ul>
<li>所有的类继承<code>object</code></li>
<li>所有的类都由<code>type</code>创建</li>
<li><code>object</code>也是由<code>type</code>创建的 有一个类 这个类没有继承任何父类 ——<code>object</code> </li>
<li>谁创建了<code>type</code>？——自身。我们的探究到此为止，至于<code>type</code>如何创建的自己，这个就很复杂了。暂时看不懂</li>
</ul>
</blockquote>
<h3 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__属性"></a><code>__metaclass__</code>属性</h3><p>你可以在定义一个类的时候为其添加<code>__metaclass__</code>属性。注意是属性~</p>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __metaclass__ = something…   <span class="comment">#这里面写这个类如何构成，过程，有属性有方法，总之就是如何创建这个类</span></span><br><span class="line">    ...省略...</span><br></pre></td></tr></table></figure>

<p>如果你在类中定义了<code>__metaclass__</code>，Python就会用元类来创建类<code>Foo</code>。</p>
<p>小心点，这里面有些技巧。你首先写下<code>class Foo(object)</code>，但是类<code>Foo</code>还没有在内存中创建。<code>Python</code>会在类的定义中寻找<code>__metaclass__</code>属性，如果找到了，<code>Python</code>就会用它来创建类<code>Foo</code>，如果没有找到，就会用内建的<code>type</code>来创建这个类。</p>
<p>当你写如下代码时 :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">Bar</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>Python做了如下的操作：</p>
<blockquote>
<ol>
<li><code>Foo</code>中有<code>__metaclass__</code>这个属性吗？如果有，则<code>Python</code>会通过<code>__metaclass__</code>创建一个名字为<code>Foo</code>的类</li>
<li>如果<code>Python</code>没有找到<code>__metaclass__</code>，它会继续在<code>Bar</code>（父类）中寻找<code>__metaclass__</code>属性，并尝试做和前面同样的操作</li>
<li>如果Python在任何父类中都找不到<code>__metaclass__</code>，它就会在模块层次中去寻找<code>__metaclass__</code>，并尝试做同样的操作</li>
<li>如果还是找不到<code>__metaclass__</code>,Python就会用内置的<code>type</code>来创建这个类对象</li>
</ol>
</blockquote>
<p>现在的问题就是，可以在<code>__metaclass__</code>中放置些什么代码呢？</p>
<p>答：可以创建一个类的东西，或者是一些约束</p>
<p>那么什么可以用来创建一个类呢？</p>
<p>答：<code>type</code>，或者任何使用到<code>type</code>或者子类化<code>type</code>的代码都可以。</p>
<p>可以理解为对python内置的<code>type</code>进行重新！如果没有重写，就会用默认的<code>type</code></p>
<h3 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h3><p>元类的主要目的就是为了当创建类时能够自动地改变类。</p>
<p>假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在<strong>模块级别</strong>设定<code>__metaclass__</code>采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。（类似一种父类的功能）</p>
<p>幸运的是，<code>__metaclass__</code>实际上可以被任意调用，它并不需要是一个正式的类</p>
<p>所以，我们这里就先以一个简单的函数作为例子开始，看如下代码：</p>
<h4 id="Python2中的代码示例："><a href="#Python2中的代码示例：" class="headerlink" title="Python2中的代码示例："></a>Python2中的代码示例：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#定义了一个类的创建过程和创建约束</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upper_attr</span>(<span class="params">class_name, class_parents, class_attr</span>):</span><br><span class="line">    <span class="comment"># class_name 会保存类的名字 Foo</span></span><br><span class="line">    <span class="comment"># class_parents 会保存类的父类 object</span></span><br><span class="line">    <span class="comment"># class_attr 会以字典的方式保存所有的类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历属性字典，把不是__开头的属性名字变为大写</span></span><br><span class="line">    new_attr = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> class_attr.items():</span><br><span class="line">        <span class="comment"># 如果是__开头的所有属性原封不动动传递给type 如果不是__开头动方法/属性 大写</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&quot;__&quot;</span>):</span><br><span class="line">            new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用type来创建一个类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __metaclass__ = upper_attr  <span class="comment"># 设置Foo类的元类为upper_attr</span></span><br><span class="line">    bar = <span class="string">&#x27;我是一个类属性&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>))</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="built_in">print</span>(f.BAR)</span><br><span class="line"><span class="comment"># 已经转成大写形式  小写方式寻找属性会找不到</span></span><br><span class="line"><span class="comment"># print(f.bar)</span></span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br><span class="line">我是一个类属性</span><br></pre></td></tr></table></figure>

<h4 id="Python3中的代码示例："><a href="#Python3中的代码示例：" class="headerlink" title="Python3中的代码示例："></a>Python3中的代码示例：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">upper_attr</span>(<span class="params">class_name, class_parents, class_attr</span>):</span><br><span class="line">    <span class="comment"># 遍历属性字典，把不是__开头的属性名字变为大写</span></span><br><span class="line">    new_attr = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> class_attr.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&quot;__&quot;</span>):</span><br><span class="line">            new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用type来创建一个类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="built_in">object</span>, metaclass=upper_attr):</span><br><span class="line">    bar = <span class="string">&#x27;我是一个类属性&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>))</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="built_in">print</span>(f.BAR)</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br><span class="line">我是一个类属性</span><br></pre></td></tr></table></figure>

<h3 id="元类编程案例"><a href="#元类编程案例" class="headerlink" title="元类编程案例"></a>元类编程案例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#继承type，type很奇怪，是一个特殊的函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperAttrMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    __new__ 是在__init__之前被调用的特殊方法</span></span><br><span class="line"><span class="string">    __new__是用来创建对象并返回值的方法。</span></span><br><span class="line"><span class="string">    new方法是在创建这个类的时候会在内存中开辟一个空间存储类属性与方法</span></span><br><span class="line"><span class="string">    而__init__只是用来将传入的参数初始化给对象</span></span><br><span class="line"><span class="string">    你很少用到__new__，除非你希望能够控制对象的创建：例如单例模式</span></span><br><span class="line"><span class="string">    这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span></span><br><span class="line"><span class="string">    如果你希望的话，你也可以在__init__中做些事情</span></span><br><span class="line"><span class="string">    还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#__new__类方法第一个参数是cls，注意是类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, class_name, class_parents, class_attr</span>):</span><br><span class="line">        <span class="comment"># 遍历属性字典，把不是__开头的属性名字变为大写</span></span><br><span class="line">        new_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&quot;__&quot;</span>):</span><br><span class="line">                new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法1：通过&#x27;type&#x27;来做类对象的创建</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法2：复用type.__new__方法</span></span><br><span class="line">        <span class="comment"># 这就是基本的OOP编程，没什么魔法</span></span><br><span class="line">        <span class="comment"># return type.__new__(cls, class_name, class_parents, new_attr)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3的用法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="built_in">object</span>, metaclass=UpperAttrMetaClass):</span><br><span class="line">    bar = <span class="string">&#x27;我是一个类属性&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python2的用法</span></span><br><span class="line"><span class="comment"># class Foo(object):</span></span><br><span class="line"><span class="comment">#     __metaclass__ = UpperAttrMetaClass</span></span><br><span class="line"><span class="comment">#     bar = &#x27;我是一个类属性&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出:True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="built_in">print</span>(f.BAR)</span><br><span class="line"><span class="comment"># 输出:&#x27;我是一个类属性&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要在项目中使用元类来开发业务代码 阅读源码</span></span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br><span class="line">我是一个类属性</span><br></pre></td></tr></table></figure>

<p>通过以上案例，我们发现<code>type</code>无非做了以下几件事情：</p>
<blockquote>
<ol>
<li>拦截类的创建</li>
<li>修改类</li>
<li>返回修改之后的类</li>
</ol>
</blockquote>
<h3 id="有使用元类的必要性么？"><a href="#有使用元类的必要性么？" class="headerlink" title="有使用元类的必要性么？"></a>有使用元类的必要性么？</h3><p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：</p>
<blockquote>
<p>元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。</p>
<p>—— Python界的领袖 <code>Tim Peters</code></p>
</blockquote>
<p>当然了也不是说元类真的没有用，我们在后面学习MySQL数据库后，会学习使用元类来自己模拟ORM，到时就要用到元类。</p>
<h2 id="元类实现ORM-课外补充"><a href="#元类实现ORM-课外补充" class="headerlink" title="元类实现ORM - 课外补充"></a>元类实现ORM - 课外补充</h2><h3 id="ORM-是什么"><a href="#ORM-是什么" class="headerlink" title="ORM 是什么"></a>ORM 是什么</h3><p>ORM 是 python编程语言后端web框架 <code>Django</code>的核心思想。”<code>Object Relational Mapping</code>“，即对象-关系映射，简称ORM。</p>
<blockquote>
<p><strong>一句话理解就是：</strong></p>
<p>创建一个实例对象，用创建它的类名当做数据表名，用创建它的类属性对应数据表的字段，当对这个实例对象操作时，能够对应MySQL语句。</p>
</blockquote>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">父类省略</span>):</span><br><span class="line">    uid = (<span class="string">&#x27;uid&#x27;</span>, <span class="string">&quot;int unsigned&quot;</span>)</span><br><span class="line">    name = (<span class="string">&#x27;username&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    email = (<span class="string">&#x27;email&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    password = (<span class="string">&#x27;password&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    ...省略...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = User(uid=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line">u.save()</span><br><span class="line"><span class="comment"># 对应如下sql语句</span></span><br><span class="line"><span class="comment"># insert into User (username,email,password,uid)</span></span><br><span class="line"><span class="comment"># values (&#x27;Michael&#x27;,&#x27;test@orm.org&#x27;,&#x27;my-pwd&#x27;,12345)</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>所谓的ORM就是让开发者在操作数据库的时候，能够像操作对象时通过<code>xxxx.属性=yyyy</code>一样简单，这是开发ORM的初衷</li>
<li>只不过ORM的实现较为复杂，<code>Django</code>中已经实现了很复杂的操作，本节知识主要通过完成一个insert相类似的ORM，理解其中的道理就就可以了。</li>
</ol>
<h3 id="通过元类简单实现ORM中的insert功能"><a href="#通过元类简单实现ORM中的insert功能" class="headerlink" title="通过元类简单实现ORM中的insert功能"></a>通过元类简单实现ORM中的<code>insert</code>功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        mappings = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 判断是否需要保存</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="comment"># 判断是否是指定的StringField或者IntegerField的实例对象</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, <span class="built_in">tuple</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Found mapping: %s ==&gt; %s&#x27;</span> % (k, v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除这些已经在字典中存储的属性</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            attrs.pop(k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将之前的uid/name/email/password以及对应的对象引用、类名字</span></span><br><span class="line">        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings  <span class="comment"># 保存属性和列的映射关系</span></span><br><span class="line">        attrs[<span class="string">&#x27;__table__&#x27;</span>] = name  <span class="comment"># 假设表名和类名一致</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(metaclass=ModelMetaclass):</span><br><span class="line">    uid = (<span class="string">&#x27;uid&#x27;</span>, <span class="string">&quot;int unsigned&quot;</span>)</span><br><span class="line">    name = (<span class="string">&#x27;username&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    email = (<span class="string">&#x27;email&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    password = (<span class="string">&#x27;password&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    <span class="comment"># 当指定元类之后，以上的类属性将不在类中，而是在__mappings__属性指定的字典中存储</span></span><br><span class="line">    <span class="comment"># 以上User类中有 </span></span><br><span class="line">    <span class="comment"># __mappings__ = &#123;</span></span><br><span class="line">    <span class="comment">#     &quot;uid&quot;: (&#x27;uid&#x27;, &quot;int unsigned&quot;)</span></span><br><span class="line">    <span class="comment">#     &quot;name&quot;: (&#x27;username&#x27;, &quot;varchar(30)&quot;)</span></span><br><span class="line">    <span class="comment">#     &quot;email&quot;: (&#x27;email&#x27;, &quot;varchar(30)&quot;)</span></span><br><span class="line">    <span class="comment">#     &quot;password&quot;: (&#x27;password&#x27;, &quot;varchar(30)&quot;)</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="comment"># __table__ = &quot;User&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="built_in">setattr</span>(self, name, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        fields = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            fields.append(v[<span class="number">0</span>])</span><br><span class="line">            args.append(<span class="built_in">getattr</span>(self, k, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (self.__table__, <span class="string">&#x27;,&#x27;</span>.join(fields), <span class="string">&#x27;,&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> args]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;SQL: %s&#x27;</span> % sql)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = User(uid=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line"><span class="comment"># print(u.__dict__)</span></span><br><span class="line">u.save()</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Found mapping: password ==&gt; (&#x27;password&#x27;, &#x27;varchar(30)&#x27;)</span><br><span class="line">Found mapping: email ==&gt; (&#x27;email&#x27;, &#x27;varchar(30)&#x27;)</span><br><span class="line">Found mapping: uid ==&gt; (&#x27;uid&#x27;, &#x27;int unsigned&#x27;)</span><br><span class="line">Found mapping: name ==&gt; (&#x27;username&#x27;, &#x27;varchar(30)&#x27;)</span><br><span class="line">SQL: insert into User (uid,password,username,email) values (12345,my-pwd,Michael,test@orm.org)</span><br></pre></td></tr></table></figure>

<h3 id="完善对数据类型的检测"><a href="#完善对数据类型的检测" class="headerlink" title="完善对数据类型的检测"></a>完善对数据类型的检测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        mappings = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 判断是否需要保存</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="comment"># 判断是否是指定的StringField或者IntegerField的实例对象</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, <span class="built_in">tuple</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Found mapping: %s ==&gt; %s&#x27;</span> % (k, v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除这些已经在字典中存储的属性</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            attrs.pop(k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将之前的uid/name/email/password以及对应的对象引用、类名字</span></span><br><span class="line">        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings  <span class="comment"># 保存属性和列的映射关系</span></span><br><span class="line">        attrs[<span class="string">&#x27;__table__&#x27;</span>] = name  <span class="comment"># 假设表名和类名一致</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(metaclass=ModelMetaclass):</span><br><span class="line">    uid = (<span class="string">&#x27;uid&#x27;</span>, <span class="string">&quot;int unsigned&quot;</span>)</span><br><span class="line">    name = (<span class="string">&#x27;username&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    email = (<span class="string">&#x27;email&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    password = (<span class="string">&#x27;password&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    <span class="comment"># 当指定元类之后，以上的类属性将不在类中，而是在__mappings__属性指定的字典中存储</span></span><br><span class="line">    <span class="comment"># 以上User类中有 </span></span><br><span class="line">    <span class="comment"># __mappings__ = &#123;</span></span><br><span class="line">    <span class="comment">#     &quot;uid&quot;: (&#x27;uid&#x27;, &quot;int unsigned&quot;)</span></span><br><span class="line">    <span class="comment">#     &quot;name&quot;: (&#x27;username&#x27;, &quot;varchar(30)&quot;)</span></span><br><span class="line">    <span class="comment">#     &quot;email&quot;: (&#x27;email&#x27;, &quot;varchar(30)&quot;)</span></span><br><span class="line">    <span class="comment">#     &quot;password&quot;: (&#x27;password&#x27;, &quot;varchar(30)&quot;)</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="comment"># __table__ = &quot;User&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="built_in">setattr</span>(self, name, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        fields = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            fields.append(v[<span class="number">0</span>])</span><br><span class="line">            args.append(<span class="built_in">getattr</span>(self, k, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">        args_temp = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> temp <span class="keyword">in</span> args:</span><br><span class="line">            <span class="comment"># 判断入如果是数字类型</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(temp, <span class="built_in">int</span>):</span><br><span class="line">                args_temp.append(<span class="built_in">str</span>(temp))</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(temp, <span class="built_in">str</span>):</span><br><span class="line">                args_temp.append(<span class="string">&quot;&quot;&quot;&#x27;%s&#x27;&quot;&quot;&quot;</span> % temp)</span><br><span class="line">        sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (self.__table__, <span class="string">&#x27;,&#x27;</span>.join(fields), <span class="string">&#x27;,&#x27;</span>.join(args_temp))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;SQL: %s&#x27;</span> % sql)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = User(uid=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line"><span class="comment"># print(u.__dict__)</span></span><br><span class="line">u.save()</span><br></pre></td></tr></table></figure>

<h3 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelMetaclass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        mappings = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 判断是否需要保存</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="comment"># 判断是否是指定的StringField或者IntegerField的实例对象</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, <span class="built_in">tuple</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Found mapping: %s ==&gt; %s&#x27;</span> % (k, v))</span><br><span class="line">                mappings[k] = v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除这些已经在字典中存储的属性</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">            attrs.pop(k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将之前的uid/name/email/password以及对应的对象引用、类名字</span></span><br><span class="line">        attrs[<span class="string">&#x27;__mappings__&#x27;</span>] = mappings  <span class="comment"># 保存属性和列的映射关系</span></span><br><span class="line">        attrs[<span class="string">&#x27;__table__&#x27;</span>] = name  <span class="comment"># 假设表名和类名一致</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(<span class="built_in">object</span>, metaclass=ModelMetaclass):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="built_in">setattr</span>(self, name, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        fields = []</span><br><span class="line">        args = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            fields.append(v[<span class="number">0</span>])</span><br><span class="line">            args.append(<span class="built_in">getattr</span>(self, k, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">        args_temp = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> temp <span class="keyword">in</span> args:</span><br><span class="line">            <span class="comment"># 判断入如果是数字类型</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(temp, <span class="built_in">int</span>):</span><br><span class="line">                args_temp.append(<span class="built_in">str</span>(temp))</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(temp, <span class="built_in">str</span>):</span><br><span class="line">                args_temp.append(<span class="string">&quot;&quot;&quot;&#x27;%s&#x27;&quot;&quot;&quot;</span> % temp)</span><br><span class="line">        sql = <span class="string">&#x27;insert into %s (%s) values (%s)&#x27;</span> % (self.__table__, <span class="string">&#x27;,&#x27;</span>.join(fields), <span class="string">&#x27;,&#x27;</span>.join(args_temp))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;SQL: %s&#x27;</span> % sql)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    uid = (<span class="string">&#x27;uid&#x27;</span>, <span class="string">&quot;int unsigned&quot;</span>)</span><br><span class="line">    name = (<span class="string">&#x27;username&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    email = (<span class="string">&#x27;email&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line">    password = (<span class="string">&#x27;password&#x27;</span>, <span class="string">&quot;varchar(30)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = User(uid=<span class="number">12345</span>, name=<span class="string">&#x27;Michael&#x27;</span>, email=<span class="string">&#x27;test@orm.org&#x27;</span>, password=<span class="string">&#x27;my-pwd&#x27;</span>)</span><br><span class="line"><span class="comment"># print(u.__dict__)</span></span><br><span class="line">u.save()</span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://gungnir.top/">晚上十一点睡觉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gungnir.top/posts/38591/">http://gungnir.top/posts/38591/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gungnir.top" target="_blank">晚上十一点睡觉のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237538.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/34423/"><img class="prev-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237489.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python核心语法学习注意点</div></div></a></div><div class="next-post pull-right"><a href="/posts/5964/"><img class="next-cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237565.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">11. 异常与文件操作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/24764/" title="1. 基础知识"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237554.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-28</div><div class="title">1. 基础知识</div></div></a></div><div><a href="/posts/5964/" title="11. 异常与文件操作"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237565.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-30</div><div class="title">11. 异常与文件操作</div></div></a></div><div><a href="/posts/10554/" title="13. 多线程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237573.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">13. 多线程</div></div></a></div><div><a href="/posts/4710/" title="12. 网络编程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237562.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">12. 网络编程</div></div></a></div><div><a href="/posts/60681/" title="14. 多进程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237532.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="title">14. 多进程</div></div></a></div><div><a href="/posts/21255/" title="15. 协程"><img class="cover" src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237516.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-06</div><div class="title">15. 协程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151640204.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">晚上十一点睡觉</div><div class="author-info__description">晚上十一点睡觉的个人博客，个人笔记及日志，最近在学习网络安全和Python</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/11pmsleep"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/11pmsleep" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:860637048@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=860637048" rel="external nofollow noreferrer" target="_blank" title="qq"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记迁移整理中~~~以前习惯有道云记笔记，整理知识也算沉淀自己的一部分吧·· 加油··stay passionate and never say die!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">元类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%9F%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">类也是对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%9A%84%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">动态的创建类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8type%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">使用type创建类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#type%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">type语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8type%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%9C%89%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用type创建带有属性的类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">添加类属性的方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">添加实例属性的方法：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8type%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">使用type创建带有方法的类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">添加实例方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">添加构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">添加静态方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">添加类方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B1%BB%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%8E%A2%E7%A9%B6"><span class="toc-number">1.4.</span> <span class="toc-text">元类本身的探究</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%B8%80%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">测试代码一：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%BA%8C%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">测试代码二：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#metaclass-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.</span> <span class="toc-text">__metaclass__属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB"><span class="toc-number">1.6.</span> <span class="toc-text">自定义元类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python2%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.6.1.</span> <span class="toc-text">Python2中的代码示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python3%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">Python3中的代码示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B1%BB%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">1.7.</span> <span class="toc-text">元类编程案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">有使用元类的必要性么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B1%BB%E5%AE%9E%E7%8E%B0ORM-%E8%AF%BE%E5%A4%96%E8%A1%A5%E5%85%85"><span class="toc-number">2.</span> <span class="toc-text">元类实现ORM - 课外补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ORM-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">ORM 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%85%83%E7%B1%BB%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0ORM%E4%B8%AD%E7%9A%84insert%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">通过元类简单实现ORM中的insert功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">2.3.</span> <span class="toc-text">完善对数据类型的检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%95%B4%E5%90%88"><span class="toc-number">2.4.</span> <span class="toc-text">代码整合</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/57137/" title="18. MySQL高级应用"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237526.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="18. MySQL高级应用"/></a><div class="content"><a class="title" href="/posts/57137/" title="18. MySQL高级应用">18. MySQL高级应用</a><time datetime="2022-12-17T16:54:18.678Z" title="更新于 2022-12-18 00:54:18">2022-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/26291/" title="17.  MySQL查询"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237522.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="17.  MySQL查询"/></a><div class="content"><a class="title" href="/posts/26291/" title="17.  MySQL查询">17.  MySQL查询</a><time datetime="2022-12-17T14:51:26.880Z" title="更新于 2022-12-17 22:51:26">2022-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/26714/" title="16. MySQL数据库"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237570.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="16. MySQL数据库"/></a><div class="content"><a class="title" href="/posts/26714/" title="16. MySQL数据库">16. MySQL数据库</a><time datetime="2022-12-17T10:54:14.553Z" title="更新于 2022-12-17 18:54:14">2022-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5766/" title="9. 三器一闭"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237578.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="9. 三器一闭"/></a><div class="content"><a class="title" href="/posts/5766/" title="9. 三器一闭">9. 三器一闭</a><time datetime="2022-12-13T09:45:33.323Z" title="更新于 2022-12-13 17:45:33">2022-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34423/" title="Python核心语法学习注意点"><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182237489.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python核心语法学习注意点"/></a><div class="content"><a class="title" href="/posts/34423/" title="Python核心语法学习注意点">Python核心语法学习注意点</a><time datetime="2022-12-10T11:10:29.899Z" title="更新于 2022-12-10 19:10:29">2022-12-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 晚上十一点睡觉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 11pmsleep's blog ~~~ 该网站用来记录学习笔记及生活，欢迎交流技术~~~Blog仅供个人记录笔记学习所用，若有侵权，联系我删除~若有错误，也望诸君不吝指正</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.gungnir.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>